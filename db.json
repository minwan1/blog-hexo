{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":0,"renderable":0},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/archive.styl","path":"css/archive.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/beantech.css","path":"css/beantech.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/beantech.min.css","path":"css/beantech.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/rocket.styl","path":"css/rocket.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/signature.styl","path":"css/signature.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/toc.styl","path":"css/toc.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/widget.styl","path":"css/widget.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.js","path":"js/hux-blog.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/toc.js","path":"js/toc.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"source/img/ironman-draw.png","path":"img/ironman-draw.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"source/img/header_img/Iron-Man-3.jpg","path":"img/header_img/Iron-Man-3.jpg","modified":0,"renderable":0},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/bootstrap.css","path":"css/bootstrap.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/ironman.png","path":"css/images/ironman.png","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/rocket.png","path":"css/images/rocket.png","modified":0,"renderable":1},{"_id":"source/img/header_img/tf-logo-dark.png","path":"img/header_img/tf-logo-dark.png","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-white.png","path":"img/signature/BeanTechSign-white.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"source/img/signature/BeanTechSign-black.png","path":"img/signature/BeanTechSign-black.png","modified":0,"renderable":0},{"_id":"source/img/beantech-desktop.png","path":"img/beantech-desktop.png","modified":0,"renderable":0},{"_id":"source/img/header_img/tag-bg.png","path":"img/header_img/tag-bg.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-2-dark.png","path":"img/header_img/home-bg-2-dark.png","modified":0,"renderable":0},{"_id":"source/img/header_img/archive-bg.png","path":"img/header_img/archive-bg.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/404.md","hash":"83c2c6d587beaa967a976e5969d60fa97fcdbe55","modified":1519468539122},{"_id":"source/CNAME","hash":"55d5b0b4757a7d65ee4966dd161f394d06d257b7","modified":1519468539122},{"_id":"themes/beantech/_config.yml","hash":"6afd65c055d9b1c70ae67323cc869f1b4aa60348","modified":1519468539193},{"_id":"themes/beantech/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1519468539193},{"_id":"source/about/index.md","hash":"ebca34cfe8d13ec641d17fcfec0127a966338f8e","modified":1519468539133},{"_id":"source/_posts/2017-03-26-spring-security-encryption.md","hash":"6274f29552f6a07b2d3d889ec113d0baa8885ea4","modified":1529510718286},{"_id":"source/_posts/2017-03-25-spring-security-theory.md","hash":"2d4a4403c84a55fa78ed76dbc9cfd7f85acb4f06","modified":1529510718290},{"_id":"source/_posts/2017-04-08-Datasource,JdbcTemplate.md","hash":"9b8d61f235972ede767139546eecbd4fd4147984","modified":1529779352561},{"_id":"source/_posts/2017-04-20-Tomcat-Session-principle .md","hash":"164112c808aaf29c42f4ee5170d5dda97569ef4a","modified":1529510718369},{"_id":"source/_posts/2017-04-22-javascript-execution-context.md","hash":"f8d3799bd16c2b025bc48a3a2425c985d3589bd1","modified":1529510994112},{"_id":"source/_posts/2017-04-22-spring-security-implement.md","hash":"3f53626c08d8352bc5891e940b593465c92ba344","modified":1529510718363},{"_id":"source/_posts/2017-04-22-spring-social.md","hash":"64bfab24aab52afb8ab3e24324f973aa51bf0354","modified":1529510718236},{"_id":"source/_posts/2017-06-04-spring-exception.md","hash":"09242c11fe723a41edea635ee72cf5929d509413","modified":1529510718324},{"_id":"source/_posts/2017-08-06-data-binding-principle.md","hash":"bdd1be967fed509577155411ab6a5cbb3b96624d","modified":1529510718319},{"_id":"source/_posts/2017-10-07-spring-Transaction,Exception.md","hash":"8351345101aee884d669170fe6803e3d83dbea40","modified":1529510718215},{"_id":"source/_posts/2017-08-06-spring-remember-me.md","hash":"f1a8a74287a00adc14806ba1e25f59e2dd79a6d4","modified":1529510718268},{"_id":"source/_posts/2017-10-08-Spring-Container,Servlet-Container.md","hash":"8ce6007ec21fdcef381eb1c18aa37f88e52e5c9c","modified":1529510718304},{"_id":"source/_posts/2017-10-29-Spring-AOP-Proxy.md","hash":"e697e29dbb20bb95f120dff5a9f9e2f6ad5741cd","modified":1529510718383},{"_id":"source/_posts/2017-10-29-Spring-Transaction,AspectJ-Compile.md","hash":"25a82d81867a52ea2e77322cb78f1e332e046028","modified":1529510718255},{"_id":"source/_posts/2018-02-04-Class-Diagram.md","hash":"623c779d3fe8a93dc2e5bd329fbc6f2fc727af1e","modified":1529510718334},{"_id":"source/_posts/2018-02-24-OAuth.md","hash":"76ef93ea01d5b422d1cf8445c2192d26408bc5b2","modified":1529510718355},{"_id":"source/_posts/2018-03-11-Spring-OAuth구현.md","hash":"f0110ba25f6e6aff5f09d14cf7e22376eacd017e","modified":1531750773410},{"_id":"source/_posts/2018-03-18-Spring-Cache.md","hash":"84086574e66620907c237a0ad70548c2303c3dab","modified":1529510718328},{"_id":"source/_posts/2018-04-01-spring-service.md","hash":"84ed2e505276846916295bbbeb5b21e8a0307ff8","modified":1529510718375},{"_id":"source/_posts/2018-05-28-HMAC.md","hash":"a4a37603caad0d8630266fec04263ddb16638a19","modified":1529510718205},{"_id":"source/_posts/2018-05-28-spring-mvc.md","hash":"0f60186f36ccd1fb674bca2285d6f86fe7aada97","modified":1529510718222},{"_id":"source/_posts/2018-06-06-Java,JVM.md","hash":"508f488677dcad8c951ceb7242229504b33d4db4","modified":1545752793030},{"_id":"source/_posts/2018-06-11-String-StringBuffer-StringBuilder.md","hash":"938acca504ce67b58377391af3e51cbcbcaf30d9","modified":1529510718389},{"_id":"source/_posts/2018-06-09-ASCII-Unicode.md","hash":"4a6eced5914fe594b34186eccd295f52e714983d","modified":1529510718277},{"_id":"source/_posts/2018-06-07-Toby-1.md","hash":"9f357ba0c6b6b2df5d5c0d9660b8d45bf85309db","modified":1529763721451},{"_id":"source/_posts/2018-06-14-EntityManagerFactory, EntityManager, PersistenceContext란.md","hash":"105f3354bb972b72c08420acd89929713d373492","modified":1529510934223},{"_id":"source/_posts/2018-06-19-운영체제란[OS-1].md","hash":"f577bd48be7772a74cc646121156719e12b6e41b","modified":1529510718242},{"_id":"source/_posts/2018-06-23-Toby-2.md","hash":"9b2a501746d04e6b9ab2b9866a570e93d11fb516","modified":1529764006457},{"_id":"source/_posts/2018-06-23-운영체제란[OS-2].md","hash":"da293234de1fadca8165db747935a5771eae27ef","modified":1529761243663},{"_id":"source/_posts/2018-07-03-collection.md","hash":"904f6e9baac748cd32b1291d5df2da02bb24d753","modified":1530620601830},{"_id":"source/_posts/2018-07-03-equals,hashcode.md","hash":"a8f24c14b0593ae4ed04fdae375991f2803fe792","modified":1539361847666},{"_id":"source/_posts/2018-07-26-intellij.md","hash":"e9fa3ffa2a5b37ebcb37d5dfad9c8d582dd5c036","modified":1532532758011},{"_id":"source/_posts/2018-07-26-spring-book-1.md","hash":"1191c8c0bd5ff875c1caa17d8928ce0edabb5361","modified":1533133068958},{"_id":"source/_posts/2018-07-26-spring-book-2.md","hash":"8d6ffa824a0fb3b4ad7da6b95f825dee160b2c49","modified":1533133102974},{"_id":"source/_posts/2018-07-26-spring-book-3.md","hash":"44af035a0f0ea757264cf660f33a70f577074230","modified":1533133121395},{"_id":"source/_posts/2018-07-26-spring-book-4.md","hash":"fa460bde5a620df968c5caad932998ccc95363a1","modified":1533133378587},{"_id":"source/_posts/2018-07-26-spring-book-5.md","hash":"189b0a0e5c86e238222df440a4063a496204c50d","modified":1533133382117},{"_id":"source/_posts/2018-08-26-spring-book-6.md","hash":"cc7106d713651d1b7dbc8038d391b284e1dd6e4f","modified":1535295040425},{"_id":"source/_posts/2018-09-03-network-network-divice.md","hash":"0c99b76c7099bf36428981799c0539430676bf01","modified":1538325795675},{"_id":"source/_posts/2018-09-03-java-reg.md","hash":"9e97d086dae87a6624c6cd253cd7ad780bd187c2","modified":1537632945029},{"_id":"source/_posts/2018-10-28-TCP-IP-DATA-PROCESSING.md","hash":"ca655f40ff16251eb2d4a7fc2ef7d17e0a14c848","modified":1540737308730},{"_id":"source/_posts/2018-11-21-jsp-springboot-동작과정.md","hash":"418acd38b08129015a5a7b70b36dff87f8f11938","modified":1545752670217},{"_id":"source/_posts/2018-12-26-jpa-관계설정.md","hash":"687a26b701f13d852493f58913766269f65be70c","modified":1545752670209},{"_id":"source/_posts/2019-01-14-https.md","hash":"9447a50a84a25a4a3ad5ee93e5fd67d104c0209e","modified":1548604961498},{"_id":"source/_posts/hexo-theme-beantech.md","hash":"d64a073e20d755ef0a234f2f88cee46a1843e503","modified":1529510934219},{"_id":"source/archive/index.md","hash":"279ff19668395f5c6b26417da99d2c1f3ecd5886","modified":1519468539133},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1519468539167},{"_id":"source/tags/index.md","hash":"9d558ce28d0d44c3463517088689bbca44bbb364","modified":1519468539174},{"_id":"themes/beantech/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1519468539194},{"_id":"themes/beantech/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1519468539194},{"_id":"themes/beantech/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1519468539195},{"_id":"themes/beantech/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1519468539195},{"_id":"themes/beantech/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1519468539195},{"_id":"themes/beantech/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1519468539196},{"_id":"themes/beantech/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1519468539196},{"_id":"themes/beantech/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1519468539197},{"_id":"themes/beantech/languages_to_be_added/zh-CN.yml","hash":"7bfcb0b8e97d7e5edcfca8ab26d55d9da2573c1c","modified":1519468539196},{"_id":"themes/beantech/layout/404.ejs","hash":"a4d73541a53e56b7dd46249c6d27cb59f4d97422","modified":1519468539197},{"_id":"themes/beantech/layout/about.ejs","hash":"edcf8fa3bf7093c974d418ffef42ac89c19af128","modified":1519468539204},{"_id":"themes/beantech/layout/archive.ejs","hash":"72a150c8dff0031a9107d12eaa7c2e6c6ce950d2","modified":1519468539204},{"_id":"themes/beantech/layout/index.ejs","hash":"dc8a6eaa00d1e7c33a40979afe0953ed5d7b512e","modified":1519468539205},{"_id":"themes/beantech/layout/keynote.ejs","hash":"f5689862281e34dbe8402b0e72f632902e53e88b","modified":1519468539205},{"_id":"themes/beantech/layout/layout.ejs","hash":"a5af5b99ac3456ab5da1a319455904b979b91601","modified":1519468539205},{"_id":"themes/beantech/layout/page.ejs","hash":"c90797e4394c5cb63c2515109480e766d04e486e","modified":1519468539206},{"_id":"themes/beantech/layout/post.ejs","hash":"2d55684fc539dc281f9e2ec0409f09ea6ca43949","modified":1519468539206},{"_id":"themes/beantech/layout/tags.ejs","hash":"2c72eb2e89130658aa068d80d27b561b509c5dcd","modified":1519468539206},{"_id":"source/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1519468539136},{"_id":"themes/beantech/layout/_partial/footer.ejs","hash":"c31863b1fa66fd915bc4913440be6c610d12af80","modified":1519468539198},{"_id":"themes/beantech/layout/_partial/head.ejs","hash":"b86b09ff6f642194f34400ab1ff768370417fc35","modified":1519468539199},{"_id":"themes/beantech/layout/_partial/nav.ejs","hash":"4c905166c960852e9b9a3c9d5c680091e37b481f","modified":1519468539199},{"_id":"themes/beantech/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1519468539199},{"_id":"themes/beantech/layout/_partial/sidebar.ejs","hash":"2e4e528a555917b2a267da4db2440bcc4a7a65ab","modified":1519468539200},{"_id":"themes/beantech/layout/_partial/header.ejs","hash":"aafb744601042f0270d2e6595129ac8a73ad2608","modified":1519468539199},{"_id":"themes/beantech/layout/_widget/archive.ejs","hash":"7594929d472806ca4c64d9906d9903a96de111a0","modified":1519468539201},{"_id":"themes/beantech/layout/_partial/toc.ejs","hash":"837f01e8a20e5023b4b292d1b3141a399567da65","modified":1519468539200},{"_id":"themes/beantech/layout/_widget/category.ejs","hash":"1cf485def07dc06e870dc9613767c6c614bcf428","modified":1519468539201},{"_id":"themes/beantech/layout/_widget/featured-tags.ejs","hash":"0c9ce1942f1943dc8891a9302a922ef1ffe300c5","modified":1519468539202},{"_id":"themes/beantech/layout/_widget/friends-blog.ejs","hash":"734d3775017aedac185028924baf890a71a74548","modified":1519468539202},{"_id":"themes/beantech/layout/_widget/recent-posts.ejs","hash":"e08ab8ba60e31638006acf27f066b989a0a3c433","modified":1519468539203},{"_id":"themes/beantech/layout/_widget/short-about.ejs","hash":"3b10bd768f6ef30a42b1703fbc9a88627f9bfdf1","modified":1519468539203},{"_id":"themes/beantech/source/css/archive.styl","hash":"715bcbd085eb95ec26c9805c11c374919cde971c","modified":1519468539207},{"_id":"themes/beantech/source/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1519468539208},{"_id":"themes/beantech/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1519468539208},{"_id":"themes/beantech/source/css/highlight.styl","hash":"e842080e6d580f0f70a7df71fbde3c4e49463c19","modified":1519468539211},{"_id":"themes/beantech/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1519468539212},{"_id":"themes/beantech/source/css/rocket.styl","hash":"e15c51c8566ecd943112e57592888dd318b6fa6a","modified":1519468539213},{"_id":"themes/beantech/source/css/signature.styl","hash":"88159b31c59d59c01a0b534af57242662a2a3969","modified":1519468539214},{"_id":"themes/beantech/source/css/toc.styl","hash":"6c9a2d5f6f981624e0c4b64323493e8614efea29","modified":1519468539214},{"_id":"themes/beantech/source/css/widget.styl","hash":"7a9f735f5ef323dc2950fbd9d76daa16c9a0f1a9","modified":1519468539215},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1519468539215},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1519468539218},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1519468539218},{"_id":"themes/beantech/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1519468539220},{"_id":"themes/beantech/source/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1519468539220},{"_id":"themes/beantech/source/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1519468539220},{"_id":"themes/beantech/source/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1519468539224},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1519468539225},{"_id":"themes/beantech/source/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1519468539225},{"_id":"themes/beantech/source/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1519468539226},{"_id":"source/img/ironman-draw.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1519468539169},{"_id":"themes/beantech/source/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1519468539211},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1519468539217},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1519468539217},{"_id":"themes/beantech/source/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1519468539219},{"_id":"themes/beantech/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1519468539224},{"_id":"source/img/header_img/Iron-Man-3.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1519468539142},{"_id":"source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1519468539141},{"_id":"themes/beantech/source/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1519468539210},{"_id":"themes/beantech/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1519468539212},{"_id":"themes/beantech/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1519468539213},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-true.png","hash":"a704520b43f26b88d650098f60689af3af5eb106","modified":1519468539133},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-false.png","hash":"86a3a4320012981f2d42eabc6ea172425f2f941a","modified":1519468539132},{"_id":"source/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1519468539166},{"_id":"source/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1519468539173},{"_id":"themes/beantech/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1519468539223},{"_id":"source/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1519468539171},{"_id":"source/img/beantech-desktop.png","hash":"4a8f8b209c9db8fd5209f15b8e4590525e258b0f","modified":1519468539139},{"_id":"source/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1519468539163},{"_id":"source/_posts/hexo-theme-beantech/Demo.png","hash":"d9fa12f1e40924a0db57761d09d52dce450b4f7b","modified":1519468539130},{"_id":"source/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1519468539157},{"_id":"source/img/header_img/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1519468539152},{"_id":"source/img/header_img/archive-bg.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1519468539147},{"_id":"public/sitemap.xml","hash":"1304c13671f33fbb69c58531320ff20d7b144049","modified":1550932600233},{"_id":"public/robots.txt","hash":"0ae802ad38c16b79e5b8ff361bfa3e92b9808855","modified":1550932452138},{"_id":"public/404.html","hash":"096ac61d2029458a9b46502b0afa1dfaa2ab7661","modified":1550932452138},{"_id":"public/tags/index.html","hash":"561a042d5fb14aece77048ffdf16522f9e29ea5e","modified":1550932600703},{"_id":"public/2019/01/09/2019-01-14-https/index.html","hash":"46ee69c6246dbc49ba08020daf60cd76369deabf","modified":1550932600703},{"_id":"public/2018/12/21/2018-12-26-jpa-관계설정/index.html","hash":"b2c0536c66df5281608d61168670fd135aa7f18b","modified":1550932452138},{"_id":"public/2018/11/21/2018-11-21-jsp-springboot-동작과정/index.html","hash":"d0a06ac2bd1f6628bdf9032cd6348abf247d386e","modified":1550932452138},{"_id":"public/2018/10/28/2018-10-28-TCP-IP-DATA-PROCESSING/index.html","hash":"93f4797262792ff9427d3ea1fab62d29f1bceb4c","modified":1550932452139},{"_id":"public/2018/10/01/2018-09-03-network-network-divice/index.html","hash":"f8fced288df86118dd2482c7fa8e0bad0cedf239","modified":1550932452139},{"_id":"public/2018/09/23/2018-09-03-java-reg/index.html","hash":"7dfcf5430978f38379022ac423bf7215c5be7c9e","modified":1550932452139},{"_id":"public/2018/08/26/2018-08-26-spring-book-6/index.html","hash":"e84741db0d750284638560f14d69932c5fa7dacb","modified":1550932452139},{"_id":"public/2018/08/01/2018-07-26-spring-book-5/index.html","hash":"c8926b78464be4656ee816b1f42816a1a20c607d","modified":1550932452139},{"_id":"public/2018/08/01/2018-07-26-spring-book-4/index.html","hash":"b42a3fc2356fe3219ce08dd3fb9baf56c376c9df","modified":1550932452139},{"_id":"public/2018/07/26/2018-07-26-intellij/index.html","hash":"bf5694b6a34a7828a1e1a7fab14c6ed95eae1822","modified":1550932452140},{"_id":"public/2018/07/26/2018-07-26-spring-book-2/index.html","hash":"f7f716061e869bee56b48f54a3dd7a94212c2486","modified":1550932452140},{"_id":"public/2018/07/26/2018-07-26-spring-book-3/index.html","hash":"ee878db57e26c2b7401a1d10e3bca37a64fb569e","modified":1550932452140},{"_id":"public/2018/07/25/2018-07-26-spring-book-1/index.html","hash":"7ed64b6ae2b116ef4e26beb25c76867b31e6ed73","modified":1550932452140},{"_id":"public/2018/07/03/2018-07-03-equals,hashcode/index.html","hash":"c7d059e6119a1acbfa0dcc67bc35c5d88b5f357f","modified":1550932452140},{"_id":"public/2018/07/03/2018-07-03-collection/index.html","hash":"6fe0dcdab415fdd0e795d2ff8c561dc7d8bb5403","modified":1550932452140},{"_id":"public/2018/06/23/2018-06-23-Toby-2/index.html","hash":"500415202e6cd82bbe4dd1f65fe837f3b3d75fc2","modified":1550932452140},{"_id":"public/2018/06/23/2018-06-23-운영체제란[OS-2]/index.html","hash":"518eabeb9b5901de6e0397d723eda572d857c04f","modified":1550932452140},{"_id":"public/2018/06/19/2018-06-19-운영체제란[OS-1]/index.html","hash":"c1cc2a6b4897cd4639432d1cdc6e8e19c4756c16","modified":1550932452140},{"_id":"public/2018/06/14/2018-06-14-EntityManagerFactory, EntityManager, PersistenceContext란/index.html","hash":"ae3c5c49cf708ae9b202d17468d0d4008bc0388f","modified":1550932452140},{"_id":"public/2018/06/11/2018-06-11-String-StringBuffer-StringBuilder/index.html","hash":"354e5ed5b532a6ab3f7d92021f5c037e47cf7555","modified":1550932452140},{"_id":"public/2018/06/09/2018-06-09-ASCII-Unicode/index.html","hash":"a7b2dfa48cf530fa50945c8b2f5a6b9b516b8d73","modified":1550932452141},{"_id":"public/2018/06/07/2018-06-07-Toby-1/index.html","hash":"f1e38f5daf385df99b15a17b2f65d9b358caab9e","modified":1550932452141},{"_id":"public/2018/06/06/2018-06-06-Java,JVM/index.html","hash":"8b9d2cb6d6035b6912e17a6ce36b439243bdfd7d","modified":1550932452141},{"_id":"public/2018/05/28/2018-05-28-HMAC/index.html","hash":"30ecce57cdc7956525c6044b4ce634aef8c9fbad","modified":1550932452141},{"_id":"public/2018/05/28/2018-05-28-spring-mvc/index.html","hash":"cbe841e89ad68cf79cd24751cfa0966f96a0b839","modified":1550932452141},{"_id":"public/2018/04/01/2018-04-01-spring-service/index.html","hash":"0d8db2ca285e2f1fc2b73392238ea2bfb655f5be","modified":1550932452141},{"_id":"public/2018/03/18/2018-03-18-Spring-Cache/index.html","hash":"9c6e2971dcb017b88445a1ae67e56f84de66da79","modified":1550932452141},{"_id":"public/2018/03/11/2018-03-11-Spring-OAuth구현/index.html","hash":"680b4dce409abc9f7e1f0baccf0e7dd12d49d522","modified":1550932452141},{"_id":"public/2018/02/24/2018-02-24-OAuth/index.html","hash":"872e6bd2522c06e3f50dbc0cef40e04aa78c6c98","modified":1550932452141},{"_id":"public/2018/02/04/2018-02-04-Class-Diagram/index.html","hash":"fc7062ef714e704b23676294643c750451a90822","modified":1550932452141},{"_id":"public/2017/10/29/2017-10-29-Spring-AOP-Proxy/index.html","hash":"e60df89351b31789259b650e1c168fa4d419ac17","modified":1550932452141},{"_id":"public/2017/10/29/2017-10-29-Spring-Transaction,AspectJ-Compile/index.html","hash":"64314329ce76ec004a9809b75a966cbf7a1f1001","modified":1550932452142},{"_id":"public/2017/10/08/2017-10-08-Spring-Container,Servlet-Container/index.html","hash":"e64bb221c45ad6fe8492b3791bfb5f3b27fe0c45","modified":1550932452142},{"_id":"public/2017/10/07/2017-10-07-spring-Transaction,Exception/index.html","hash":"d6ca5f1453a7e20d565cd530b98f4c17ab2225b0","modified":1550932452142},{"_id":"public/2017/08/06/2017-08-06-data-binding-principle/index.html","hash":"9ac7c2553f78fe8a935868cdfcaed27ad9d7feb4","modified":1550932452142},{"_id":"public/2017/08/06/2017-08-06-spring-remember-me/index.html","hash":"765065c43071aaba1e46d7c75d34293a5f995ce9","modified":1550932452142},{"_id":"public/2017/06/04/2017-06-04-spring-exception/index.html","hash":"07d2f2f139369caf80d8304fca04ef1a066d1d48","modified":1550932452142},{"_id":"public/2017/04/22/2017-04-22-javascript-execution-context/index.html","hash":"ad862fc7f4a083d248b83385bdbc479ec942d4d0","modified":1550932452142},{"_id":"public/2017/04/22/2017-04-22-spring-security-implement/index.html","hash":"745691d2021798c2c7395c9441ff5cbf9ad5f7f6","modified":1550932452142},{"_id":"public/2017/04/22/2017-04-22-spring-social/index.html","hash":"349aee8792adf7aeb1bb17e90a189bc2c55b6e57","modified":1550932452142},{"_id":"public/2017/04/20/2017-04-20-Tomcat-Session-principle /index.html","hash":"9a902279d195e0e1c3622957192e2d3f0166ada0","modified":1550932452143},{"_id":"public/2017/04/08/2017-04-08-Datasource,JdbcTemplate/index.html","hash":"586149f11f88a8e49fdfcb21595b36cb528e0bd8","modified":1550932452143},{"_id":"public/2017/03/26/2017-03-26-spring-security-encryption/index.html","hash":"3aac8ef73392e29ab6fef4dd29c06ca7a274a60c","modified":1550932452143},{"_id":"public/2017/03/25/2017-03-25-spring-security-theory/index.html","hash":"4c781224ab1c1839390bbe01be5f85f9976f5d34","modified":1550932452143},{"_id":"public/2017/03/18/hexo-theme-beantech/index.html","hash":"fd77c0e2ce22c5cdcf24e1c3684bc43f5ef317bc","modified":1550932452143},{"_id":"public/about/index.html","hash":"65e304eb4ffeab0b76e25eb40d51393f35aa1587","modified":1550932600703},{"_id":"public/archive/index.html","hash":"9aaa6a36be6e65930e9060e5c07a54a0b78977b9","modified":1550932600703},{"_id":"public/index.html","hash":"a38bf85dca59f98677877d1d6945864b4ce8dc3b","modified":1550932600703},{"_id":"public/archives/2/index.html","hash":"a81f6a3d406ce95e8235b340a24d2fb2c90fa1d0","modified":1550932600703},{"_id":"public/archives/3/index.html","hash":"985de32001d38bad745bc112d401baef6a0dfa1b","modified":1550932600703},{"_id":"public/archives/4/index.html","hash":"1f394e7477945cc80e8e1eddef4f5d6b00306cec","modified":1550932600704},{"_id":"public/archives/5/index.html","hash":"6ecfd2f78356f380b8119bf363c898abeb89f016","modified":1550932600704},{"_id":"public/tags/Spring/index.html","hash":"f32574afb4e42deae55f75377b83be41c0ae1e16","modified":1550932600705},{"_id":"public/tags/Spring/archives/2/index.html","hash":"c026bdc4fbec63cc0264cb2ded485a8cba8ff814","modified":1550932600705},{"_id":"public/tags/Spring/archives/3/index.html","hash":"c6be7042773dc1e6c971899e8abc5e4143a9dce8","modified":1550932600705},{"_id":"public/tags/Java/index.html","hash":"3cd7febc5392c1ecfc3ff01591fa43b373ce238b","modified":1550932600705},{"_id":"public/tags/Java/archives/2/index.html","hash":"1bbba13b1c98c61ca1a37769b22cd6eb6ff75b01","modified":1550932600705},{"_id":"public/tags/Java/archives/3/index.html","hash":"5654b8a8fedac3b501e3d4ca130b24da4387e57a","modified":1550932600706},{"_id":"public/tags/Java/archives/4/index.html","hash":"5777367a6c33029698132a0febe10121a42bdb4a","modified":1550932600706},{"_id":"public/tags/ETC/index.html","hash":"cbccf6b23c42f18bfec6e405f37990047f06e267","modified":1550932600706},{"_id":"public/tags/Javascript/index.html","hash":"f992ee0490aa946cf54157cf8ecb9e47a97112db","modified":1550932600706},{"_id":"public/tags/Angular/index.html","hash":"e3855a1bb47478088c51b33597fc38e937f67e37","modified":1550932600706},{"_id":"public/tags/JPA/index.html","hash":"cb98b7a7fcfb1209f5dbe0a796473d6d1e941408","modified":1550932600706},{"_id":"public/tags/Intellij/index.html","hash":"c1f4de3dafd18b7c948f90f293bb50818bd99072","modified":1550932600706},{"_id":"public/tags/온라인-서점-API-만들기로-살펴보는-Spring-Boot-OOP/index.html","hash":"f1c37c3faee175f7e5bf6161ea97f2389414c356","modified":1550932600706},{"_id":"public/tags/Netowork/index.html","hash":"abd0510a07a022341c868fbb37e277fa492d1ddd","modified":1550932600706},{"_id":"public/tags/Blog/index.html","hash":"0441c328596f074290f5f701e84d348ed89f244a","modified":1550932600706},{"_id":"public/tags/JVM/index.html","hash":"59b839c680989d82274b890eda0ac9450dfd73df","modified":1550932600706},{"_id":"public/tags/O-S/index.html","hash":"ee47a02a2922685c960fed54cdfbba68a5239051","modified":1550932600706},{"_id":"public/tags/Toby/index.html","hash":"133d4fce20eb9d2cd69d79752bb949b81822537e","modified":1550932600706},{"_id":"public/tags/OAuth/index.html","hash":"cf76322297c3d98d27d3407e644c8c5d6d5a03f0","modified":1550932600706},{"_id":"public/archives/index.html","hash":"24a7afd750a2e94658fc6c80f520fa5b883e3805","modified":1550932600704},{"_id":"public/archives/archives/2/index.html","hash":"7b7daaa4d6ae4df881a9fa3713700c9164d1afa9","modified":1550932600704},{"_id":"public/archives/archives/3/index.html","hash":"8b6c0038a5be1dae995be89bb4a923fca6ad0d22","modified":1550932600704},{"_id":"public/archives/archives/4/index.html","hash":"37b8979961a04911213db75f443776920a83170e","modified":1550932600704},{"_id":"public/archives/archives/5/index.html","hash":"0996b81cd12ce1fb316a70fd7c6e118830b5919f","modified":1550932600704},{"_id":"public/archives/2017/index.html","hash":"fb7e5a9a769bdad51f0e4d60da943b23778d8478","modified":1550932600704},{"_id":"public/archives/2017/archives/2/index.html","hash":"7340590465b080bb50afe2b3fa224bed0345921b","modified":1550932600704},{"_id":"public/archives/2017/03/index.html","hash":"ebe39412d17ccfcb57a343beab9ef657f900466a","modified":1550932600704},{"_id":"public/archives/2017/04/index.html","hash":"9f4e88989de0494f926c043247df048f4b1963db","modified":1550932600704},{"_id":"public/archives/2017/06/index.html","hash":"c49fdb3f7643ffa0e41add1c454be227f69f2447","modified":1550932600704},{"_id":"public/archives/2017/08/index.html","hash":"96be9f35caa4bc15937ce74f5279e484b084718b","modified":1550932600704},{"_id":"public/archives/2017/10/index.html","hash":"3071c7b18ed711001b5d05ddae811e2924cdae7b","modified":1550932600704},{"_id":"public/archives/2018/index.html","hash":"1240e626d0ffccb1d4d4a0e7506768c736ce76de","modified":1550932600704},{"_id":"public/archives/2018/archives/2/index.html","hash":"76dc0895812248f65a7f6592b8bf72566aa4d9ad","modified":1550932600704},{"_id":"public/archives/2018/archives/3/index.html","hash":"790e460592fef4d7e836dcc0cf7523666a66322b","modified":1550932600704},{"_id":"public/archives/2018/02/index.html","hash":"8899786e31248d43277868dc910fef844ed49231","modified":1550932600704},{"_id":"public/archives/2018/03/index.html","hash":"ea5f940a2573d2f921f09ec99573c18624d5c714","modified":1550932600705},{"_id":"public/archives/2018/04/index.html","hash":"3b5cf87433a9055bc91087692053f7d1def20a76","modified":1550932600705},{"_id":"public/archives/2018/05/index.html","hash":"9cb85de8c7476da5f11bc4bbd75a4f2814f4beae","modified":1550932600705},{"_id":"public/archives/2018/06/index.html","hash":"6b0f66c9f8bb6ef1b19eeb81075cb9411bcbb5fe","modified":1550932600705},{"_id":"public/archives/2018/07/index.html","hash":"aa28f369cb520d3bb104d9eef11fe70736de35f3","modified":1550932600705},{"_id":"public/archives/2018/08/index.html","hash":"be6ef7566b58547e24b5952ce53e5a3bead22977","modified":1550932600705},{"_id":"public/archives/2018/09/index.html","hash":"2b9f1aa9143fb06993c0c84413ce7a4435cb4f85","modified":1550932600705},{"_id":"public/archives/2018/10/index.html","hash":"eb3998c672cee652080d6f989a110e0d43030aad","modified":1550932600705},{"_id":"public/archives/2018/11/index.html","hash":"34b0a1b3ed31485bd7a19d9f574dd8b3e79188d6","modified":1550932600705},{"_id":"public/archives/2018/12/index.html","hash":"896afb715ba12570b306fcb10a6f6d0f8d6481fd","modified":1550932600705},{"_id":"public/archives/2019/index.html","hash":"a16f44eadb87fd9c9a272ed20a20a7379ac8d74c","modified":1550932600705},{"_id":"public/archives/2019/01/index.html","hash":"afe40897a0bf4e472bf2d7ab7d48a4ab383769e0","modified":1550932600705},{"_id":"source/_posts/2019-02-23-Git Commit 전에 ESLint 자동 검사하기.md","hash":"5433e608c0bc44a70b26c31e2f36fb6e102c9d09","modified":1550932594261},{"_id":"source/_posts/2019-01-28-HandlerMethodArgumentResolver.md","hash":"e4498814d9142582996892f9c45e1e768e7cca8a","modified":1550932177848},{"_id":"public/post-sitemap.xml","hash":"0dbdf5da367959c01895195ed866dbdc0e8f38a5","modified":1550932600691},{"_id":"public/page-sitemap.xml","hash":"aee847e06df9c8523cf481081d987bdd0eb2887f","modified":1550932600700},{"_id":"public/tag-sitemap.xml","hash":"982fc8b9bbde5124a533d192f8d13165c60b3f99","modified":1550932600702},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1550932600703},{"_id":"public/2019/01/28/2019-01-28-HandlerMethodArgumentResolver/index.html","hash":"5ee19cd805ed98d451d59ff496c06593fc216e3e","modified":1550932600703},{"_id":"public/tags/JavaScript/index.html","hash":"3a6319899597c68dfce053f5791ac24a4566f027","modified":1550932600706},{"_id":"public/2019/02/23/2019-02-23-Git Commit 전에 ESLint 자동 검사하기/index.html","hash":"35921b559b241a977129ea929a398cf92afa43d6","modified":1550932600712},{"_id":"public/archives/2019/02/index.html","hash":"e27a93be03f8e8769d65acbbb3bc522ff0e99e05","modified":1550932600713}],"Category":[],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2018-02-24T10:35:39.122Z","updated":"2018-02-24T10:35:39.122Z","path":"404.html","title":"","comments":1,"_id":"cjshl279d0000jjpeskzw2bzq","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2016-04-20T19:48:33.000Z","description":"Wish for the Best, Prepare for the Worst","header-img":"img/header_img/Iron-Man-3.jpg","comments":1,"_content":"\n> 光有好奇心而不去實踐，等於自願放棄成功機會\n> 別為自己畫地自限，Just Do It！！\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ndescription: \"Wish for the Best, Prepare for the Worst\"\nheader-img: \"img/header_img/Iron-Man-3.jpg\"\ncomments: true\n---\n\n> 光有好奇心而不去實踐，等於自願放棄成功機會\n> 別為自己畫地自限，Just Do It！！\n","updated":"2018-02-24T10:35:39.133Z","path":"about/index.html","_id":"cjshl27al0002jjpe83fb5tiw","content":"<blockquote>\n<p>光有好奇心而不去實踐，等於自願放棄成功機會<br>\n別為自己畫地自限，Just Do It！！</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>光有好奇心而不去實踐，等於自願放棄成功機會<br>\n別為自己畫地自限，Just Do It！！</p>\n</blockquote>\n"},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"img/header_img/tag-bg.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"img/header_img/tag-bg.png\"\n---\n","date":"2018-02-24T10:35:39.174Z","updated":"2018-02-24T10:35:39.174Z","path":"tags/index.html","comments":1,"_id":"cjshl27ao0004jjpevj923ceg","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"archive","title":"Archives","header-img":"img/header_img/archive-bg.png","comments":0,"date":"2017-03-20T11:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"img/header_img/archive-bg.png\"\ncomments: false\ndate: 2017-03-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2018-02-24T10:35:39.133Z","path":"archive/index.html","_id":"cjshl27as0007jjpeq5fq9ucq","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Spring Security 암호화","catalog":true,"date":"2017-03-25T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n# Spring Security 암호화\n## 개요\n단순히 Spring-security을 이용해 DaoAuthenticationProvider와 UserDetailsService을 이용해 인증기능(로그인기능)을 구현하게되면 한가지 문제점이 존재한다. 보안사고가 발생할경우 비밀번호가 평문으로 되어있다는것이다. Spring에서는 plaintext, sha, sha256, md4, md5의 암호화 기능을 지원한다. Spring-security에서 DaoAuthenticationProviderClass는 암호화기능을 지원한다. 일반적으로 설정을 하지않을경우에는 PlaintextPasswordEncoder를 사용한다. PlaintextPasswordEncoderclass는 단순 문자열로 비교해서 비밀번호 일치여부를 판단한다. 만약 비밀번호를 암호화하고 이를 기준으로 암호를 비교하고싶다면 PasswordEncoderclass를 스프링 빈으로 등록하고 이것을 사용하면된다.\n\n> 기존의 org.springframework.security.authentication.encoding.PasswordEncode 인터페이스가 있었는데 이클래스는 salt방식으로 암호화처리를했는데 보안문제인지 모르겠지만 spring3.1+부터는org.springframework.security.crypto.passwordPasswordEncode인터페이스로 다시 재정의 했다. 여기에서 salt는 회원의 정보를 이용해 해커가 단어를 유추해 해킹을 방지하기위해 회원의 비번에 회원정보를 삽입해 비번을 만드는 방식이다.위에방식은 org.springframework.security.crypto.password.PasswordEncode인터페이스를 이용하는 방식이다. crypto.passwordPasswordEncode인터페이스는 salt방식의 데이터를 생성할때 데이터를 생성할때 유저개인정보가아닌 데이터를 랜덤하게 생성해서 암호화를 하는 방식으로 지원한다.\n\n## 내용\n***org.springframework.security.crypto.password.PasswordEncode인터페이스*** 는 2개의 메소드가 존재한다.\n\n* String encode(CharSequence rawPassword);\n  * 비번을 입력하면 암호화된 패스원드를 return한다\n* boolean matches(CharSequence rawPassword, String encodedPassword);\n  * 비번의 일치여부의 결과를 돌려준다\n  * 1번째 인자는 암호화되지않은 값을, 2번째는 암호화된값을 넣어주면된다.\n\n\n***org.springframework.security.crypto.password.PasswordEncode*** 인터페이스를 구현할 클래스\n\n* org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder\n  * org.springframework.security.crypto.bcrypt클래스를 이용해서 암화를 처리한다.\n  * Spring-security에서 추천하고 있는방식\n* org.springframework.security.crypto.password.NoOpPasswordEncoder\n  * 테스트용 목적으로 구현된 클래스이다. 실제로 값을 넣어도 암호화되지 않는다.\n* org.springframework.security.crypto.password.StandardPasswordEncoder\n  * 별도의 설정이없으면 sha-256으로 암호화를 한다.\n\n```xml\n<security:authentication-provider user-service-ref=\"customeUserDetailsService\">\n  <security:password-encoder hash=\"md5\"></security:password-encoder>\n</security:authentication-provider>\n```\n위에방식의 xml로 진행하게되면 md5로 hash값을 입력하게되면 md5로 진행하게된다.\n\n```xml\n<bean id=\"passwordEncoder\" class=\"org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder\"></bean>\n\n<security:authentication-manager alias=\"authenticationManager\">\n  <security:authentication-provider ref=\"customeAuthenticationProvider\">\n  </security:authentication-provider>\n    <security:authentication-provider user-service-ref=\"customeUserDetailsService\">\n      <security:password-encoder ref=\"passwordEncoder\" />\n    </security:authentication-provider>\n</security:authentication-manager>\n```\n\n\n하지만 일반적으로 비밀번호를 등록을해야하기때문에 위 xml방식으로 구현하게 된다.\n\n## 결론\n\n```java\n@Autowired\nBCryptPasswordEncoder passwordEncoder;\npasswordEncoder.encode(userPassword);//암호환값을 디비에저장한다\n```\n디비에 저정할 때 위와 같이 암호화해서 저장을한다.\n```java\n<security:password-encoder ref=\"passwordEncoder\" />\n```\nxml설정을 위와 같이 설정해주게되면 비밀번호를 체크를 할 때 자동으로 BCryptPasswordEncoder class 를통해 암호화 인증을 진행하게된다.\n\n참고 <br>\n* [사랑이 고픈프로그래머..](http://zgundam.tistory.com/54)<br>\n* [Spring 4.0 프로그래밍](http://storefarm.naver.com/dcvirus/products/458328014?NaPm=ct%3Dj06r6ydk%7Cci%3D1744f23aa4586709889a372fc15683afa2b4928e%7Ctr%3Dsls%7Csn%3D182521%7Chk%3Dab9fe496302792c50421edea06a3e322286ad2b9) / 최범균 /\n","source":"_posts/2017-03-26-spring-security-encryption.md","raw":"---\ntitle: Spring Security 암호화\ncatalog: true\ndate: 2017-03-26\nsubtitle:\nheader-img:\ntags:\n- Spring\n- Java\n---\n\n# Spring Security 암호화\n## 개요\n단순히 Spring-security을 이용해 DaoAuthenticationProvider와 UserDetailsService을 이용해 인증기능(로그인기능)을 구현하게되면 한가지 문제점이 존재한다. 보안사고가 발생할경우 비밀번호가 평문으로 되어있다는것이다. Spring에서는 plaintext, sha, sha256, md4, md5의 암호화 기능을 지원한다. Spring-security에서 DaoAuthenticationProviderClass는 암호화기능을 지원한다. 일반적으로 설정을 하지않을경우에는 PlaintextPasswordEncoder를 사용한다. PlaintextPasswordEncoderclass는 단순 문자열로 비교해서 비밀번호 일치여부를 판단한다. 만약 비밀번호를 암호화하고 이를 기준으로 암호를 비교하고싶다면 PasswordEncoderclass를 스프링 빈으로 등록하고 이것을 사용하면된다.\n\n> 기존의 org.springframework.security.authentication.encoding.PasswordEncode 인터페이스가 있었는데 이클래스는 salt방식으로 암호화처리를했는데 보안문제인지 모르겠지만 spring3.1+부터는org.springframework.security.crypto.passwordPasswordEncode인터페이스로 다시 재정의 했다. 여기에서 salt는 회원의 정보를 이용해 해커가 단어를 유추해 해킹을 방지하기위해 회원의 비번에 회원정보를 삽입해 비번을 만드는 방식이다.위에방식은 org.springframework.security.crypto.password.PasswordEncode인터페이스를 이용하는 방식이다. crypto.passwordPasswordEncode인터페이스는 salt방식의 데이터를 생성할때 데이터를 생성할때 유저개인정보가아닌 데이터를 랜덤하게 생성해서 암호화를 하는 방식으로 지원한다.\n\n## 내용\n***org.springframework.security.crypto.password.PasswordEncode인터페이스*** 는 2개의 메소드가 존재한다.\n\n* String encode(CharSequence rawPassword);\n  * 비번을 입력하면 암호화된 패스원드를 return한다\n* boolean matches(CharSequence rawPassword, String encodedPassword);\n  * 비번의 일치여부의 결과를 돌려준다\n  * 1번째 인자는 암호화되지않은 값을, 2번째는 암호화된값을 넣어주면된다.\n\n\n***org.springframework.security.crypto.password.PasswordEncode*** 인터페이스를 구현할 클래스\n\n* org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder\n  * org.springframework.security.crypto.bcrypt클래스를 이용해서 암화를 처리한다.\n  * Spring-security에서 추천하고 있는방식\n* org.springframework.security.crypto.password.NoOpPasswordEncoder\n  * 테스트용 목적으로 구현된 클래스이다. 실제로 값을 넣어도 암호화되지 않는다.\n* org.springframework.security.crypto.password.StandardPasswordEncoder\n  * 별도의 설정이없으면 sha-256으로 암호화를 한다.\n\n```xml\n<security:authentication-provider user-service-ref=\"customeUserDetailsService\">\n  <security:password-encoder hash=\"md5\"></security:password-encoder>\n</security:authentication-provider>\n```\n위에방식의 xml로 진행하게되면 md5로 hash값을 입력하게되면 md5로 진행하게된다.\n\n```xml\n<bean id=\"passwordEncoder\" class=\"org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder\"></bean>\n\n<security:authentication-manager alias=\"authenticationManager\">\n  <security:authentication-provider ref=\"customeAuthenticationProvider\">\n  </security:authentication-provider>\n    <security:authentication-provider user-service-ref=\"customeUserDetailsService\">\n      <security:password-encoder ref=\"passwordEncoder\" />\n    </security:authentication-provider>\n</security:authentication-manager>\n```\n\n\n하지만 일반적으로 비밀번호를 등록을해야하기때문에 위 xml방식으로 구현하게 된다.\n\n## 결론\n\n```java\n@Autowired\nBCryptPasswordEncoder passwordEncoder;\npasswordEncoder.encode(userPassword);//암호환값을 디비에저장한다\n```\n디비에 저정할 때 위와 같이 암호화해서 저장을한다.\n```java\n<security:password-encoder ref=\"passwordEncoder\" />\n```\nxml설정을 위와 같이 설정해주게되면 비밀번호를 체크를 할 때 자동으로 BCryptPasswordEncoder class 를통해 암호화 인증을 진행하게된다.\n\n참고 <br>\n* [사랑이 고픈프로그래머..](http://zgundam.tistory.com/54)<br>\n* [Spring 4.0 프로그래밍](http://storefarm.naver.com/dcvirus/products/458328014?NaPm=ct%3Dj06r6ydk%7Cci%3D1744f23aa4586709889a372fc15683afa2b4928e%7Ctr%3Dsls%7Csn%3D182521%7Chk%3Dab9fe496302792c50421edea06a3e322286ad2b9) / 최범균 /\n","slug":"2017-03-26-spring-security-encryption","published":1,"updated":"2018-06-20T16:05:18.286Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27ag0001jjpe4dultufg","content":"<h1><span id=\"spring-security-암호화\">Spring Security 암호화</span></h1>\n<h2><span id=\"개요\">개요</span></h2>\n<p>단순히 Spring-security을 이용해 DaoAuthenticationProvider와 UserDetailsService을 이용해 인증기능(로그인기능)을 구현하게되면 한가지 문제점이 존재한다. 보안사고가 발생할경우 비밀번호가 평문으로 되어있다는것이다. Spring에서는 plaintext, sha, sha256, md4, md5의 암호화 기능을 지원한다. Spring-security에서 DaoAuthenticationProviderClass는 암호화기능을 지원한다. 일반적으로 설정을 하지않을경우에는 PlaintextPasswordEncoder를 사용한다. PlaintextPasswordEncoderclass는 단순 문자열로 비교해서 비밀번호 일치여부를 판단한다. 만약 비밀번호를 암호화하고 이를 기준으로 암호를 비교하고싶다면 PasswordEncoderclass를 스프링 빈으로 등록하고 이것을 사용하면된다.</p>\n<blockquote>\n<p>기존의 org.springframework.security.authentication.encoding.PasswordEncode 인터페이스가 있었는데 이클래스는 salt방식으로 암호화처리를했는데 보안문제인지 모르겠지만 spring3.1+부터는org.springframework.security.crypto.passwordPasswordEncode인터페이스로 다시 재정의 했다. 여기에서 salt는 회원의 정보를 이용해 해커가 단어를 유추해 해킹을 방지하기위해 회원의 비번에 회원정보를 삽입해 비번을 만드는 방식이다.위에방식은 org.springframework.security.crypto.password.PasswordEncode인터페이스를 이용하는 방식이다. crypto.passwordPasswordEncode인터페이스는 salt방식의 데이터를 생성할때 데이터를 생성할때 유저개인정보가아닌 데이터를 랜덤하게 생성해서 암호화를 하는 방식으로 지원한다.</p>\n</blockquote>\n<h2><span id=\"내용\">내용</span></h2>\n<p><strong><em>org.springframework.security.crypto.password.PasswordEncode인터페이스</em></strong> 는 2개의 메소드가 존재한다.</p>\n<ul>\n<li>String encode(CharSequence rawPassword);\n<ul>\n<li>비번을 입력하면 암호화된 패스원드를 return한다</li>\n</ul>\n</li>\n<li>boolean matches(CharSequence rawPassword, String encodedPassword);\n<ul>\n<li>비번의 일치여부의 결과를 돌려준다</li>\n<li>1번째 인자는 암호화되지않은 값을, 2번째는 암호화된값을 넣어주면된다.</li>\n</ul>\n</li>\n</ul>\n<p><strong><em>org.springframework.security.crypto.password.PasswordEncode</em></strong> 인터페이스를 구현할 클래스</p>\n<ul>\n<li>org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder\n<ul>\n<li>org.springframework.security.crypto.bcrypt클래스를 이용해서 암화를 처리한다.</li>\n<li>Spring-security에서 추천하고 있는방식</li>\n</ul>\n</li>\n<li>org.springframework.security.crypto.password.NoOpPasswordEncoder\n<ul>\n<li>테스트용 목적으로 구현된 클래스이다. 실제로 값을 넣어도 암호화되지 않는다.</li>\n</ul>\n</li>\n<li>org.springframework.security.crypto.password.StandardPasswordEncoder\n<ul>\n<li>별도의 설정이없으면 sha-256으로 암호화를 한다.</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">security:authentication-provider</span> <span class=\"attr\">user-service-ref</span>=<span class=\"string\">\"customeUserDetailsService\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">security:password-encoder</span> <span class=\"attr\">hash</span>=<span class=\"string\">\"md5\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">security:password-encoder</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">security:authentication-provider</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>위에방식의 xml로 진행하게되면 md5로 hash값을 입력하게되면 md5로 진행하게된다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"passwordEncoder\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">security:authentication-manager</span> <span class=\"attr\">alias</span>=<span class=\"string\">\"authenticationManager\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">security:authentication-provider</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"customeAuthenticationProvider\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">security:authentication-provider</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">security:authentication-provider</span> <span class=\"attr\">user-service-ref</span>=<span class=\"string\">\"customeUserDetailsService\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">security:password-encoder</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"passwordEncoder\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">security:authentication-provider</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">security:authentication-manager</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>하지만 일반적으로 비밀번호를 등록을해야하기때문에 위 xml방식으로 구현하게 된다.</p>\n<h2><span id=\"결론\">결론</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\">BCryptPasswordEncoder passwordEncoder;</span><br><span class=\"line\">passwordEncoder.encode(userPassword);<span class=\"comment\">//암호환값을 디비에저장한다</span></span><br></pre></td></tr></table></figure>\n<p>디비에 저정할 때 위와 같이 암호화해서 저장을한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;security:password-encoder ref=<span class=\"string\">\"passwordEncoder\"</span> /&gt;</span><br></pre></td></tr></table></figure>\n<p>xml설정을 위와 같이 설정해주게되면 비밀번호를 체크를 할 때 자동으로 BCryptPasswordEncoder class 를통해 암호화 인증을 진행하게된다.</p>\n<p>참고 <br></p>\n<ul>\n<li><a href=\"http://zgundam.tistory.com/54\" target=\"_blank\" rel=\"noopener\">사랑이 고픈프로그래머…</a><br></li>\n<li><a href=\"http://storefarm.naver.com/dcvirus/products/458328014?NaPm=ct%3Dj06r6ydk%7Cci%3D1744f23aa4586709889a372fc15683afa2b4928e%7Ctr%3Dsls%7Csn%3D182521%7Chk%3Dab9fe496302792c50421edea06a3e322286ad2b9\" target=\"_blank\" rel=\"noopener\">Spring 4.0 프로그래밍</a> / 최범균 /</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>Spring Security 암호화</h1>\n<h2>개요</h2>\n<p>단순히 Spring-security을 이용해 DaoAuthenticationProvider와 UserDetailsService을 이용해 인증기능(로그인기능)을 구현하게되면 한가지 문제점이 존재한다. 보안사고가 발생할경우 비밀번호가 평문으로 되어있다는것이다. Spring에서는 plaintext, sha, sha256, md4, md5의 암호화 기능을 지원한다. Spring-security에서 DaoAuthenticationProviderClass는 암호화기능을 지원한다. 일반적으로 설정을 하지않을경우에는 PlaintextPasswordEncoder를 사용한다. PlaintextPasswordEncoderclass는 단순 문자열로 비교해서 비밀번호 일치여부를 판단한다. 만약 비밀번호를 암호화하고 이를 기준으로 암호를 비교하고싶다면 PasswordEncoderclass를 스프링 빈으로 등록하고 이것을 사용하면된다.</p>\n<blockquote>\n<p>기존의 org.springframework.security.authentication.encoding.PasswordEncode 인터페이스가 있었는데 이클래스는 salt방식으로 암호화처리를했는데 보안문제인지 모르겠지만 spring3.1+부터는org.springframework.security.crypto.passwordPasswordEncode인터페이스로 다시 재정의 했다. 여기에서 salt는 회원의 정보를 이용해 해커가 단어를 유추해 해킹을 방지하기위해 회원의 비번에 회원정보를 삽입해 비번을 만드는 방식이다.위에방식은 org.springframework.security.crypto.password.PasswordEncode인터페이스를 이용하는 방식이다. crypto.passwordPasswordEncode인터페이스는 salt방식의 데이터를 생성할때 데이터를 생성할때 유저개인정보가아닌 데이터를 랜덤하게 생성해서 암호화를 하는 방식으로 지원한다.</p>\n</blockquote>\n<h2>내용</h2>\n<p><strong><em>org.springframework.security.crypto.password.PasswordEncode인터페이스</em></strong> 는 2개의 메소드가 존재한다.</p>\n<ul>\n<li>String encode(CharSequence rawPassword);\n<ul>\n<li>비번을 입력하면 암호화된 패스원드를 return한다</li>\n</ul>\n</li>\n<li>boolean matches(CharSequence rawPassword, String encodedPassword);\n<ul>\n<li>비번의 일치여부의 결과를 돌려준다</li>\n<li>1번째 인자는 암호화되지않은 값을, 2번째는 암호화된값을 넣어주면된다.</li>\n</ul>\n</li>\n</ul>\n<p><strong><em>org.springframework.security.crypto.password.PasswordEncode</em></strong> 인터페이스를 구현할 클래스</p>\n<ul>\n<li>org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder\n<ul>\n<li>org.springframework.security.crypto.bcrypt클래스를 이용해서 암화를 처리한다.</li>\n<li>Spring-security에서 추천하고 있는방식</li>\n</ul>\n</li>\n<li>org.springframework.security.crypto.password.NoOpPasswordEncoder\n<ul>\n<li>테스트용 목적으로 구현된 클래스이다. 실제로 값을 넣어도 암호화되지 않는다.</li>\n</ul>\n</li>\n<li>org.springframework.security.crypto.password.StandardPasswordEncoder\n<ul>\n<li>별도의 설정이없으면 sha-256으로 암호화를 한다.</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">security:authentication-provider</span> <span class=\"attr\">user-service-ref</span>=<span class=\"string\">\"customeUserDetailsService\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">security:password-encoder</span> <span class=\"attr\">hash</span>=<span class=\"string\">\"md5\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">security:password-encoder</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">security:authentication-provider</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>위에방식의 xml로 진행하게되면 md5로 hash값을 입력하게되면 md5로 진행하게된다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"passwordEncoder\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">security:authentication-manager</span> <span class=\"attr\">alias</span>=<span class=\"string\">\"authenticationManager\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">security:authentication-provider</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"customeAuthenticationProvider\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">security:authentication-provider</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">security:authentication-provider</span> <span class=\"attr\">user-service-ref</span>=<span class=\"string\">\"customeUserDetailsService\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">security:password-encoder</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"passwordEncoder\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">security:authentication-provider</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">security:authentication-manager</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>하지만 일반적으로 비밀번호를 등록을해야하기때문에 위 xml방식으로 구현하게 된다.</p>\n<h2>결론</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\">BCryptPasswordEncoder passwordEncoder;</span><br><span class=\"line\">passwordEncoder.encode(userPassword);<span class=\"comment\">//암호환값을 디비에저장한다</span></span><br></pre></td></tr></table></figure>\n<p>디비에 저정할 때 위와 같이 암호화해서 저장을한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;security:password-encoder ref=<span class=\"string\">\"passwordEncoder\"</span> /&gt;</span><br></pre></td></tr></table></figure>\n<p>xml설정을 위와 같이 설정해주게되면 비밀번호를 체크를 할 때 자동으로 BCryptPasswordEncoder class 를통해 암호화 인증을 진행하게된다.</p>\n<p>참고 <br></p>\n<ul>\n<li><a href=\"http://zgundam.tistory.com/54\" target=\"_blank\" rel=\"noopener\">사랑이 고픈프로그래머…</a><br></li>\n<li><a href=\"http://storefarm.naver.com/dcvirus/products/458328014?NaPm=ct%3Dj06r6ydk%7Cci%3D1744f23aa4586709889a372fc15683afa2b4928e%7Ctr%3Dsls%7Csn%3D182521%7Chk%3Dab9fe496302792c50421edea06a3e322286ad2b9\" target=\"_blank\" rel=\"noopener\">Spring 4.0 프로그래밍</a> / 최범균 /</li>\n</ul>\n"},{"title":"Spring-security-구조","catalog":true,"date":"2017-03-24T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n## Spring Security 구조\n먼저 Spring Security에서 유저 인증을 구현할 때 최상위 인터페이스로는 아래 그림 같이 Authentication Manager Interface가 존재한다. 그리고 ***authenticationManager*** Interface를 통해 유저 인증 구현 한다.\n![](http://i.imgur.com/m5dfYew.png)\n***<center>[이미지 1]</center>***\n위 그림과 같이 ***authenticationManager*** 의 구현체로 ***ProviderManager*** 가 존재한다. ***ProviderManager*** 는 인증구현을 ***AuthenticationProvider Interface*** 에게 위임한다. 일반적으로 ***AuthenticationProvider*** 을 커스터마이징해서 인증을 구현한다. ***AuthenticationProvider*** 구현체는 3개가 있고, 이것에 인증에 성공하지 못할경우 예외처리가 발생한다. 구현체로 ***DaoAuthenticationProvider, LadpAuthenticationProvider, OpenIdAuthenticationProvider*** 가 존재한다.\n![](http://i.imgur.com/ByfYXXm.png)\n\n***<center>[이미지 2]</center>***\n**이미지2** 는 AuthenticationProvider구현체까지 구현된 class다이어그램이다. 그림에서 보듯이 DaoAuthenticationProvider는 내부적으로 UserDetailsService를 이용해서 사용자 정보를 읽어오는데 아래 이미지 3은 Spring Security에서 UserDetailsService의 구현체인 jdbcDaoImpl까지 구현된 class다이어그램이다. 유저가 로그인을 하게되면 UserDetailsService의 loadUserByUsername으로 유저를 조회해 AuthencationProvider로 리턴해주고 AuthencationProvider의 authenticate메소드에서 유저가 입력한 비번과 대조하게된다.\n\n![](http://i.imgur.com/nCawRsL.png)\n***<center>[이미지 3]</center>***\n인증에 성공하게 되면 authenticate메소드에서 authentication 객체를 리턴해야한다. authentication 객체는 스프링에서 구현해놓은은 UsernamePasswordAuthenticationToken 사용해도 무방하다.UsernamePasswordAuthenticationToken(UserDetailsService.loadUserByUsername(String username),null(보통은널),권한) 을 생성하게되면 Aunthetication이 생성되어지고 최종적으로 이것을 리턴해주게되면 security 인증이 끝나게 된다.\n\n## Security 인증 순서\nSecurity 인증 순서는 ***UserDetailsService*** 에 loadUserByUsername(String username)로 디비에서 유저정보를 조회 해오면 ***AuthenticationProvider*** 에서 authenticate(Authentication authentication)메소드로 ***UserDetailsService.loadUserByUsername(String username)*** 메소드로 가지고온 디비유저정보와 authenticate(Authentication authentication)로 접속한유저 정보(authentication)로 비밀번호를 인증을 처리하게되고 ***AuthenticationProvider***  인증에 성공하게되면 ***Authentication객체*** 를 돌려준게된다.\n* 디비에서 유저정보를 불러오려면 UserDetailsService interface를 직접 구현하면 된다.\n* 비밀번호 비교를 직접 구현하려면 AuthenticationProvider 구현하면 된다.\n* AuthenticationProvider을 따로 구현안해도 UserDetailsService로 유저정보를 추가할수 있다.\n\n아이디/패스워드 사용자 정보를 넣고 실제 가입된 사용자인지 체크한후 인증에 성공하면 사용자의 principal과 credential 정보를 Authentication에 담습니다.\n![](http://i.imgur.com/77uaOY2.png)\nSpring Security에서 방금 담은 Authentication을  SecurityContext에 보관합니다.\n![](http://i.imgur.com/0PY4TWC.png)\n이 SecurityContext를 SecurityContextHolder에 담아 보관하게 됩니다.\n![](http://i.imgur.com/a3pQv6A.png)\n## 결론\n\n1. 스프링 시큐리는 크게 2가지 인증/인가 처리를 도와준다. (AuthenticationProvider,UserDetailsService)\n2. o.s.security.core.Authentication은 시큐리티에서 접근한 외부에서 접근한 정보를 보관하는 역할을한다.(이름,권한,인증여부등을 조회함)\n3. 이러한 Authentication 정보는 o.s.s.core.context.SecurityContextHolder안에서 가지고온다.\n4. 그리고 Authentication의 정보는 최초 SecurityContextHolder 맨처음에 접근하는 세션이 이곳에 먼저 저장되어져 위에와같은 로직이 진행되는 것이다.\n    * 이것들이 필터체인에 순서대로적용된다. 이순서가 필터중에서 가장먼저 실행됨.\n5. 최종적으로 SecurityContextHolder.getContext().getAuthentication()으로 유저 정보를 불러오게 된다.\n5. 스프링 시큐리가 제공해주는 authentication-provider을 이용해 인증을 진행하게되는데 유저 인증은 UserDetailsService에 UserDetails객체를 이용해 인증을 진행하게 된다.\n    * <jdbc-user-service>을 사용하게되면 인증을 알아서 진행하는듯, 단 유저정보를 가지고올수있는 제약이걸림 사실상 사용못함(userdetailsserver을 구현해서 사용해야함).\n6. 그렇게 UserDetailsService에서 데이터를 가지고와서 DaoAuthenticationProvider에서 인증과정을 거친다.(UserDetailsService의 loadUserByUsername메소드를 이용함)\n7. 만약에 UserDetailsService를 커스텀 한다면 loadUserByUsername에서 회원정보를 꼭리턴해줘야한다. 왜냐하면 아까 말했듯이 이것을 통해 사용자가 입력한 암호를 비교 하기때문이다.\n\n\n참고<br>\n* [버리야 놀자](http://flyburi.com/584) <br>\n* [Spring 4.0 프로그래밍](http://storefarm.naver.com/dcvirus/products/458328014?NaPm=ct%3Dj06r6ydk%7Cci%3D1744f23aa4586709889a372fc15683afa2b4928e%7Ctr%3Dsls%7Csn%3D182521%7Chk%3Dab9fe496302792c50421edea06a3e322286ad2b9) / 최범균 /<br>\n* [Syaku(샤쿠)](http://syaku.tistory.com/286)<br>\n","source":"_posts/2017-03-25-spring-security-theory.md","raw":"---\ntitle: Spring-security-구조\ncatalog: true\ndate: 2017-3-25\nsubtitle:\nheader-img:\ntags:\n- Spring\n- Java\n---\n\n## Spring Security 구조\n먼저 Spring Security에서 유저 인증을 구현할 때 최상위 인터페이스로는 아래 그림 같이 Authentication Manager Interface가 존재한다. 그리고 ***authenticationManager*** Interface를 통해 유저 인증 구현 한다.\n![](http://i.imgur.com/m5dfYew.png)\n***<center>[이미지 1]</center>***\n위 그림과 같이 ***authenticationManager*** 의 구현체로 ***ProviderManager*** 가 존재한다. ***ProviderManager*** 는 인증구현을 ***AuthenticationProvider Interface*** 에게 위임한다. 일반적으로 ***AuthenticationProvider*** 을 커스터마이징해서 인증을 구현한다. ***AuthenticationProvider*** 구현체는 3개가 있고, 이것에 인증에 성공하지 못할경우 예외처리가 발생한다. 구현체로 ***DaoAuthenticationProvider, LadpAuthenticationProvider, OpenIdAuthenticationProvider*** 가 존재한다.\n![](http://i.imgur.com/ByfYXXm.png)\n\n***<center>[이미지 2]</center>***\n**이미지2** 는 AuthenticationProvider구현체까지 구현된 class다이어그램이다. 그림에서 보듯이 DaoAuthenticationProvider는 내부적으로 UserDetailsService를 이용해서 사용자 정보를 읽어오는데 아래 이미지 3은 Spring Security에서 UserDetailsService의 구현체인 jdbcDaoImpl까지 구현된 class다이어그램이다. 유저가 로그인을 하게되면 UserDetailsService의 loadUserByUsername으로 유저를 조회해 AuthencationProvider로 리턴해주고 AuthencationProvider의 authenticate메소드에서 유저가 입력한 비번과 대조하게된다.\n\n![](http://i.imgur.com/nCawRsL.png)\n***<center>[이미지 3]</center>***\n인증에 성공하게 되면 authenticate메소드에서 authentication 객체를 리턴해야한다. authentication 객체는 스프링에서 구현해놓은은 UsernamePasswordAuthenticationToken 사용해도 무방하다.UsernamePasswordAuthenticationToken(UserDetailsService.loadUserByUsername(String username),null(보통은널),권한) 을 생성하게되면 Aunthetication이 생성되어지고 최종적으로 이것을 리턴해주게되면 security 인증이 끝나게 된다.\n\n## Security 인증 순서\nSecurity 인증 순서는 ***UserDetailsService*** 에 loadUserByUsername(String username)로 디비에서 유저정보를 조회 해오면 ***AuthenticationProvider*** 에서 authenticate(Authentication authentication)메소드로 ***UserDetailsService.loadUserByUsername(String username)*** 메소드로 가지고온 디비유저정보와 authenticate(Authentication authentication)로 접속한유저 정보(authentication)로 비밀번호를 인증을 처리하게되고 ***AuthenticationProvider***  인증에 성공하게되면 ***Authentication객체*** 를 돌려준게된다.\n* 디비에서 유저정보를 불러오려면 UserDetailsService interface를 직접 구현하면 된다.\n* 비밀번호 비교를 직접 구현하려면 AuthenticationProvider 구현하면 된다.\n* AuthenticationProvider을 따로 구현안해도 UserDetailsService로 유저정보를 추가할수 있다.\n\n아이디/패스워드 사용자 정보를 넣고 실제 가입된 사용자인지 체크한후 인증에 성공하면 사용자의 principal과 credential 정보를 Authentication에 담습니다.\n![](http://i.imgur.com/77uaOY2.png)\nSpring Security에서 방금 담은 Authentication을  SecurityContext에 보관합니다.\n![](http://i.imgur.com/0PY4TWC.png)\n이 SecurityContext를 SecurityContextHolder에 담아 보관하게 됩니다.\n![](http://i.imgur.com/a3pQv6A.png)\n## 결론\n\n1. 스프링 시큐리는 크게 2가지 인증/인가 처리를 도와준다. (AuthenticationProvider,UserDetailsService)\n2. o.s.security.core.Authentication은 시큐리티에서 접근한 외부에서 접근한 정보를 보관하는 역할을한다.(이름,권한,인증여부등을 조회함)\n3. 이러한 Authentication 정보는 o.s.s.core.context.SecurityContextHolder안에서 가지고온다.\n4. 그리고 Authentication의 정보는 최초 SecurityContextHolder 맨처음에 접근하는 세션이 이곳에 먼저 저장되어져 위에와같은 로직이 진행되는 것이다.\n    * 이것들이 필터체인에 순서대로적용된다. 이순서가 필터중에서 가장먼저 실행됨.\n5. 최종적으로 SecurityContextHolder.getContext().getAuthentication()으로 유저 정보를 불러오게 된다.\n5. 스프링 시큐리가 제공해주는 authentication-provider을 이용해 인증을 진행하게되는데 유저 인증은 UserDetailsService에 UserDetails객체를 이용해 인증을 진행하게 된다.\n    * <jdbc-user-service>을 사용하게되면 인증을 알아서 진행하는듯, 단 유저정보를 가지고올수있는 제약이걸림 사실상 사용못함(userdetailsserver을 구현해서 사용해야함).\n6. 그렇게 UserDetailsService에서 데이터를 가지고와서 DaoAuthenticationProvider에서 인증과정을 거친다.(UserDetailsService의 loadUserByUsername메소드를 이용함)\n7. 만약에 UserDetailsService를 커스텀 한다면 loadUserByUsername에서 회원정보를 꼭리턴해줘야한다. 왜냐하면 아까 말했듯이 이것을 통해 사용자가 입력한 암호를 비교 하기때문이다.\n\n\n참고<br>\n* [버리야 놀자](http://flyburi.com/584) <br>\n* [Spring 4.0 프로그래밍](http://storefarm.naver.com/dcvirus/products/458328014?NaPm=ct%3Dj06r6ydk%7Cci%3D1744f23aa4586709889a372fc15683afa2b4928e%7Ctr%3Dsls%7Csn%3D182521%7Chk%3Dab9fe496302792c50421edea06a3e322286ad2b9) / 최범균 /<br>\n* [Syaku(샤쿠)](http://syaku.tistory.com/286)<br>\n","slug":"2017-03-25-spring-security-theory","published":1,"updated":"2018-06-20T16:05:18.290Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27am0003jjpezjg34o2h","content":"<h2><span id=\"spring-security-구조\">Spring Security 구조</span></h2>\n<p>먼저 Spring Security에서 유저 인증을 구현할 때 최상위 인터페이스로는 아래 그림 같이 Authentication Manager Interface가 존재한다. 그리고 <strong><em>authenticationManager</em></strong> Interface를 통해 유저 인증 구현 한다.<br>\n<img src=\"http://i.imgur.com/m5dfYew.png\" alt=\"\"><br>\n<strong><em><center>[이미지 1]</center></em></strong><br>\n위 그림과 같이 <strong><em>authenticationManager</em></strong> 의 구현체로 <strong><em>ProviderManager</em></strong> 가 존재한다. <strong><em>ProviderManager</em></strong> 는 인증구현을 <strong><em>AuthenticationProvider Interface</em></strong> 에게 위임한다. 일반적으로 <strong><em>AuthenticationProvider</em></strong> 을 커스터마이징해서 인증을 구현한다. <strong><em>AuthenticationProvider</em></strong> 구현체는 3개가 있고, 이것에 인증에 성공하지 못할경우 예외처리가 발생한다. 구현체로 <strong><em>DaoAuthenticationProvider, LadpAuthenticationProvider, OpenIdAuthenticationProvider</em></strong> 가 존재한다.<br>\n<img src=\"http://i.imgur.com/ByfYXXm.png\" alt=\"\"></p>\n<p><strong><em><center>[이미지 2]</center></em></strong><br>\n<strong>이미지2</strong> 는 AuthenticationProvider구현체까지 구현된 class다이어그램이다. 그림에서 보듯이 DaoAuthenticationProvider는 내부적으로 UserDetailsService를 이용해서 사용자 정보를 읽어오는데 아래 이미지 3은 Spring Security에서 UserDetailsService의 구현체인 jdbcDaoImpl까지 구현된 class다이어그램이다. 유저가 로그인을 하게되면 UserDetailsService의 loadUserByUsername으로 유저를 조회해 AuthencationProvider로 리턴해주고 AuthencationProvider의 authenticate메소드에서 유저가 입력한 비번과 대조하게된다.</p>\n<p><img src=\"http://i.imgur.com/nCawRsL.png\" alt=\"\"><br>\n<strong><em><center>[이미지 3]</center></em></strong><br>\n인증에 성공하게 되면 authenticate메소드에서 authentication 객체를 리턴해야한다. authentication 객체는 스프링에서 구현해놓은은 UsernamePasswordAuthenticationToken 사용해도 무방하다.UsernamePasswordAuthenticationToken(UserDetailsService.loadUserByUsername(String username),null(보통은널),권한) 을 생성하게되면 Aunthetication이 생성되어지고 최종적으로 이것을 리턴해주게되면 security 인증이 끝나게 된다.</p>\n<h2><span id=\"security-인증-순서\">Security 인증 순서</span></h2>\n<p>Security 인증 순서는 <strong><em>UserDetailsService</em></strong> 에 loadUserByUsername(String username)로 디비에서 유저정보를 조회 해오면 <strong><em>AuthenticationProvider</em></strong> 에서 authenticate(Authentication authentication)메소드로 <strong><em>UserDetailsService.loadUserByUsername(String username)</em></strong> 메소드로 가지고온 디비유저정보와 authenticate(Authentication authentication)로 접속한유저 정보(authentication)로 비밀번호를 인증을 처리하게되고 <strong><em>AuthenticationProvider</em></strong>  인증에 성공하게되면 <strong><em>Authentication객체</em></strong> 를 돌려준게된다.</p>\n<ul>\n<li>디비에서 유저정보를 불러오려면 UserDetailsService interface를 직접 구현하면 된다.</li>\n<li>비밀번호 비교를 직접 구현하려면 AuthenticationProvider 구현하면 된다.</li>\n<li>AuthenticationProvider을 따로 구현안해도 UserDetailsService로 유저정보를 추가할수 있다.</li>\n</ul>\n<p>아이디/패스워드 사용자 정보를 넣고 실제 가입된 사용자인지 체크한후 인증에 성공하면 사용자의 principal과 credential 정보를 Authentication에 담습니다.<br>\n<img src=\"http://i.imgur.com/77uaOY2.png\" alt=\"\"><br>\nSpring Security에서 방금 담은 Authentication을  SecurityContext에 보관합니다.<br>\n<img src=\"http://i.imgur.com/0PY4TWC.png\" alt=\"\"><br>\n이 SecurityContext를 SecurityContextHolder에 담아 보관하게 됩니다.<br>\n<img src=\"http://i.imgur.com/a3pQv6A.png\" alt=\"\"></p>\n<h2><span id=\"결론\">결론</span></h2>\n<ol>\n<li>스프링 시큐리는 크게 2가지 인증/인가 처리를 도와준다. (AuthenticationProvider,UserDetailsService)</li>\n<li>o.s.security.core.Authentication은 시큐리티에서 접근한 외부에서 접근한 정보를 보관하는 역할을한다.(이름,권한,인증여부등을 조회함)</li>\n<li>이러한 Authentication 정보는 o.s.s.core.context.SecurityContextHolder안에서 가지고온다.</li>\n<li>그리고 Authentication의 정보는 최초 SecurityContextHolder 맨처음에 접근하는 세션이 이곳에 먼저 저장되어져 위에와같은 로직이 진행되는 것이다.\n<ul>\n<li>이것들이 필터체인에 순서대로적용된다. 이순서가 필터중에서 가장먼저 실행됨.</li>\n</ul>\n</li>\n<li>최종적으로 SecurityContextHolder.getContext().getAuthentication()으로 유저 정보를 불러오게 된다.</li>\n<li>스프링 시큐리가 제공해주는 authentication-provider을 이용해 인증을 진행하게되는데 유저 인증은 UserDetailsService에 UserDetails객체를 이용해 인증을 진행하게 된다.\n<ul>\n<li><jdbc-user-service>을 사용하게되면 인증을 알아서 진행하는듯, 단 유저정보를 가지고올수있는 제약이걸림 사실상 사용못함(userdetailsserver을 구현해서 사용해야함).</jdbc-user-service></li>\n</ul>\n</li>\n<li>그렇게 UserDetailsService에서 데이터를 가지고와서 DaoAuthenticationProvider에서 인증과정을 거친다.(UserDetailsService의 loadUserByUsername메소드를 이용함)</li>\n<li>만약에 UserDetailsService를 커스텀 한다면 loadUserByUsername에서 회원정보를 꼭리턴해줘야한다. 왜냐하면 아까 말했듯이 이것을 통해 사용자가 입력한 암호를 비교 하기때문이다.</li>\n</ol>\n<p>참고<br></p>\n<ul>\n<li><a href=\"http://flyburi.com/584\" target=\"_blank\" rel=\"noopener\">버리야 놀자</a> <br></li>\n<li><a href=\"http://storefarm.naver.com/dcvirus/products/458328014?NaPm=ct%3Dj06r6ydk%7Cci%3D1744f23aa4586709889a372fc15683afa2b4928e%7Ctr%3Dsls%7Csn%3D182521%7Chk%3Dab9fe496302792c50421edea06a3e322286ad2b9\" target=\"_blank\" rel=\"noopener\">Spring 4.0 프로그래밍</a> / 최범균 /<br></li>\n<li><a href=\"http://syaku.tistory.com/286\" target=\"_blank\" rel=\"noopener\">Syaku(샤쿠)</a><br></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>Spring Security 구조</h2>\n<p>먼저 Spring Security에서 유저 인증을 구현할 때 최상위 인터페이스로는 아래 그림 같이 Authentication Manager Interface가 존재한다. 그리고 <strong><em>authenticationManager</em></strong> Interface를 통해 유저 인증 구현 한다.<br>\n<img src=\"http://i.imgur.com/m5dfYew.png\" alt=\"\"><br>\n<strong><em><center>[이미지 1]</center></em></strong><br>\n위 그림과 같이 <strong><em>authenticationManager</em></strong> 의 구현체로 <strong><em>ProviderManager</em></strong> 가 존재한다. <strong><em>ProviderManager</em></strong> 는 인증구현을 <strong><em>AuthenticationProvider Interface</em></strong> 에게 위임한다. 일반적으로 <strong><em>AuthenticationProvider</em></strong> 을 커스터마이징해서 인증을 구현한다. <strong><em>AuthenticationProvider</em></strong> 구현체는 3개가 있고, 이것에 인증에 성공하지 못할경우 예외처리가 발생한다. 구현체로 <strong><em>DaoAuthenticationProvider, LadpAuthenticationProvider, OpenIdAuthenticationProvider</em></strong> 가 존재한다.<br>\n<img src=\"http://i.imgur.com/ByfYXXm.png\" alt=\"\"></p>\n<p><strong><em><center>[이미지 2]</center></em></strong><br>\n<strong>이미지2</strong> 는 AuthenticationProvider구현체까지 구현된 class다이어그램이다. 그림에서 보듯이 DaoAuthenticationProvider는 내부적으로 UserDetailsService를 이용해서 사용자 정보를 읽어오는데 아래 이미지 3은 Spring Security에서 UserDetailsService의 구현체인 jdbcDaoImpl까지 구현된 class다이어그램이다. 유저가 로그인을 하게되면 UserDetailsService의 loadUserByUsername으로 유저를 조회해 AuthencationProvider로 리턴해주고 AuthencationProvider의 authenticate메소드에서 유저가 입력한 비번과 대조하게된다.</p>\n<p><img src=\"http://i.imgur.com/nCawRsL.png\" alt=\"\"><br>\n<strong><em><center>[이미지 3]</center></em></strong><br>\n인증에 성공하게 되면 authenticate메소드에서 authentication 객체를 리턴해야한다. authentication 객체는 스프링에서 구현해놓은은 UsernamePasswordAuthenticationToken 사용해도 무방하다.UsernamePasswordAuthenticationToken(UserDetailsService.loadUserByUsername(String username),null(보통은널),권한) 을 생성하게되면 Aunthetication이 생성되어지고 최종적으로 이것을 리턴해주게되면 security 인증이 끝나게 된다.</p>\n<h2>Security 인증 순서</h2>\n<p>Security 인증 순서는 <strong><em>UserDetailsService</em></strong> 에 loadUserByUsername(String username)로 디비에서 유저정보를 조회 해오면 <strong><em>AuthenticationProvider</em></strong> 에서 authenticate(Authentication authentication)메소드로 <strong><em>UserDetailsService.loadUserByUsername(String username)</em></strong> 메소드로 가지고온 디비유저정보와 authenticate(Authentication authentication)로 접속한유저 정보(authentication)로 비밀번호를 인증을 처리하게되고 <strong><em>AuthenticationProvider</em></strong>  인증에 성공하게되면 <strong><em>Authentication객체</em></strong> 를 돌려준게된다.</p>\n<ul>\n<li>디비에서 유저정보를 불러오려면 UserDetailsService interface를 직접 구현하면 된다.</li>\n<li>비밀번호 비교를 직접 구현하려면 AuthenticationProvider 구현하면 된다.</li>\n<li>AuthenticationProvider을 따로 구현안해도 UserDetailsService로 유저정보를 추가할수 있다.</li>\n</ul>\n<p>아이디/패스워드 사용자 정보를 넣고 실제 가입된 사용자인지 체크한후 인증에 성공하면 사용자의 principal과 credential 정보를 Authentication에 담습니다.<br>\n<img src=\"http://i.imgur.com/77uaOY2.png\" alt=\"\"><br>\nSpring Security에서 방금 담은 Authentication을  SecurityContext에 보관합니다.<br>\n<img src=\"http://i.imgur.com/0PY4TWC.png\" alt=\"\"><br>\n이 SecurityContext를 SecurityContextHolder에 담아 보관하게 됩니다.<br>\n<img src=\"http://i.imgur.com/a3pQv6A.png\" alt=\"\"></p>\n<h2>결론</h2>\n<ol>\n<li>스프링 시큐리는 크게 2가지 인증/인가 처리를 도와준다. (AuthenticationProvider,UserDetailsService)</li>\n<li>o.s.security.core.Authentication은 시큐리티에서 접근한 외부에서 접근한 정보를 보관하는 역할을한다.(이름,권한,인증여부등을 조회함)</li>\n<li>이러한 Authentication 정보는 o.s.s.core.context.SecurityContextHolder안에서 가지고온다.</li>\n<li>그리고 Authentication의 정보는 최초 SecurityContextHolder 맨처음에 접근하는 세션이 이곳에 먼저 저장되어져 위에와같은 로직이 진행되는 것이다.\n<ul>\n<li>이것들이 필터체인에 순서대로적용된다. 이순서가 필터중에서 가장먼저 실행됨.</li>\n</ul>\n</li>\n<li>최종적으로 SecurityContextHolder.getContext().getAuthentication()으로 유저 정보를 불러오게 된다.</li>\n<li>스프링 시큐리가 제공해주는 authentication-provider을 이용해 인증을 진행하게되는데 유저 인증은 UserDetailsService에 UserDetails객체를 이용해 인증을 진행하게 된다.\n<ul>\n<li><jdbc-user-service>을 사용하게되면 인증을 알아서 진행하는듯, 단 유저정보를 가지고올수있는 제약이걸림 사실상 사용못함(userdetailsserver을 구현해서 사용해야함).</jdbc-user-service></li>\n</ul>\n</li>\n<li>그렇게 UserDetailsService에서 데이터를 가지고와서 DaoAuthenticationProvider에서 인증과정을 거친다.(UserDetailsService의 loadUserByUsername메소드를 이용함)</li>\n<li>만약에 UserDetailsService를 커스텀 한다면 loadUserByUsername에서 회원정보를 꼭리턴해줘야한다. 왜냐하면 아까 말했듯이 이것을 통해 사용자가 입력한 암호를 비교 하기때문이다.</li>\n</ol>\n<p>참고<br></p>\n<ul>\n<li><a href=\"http://flyburi.com/584\" target=\"_blank\" rel=\"noopener\">버리야 놀자</a> <br></li>\n<li><a href=\"http://storefarm.naver.com/dcvirus/products/458328014?NaPm=ct%3Dj06r6ydk%7Cci%3D1744f23aa4586709889a372fc15683afa2b4928e%7Ctr%3Dsls%7Csn%3D182521%7Chk%3Dab9fe496302792c50421edea06a3e322286ad2b9\" target=\"_blank\" rel=\"noopener\">Spring 4.0 프로그래밍</a> / 최범균 /<br></li>\n<li><a href=\"http://syaku.tistory.com/286\" target=\"_blank\" rel=\"noopener\">Syaku(샤쿠)</a><br></li>\n</ul>\n"},{"title":"JDBC, Connection, ConnectionPool, Datasource, JdbcTemplate이란 ?","catalog":true,"date":"2017-04-07T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n## JDBC, Connection, ConnectionPool, Datasource, JdbcTemplate이란 ?\n먼저 위 타이틀을 알아보기전에 아래소스를 보자. 왜 위 API들이 우리에게 필요한지 알아보자. 우리가 자바를 사용해서 디비에서 List형태의 데이터를 불러오려면 아래와같이 복잡한 소스를 작성해야한다. 하지만 자바와 스프링에서 제공해주는 API DataSource, JdbcTemplate등을 이용하면 훨씬 더 깔끔하고 안정적이 구조로 데이터를 조회할 수 있다. 먼저 DataSource와 JdbcTemplate을 알아보기전에 자바에서 어떻게 데이터베이스에 접근하는지 알아볼것이다.\n\n```java\npublic class jdbcTest {\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tConnection con = null;\n\t\t\tClass.forName(\"com.mysql.jdbc.Driver\");\n\t\t\tcon = DriverManager.getConnection(\"jdbc:mysql://localhost\",\"root\", \"1234\");\n\n\t\t\tjava.sql.Statement st = null;\n\t\t\tResultSet rs = null;\n\t\t\tst = con.createStatement();\n\t\t\trs = st.executeQuery(\"SHOW DATABASES\");\n\n\t\t\tif (st.execute(\"SHOW DATABASES\")) {\n\t\t\t\trs = st.getResultSet();\n\t\t\t}\n\n\t\t\twhile (rs.next()) {\n\t\t\t\tString str = rs.getNString(1);\n\t\t\t\tSystem.out.println(str);\n\t\t\t}\n\t\t\trs.close;\n\t\t\tst.close;\n\t\t\tcon.close;\n\t\t} catch (SQLException sqex) {\n\t\t\tSystem.out.println(\"SQLException: \" + sqex.getMessage());\n\t\t}\n\t}\n\n}\n```\n\n### JDBC란\nJDBC는 Java Database Connectivity의 약어로 자바 언어로 다양한 종류의 관계형 데이터베이스에 접속하고 SQL문을 수행하여 처리하고자할때 사용되는 표준 SQL 인터페이스 API이다. 데이터베이스마다 연결방식과 통식 규격이 따로 있다. 프로그램을 데이터베이스에서 제공하는 방법으로 연결한다면 해당 데이터베이스와 관련된 기술적 내용을 자세히 배워야한다. 그리고 데이터베이스를 변경한다면 많은 변경을 해줘야한다.하지만 이론적으로는 각 DBMS에 맞는 JDBC를 받아주게되면 쉽게 DBMS를 변경할 수 있게 된다. 아래그림은 JDBC를 이용해 데이터베이스를 접근하는 순서를 표현하는 그림이다.\n\n![](https://i.imgur.com/dbpdf3P.png)\n\n### Connection Pool이란?\nConnection Pool 이란 클라이언트의 요청 시점에 Connection을 연결하는 것이 아니라 미리 일정수의 Connection 을 만들어 놓고 필요한 어플리케이션에 전달하여 이용하도록 하는 방법이다. Container 구동 시 일정수의 Connection 객체를 생성하게 되며 클라이언트의 요청에 의해 Application 이 DBMS 작업을 수행해야 하면 Connection Pool 에서 Connection 객체를 받아와 작업을 진행하며 작업이 끝나면 다시 Connection Pool 에 반납하는 과정을 거친다.\n\n### Connection이란?\nDriverManager.getConnection()은 실제 자바프로그램과 데이터베이스를 네트워크상에서 연결을 해주는 메소드이다. 연결에 성공하면 DB와 연결 상태를 Connection 객체로 표현하여 반환한다. Connection은 아래의 그림과 같이 네트워크상의 연결 자체를 의미한다. 자바프로그램과 DB사이의 길로 볼 수 있다. 보통 Connection하나당 트랜잭션 하나를 관리한다. 트랜잭션은 하나 이상의 쿼리에서 동일한 Connection 객체를 공유하는 것을 뜻한다. Mybatis의 SqlSession, Hibernate에 TransactionManager등의 Close가 이루어지면 Connection을 ConnectionPool에 반납하게 된다.\n![](https://i.imgur.com/OWPyJNm.png)\n\n### Statement\nConnection으로 길을 만들었으면 DB쪽으로 SQL문을 보내야고 그결과값을 받아야하는데 이역할을 하는것이 Statement객체이다.\n\n### Datasource란?\n***javax.sql.DataSource*** 는 인터페이스는 ConnectionPool을 관리하는 목적으로 사용되는 객체로 Application에서는 이 Datasource 인터페이스를 통해서 Connection을 얻어오고 반납하는 등의 작업을 구현해야하는 인터페이스이다. Connection Pool에는 여러개의 Connection 객체가 생성되어 운용되어진다. 각각을 직접 웹 어플리케이션에서 이용하면 체계적인 관리가 힘들게 되므로 DataSource라는 개념을 도입하여 사용하고 있다. DataSource 인터페이스는 Connection pool을 어플리케이션단에서 어떻게 관리할지를 구현해야하는 인터페이스이다.\n\n\n### JdbcTemplate란?\nStatement 처리를 위해서 Spring에서 JDBC를 지원하는데 그것이 JdbcTemplate 클래스, JdbcTemplate 클래스는 setDataSource()가 있어서 생성자 방식으로 Datasource를 지정가능하다. 아래는 Mybatis를이용한 간단한 JdbcTemplate예제이다.\n## Context.xml에서 빈등록하기\n```xml\n<context:property-placeholder location=\"classpath:database.properties\"/>\n\n<!-- 인프라빈 -->\n    <bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n    <property name=\"driverClassName\" value=\"${db.driver}\"/>\n    <property name=\"url\" value=\"${db.url}\"/>\n    <property name=\"username\" value=\"${db.id}\"/>\n    <property name=\"password\" value=\"${db.pw}\"/>\n    </bean>\n\n<!-- 인프라빈 -->\n<bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n        <property name=\"dataSource\" ref=\"dataSource\"></property>\n    </bean>\n\n <!-- autowired를 사용해도되고, 그냥 이런식으로 주입해서 써도 무방함 -->\n<bean id=\"memberDao\" class=\"dao.MemberDaoImpl\">\n           <property name=\"jdbcTemplate\" ref=\"jdbcTemplate\"></property>\n </bean>\n```\n#### MemberDaoClass 안에서 동작하는 JdbcTemplate\n* datasource가 존재하지않는다면 드라이버를 로드하고 커넥션풀등을 생성을해야하는데 이러한 불필요한 행동들을 없애준다.\n```java\nstring sql =\"SELECT * FROM member\";\n        List<Member> list = jdbcTemplate.query(sql,new MemberRowMapper())\n```\n```java\nclass MemberRowMapper implements RowMapper<Member>{\n        @Override\n        public Member mapRow(ResultSet rs, int arg1) throws SQLException{\n            Member member = new Member();\n            member.setId(rs.getString(\"id\"));\n            member.setPw(rs.getString(\"pw\"));\n            return member;\n        }\n    }\n```\n#### Mapper가 필요한이유\nquery의 결과가 list가 아닌 resultSet이기 때문에 resultSet과 list<Member>를 mapping시키는 역할을 BeanPropertyRowMapper 가 수행한다. JDBC의 resultSet (table 행 list)로부터 java의 List로(객체의 list) 한 행씩 맵핑 이전까지 while(rs.next(){}를 사용해서 직접 해줬던 작업이다.\n#### Mybatis에서는 이러한 mapper 설정없이 sqlsession이 이러한처리를 해준다.\ne.g.\n```java\npublic List<Member> selectAll(){\n        SqlSession session = sqlSessionFactory.openSession();\n        try\n        {\n            return session.selectList(\"dao.deptMapper.selectAll\");\n        }\n        finally\n        {\n            session.close();\n        }\n    }\n```\n바로 Mapper없이 List을 반환해준다.\n\n\n\n\n\n참고\n* [내일의 나를 만드는 방법](http://choong0121.tistory.com/entry/DataSource-란)\n* [keep moving keep living](http://chocobeans.tistory.com/entry/spring-JDBC-사용하기 )\n* [초보개발자 이야기.](http://ra2kstar.tistory.com/134)\n* [처음 해보는 Servlet & JSP 웹 프로그래밍](http://www.yes24.com/24/goods/37235901)\n","source":"_posts/2017-04-08-Datasource,JdbcTemplate.md","raw":"\n---\ntitle: JDBC, Connection, ConnectionPool, Datasource, JdbcTemplate이란 ?\ncatalog: true\ndate: 2017-04-08\nsubtitle:\nheader-img:\ntags:\n\n- Spring\n- Java\n\n---\n\n## JDBC, Connection, ConnectionPool, Datasource, JdbcTemplate이란 ?\n먼저 위 타이틀을 알아보기전에 아래소스를 보자. 왜 위 API들이 우리에게 필요한지 알아보자. 우리가 자바를 사용해서 디비에서 List형태의 데이터를 불러오려면 아래와같이 복잡한 소스를 작성해야한다. 하지만 자바와 스프링에서 제공해주는 API DataSource, JdbcTemplate등을 이용하면 훨씬 더 깔끔하고 안정적이 구조로 데이터를 조회할 수 있다. 먼저 DataSource와 JdbcTemplate을 알아보기전에 자바에서 어떻게 데이터베이스에 접근하는지 알아볼것이다.\n\n```java\npublic class jdbcTest {\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tConnection con = null;\n\t\t\tClass.forName(\"com.mysql.jdbc.Driver\");\n\t\t\tcon = DriverManager.getConnection(\"jdbc:mysql://localhost\",\"root\", \"1234\");\n\n\t\t\tjava.sql.Statement st = null;\n\t\t\tResultSet rs = null;\n\t\t\tst = con.createStatement();\n\t\t\trs = st.executeQuery(\"SHOW DATABASES\");\n\n\t\t\tif (st.execute(\"SHOW DATABASES\")) {\n\t\t\t\trs = st.getResultSet();\n\t\t\t}\n\n\t\t\twhile (rs.next()) {\n\t\t\t\tString str = rs.getNString(1);\n\t\t\t\tSystem.out.println(str);\n\t\t\t}\n\t\t\trs.close;\n\t\t\tst.close;\n\t\t\tcon.close;\n\t\t} catch (SQLException sqex) {\n\t\t\tSystem.out.println(\"SQLException: \" + sqex.getMessage());\n\t\t}\n\t}\n\n}\n```\n\n### JDBC란\nJDBC는 Java Database Connectivity의 약어로 자바 언어로 다양한 종류의 관계형 데이터베이스에 접속하고 SQL문을 수행하여 처리하고자할때 사용되는 표준 SQL 인터페이스 API이다. 데이터베이스마다 연결방식과 통식 규격이 따로 있다. 프로그램을 데이터베이스에서 제공하는 방법으로 연결한다면 해당 데이터베이스와 관련된 기술적 내용을 자세히 배워야한다. 그리고 데이터베이스를 변경한다면 많은 변경을 해줘야한다.하지만 이론적으로는 각 DBMS에 맞는 JDBC를 받아주게되면 쉽게 DBMS를 변경할 수 있게 된다. 아래그림은 JDBC를 이용해 데이터베이스를 접근하는 순서를 표현하는 그림이다.\n\n![](https://i.imgur.com/dbpdf3P.png)\n\n### Connection Pool이란?\nConnection Pool 이란 클라이언트의 요청 시점에 Connection을 연결하는 것이 아니라 미리 일정수의 Connection 을 만들어 놓고 필요한 어플리케이션에 전달하여 이용하도록 하는 방법이다. Container 구동 시 일정수의 Connection 객체를 생성하게 되며 클라이언트의 요청에 의해 Application 이 DBMS 작업을 수행해야 하면 Connection Pool 에서 Connection 객체를 받아와 작업을 진행하며 작업이 끝나면 다시 Connection Pool 에 반납하는 과정을 거친다.\n\n### Connection이란?\nDriverManager.getConnection()은 실제 자바프로그램과 데이터베이스를 네트워크상에서 연결을 해주는 메소드이다. 연결에 성공하면 DB와 연결 상태를 Connection 객체로 표현하여 반환한다. Connection은 아래의 그림과 같이 네트워크상의 연결 자체를 의미한다. 자바프로그램과 DB사이의 길로 볼 수 있다. 보통 Connection하나당 트랜잭션 하나를 관리한다. 트랜잭션은 하나 이상의 쿼리에서 동일한 Connection 객체를 공유하는 것을 뜻한다. Mybatis의 SqlSession, Hibernate에 TransactionManager등의 Close가 이루어지면 Connection을 ConnectionPool에 반납하게 된다.\n![](https://i.imgur.com/OWPyJNm.png)\n\n### Statement\nConnection으로 길을 만들었으면 DB쪽으로 SQL문을 보내야고 그결과값을 받아야하는데 이역할을 하는것이 Statement객체이다.\n\n### Datasource란?\n***javax.sql.DataSource*** 는 인터페이스는 ConnectionPool을 관리하는 목적으로 사용되는 객체로 Application에서는 이 Datasource 인터페이스를 통해서 Connection을 얻어오고 반납하는 등의 작업을 구현해야하는 인터페이스이다. Connection Pool에는 여러개의 Connection 객체가 생성되어 운용되어진다. 각각을 직접 웹 어플리케이션에서 이용하면 체계적인 관리가 힘들게 되므로 DataSource라는 개념을 도입하여 사용하고 있다. DataSource 인터페이스는 Connection pool을 어플리케이션단에서 어떻게 관리할지를 구현해야하는 인터페이스이다.\n\n\n### JdbcTemplate란?\nStatement 처리를 위해서 Spring에서 JDBC를 지원하는데 그것이 JdbcTemplate 클래스, JdbcTemplate 클래스는 setDataSource()가 있어서 생성자 방식으로 Datasource를 지정가능하다. 아래는 Mybatis를이용한 간단한 JdbcTemplate예제이다.\n## Context.xml에서 빈등록하기\n```xml\n<context:property-placeholder location=\"classpath:database.properties\"/>\n\n<!-- 인프라빈 -->\n    <bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n    <property name=\"driverClassName\" value=\"${db.driver}\"/>\n    <property name=\"url\" value=\"${db.url}\"/>\n    <property name=\"username\" value=\"${db.id}\"/>\n    <property name=\"password\" value=\"${db.pw}\"/>\n    </bean>\n\n<!-- 인프라빈 -->\n<bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\">\n        <property name=\"dataSource\" ref=\"dataSource\"></property>\n    </bean>\n\n <!-- autowired를 사용해도되고, 그냥 이런식으로 주입해서 써도 무방함 -->\n<bean id=\"memberDao\" class=\"dao.MemberDaoImpl\">\n           <property name=\"jdbcTemplate\" ref=\"jdbcTemplate\"></property>\n </bean>\n```\n#### MemberDaoClass 안에서 동작하는 JdbcTemplate\n* datasource가 존재하지않는다면 드라이버를 로드하고 커넥션풀등을 생성을해야하는데 이러한 불필요한 행동들을 없애준다.\n```java\nstring sql =\"SELECT * FROM member\";\n        List<Member> list = jdbcTemplate.query(sql,new MemberRowMapper())\n```\n```java\nclass MemberRowMapper implements RowMapper<Member>{\n        @Override\n        public Member mapRow(ResultSet rs, int arg1) throws SQLException{\n            Member member = new Member();\n            member.setId(rs.getString(\"id\"));\n            member.setPw(rs.getString(\"pw\"));\n            return member;\n        }\n    }\n```\n#### Mapper가 필요한이유\nquery의 결과가 list가 아닌 resultSet이기 때문에 resultSet과 list<Member>를 mapping시키는 역할을 BeanPropertyRowMapper 가 수행한다. JDBC의 resultSet (table 행 list)로부터 java의 List로(객체의 list) 한 행씩 맵핑 이전까지 while(rs.next(){}를 사용해서 직접 해줬던 작업이다.\n#### Mybatis에서는 이러한 mapper 설정없이 sqlsession이 이러한처리를 해준다.\ne.g.\n```java\npublic List<Member> selectAll(){\n        SqlSession session = sqlSessionFactory.openSession();\n        try\n        {\n            return session.selectList(\"dao.deptMapper.selectAll\");\n        }\n        finally\n        {\n            session.close();\n        }\n    }\n```\n바로 Mapper없이 List을 반환해준다.\n\n\n\n\n\n참고\n* [내일의 나를 만드는 방법](http://choong0121.tistory.com/entry/DataSource-란)\n* [keep moving keep living](http://chocobeans.tistory.com/entry/spring-JDBC-사용하기 )\n* [초보개발자 이야기.](http://ra2kstar.tistory.com/134)\n* [처음 해보는 Servlet & JSP 웹 프로그래밍](http://www.yes24.com/24/goods/37235901)\n","slug":"2017-04-08-Datasource,JdbcTemplate","published":1,"updated":"2018-06-23T18:42:32.561Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27ar0006jjpeki1qiiqz","content":"<h2><span id=\"jdbc-connection-connectionpool-datasource-jdbctemplate이란\">JDBC, Connection, ConnectionPool, Datasource, JdbcTemplate이란 ?</span></h2>\n<p>먼저 위 타이틀을 알아보기전에 아래소스를 보자. 왜 위 API들이 우리에게 필요한지 알아보자. 우리가 자바를 사용해서 디비에서 List형태의 데이터를 불러오려면 아래와같이 복잡한 소스를 작성해야한다. 하지만 자바와 스프링에서 제공해주는 API DataSource, JdbcTemplate등을 이용하면 훨씬 더 깔끔하고 안정적이 구조로 데이터를 조회할 수 있다. 먼저 DataSource와 JdbcTemplate을 알아보기전에 자바에서 어떻게 데이터베이스에 접근하는지 알아볼것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">jdbcTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\tConnection con = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\tClass.forName(<span class=\"string\">\"com.mysql.jdbc.Driver\"</span>);</span><br><span class=\"line\">\t\t\tcon = DriverManager.getConnection(<span class=\"string\">\"jdbc:mysql://localhost\"</span>,<span class=\"string\">\"root\"</span>, <span class=\"string\">\"1234\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tjava.sql.Statement st = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\tResultSet rs = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\tst = con.createStatement();</span><br><span class=\"line\">\t\t\trs = st.executeQuery(<span class=\"string\">\"SHOW DATABASES\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (st.execute(<span class=\"string\">\"SHOW DATABASES\"</span>)) &#123;</span><br><span class=\"line\">\t\t\t\trs = st.getResultSet();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (rs.next()) &#123;</span><br><span class=\"line\">\t\t\t\tString str = rs.getNString(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t\tSystem.out.println(str);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\trs.close;</span><br><span class=\"line\">\t\t\tst.close;</span><br><span class=\"line\">\t\t\tcon.close;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (SQLException sqex) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"SQLException: \"</span> + sqex.getMessage());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"jdbc란\">JDBC란</span></h3>\n<p>JDBC는 Java Database Connectivity의 약어로 자바 언어로 다양한 종류의 관계형 데이터베이스에 접속하고 SQL문을 수행하여 처리하고자할때 사용되는 표준 SQL 인터페이스 API이다. 데이터베이스마다 연결방식과 통식 규격이 따로 있다. 프로그램을 데이터베이스에서 제공하는 방법으로 연결한다면 해당 데이터베이스와 관련된 기술적 내용을 자세히 배워야한다. 그리고 데이터베이스를 변경한다면 많은 변경을 해줘야한다.하지만 이론적으로는 각 DBMS에 맞는 JDBC를 받아주게되면 쉽게 DBMS를 변경할 수 있게 된다. 아래그림은 JDBC를 이용해 데이터베이스를 접근하는 순서를 표현하는 그림이다.</p>\n<p><img src=\"https://i.imgur.com/dbpdf3P.png\" alt=\"\"></p>\n<h3><span id=\"connection-pool이란\">Connection Pool이란?</span></h3>\n<p>Connection Pool 이란 클라이언트의 요청 시점에 Connection을 연결하는 것이 아니라 미리 일정수의 Connection 을 만들어 놓고 필요한 어플리케이션에 전달하여 이용하도록 하는 방법이다. Container 구동 시 일정수의 Connection 객체를 생성하게 되며 클라이언트의 요청에 의해 Application 이 DBMS 작업을 수행해야 하면 Connection Pool 에서 Connection 객체를 받아와 작업을 진행하며 작업이 끝나면 다시 Connection Pool 에 반납하는 과정을 거친다.</p>\n<h3><span id=\"connection이란\">Connection이란?</span></h3>\n<p>DriverManager.getConnection()은 실제 자바프로그램과 데이터베이스를 네트워크상에서 연결을 해주는 메소드이다. 연결에 성공하면 DB와 연결 상태를 Connection 객체로 표현하여 반환한다. Connection은 아래의 그림과 같이 네트워크상의 연결 자체를 의미한다. 자바프로그램과 DB사이의 길로 볼 수 있다. 보통 Connection하나당 트랜잭션 하나를 관리한다. 트랜잭션은 하나 이상의 쿼리에서 동일한 Connection 객체를 공유하는 것을 뜻한다. Mybatis의 SqlSession, Hibernate에 TransactionManager등의 Close가 이루어지면 Connection을 ConnectionPool에 반납하게 된다.<br>\n<img src=\"https://i.imgur.com/OWPyJNm.png\" alt=\"\"></p>\n<h3><span id=\"statement\">Statement</span></h3>\n<p>Connection으로 길을 만들었으면 DB쪽으로 SQL문을 보내야고 그결과값을 받아야하는데 이역할을 하는것이 Statement객체이다.</p>\n<h3><span id=\"datasource란\">Datasource란?</span></h3>\n<p><strong><em>javax.sql.DataSource</em></strong> 는 인터페이스는 ConnectionPool을 관리하는 목적으로 사용되는 객체로 Application에서는 이 Datasource 인터페이스를 통해서 Connection을 얻어오고 반납하는 등의 작업을 구현해야하는 인터페이스이다. Connection Pool에는 여러개의 Connection 객체가 생성되어 운용되어진다. 각각을 직접 웹 어플리케이션에서 이용하면 체계적인 관리가 힘들게 되므로 DataSource라는 개념을 도입하여 사용하고 있다. DataSource 인터페이스는 Connection pool을 어플리케이션단에서 어떻게 관리할지를 구현해야하는 인터페이스이다.</p>\n<h3><span id=\"jdbctemplate란\">JdbcTemplate란?</span></h3>\n<p>Statement 처리를 위해서 Spring에서 JDBC를 지원하는데 그것이 JdbcTemplate 클래스, JdbcTemplate 클래스는 setDataSource()가 있어서 생성자 방식으로 Datasource를 지정가능하다. 아래는 Mybatis를이용한 간단한 JdbcTemplate예제이다.</p>\n<h2><span id=\"contextxml에서-빈등록하기\">Context.xml에서 빈등록하기</span></h2>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">\"classpath:database.properties\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 인프라빈 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.jdbc.datasource.DriverManagerDataSource\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driverClassName\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;db.driver&#125;\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;db.url&#125;\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;db.id&#125;\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;db.pw&#125;\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 인프라빈 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"jdbcTemplate\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.jdbc.core.JdbcTemplate\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"dataSource\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">&lt;!-- autowired를 사용해도되고, 그냥 이런식으로 주입해서 써도 무방함 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"memberDao\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"dao.MemberDaoImpl\"</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"jdbcTemplate\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"jdbcTemplate\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4><span id=\"memberdaoclass-안에서-동작하는-jdbctemplate\">MemberDaoClass 안에서 동작하는 JdbcTemplate</span></h4>\n<ul>\n<li>datasource가 존재하지않는다면 드라이버를 로드하고 커넥션풀등을 생성을해야하는데 이러한 불필요한 행동들을 없애준다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">string sql =<span class=\"string\">\"SELECT * FROM member\"</span>;</span><br><span class=\"line\">        List&lt;Member&gt; list = jdbcTemplate.query(sql,<span class=\"keyword\">new</span> MemberRowMapper())</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MemberRowMapper</span> <span class=\"keyword\">implements</span> <span class=\"title\">RowMapper</span>&lt;<span class=\"title\">Member</span>&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Member <span class=\"title\">mapRow</span><span class=\"params\">(ResultSet rs, <span class=\"keyword\">int</span> arg1)</span> <span class=\"keyword\">throws</span> SQLException</span>&#123;</span><br><span class=\"line\">            Member member = <span class=\"keyword\">new</span> Member();</span><br><span class=\"line\">            member.setId(rs.getString(<span class=\"string\">\"id\"</span>));</span><br><span class=\"line\">            member.setPw(rs.getString(<span class=\"string\">\"pw\"</span>));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> member;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4><span id=\"mapper가-필요한이유\">Mapper가 필요한이유</span></h4>\n<p>query의 결과가 list가 아닌 resultSet이기 때문에 resultSet과 list<member>를 mapping시키는 역할을 BeanPropertyRowMapper 가 수행한다. JDBC의 resultSet (table 행 list)로부터 java의 List로(객체의 list) 한 행씩 맵핑 이전까지 while(rs.next(){}를 사용해서 직접 해줬던 작업이다.</member></p>\n<h4><span id=\"mybatis에서는-이러한-mapper-설정없이-sqlsession이-이러한처리를-해준다\">Mybatis에서는 이러한 mapper 설정없이 sqlsession이 이러한처리를 해준다.</span></h4>\n<p>e.g.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Member&gt; <span class=\"title\">selectAll</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> session.selectList(<span class=\"string\">\"dao.deptMapper.selectAll\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">finally</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            session.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>바로 Mapper없이 List을 반환해준다.</p>\n<p>참고</p>\n<ul>\n<li><a href=\"http://choong0121.tistory.com/entry/DataSource-%EB%9E%80\" target=\"_blank\" rel=\"noopener\">내일의 나를 만드는 방법</a></li>\n<li><a href=\"http://chocobeans.tistory.com/entry/spring-JDBC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" target=\"_blank\" rel=\"noopener\">keep moving keep living</a></li>\n<li><a href=\"http://ra2kstar.tistory.com/134\" target=\"_blank\" rel=\"noopener\">초보개발자 이야기.</a></li>\n<li><a href=\"http://www.yes24.com/24/goods/37235901\" target=\"_blank\" rel=\"noopener\">처음 해보는 Servlet &amp; JSP 웹 프로그래밍</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>JDBC, Connection, ConnectionPool, Datasource, JdbcTemplate이란 ?</h2>\n<p>먼저 위 타이틀을 알아보기전에 아래소스를 보자. 왜 위 API들이 우리에게 필요한지 알아보자. 우리가 자바를 사용해서 디비에서 List형태의 데이터를 불러오려면 아래와같이 복잡한 소스를 작성해야한다. 하지만 자바와 스프링에서 제공해주는 API DataSource, JdbcTemplate등을 이용하면 훨씬 더 깔끔하고 안정적이 구조로 데이터를 조회할 수 있다. 먼저 DataSource와 JdbcTemplate을 알아보기전에 자바에서 어떻게 데이터베이스에 접근하는지 알아볼것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">jdbcTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\tConnection con = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\tClass.forName(<span class=\"string\">\"com.mysql.jdbc.Driver\"</span>);</span><br><span class=\"line\">\t\t\tcon = DriverManager.getConnection(<span class=\"string\">\"jdbc:mysql://localhost\"</span>,<span class=\"string\">\"root\"</span>, <span class=\"string\">\"1234\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\tjava.sql.Statement st = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\tResultSet rs = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t\tst = con.createStatement();</span><br><span class=\"line\">\t\t\trs = st.executeQuery(<span class=\"string\">\"SHOW DATABASES\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span> (st.execute(<span class=\"string\">\"SHOW DATABASES\"</span>)) &#123;</span><br><span class=\"line\">\t\t\t\trs = st.getResultSet();</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> (rs.next()) &#123;</span><br><span class=\"line\">\t\t\t\tString str = rs.getNString(<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t\t\tSystem.out.println(str);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\trs.close;</span><br><span class=\"line\">\t\t\tst.close;</span><br><span class=\"line\">\t\t\tcon.close;</span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (SQLException sqex) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"SQLException: \"</span> + sqex.getMessage());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>JDBC란</h3>\n<p>JDBC는 Java Database Connectivity의 약어로 자바 언어로 다양한 종류의 관계형 데이터베이스에 접속하고 SQL문을 수행하여 처리하고자할때 사용되는 표준 SQL 인터페이스 API이다. 데이터베이스마다 연결방식과 통식 규격이 따로 있다. 프로그램을 데이터베이스에서 제공하는 방법으로 연결한다면 해당 데이터베이스와 관련된 기술적 내용을 자세히 배워야한다. 그리고 데이터베이스를 변경한다면 많은 변경을 해줘야한다.하지만 이론적으로는 각 DBMS에 맞는 JDBC를 받아주게되면 쉽게 DBMS를 변경할 수 있게 된다. 아래그림은 JDBC를 이용해 데이터베이스를 접근하는 순서를 표현하는 그림이다.</p>\n<p><img src=\"https://i.imgur.com/dbpdf3P.png\" alt=\"\"></p>\n<h3>Connection Pool이란?</h3>\n<p>Connection Pool 이란 클라이언트의 요청 시점에 Connection을 연결하는 것이 아니라 미리 일정수의 Connection 을 만들어 놓고 필요한 어플리케이션에 전달하여 이용하도록 하는 방법이다. Container 구동 시 일정수의 Connection 객체를 생성하게 되며 클라이언트의 요청에 의해 Application 이 DBMS 작업을 수행해야 하면 Connection Pool 에서 Connection 객체를 받아와 작업을 진행하며 작업이 끝나면 다시 Connection Pool 에 반납하는 과정을 거친다.</p>\n<h3>Connection이란?</h3>\n<p>DriverManager.getConnection()은 실제 자바프로그램과 데이터베이스를 네트워크상에서 연결을 해주는 메소드이다. 연결에 성공하면 DB와 연결 상태를 Connection 객체로 표현하여 반환한다. Connection은 아래의 그림과 같이 네트워크상의 연결 자체를 의미한다. 자바프로그램과 DB사이의 길로 볼 수 있다. 보통 Connection하나당 트랜잭션 하나를 관리한다. 트랜잭션은 하나 이상의 쿼리에서 동일한 Connection 객체를 공유하는 것을 뜻한다. Mybatis의 SqlSession, Hibernate에 TransactionManager등의 Close가 이루어지면 Connection을 ConnectionPool에 반납하게 된다.<br>\n<img src=\"https://i.imgur.com/OWPyJNm.png\" alt=\"\"></p>\n<h3>Statement</h3>\n<p>Connection으로 길을 만들었으면 DB쪽으로 SQL문을 보내야고 그결과값을 받아야하는데 이역할을 하는것이 Statement객체이다.</p>\n<h3>Datasource란?</h3>\n<p><strong><em>javax.sql.DataSource</em></strong> 는 인터페이스는 ConnectionPool을 관리하는 목적으로 사용되는 객체로 Application에서는 이 Datasource 인터페이스를 통해서 Connection을 얻어오고 반납하는 등의 작업을 구현해야하는 인터페이스이다. Connection Pool에는 여러개의 Connection 객체가 생성되어 운용되어진다. 각각을 직접 웹 어플리케이션에서 이용하면 체계적인 관리가 힘들게 되므로 DataSource라는 개념을 도입하여 사용하고 있다. DataSource 인터페이스는 Connection pool을 어플리케이션단에서 어떻게 관리할지를 구현해야하는 인터페이스이다.</p>\n<h3>JdbcTemplate란?</h3>\n<p>Statement 처리를 위해서 Spring에서 JDBC를 지원하는데 그것이 JdbcTemplate 클래스, JdbcTemplate 클래스는 setDataSource()가 있어서 생성자 방식으로 Datasource를 지정가능하다. 아래는 Mybatis를이용한 간단한 JdbcTemplate예제이다.</p>\n<h2>Context.xml에서 빈등록하기</h2>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context:property-placeholder</span> <span class=\"attr\">location</span>=<span class=\"string\">\"classpath:database.properties\"</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 인프라빈 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.jdbc.datasource.DriverManagerDataSource\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driverClassName\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;db.driver&#125;\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;db.url&#125;\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;db.id&#125;\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"$&#123;db.pw&#125;\"</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 인프라빈 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"jdbcTemplate\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.jdbc.core.JdbcTemplate\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"dataSource\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">&lt;!-- autowired를 사용해도되고, 그냥 이런식으로 주입해서 써도 무방함 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"memberDao\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"dao.MemberDaoImpl\"</span>&gt;</span></span><br><span class=\"line\">           <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"jdbcTemplate\"</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"jdbcTemplate\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h4>MemberDaoClass 안에서 동작하는 JdbcTemplate</h4>\n<ul>\n<li>datasource가 존재하지않는다면 드라이버를 로드하고 커넥션풀등을 생성을해야하는데 이러한 불필요한 행동들을 없애준다.</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">string sql =<span class=\"string\">\"SELECT * FROM member\"</span>;</span><br><span class=\"line\">        List&lt;Member&gt; list = jdbcTemplate.query(sql,<span class=\"keyword\">new</span> MemberRowMapper())</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MemberRowMapper</span> <span class=\"keyword\">implements</span> <span class=\"title\">RowMapper</span>&lt;<span class=\"title\">Member</span>&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Member <span class=\"title\">mapRow</span><span class=\"params\">(ResultSet rs, <span class=\"keyword\">int</span> arg1)</span> <span class=\"keyword\">throws</span> SQLException</span>&#123;</span><br><span class=\"line\">            Member member = <span class=\"keyword\">new</span> Member();</span><br><span class=\"line\">            member.setId(rs.getString(<span class=\"string\">\"id\"</span>));</span><br><span class=\"line\">            member.setPw(rs.getString(<span class=\"string\">\"pw\"</span>));</span><br><span class=\"line\">            <span class=\"keyword\">return</span> member;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4>Mapper가 필요한이유</h4>\n<p>query의 결과가 list가 아닌 resultSet이기 때문에 resultSet과 list<member>를 mapping시키는 역할을 BeanPropertyRowMapper 가 수행한다. JDBC의 resultSet (table 행 list)로부터 java의 List로(객체의 list) 한 행씩 맵핑 이전까지 while(rs.next(){}를 사용해서 직접 해줬던 작업이다.</member></p>\n<h4>Mybatis에서는 이러한 mapper 설정없이 sqlsession이 이러한처리를 해준다.</h4>\n<p>e.g.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Member&gt; <span class=\"title\">selectAll</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class=\"line\">        <span class=\"keyword\">try</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> session.selectList(<span class=\"string\">\"dao.deptMapper.selectAll\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">finally</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            session.close();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>바로 Mapper없이 List을 반환해준다.</p>\n<p>참고</p>\n<ul>\n<li><a href=\"http://choong0121.tistory.com/entry/DataSource-%EB%9E%80\" target=\"_blank\" rel=\"noopener\">내일의 나를 만드는 방법</a></li>\n<li><a href=\"http://chocobeans.tistory.com/entry/spring-JDBC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\" target=\"_blank\" rel=\"noopener\">keep moving keep living</a></li>\n<li><a href=\"http://ra2kstar.tistory.com/134\" target=\"_blank\" rel=\"noopener\">초보개발자 이야기.</a></li>\n<li><a href=\"http://www.yes24.com/24/goods/37235901\" target=\"_blank\" rel=\"noopener\">처음 해보는 Servlet &amp; JSP 웹 프로그래밍</a></li>\n</ul>\n"},{"title":"톰켓 세션 동작원리","catalog":true,"date":"2017-04-19T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"## 톰켓 세션 동작원리 \n### Cookie\n* 사용자 하드웨어에 저장되는 텍스트이다.\n* 클라이언트가 웹서버에 접근하면 요청한 response로 웹페이지를 전송하면서 쿠키정보도 보내줌.\n\n### 세션\n* HTTP프로토콜은 비접속형 프로토콜, 매 접속마다 새로운 네트웤 연결이 이루어진다. 그래서 서버는 클라이언트의 이전 상태를 기억하기위해 세션이라는 개념을 사용한다.\n\n웹 어플리케이션에서 개발할때 세션을 이용해서 사용자의 로그인정보의 상태를 유지할 수 있게 한다. 로그인상태를 유지하기 위해서는 서블릿 컨테이너인 tomcat이 내부적으로 어떻게 동작하는지 알아야한다.\n\n* login페이지를 들어가게되면 HTTP 헤더 response 정보를 보게되면 JSESSIONID값이 톰켓에서 발급되는 쿠키정보를 볼수 있습니다.\n\n![](http://i.imgur.com/4XY0xHS.png)\n<center><그림 1></center>\n\n* 톰켓은 사용자가 로그인을 하지 않아도 최초 접속 시 JSESSIONID쿠키 값을 브라우저에 내려주는 것을 알 수 있다. 이렇게 쿠키를 response해주는 이유는 HTTP 프로토콜의 stateless의 특징 때문이다. 이것은 클라이언트와 서버는 단한번의 요청과 응답으로 연결이 끊어기 때문이다. 그렇기 때문에 서버에서는 사용자의 로그인 인증 여부를 확인할 수 있도록 key값처럼 사용할 수 있는 JSESSIONID값을 클라이언트로 내려줌으로써 이를 통하여 로그인 처리를 한다.\n\n![](http://i.imgur.com/MZgEtKF.png)\n<center><그림 2></center>\n\n* 그림2 화면처럼 쿠키정보를 확인하게되면 JSESSIONID라는 이름으로 쿠키 정보가 저장되어지는 것 을 알수 있다. 로그인 페이지를 reload하면 client 브라우저에 저장되어있는 JSESSIONID쿠키 값을 request header로 전달하며 response로는 JSESSIONID쿠키값을 response하지 않는다.\n\n* 사용자가 로그인 인증을 하게 되면 서버에서 세션 객체에 JESSIONID쿠키 값을 키로 사용하는 사용자 정보를 메모리 영역에 저장한다. 이와같은 키로 사용되는 세션 아이디값이 메모리에 저장됨으로 여러 페이지를 이동하여도 로그인 상태정보를 유지 할 수 있다.\n\n### 쿠키 충돌주의\n만약 톰켓 인스턴스 3개가 있다고 가정하자.\n\n>222.111.111.111:8001<br>\n>222.111.111.111:8002<br>\n>222.111.111.111:8003<br>\n\n하나의 애플리케이션에서 로그인 후 또 다른 어플리케이션에 로그인 하면 처음에 로그인 했던 어플리케이션의 세션이 사라져서 자동으로 로그아웃 처리 된 것을 확인할 수 있는데 이는 JSESSIONID 라는 쿠키 이름의 충돌 때문이다.\n\n충돌이 발생하는 이유는 각 애플리케이션의 아이피가 같기 때문이다.\n참고로 쿠키는 포트를 구분하지 않기 때문에 8001, 8002, 8003 포트로 서비스를 분리하여도 동일 서비스로 인식하여 로컬에 저장되어 있는 쿠키를 서버로 전송한다.\n이를 해결하기 위해서는 server.xml의 context에 다음을 추가하여 각 서비스를 구분하면 위의 문제를 해결할 수 있다.\n\n>sessionCookieName=\"ADMIN_JSESSIONID\"\n\n추가적으로 톰켓은 JSESSIONID 쿠키를 풀 도메인으로 셋팅한다. 아래와같이 만약 여러 도메인의 세션을 공유하기 원한다면 server.xml에 설정이 필요하다.\n\n>a.test.com <-- JSESSIONID : 11114B1E761B88562A923438B1DA2F17<br>\n>b.test.com <-- JSESSIONID : 22224B1E761B88562A923438B1DA2F17<br>\n>c.test.com <-- JSESSIONID : 33334B1E761B88562A923438B1DA2F17<br>\n\n\n참고<br>\n* [탁구치는 개발자](http://lng1982.tistory.com/143)\n","source":"_posts/2017-04-20-Tomcat-Session-principle .md","raw":"---\ntitle: 톰켓 세션 동작원리\ncatalog: true\ndate: 2017-04-20\nsubtitle:\nheader-img:\ntags:\n- ETC\n\n\n---\n## 톰켓 세션 동작원리 \n### Cookie\n* 사용자 하드웨어에 저장되는 텍스트이다.\n* 클라이언트가 웹서버에 접근하면 요청한 response로 웹페이지를 전송하면서 쿠키정보도 보내줌.\n\n### 세션\n* HTTP프로토콜은 비접속형 프로토콜, 매 접속마다 새로운 네트웤 연결이 이루어진다. 그래서 서버는 클라이언트의 이전 상태를 기억하기위해 세션이라는 개념을 사용한다.\n\n웹 어플리케이션에서 개발할때 세션을 이용해서 사용자의 로그인정보의 상태를 유지할 수 있게 한다. 로그인상태를 유지하기 위해서는 서블릿 컨테이너인 tomcat이 내부적으로 어떻게 동작하는지 알아야한다.\n\n* login페이지를 들어가게되면 HTTP 헤더 response 정보를 보게되면 JSESSIONID값이 톰켓에서 발급되는 쿠키정보를 볼수 있습니다.\n\n![](http://i.imgur.com/4XY0xHS.png)\n<center><그림 1></center>\n\n* 톰켓은 사용자가 로그인을 하지 않아도 최초 접속 시 JSESSIONID쿠키 값을 브라우저에 내려주는 것을 알 수 있다. 이렇게 쿠키를 response해주는 이유는 HTTP 프로토콜의 stateless의 특징 때문이다. 이것은 클라이언트와 서버는 단한번의 요청과 응답으로 연결이 끊어기 때문이다. 그렇기 때문에 서버에서는 사용자의 로그인 인증 여부를 확인할 수 있도록 key값처럼 사용할 수 있는 JSESSIONID값을 클라이언트로 내려줌으로써 이를 통하여 로그인 처리를 한다.\n\n![](http://i.imgur.com/MZgEtKF.png)\n<center><그림 2></center>\n\n* 그림2 화면처럼 쿠키정보를 확인하게되면 JSESSIONID라는 이름으로 쿠키 정보가 저장되어지는 것 을 알수 있다. 로그인 페이지를 reload하면 client 브라우저에 저장되어있는 JSESSIONID쿠키 값을 request header로 전달하며 response로는 JSESSIONID쿠키값을 response하지 않는다.\n\n* 사용자가 로그인 인증을 하게 되면 서버에서 세션 객체에 JESSIONID쿠키 값을 키로 사용하는 사용자 정보를 메모리 영역에 저장한다. 이와같은 키로 사용되는 세션 아이디값이 메모리에 저장됨으로 여러 페이지를 이동하여도 로그인 상태정보를 유지 할 수 있다.\n\n### 쿠키 충돌주의\n만약 톰켓 인스턴스 3개가 있다고 가정하자.\n\n>222.111.111.111:8001<br>\n>222.111.111.111:8002<br>\n>222.111.111.111:8003<br>\n\n하나의 애플리케이션에서 로그인 후 또 다른 어플리케이션에 로그인 하면 처음에 로그인 했던 어플리케이션의 세션이 사라져서 자동으로 로그아웃 처리 된 것을 확인할 수 있는데 이는 JSESSIONID 라는 쿠키 이름의 충돌 때문이다.\n\n충돌이 발생하는 이유는 각 애플리케이션의 아이피가 같기 때문이다.\n참고로 쿠키는 포트를 구분하지 않기 때문에 8001, 8002, 8003 포트로 서비스를 분리하여도 동일 서비스로 인식하여 로컬에 저장되어 있는 쿠키를 서버로 전송한다.\n이를 해결하기 위해서는 server.xml의 context에 다음을 추가하여 각 서비스를 구분하면 위의 문제를 해결할 수 있다.\n\n>sessionCookieName=\"ADMIN_JSESSIONID\"\n\n추가적으로 톰켓은 JSESSIONID 쿠키를 풀 도메인으로 셋팅한다. 아래와같이 만약 여러 도메인의 세션을 공유하기 원한다면 server.xml에 설정이 필요하다.\n\n>a.test.com <-- JSESSIONID : 11114B1E761B88562A923438B1DA2F17<br>\n>b.test.com <-- JSESSIONID : 22224B1E761B88562A923438B1DA2F17<br>\n>c.test.com <-- JSESSIONID : 33334B1E761B88562A923438B1DA2F17<br>\n\n\n참고<br>\n* [탁구치는 개발자](http://lng1982.tistory.com/143)\n","slug":"2017-04-20-Tomcat-Session-principle ","published":1,"updated":"2018-06-20T16:05:18.369Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27at0008jjpeq8t1oez3","content":"<h2><span id=\"톰켓-세션-동작원리\">톰켓 세션 동작원리</span></h2>\n<h3><span id=\"cookie\">Cookie</span></h3>\n<ul>\n<li>사용자 하드웨어에 저장되는 텍스트이다.</li>\n<li>클라이언트가 웹서버에 접근하면 요청한 response로 웹페이지를 전송하면서 쿠키정보도 보내줌.</li>\n</ul>\n<h3><span id=\"세션\">세션</span></h3>\n<ul>\n<li>HTTP프로토콜은 비접속형 프로토콜, 매 접속마다 새로운 네트웤 연결이 이루어진다. 그래서 서버는 클라이언트의 이전 상태를 기억하기위해 세션이라는 개념을 사용한다.</li>\n</ul>\n<p>웹 어플리케이션에서 개발할때 세션을 이용해서 사용자의 로그인정보의 상태를 유지할 수 있게 한다. 로그인상태를 유지하기 위해서는 서블릿 컨테이너인 tomcat이 내부적으로 어떻게 동작하는지 알아야한다.</p>\n<ul>\n<li>login페이지를 들어가게되면 HTTP 헤더 response 정보를 보게되면 JSESSIONID값이 톰켓에서 발급되는 쿠키정보를 볼수 있습니다.</li>\n</ul>\n<p><img src=\"http://i.imgur.com/4XY0xHS.png\" alt=\"\"></p>\n<center><그림 1=\"\"></그림></center>\n<ul>\n<li>톰켓은 사용자가 로그인을 하지 않아도 최초 접속 시 JSESSIONID쿠키 값을 브라우저에 내려주는 것을 알 수 있다. 이렇게 쿠키를 response해주는 이유는 HTTP 프로토콜의 stateless의 특징 때문이다. 이것은 클라이언트와 서버는 단한번의 요청과 응답으로 연결이 끊어기 때문이다. 그렇기 때문에 서버에서는 사용자의 로그인 인증 여부를 확인할 수 있도록 key값처럼 사용할 수 있는 JSESSIONID값을 클라이언트로 내려줌으로써 이를 통하여 로그인 처리를 한다.</li>\n</ul>\n<p><img src=\"http://i.imgur.com/MZgEtKF.png\" alt=\"\"></p>\n<center><그림 2=\"\"></그림></center>\n<ul>\n<li>\n<p>그림2 화면처럼 쿠키정보를 확인하게되면 JSESSIONID라는 이름으로 쿠키 정보가 저장되어지는 것 을 알수 있다. 로그인 페이지를 reload하면 client 브라우저에 저장되어있는 JSESSIONID쿠키 값을 request header로 전달하며 response로는 JSESSIONID쿠키값을 response하지 않는다.</p>\n</li>\n<li>\n<p>사용자가 로그인 인증을 하게 되면 서버에서 세션 객체에 JESSIONID쿠키 값을 키로 사용하는 사용자 정보를 메모리 영역에 저장한다. 이와같은 키로 사용되는 세션 아이디값이 메모리에 저장됨으로 여러 페이지를 이동하여도 로그인 상태정보를 유지 할 수 있다.</p>\n</li>\n</ul>\n<h3><span id=\"쿠키-충돌주의\">쿠키 충돌주의</span></h3>\n<p>만약 톰켓 인스턴스 3개가 있다고 가정하자.</p>\n<blockquote>\n<p>222.111.111.111:8001<br><br>\n222.111.111.111:8002<br><br>\n222.111.111.111:8003<br></p>\n</blockquote>\n<p>하나의 애플리케이션에서 로그인 후 또 다른 어플리케이션에 로그인 하면 처음에 로그인 했던 어플리케이션의 세션이 사라져서 자동으로 로그아웃 처리 된 것을 확인할 수 있는데 이는 JSESSIONID 라는 쿠키 이름의 충돌 때문이다.</p>\n<p>충돌이 발생하는 이유는 각 애플리케이션의 아이피가 같기 때문이다.<br>\n참고로 쿠키는 포트를 구분하지 않기 때문에 8001, 8002, 8003 포트로 서비스를 분리하여도 동일 서비스로 인식하여 로컬에 저장되어 있는 쿠키를 서버로 전송한다.<br>\n이를 해결하기 위해서는 server.xml의 context에 다음을 추가하여 각 서비스를 구분하면 위의 문제를 해결할 수 있다.</p>\n<blockquote>\n<p>sessionCookieName=“ADMIN_JSESSIONID”</p>\n</blockquote>\n<p>추가적으로 톰켓은 JSESSIONID 쿠키를 풀 도메인으로 셋팅한다. 아래와같이 만약 여러 도메인의 세션을 공유하기 원한다면 server.xml에 설정이 필요하다.</p>\n<blockquote>\n<p><a href=\"http://a.test.com\" target=\"_blank\" rel=\"noopener\">a.test.com</a> &lt;-- JSESSIONID : 11114B1E761B88562A923438B1DA2F17<br><br>\n<a href=\"http://b.test.com\" target=\"_blank\" rel=\"noopener\">b.test.com</a> &lt;-- JSESSIONID : 22224B1E761B88562A923438B1DA2F17<br><br>\n<a href=\"http://c.test.com\" target=\"_blank\" rel=\"noopener\">c.test.com</a> &lt;-- JSESSIONID : 33334B1E761B88562A923438B1DA2F17<br></p>\n</blockquote>\n<p>참고<br></p>\n<ul>\n<li><a href=\"http://lng1982.tistory.com/143\" target=\"_blank\" rel=\"noopener\">탁구치는 개발자</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>톰켓 세션 동작원리</h2>\n<h3>Cookie</h3>\n<ul>\n<li>사용자 하드웨어에 저장되는 텍스트이다.</li>\n<li>클라이언트가 웹서버에 접근하면 요청한 response로 웹페이지를 전송하면서 쿠키정보도 보내줌.</li>\n</ul>\n<h3>세션</h3>\n<ul>\n<li>HTTP프로토콜은 비접속형 프로토콜, 매 접속마다 새로운 네트웤 연결이 이루어진다. 그래서 서버는 클라이언트의 이전 상태를 기억하기위해 세션이라는 개념을 사용한다.</li>\n</ul>\n<p>웹 어플리케이션에서 개발할때 세션을 이용해서 사용자의 로그인정보의 상태를 유지할 수 있게 한다. 로그인상태를 유지하기 위해서는 서블릿 컨테이너인 tomcat이 내부적으로 어떻게 동작하는지 알아야한다.</p>\n<ul>\n<li>login페이지를 들어가게되면 HTTP 헤더 response 정보를 보게되면 JSESSIONID값이 톰켓에서 발급되는 쿠키정보를 볼수 있습니다.</li>\n</ul>\n<p><img src=\"http://i.imgur.com/4XY0xHS.png\" alt=\"\"></p>\n<center><그림 1=\"\"></그림></center>\n<ul>\n<li>톰켓은 사용자가 로그인을 하지 않아도 최초 접속 시 JSESSIONID쿠키 값을 브라우저에 내려주는 것을 알 수 있다. 이렇게 쿠키를 response해주는 이유는 HTTP 프로토콜의 stateless의 특징 때문이다. 이것은 클라이언트와 서버는 단한번의 요청과 응답으로 연결이 끊어기 때문이다. 그렇기 때문에 서버에서는 사용자의 로그인 인증 여부를 확인할 수 있도록 key값처럼 사용할 수 있는 JSESSIONID값을 클라이언트로 내려줌으로써 이를 통하여 로그인 처리를 한다.</li>\n</ul>\n<p><img src=\"http://i.imgur.com/MZgEtKF.png\" alt=\"\"></p>\n<center><그림 2=\"\"></그림></center>\n<ul>\n<li>\n<p>그림2 화면처럼 쿠키정보를 확인하게되면 JSESSIONID라는 이름으로 쿠키 정보가 저장되어지는 것 을 알수 있다. 로그인 페이지를 reload하면 client 브라우저에 저장되어있는 JSESSIONID쿠키 값을 request header로 전달하며 response로는 JSESSIONID쿠키값을 response하지 않는다.</p>\n</li>\n<li>\n<p>사용자가 로그인 인증을 하게 되면 서버에서 세션 객체에 JESSIONID쿠키 값을 키로 사용하는 사용자 정보를 메모리 영역에 저장한다. 이와같은 키로 사용되는 세션 아이디값이 메모리에 저장됨으로 여러 페이지를 이동하여도 로그인 상태정보를 유지 할 수 있다.</p>\n</li>\n</ul>\n<h3>쿠키 충돌주의</h3>\n<p>만약 톰켓 인스턴스 3개가 있다고 가정하자.</p>\n<blockquote>\n<p>222.111.111.111:8001<br><br>\n222.111.111.111:8002<br><br>\n222.111.111.111:8003<br></p>\n</blockquote>\n<p>하나의 애플리케이션에서 로그인 후 또 다른 어플리케이션에 로그인 하면 처음에 로그인 했던 어플리케이션의 세션이 사라져서 자동으로 로그아웃 처리 된 것을 확인할 수 있는데 이는 JSESSIONID 라는 쿠키 이름의 충돌 때문이다.</p>\n<p>충돌이 발생하는 이유는 각 애플리케이션의 아이피가 같기 때문이다.<br>\n참고로 쿠키는 포트를 구분하지 않기 때문에 8001, 8002, 8003 포트로 서비스를 분리하여도 동일 서비스로 인식하여 로컬에 저장되어 있는 쿠키를 서버로 전송한다.<br>\n이를 해결하기 위해서는 server.xml의 context에 다음을 추가하여 각 서비스를 구분하면 위의 문제를 해결할 수 있다.</p>\n<blockquote>\n<p>sessionCookieName=“ADMIN_JSESSIONID”</p>\n</blockquote>\n<p>추가적으로 톰켓은 JSESSIONID 쿠키를 풀 도메인으로 셋팅한다. 아래와같이 만약 여러 도메인의 세션을 공유하기 원한다면 server.xml에 설정이 필요하다.</p>\n<blockquote>\n<p><a href=\"http://a.test.com\" target=\"_blank\" rel=\"noopener\">a.test.com</a> &lt;-- JSESSIONID : 11114B1E761B88562A923438B1DA2F17<br><br>\n<a href=\"http://b.test.com\" target=\"_blank\" rel=\"noopener\">b.test.com</a> &lt;-- JSESSIONID : 22224B1E761B88562A923438B1DA2F17<br><br>\n<a href=\"http://c.test.com\" target=\"_blank\" rel=\"noopener\">c.test.com</a> &lt;-- JSESSIONID : 33334B1E761B88562A923438B1DA2F17<br></p>\n</blockquote>\n<p>참고<br></p>\n<ul>\n<li><a href=\"http://lng1982.tistory.com/143\" target=\"_blank\" rel=\"noopener\">탁구치는 개발자</a></li>\n</ul>\n"},{"title":"자바스크립트 Execution Context","catalog":true,"date":"2017-04-21T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"# 자바스크립트 Execution Context\n실행 가능한 코드(Executable Code) Global code, eval code, Function code 들을 만날때마다, 처음에는 Global context가 생성되고 그다음 실행가능한 코드들을 만날때마다 Execution context가 생성되고 그안에 또 Excution context들이 스택처럼 쌓인다. 각각의 Context는 언제나 1개의 변수 환경(Variable Environment), 1개의 Lexical Environment, 그리고 1개의 ThisBinding 속성, 총 3개의 부분으로 구성되 있다.\n\n1. LexicalEnviroment\n* 구성환경객체(Lexical Environment Object): 해당 Context안의 함수, 변수 등을 저장, 또한 바로 상위 단계의 정보도 저장\n2. VariableEnviroment\n* 변수환경객체(Variable Environment Object): 함수, 변수 등을 저장한다는 점에서 Lexical Environment와 같지만, Lexical Environment의 값은 실행 중 변하는 반면, Variable Environment의 값은 변하지 않는다는 차이점이 있다.\n3. ThisBinding\n* This Binding Object: 현재 Context가 참조하고 있는 객체를 가리키는 this object를 저장. Execution Context에서 사용자가 유일하게 접근 가능한 부분이다. This 가 가리키는 object는 해당 함수가 어떻게 호출되었는지에 따라 달라진다.\n\n![](http://i.imgur.com/2tWB9In.jpg)\n<center>[이미지1]</center>\n\n이미지 1처럼 Executable code만큼 execution Context가 생성된다. 현재는 global context를 포함해 4개의 context가 생성되었다.\n```javascript\nvar name = 'Hee'\nfunction simple(){\n  var car = 'Audi';\n  demo1();\n  function demo1(){\n    console.log(car);\n    demo2();\n  }\n  function demo2(){\n    console.log(name);\n  }\n}\nsimple();\n```\n\n예를들어 simple()을 호출하게되면 Execution Context Stack에는 아래와같이 쌓인다.\n\n```javascript\ndemo2() <<가장 먼저 실행됨.\ndemo1()\nsimple()\nGlobal Execution Context //항상 밑에 포함된다.\n```\n\n처음에 프로그램실행시 Global Execution Context가 생성되고 simple 컨텍스트가 생성되고 demo1 context가 생성되고 demo2가 차례대로 스택에 쌓여 생성된다. 그렇게 되면 스택은 LIFO 의원리로 demo2부터 실행하게 된다. 이렇게 순서대로 스택이 쌓이므로 demo1, demo2함수는 전역변수에 접근 할 수 있지만 Global scope에서 지역 scope로는 접근이 불가능한것이다.\n\n참고링크<br>\n* [chanlee blog](http://chanlee.github.io/2013/12/10/javascript-variable-scope-and-hoisting/)<br>\n* [Young-Beom Rhee](https://www.slideshare.net/youngbeomrhee/javascript-executable-code-execution-context-lexical-environment)<br>\n* [ggobugi's Blog](http://ggobugi.tistory.com/248)\n","source":"_posts/2017-04-22-javascript-execution-context.md","raw":"---\ntitle: 자바스크립트 Execution Context\ncatalog: true\ndate: 2017-04-22\nsubtitle:\nheader-img:\ntags:\n- Javascript\n\n---\n# 자바스크립트 Execution Context\n실행 가능한 코드(Executable Code) Global code, eval code, Function code 들을 만날때마다, 처음에는 Global context가 생성되고 그다음 실행가능한 코드들을 만날때마다 Execution context가 생성되고 그안에 또 Excution context들이 스택처럼 쌓인다. 각각의 Context는 언제나 1개의 변수 환경(Variable Environment), 1개의 Lexical Environment, 그리고 1개의 ThisBinding 속성, 총 3개의 부분으로 구성되 있다.\n\n1. LexicalEnviroment\n* 구성환경객체(Lexical Environment Object): 해당 Context안의 함수, 변수 등을 저장, 또한 바로 상위 단계의 정보도 저장\n2. VariableEnviroment\n* 변수환경객체(Variable Environment Object): 함수, 변수 등을 저장한다는 점에서 Lexical Environment와 같지만, Lexical Environment의 값은 실행 중 변하는 반면, Variable Environment의 값은 변하지 않는다는 차이점이 있다.\n3. ThisBinding\n* This Binding Object: 현재 Context가 참조하고 있는 객체를 가리키는 this object를 저장. Execution Context에서 사용자가 유일하게 접근 가능한 부분이다. This 가 가리키는 object는 해당 함수가 어떻게 호출되었는지에 따라 달라진다.\n\n![](http://i.imgur.com/2tWB9In.jpg)\n<center>[이미지1]</center>\n\n이미지 1처럼 Executable code만큼 execution Context가 생성된다. 현재는 global context를 포함해 4개의 context가 생성되었다.\n```javascript\nvar name = 'Hee'\nfunction simple(){\n  var car = 'Audi';\n  demo1();\n  function demo1(){\n    console.log(car);\n    demo2();\n  }\n  function demo2(){\n    console.log(name);\n  }\n}\nsimple();\n```\n\n예를들어 simple()을 호출하게되면 Execution Context Stack에는 아래와같이 쌓인다.\n\n```javascript\ndemo2() <<가장 먼저 실행됨.\ndemo1()\nsimple()\nGlobal Execution Context //항상 밑에 포함된다.\n```\n\n처음에 프로그램실행시 Global Execution Context가 생성되고 simple 컨텍스트가 생성되고 demo1 context가 생성되고 demo2가 차례대로 스택에 쌓여 생성된다. 그렇게 되면 스택은 LIFO 의원리로 demo2부터 실행하게 된다. 이렇게 순서대로 스택이 쌓이므로 demo1, demo2함수는 전역변수에 접근 할 수 있지만 Global scope에서 지역 scope로는 접근이 불가능한것이다.\n\n참고링크<br>\n* [chanlee blog](http://chanlee.github.io/2013/12/10/javascript-variable-scope-and-hoisting/)<br>\n* [Young-Beom Rhee](https://www.slideshare.net/youngbeomrhee/javascript-executable-code-execution-context-lexical-environment)<br>\n* [ggobugi's Blog](http://ggobugi.tistory.com/248)\n","slug":"2017-04-22-javascript-execution-context","published":1,"updated":"2018-06-20T16:09:54.112Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27av0009jjpe1qytqzrd","content":"<h1><span id=\"자바스크립트-execution-context\">자바스크립트 Execution Context</span></h1>\n<p>실행 가능한 코드(Executable Code) Global code, eval code, Function code 들을 만날때마다, 처음에는 Global context가 생성되고 그다음 실행가능한 코드들을 만날때마다 Execution context가 생성되고 그안에 또 Excution context들이 스택처럼 쌓인다. 각각의 Context는 언제나 1개의 변수 환경(Variable Environment), 1개의 Lexical Environment, 그리고 1개의 ThisBinding 속성, 총 3개의 부분으로 구성되 있다.</p>\n<ol>\n<li>LexicalEnviroment</li>\n</ol>\n<ul>\n<li>구성환경객체(Lexical Environment Object): 해당 Context안의 함수, 변수 등을 저장, 또한 바로 상위 단계의 정보도 저장</li>\n</ul>\n<ol start=\"2\">\n<li>VariableEnviroment</li>\n</ol>\n<ul>\n<li>변수환경객체(Variable Environment Object): 함수, 변수 등을 저장한다는 점에서 Lexical Environment와 같지만, Lexical Environment의 값은 실행 중 변하는 반면, Variable Environment의 값은 변하지 않는다는 차이점이 있다.</li>\n</ul>\n<ol start=\"3\">\n<li>ThisBinding</li>\n</ol>\n<ul>\n<li>This Binding Object: 현재 Context가 참조하고 있는 객체를 가리키는 this object를 저장. Execution Context에서 사용자가 유일하게 접근 가능한 부분이다. This 가 가리키는 object는 해당 함수가 어떻게 호출되었는지에 따라 달라진다.</li>\n</ul>\n<p><img src=\"http://i.imgur.com/2tWB9In.jpg\" alt=\"\"></p>\n<center>[이미지1]</center>\n<p>이미지 1처럼 Executable code만큼 execution Context가 생성된다. 현재는 global context를 포함해 4개의 context가 생성되었다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Hee'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">simple</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> car = <span class=\"string\">'Audi'</span>;</span><br><span class=\"line\">  demo1();</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">demo1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(car);</span><br><span class=\"line\">    demo2();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">demo2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">simple();</span><br></pre></td></tr></table></figure>\n<p>예를들어 simple()을 호출하게되면 Execution Context Stack에는 아래와같이 쌓인다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">demo2() &lt;&lt;가장 먼저 실행됨.</span><br><span class=\"line\">demo1()</span><br><span class=\"line\">simple()</span><br><span class=\"line\">Global Execution Context <span class=\"comment\">//항상 밑에 포함된다.</span></span><br></pre></td></tr></table></figure>\n<p>처음에 프로그램실행시 Global Execution Context가 생성되고 simple 컨텍스트가 생성되고 demo1 context가 생성되고 demo2가 차례대로 스택에 쌓여 생성된다. 그렇게 되면 스택은 LIFO 의원리로 demo2부터 실행하게 된다. 이렇게 순서대로 스택이 쌓이므로 demo1, demo2함수는 전역변수에 접근 할 수 있지만 Global scope에서 지역 scope로는 접근이 불가능한것이다.</p>\n<p>참고링크<br></p>\n<ul>\n<li><a href=\"http://chanlee.github.io/2013/12/10/javascript-variable-scope-and-hoisting/\" target=\"_blank\" rel=\"noopener\">chanlee blog</a><br></li>\n<li><a href=\"https://www.slideshare.net/youngbeomrhee/javascript-executable-code-execution-context-lexical-environment\" target=\"_blank\" rel=\"noopener\">Young-Beom Rhee</a><br></li>\n<li><a href=\"http://ggobugi.tistory.com/248\" target=\"_blank\" rel=\"noopener\">ggobugi’s Blog</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>자바스크립트 Execution Context</h1>\n<p>실행 가능한 코드(Executable Code) Global code, eval code, Function code 들을 만날때마다, 처음에는 Global context가 생성되고 그다음 실행가능한 코드들을 만날때마다 Execution context가 생성되고 그안에 또 Excution context들이 스택처럼 쌓인다. 각각의 Context는 언제나 1개의 변수 환경(Variable Environment), 1개의 Lexical Environment, 그리고 1개의 ThisBinding 속성, 총 3개의 부분으로 구성되 있다.</p>\n<ol>\n<li>LexicalEnviroment</li>\n</ol>\n<ul>\n<li>구성환경객체(Lexical Environment Object): 해당 Context안의 함수, 변수 등을 저장, 또한 바로 상위 단계의 정보도 저장</li>\n</ul>\n<ol start=\"2\">\n<li>VariableEnviroment</li>\n</ol>\n<ul>\n<li>변수환경객체(Variable Environment Object): 함수, 변수 등을 저장한다는 점에서 Lexical Environment와 같지만, Lexical Environment의 값은 실행 중 변하는 반면, Variable Environment의 값은 변하지 않는다는 차이점이 있다.</li>\n</ul>\n<ol start=\"3\">\n<li>ThisBinding</li>\n</ol>\n<ul>\n<li>This Binding Object: 현재 Context가 참조하고 있는 객체를 가리키는 this object를 저장. Execution Context에서 사용자가 유일하게 접근 가능한 부분이다. This 가 가리키는 object는 해당 함수가 어떻게 호출되었는지에 따라 달라진다.</li>\n</ul>\n<p><img src=\"http://i.imgur.com/2tWB9In.jpg\" alt=\"\"></p>\n<center>[이미지1]</center>\n<p>이미지 1처럼 Executable code만큼 execution Context가 생성된다. 현재는 global context를 포함해 4개의 context가 생성되었다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'Hee'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">simple</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> car = <span class=\"string\">'Audi'</span>;</span><br><span class=\"line\">  demo1();</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">demo1</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(car);</span><br><span class=\"line\">    demo2();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">demo2</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">simple();</span><br></pre></td></tr></table></figure>\n<p>예를들어 simple()을 호출하게되면 Execution Context Stack에는 아래와같이 쌓인다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">demo2() &lt;&lt;가장 먼저 실행됨.</span><br><span class=\"line\">demo1()</span><br><span class=\"line\">simple()</span><br><span class=\"line\">Global Execution Context <span class=\"comment\">//항상 밑에 포함된다.</span></span><br></pre></td></tr></table></figure>\n<p>처음에 프로그램실행시 Global Execution Context가 생성되고 simple 컨텍스트가 생성되고 demo1 context가 생성되고 demo2가 차례대로 스택에 쌓여 생성된다. 그렇게 되면 스택은 LIFO 의원리로 demo2부터 실행하게 된다. 이렇게 순서대로 스택이 쌓이므로 demo1, demo2함수는 전역변수에 접근 할 수 있지만 Global scope에서 지역 scope로는 접근이 불가능한것이다.</p>\n<p>참고링크<br></p>\n<ul>\n<li><a href=\"http://chanlee.github.io/2013/12/10/javascript-variable-scope-and-hoisting/\" target=\"_blank\" rel=\"noopener\">chanlee blog</a><br></li>\n<li><a href=\"https://www.slideshare.net/youngbeomrhee/javascript-executable-code-execution-context-lexical-environment\" target=\"_blank\" rel=\"noopener\">Young-Beom Rhee</a><br></li>\n<li><a href=\"http://ggobugi.tistory.com/248\" target=\"_blank\" rel=\"noopener\">ggobugi’s Blog</a></li>\n</ul>\n"},{"title":"Spring-Rest-Exception","catalog":true,"date":"2017-06-03T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n## 자바 Exception\n자바에서 크게 에러는 2가지가 존재한다.\n\n* 문법에러\n\t* 오타와같이 자바 구문에서 에러가나는 경우 이다. 이것은 컴파일시 에러로 발생으로 수 가능하다.\n* 실행에러\n\t* 실행 에러는 프로그램 실행시 상황에 따라 발생하는 오류이다.\n\t* 실행 에러안에서 크게 또 논리에러, 시스템에러, 예외사항으로 나뉘어진다.\n\n여기서 문법적인 에러는 컴파일시 대부분 수정이 가능하다. 실행에러는 컴파일은 수행되었으나 실행시에 문제가 되는 경우로논리적인 에러, 시스템에러, 예외 사항의 발생이다. 이중 논리적인 에러는 프로그래머가 코드를 잘못 작성해서 생기는 경우이며, 시스템적인 에러는 프로그래머의 의지와는 상관없이 발생하는 것이므로 프로그래머가 처리할 수 있는 방법은 없다. 예외사항은 정상적으로 프로그램이 동작중에 발생할 수 있는 여러가지 사항들이며 자바는 언어차원에서 이런 예외적인 사항의 처리를 지원하기 때문에 탄탄한 프로그램을 작성할 수 있다.\n\n\n아래는 exception class들의 계층 구도이다.\n![](http://i.imgur.com/NHoaID9.jpg)\n이미지에서 체크되어져있는 부분의클래스(thorws 하니까)들은 예외처리를 필수로 안해줘도되지만 언체크된부분들은 필수로 예외처리를 해야만 컴파일이 되어진다.\n\n## Spring Exception\n\nSrping에서 추천해주는 해결법은 3.2버전과 4.x버전이 존재한다. 3.2번전은 HandlerExceptionResolver, @ExceptionHandler을 사용하는것이고, 3.2이후 버전은 @controllerAdvice를 사용하는 방법이 있다.\n\n### 해결방법 1. 컨트롤 레벨 @ExceptionHandler\n@ExceptionHandler 핸들러는 컨트롤러에서 잘작동한다. 예를들어 아래와 같이 \"/cal/divide\"를 호출했을대 연산중에 에러가 날경우 아래 ArithmeticException을 타게된다.\n\n```java\npublic class FooController{\n\n\t@RequestMapping(\"/cal/divide\")\n\tpublic String divide(int op1/int op2){\n\t\tmodel.addAttribute(\"result\",op1/op2);\n\t\treturn \"cal/result\"\n\t}\n\n\t@ExceptionHandler(ArithmeticException.Class)\n\tpublic String handleException(){\n\t\treturn \"error/exception\";\n\t}\n}\n```\n\n 하지만 이것은 단점이 하나 존재한다. @ExceptionHandler는 오직 컨트롤러에서만 사용 가능하다. 이것을 basecontroller로 만들어 상속하여 이러한 문제를 조금은 해결할 수 있지만. 하지만 basecontroller 상속하게되면 다른 클래스들를 상속하여 사용할 수 없게 된다.\n\n###  해결방법 2. HandlerExceptionResolver\n\nHandlerExceptionResolver은 모든 던져지는 exception을 처리 할 수 있다. 이것은 또한 우리에게 restapi에서 처리할 수 있는 ExceptionHandler을 구현할 수 있게 해준다.\n\n* ExceptionHandlerExceptionResolver\n\t* 이것은 spring 3.1에 도입되어있고 DispatcherServlet에 기본으로 활성화 되어 있다.\n\t* 이것은 실제로  @ExceptionHandler의 핵심 코어 구성요소이다.\n* DefaultHandlerExceptionResolver\n\t* 이것은 spring 3.0에 도입되어있고 DispatcherServlet에 기본으로 활성화 되어 있다.\n\t* 이것은 http client error 4xx server error 5xx 해당하는 http status 코드를 처리하는데 일반적인 스프링 익셉션으로 사용한다.\n\t* 적절하게 응답코드에 status 코드를 설정가능하지만 바디에는 어떠한 설정도 불가능하다. 또한 rest api에게 status code를 제공하기에는 충분한 정보를 제시하지 못한다.\n\t* 등등\n\n###  해결방법 3. @ControllerAdvice\n@ControllerAdvice는 글로벌로 @ExceptionHandler를 지원한다. 아래는 server 내부에러나 resource를 찾지 못했을때 응답해줄 수 있는 핸들러이다. 아래와같이 특정 컨트롤러에 @ControllerAdvice를 추가하여 에러가 발생시 throw 처리를 통해 특정 handler로 응답처리를 손쉽게 해줄 수 있다.\n\n```java\n@ControllerAdvice\npublic class ControllerStatusAdvice {\n\n    @ExceptionHandler(value = { HttpServerException.class })\n    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)\n    @ResponseBody\n    protected ErrorMessage handleConflict(RuntimeException ex, WebRequest request) {\n    \tErrorMessage er = new ErrorMessage();\n    \ter.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());\n    \ter.setMessage(ex.getMessage());\n        return er;\n    }\n\n    @ExceptionHandler(value = {HttpNotFoundException.class })\n    @ResponseStatus(HttpStatus.NOT_FOUND)\n    @ResponseBody\n    protected ErrorMessage handleNotfound(RuntimeException ex, WebRequest request) {\n    \tErrorMessage er = new ErrorMessage();\n    \ter.setStatus(HttpStatus.NOT_FOUND.value());\n    \ter.setMessage(ex.getMessage());\n        return er;\n    }\n\n}\n\n@Controller\npublic class TestController {\n\n\t@RequestMapping(value=\"/test\")\n\tpublic void ExecuteException(){\n\t\tthrow new HttpServerException(\"TEST\");\n\t}\n\n}\n\n```\n\n\n참고<br>\n* [Baeldung](http://www.baeldung.com/exception-handling-for-rest-with-spring)<br>\n* [개발이하고싶어요](http://hyeonstorage.tistory.com/199)\n","source":"_posts/2017-06-04-spring-exception.md","raw":"---\ntitle: Spring-Rest-Exception\ncatalog: true\ndate: 2017-06-04\nsubtitle:\nheader-img:\ntags:\n- Spring\n- Java\n\n---\n\n## 자바 Exception\n자바에서 크게 에러는 2가지가 존재한다.\n\n* 문법에러\n\t* 오타와같이 자바 구문에서 에러가나는 경우 이다. 이것은 컴파일시 에러로 발생으로 수 가능하다.\n* 실행에러\n\t* 실행 에러는 프로그램 실행시 상황에 따라 발생하는 오류이다.\n\t* 실행 에러안에서 크게 또 논리에러, 시스템에러, 예외사항으로 나뉘어진다.\n\n여기서 문법적인 에러는 컴파일시 대부분 수정이 가능하다. 실행에러는 컴파일은 수행되었으나 실행시에 문제가 되는 경우로논리적인 에러, 시스템에러, 예외 사항의 발생이다. 이중 논리적인 에러는 프로그래머가 코드를 잘못 작성해서 생기는 경우이며, 시스템적인 에러는 프로그래머의 의지와는 상관없이 발생하는 것이므로 프로그래머가 처리할 수 있는 방법은 없다. 예외사항은 정상적으로 프로그램이 동작중에 발생할 수 있는 여러가지 사항들이며 자바는 언어차원에서 이런 예외적인 사항의 처리를 지원하기 때문에 탄탄한 프로그램을 작성할 수 있다.\n\n\n아래는 exception class들의 계층 구도이다.\n![](http://i.imgur.com/NHoaID9.jpg)\n이미지에서 체크되어져있는 부분의클래스(thorws 하니까)들은 예외처리를 필수로 안해줘도되지만 언체크된부분들은 필수로 예외처리를 해야만 컴파일이 되어진다.\n\n## Spring Exception\n\nSrping에서 추천해주는 해결법은 3.2버전과 4.x버전이 존재한다. 3.2번전은 HandlerExceptionResolver, @ExceptionHandler을 사용하는것이고, 3.2이후 버전은 @controllerAdvice를 사용하는 방법이 있다.\n\n### 해결방법 1. 컨트롤 레벨 @ExceptionHandler\n@ExceptionHandler 핸들러는 컨트롤러에서 잘작동한다. 예를들어 아래와 같이 \"/cal/divide\"를 호출했을대 연산중에 에러가 날경우 아래 ArithmeticException을 타게된다.\n\n```java\npublic class FooController{\n\n\t@RequestMapping(\"/cal/divide\")\n\tpublic String divide(int op1/int op2){\n\t\tmodel.addAttribute(\"result\",op1/op2);\n\t\treturn \"cal/result\"\n\t}\n\n\t@ExceptionHandler(ArithmeticException.Class)\n\tpublic String handleException(){\n\t\treturn \"error/exception\";\n\t}\n}\n```\n\n 하지만 이것은 단점이 하나 존재한다. @ExceptionHandler는 오직 컨트롤러에서만 사용 가능하다. 이것을 basecontroller로 만들어 상속하여 이러한 문제를 조금은 해결할 수 있지만. 하지만 basecontroller 상속하게되면 다른 클래스들를 상속하여 사용할 수 없게 된다.\n\n###  해결방법 2. HandlerExceptionResolver\n\nHandlerExceptionResolver은 모든 던져지는 exception을 처리 할 수 있다. 이것은 또한 우리에게 restapi에서 처리할 수 있는 ExceptionHandler을 구현할 수 있게 해준다.\n\n* ExceptionHandlerExceptionResolver\n\t* 이것은 spring 3.1에 도입되어있고 DispatcherServlet에 기본으로 활성화 되어 있다.\n\t* 이것은 실제로  @ExceptionHandler의 핵심 코어 구성요소이다.\n* DefaultHandlerExceptionResolver\n\t* 이것은 spring 3.0에 도입되어있고 DispatcherServlet에 기본으로 활성화 되어 있다.\n\t* 이것은 http client error 4xx server error 5xx 해당하는 http status 코드를 처리하는데 일반적인 스프링 익셉션으로 사용한다.\n\t* 적절하게 응답코드에 status 코드를 설정가능하지만 바디에는 어떠한 설정도 불가능하다. 또한 rest api에게 status code를 제공하기에는 충분한 정보를 제시하지 못한다.\n\t* 등등\n\n###  해결방법 3. @ControllerAdvice\n@ControllerAdvice는 글로벌로 @ExceptionHandler를 지원한다. 아래는 server 내부에러나 resource를 찾지 못했을때 응답해줄 수 있는 핸들러이다. 아래와같이 특정 컨트롤러에 @ControllerAdvice를 추가하여 에러가 발생시 throw 처리를 통해 특정 handler로 응답처리를 손쉽게 해줄 수 있다.\n\n```java\n@ControllerAdvice\npublic class ControllerStatusAdvice {\n\n    @ExceptionHandler(value = { HttpServerException.class })\n    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)\n    @ResponseBody\n    protected ErrorMessage handleConflict(RuntimeException ex, WebRequest request) {\n    \tErrorMessage er = new ErrorMessage();\n    \ter.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());\n    \ter.setMessage(ex.getMessage());\n        return er;\n    }\n\n    @ExceptionHandler(value = {HttpNotFoundException.class })\n    @ResponseStatus(HttpStatus.NOT_FOUND)\n    @ResponseBody\n    protected ErrorMessage handleNotfound(RuntimeException ex, WebRequest request) {\n    \tErrorMessage er = new ErrorMessage();\n    \ter.setStatus(HttpStatus.NOT_FOUND.value());\n    \ter.setMessage(ex.getMessage());\n        return er;\n    }\n\n}\n\n@Controller\npublic class TestController {\n\n\t@RequestMapping(value=\"/test\")\n\tpublic void ExecuteException(){\n\t\tthrow new HttpServerException(\"TEST\");\n\t}\n\n}\n\n```\n\n\n참고<br>\n* [Baeldung](http://www.baeldung.com/exception-handling-for-rest-with-spring)<br>\n* [개발이하고싶어요](http://hyeonstorage.tistory.com/199)\n","slug":"2017-06-04-spring-exception","published":1,"updated":"2018-06-20T16:05:18.324Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27b0000bjjpek08imevu","content":"<h2><span id=\"자바-exception\">자바 Exception</span></h2>\n<p>자바에서 크게 에러는 2가지가 존재한다.</p>\n<ul>\n<li>문법에러\n<ul>\n<li>오타와같이 자바 구문에서 에러가나는 경우 이다. 이것은 컴파일시 에러로 발생으로 수 가능하다.</li>\n</ul>\n</li>\n<li>실행에러\n<ul>\n<li>실행 에러는 프로그램 실행시 상황에 따라 발생하는 오류이다.</li>\n<li>실행 에러안에서 크게 또 논리에러, 시스템에러, 예외사항으로 나뉘어진다.</li>\n</ul>\n</li>\n</ul>\n<p>여기서 문법적인 에러는 컴파일시 대부분 수정이 가능하다. 실행에러는 컴파일은 수행되었으나 실행시에 문제가 되는 경우로논리적인 에러, 시스템에러, 예외 사항의 발생이다. 이중 논리적인 에러는 프로그래머가 코드를 잘못 작성해서 생기는 경우이며, 시스템적인 에러는 프로그래머의 의지와는 상관없이 발생하는 것이므로 프로그래머가 처리할 수 있는 방법은 없다. 예외사항은 정상적으로 프로그램이 동작중에 발생할 수 있는 여러가지 사항들이며 자바는 언어차원에서 이런 예외적인 사항의 처리를 지원하기 때문에 탄탄한 프로그램을 작성할 수 있다.</p>\n<p>아래는 exception class들의 계층 구도이다.<br>\n<img src=\"http://i.imgur.com/NHoaID9.jpg\" alt=\"\"><br>\n이미지에서 체크되어져있는 부분의클래스(thorws 하니까)들은 예외처리를 필수로 안해줘도되지만 언체크된부분들은 필수로 예외처리를 해야만 컴파일이 되어진다.</p>\n<h2><span id=\"spring-exception\">Spring Exception</span></h2>\n<p>Srping에서 추천해주는 해결법은 3.2버전과 4.x버전이 존재한다. 3.2번전은 HandlerExceptionResolver, @ExceptionHandler을 사용하는것이고, 3.2이후 버전은 @controllerAdvice를 사용하는 방법이 있다.</p>\n<h3><span id=\"해결방법-1-컨트롤-레벨-exceptionhandler\">해결방법 1. 컨트롤 레벨 @ExceptionHandler</span></h3>\n<p>@ExceptionHandler 핸들러는 컨트롤러에서 잘작동한다. 예를들어 아래와 같이 &quot;/cal/divide&quot;를 호출했을대 연산중에 에러가 날경우 아래 ArithmeticException을 타게된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FooController</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/cal/divide\"</span>)</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">divide</span><span class=\"params\">(<span class=\"keyword\">int</span> op1/<span class=\"keyword\">int</span> op2)</span></span>&#123;</span><br><span class=\"line\">\t\tmodel.addAttribute(<span class=\"string\">\"result\"</span>,op1/op2);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"cal/result\"</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@ExceptionHandler</span>(ArithmeticException.Class)</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">handleException</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"error/exception\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>하지만 이것은 단점이 하나 존재한다. @ExceptionHandler는 오직 컨트롤러에서만 사용 가능하다. 이것을 basecontroller로 만들어 상속하여 이러한 문제를 조금은 해결할 수 있지만. 하지만 basecontroller 상속하게되면 다른 클래스들를 상속하여 사용할 수 없게 된다.</p>\n<h3><span id=\"해결방법-2-handlerexceptionresolver\">해결방법 2. HandlerExceptionResolver</span></h3>\n<p>HandlerExceptionResolver은 모든 던져지는 exception을 처리 할 수 있다. 이것은 또한 우리에게 restapi에서 처리할 수 있는 ExceptionHandler을 구현할 수 있게 해준다.</p>\n<ul>\n<li>ExceptionHandlerExceptionResolver\n<ul>\n<li>이것은 spring 3.1에 도입되어있고 DispatcherServlet에 기본으로 활성화 되어 있다.</li>\n<li>이것은 실제로  @ExceptionHandler의 핵심 코어 구성요소이다.</li>\n</ul>\n</li>\n<li>DefaultHandlerExceptionResolver\n<ul>\n<li>이것은 spring 3.0에 도입되어있고 DispatcherServlet에 기본으로 활성화 되어 있다.</li>\n<li>이것은 http client error 4xx server error 5xx 해당하는 http status 코드를 처리하는데 일반적인 스프링 익셉션으로 사용한다.</li>\n<li>적절하게 응답코드에 status 코드를 설정가능하지만 바디에는 어떠한 설정도 불가능하다. 또한 rest api에게 status code를 제공하기에는 충분한 정보를 제시하지 못한다.</li>\n<li>등등</li>\n</ul>\n</li>\n</ul>\n<h3><span id=\"해결방법-3-controlleradvice\">해결방법 3. @ControllerAdvice</span></h3>\n<p>@ControllerAdvice는 글로벌로 @ExceptionHandler를 지원한다. 아래는 server 내부에러나 resource를 찾지 못했을때 응답해줄 수 있는 핸들러이다. 아래와같이 특정 컨트롤러에 @ControllerAdvice를 추가하여 에러가 발생시 throw 처리를 통해 특정 handler로 응답처리를 손쉽게 해줄 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ControllerAdvice</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ControllerStatusAdvice</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler</span>(value = &#123; HttpServerException.class &#125;)</span><br><span class=\"line\">    <span class=\"meta\">@ResponseStatus</span>(HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> ErrorMessage <span class=\"title\">handleConflict</span><span class=\"params\">(RuntimeException ex, WebRequest request)</span> </span>&#123;</span><br><span class=\"line\">    \tErrorMessage er = <span class=\"keyword\">new</span> ErrorMessage();</span><br><span class=\"line\">    \ter.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());</span><br><span class=\"line\">    \ter.setMessage(ex.getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> er;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler</span>(value = &#123;HttpNotFoundException.class &#125;)</span><br><span class=\"line\">    <span class=\"meta\">@ResponseStatus</span>(HttpStatus.NOT_FOUND)</span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> ErrorMessage <span class=\"title\">handleNotfound</span><span class=\"params\">(RuntimeException ex, WebRequest request)</span> </span>&#123;</span><br><span class=\"line\">    \tErrorMessage er = <span class=\"keyword\">new</span> ErrorMessage();</span><br><span class=\"line\">    \ter.setStatus(HttpStatus.NOT_FOUND.value());</span><br><span class=\"line\">    \ter.setMessage(ex.getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> er;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@RequestMapping</span>(value=<span class=\"string\">\"/test\"</span>)</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ExecuteException</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> HttpServerException(<span class=\"string\">\"TEST\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>참고<br></p>\n<ul>\n<li><a href=\"http://www.baeldung.com/exception-handling-for-rest-with-spring\" target=\"_blank\" rel=\"noopener\">Baeldung</a><br></li>\n<li><a href=\"http://hyeonstorage.tistory.com/199\" target=\"_blank\" rel=\"noopener\">개발이하고싶어요</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>자바 Exception</h2>\n<p>자바에서 크게 에러는 2가지가 존재한다.</p>\n<ul>\n<li>문법에러\n<ul>\n<li>오타와같이 자바 구문에서 에러가나는 경우 이다. 이것은 컴파일시 에러로 발생으로 수 가능하다.</li>\n</ul>\n</li>\n<li>실행에러\n<ul>\n<li>실행 에러는 프로그램 실행시 상황에 따라 발생하는 오류이다.</li>\n<li>실행 에러안에서 크게 또 논리에러, 시스템에러, 예외사항으로 나뉘어진다.</li>\n</ul>\n</li>\n</ul>\n<p>여기서 문법적인 에러는 컴파일시 대부분 수정이 가능하다. 실행에러는 컴파일은 수행되었으나 실행시에 문제가 되는 경우로논리적인 에러, 시스템에러, 예외 사항의 발생이다. 이중 논리적인 에러는 프로그래머가 코드를 잘못 작성해서 생기는 경우이며, 시스템적인 에러는 프로그래머의 의지와는 상관없이 발생하는 것이므로 프로그래머가 처리할 수 있는 방법은 없다. 예외사항은 정상적으로 프로그램이 동작중에 발생할 수 있는 여러가지 사항들이며 자바는 언어차원에서 이런 예외적인 사항의 처리를 지원하기 때문에 탄탄한 프로그램을 작성할 수 있다.</p>\n<p>아래는 exception class들의 계층 구도이다.<br>\n<img src=\"http://i.imgur.com/NHoaID9.jpg\" alt=\"\"><br>\n이미지에서 체크되어져있는 부분의클래스(thorws 하니까)들은 예외처리를 필수로 안해줘도되지만 언체크된부분들은 필수로 예외처리를 해야만 컴파일이 되어진다.</p>\n<h2>Spring Exception</h2>\n<p>Srping에서 추천해주는 해결법은 3.2버전과 4.x버전이 존재한다. 3.2번전은 HandlerExceptionResolver, @ExceptionHandler을 사용하는것이고, 3.2이후 버전은 @controllerAdvice를 사용하는 방법이 있다.</p>\n<h3>해결방법 1. 컨트롤 레벨 @ExceptionHandler</h3>\n<p>@ExceptionHandler 핸들러는 컨트롤러에서 잘작동한다. 예를들어 아래와 같이 &quot;/cal/divide&quot;를 호출했을대 연산중에 에러가 날경우 아래 ArithmeticException을 타게된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FooController</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/cal/divide\"</span>)</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">divide</span><span class=\"params\">(<span class=\"keyword\">int</span> op1/<span class=\"keyword\">int</span> op2)</span></span>&#123;</span><br><span class=\"line\">\t\tmodel.addAttribute(<span class=\"string\">\"result\"</span>,op1/op2);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"cal/result\"</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@ExceptionHandler</span>(ArithmeticException.Class)</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">handleException</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"error/exception\"</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>하지만 이것은 단점이 하나 존재한다. @ExceptionHandler는 오직 컨트롤러에서만 사용 가능하다. 이것을 basecontroller로 만들어 상속하여 이러한 문제를 조금은 해결할 수 있지만. 하지만 basecontroller 상속하게되면 다른 클래스들를 상속하여 사용할 수 없게 된다.</p>\n<h3>해결방법 2. HandlerExceptionResolver</h3>\n<p>HandlerExceptionResolver은 모든 던져지는 exception을 처리 할 수 있다. 이것은 또한 우리에게 restapi에서 처리할 수 있는 ExceptionHandler을 구현할 수 있게 해준다.</p>\n<ul>\n<li>ExceptionHandlerExceptionResolver\n<ul>\n<li>이것은 spring 3.1에 도입되어있고 DispatcherServlet에 기본으로 활성화 되어 있다.</li>\n<li>이것은 실제로  @ExceptionHandler의 핵심 코어 구성요소이다.</li>\n</ul>\n</li>\n<li>DefaultHandlerExceptionResolver\n<ul>\n<li>이것은 spring 3.0에 도입되어있고 DispatcherServlet에 기본으로 활성화 되어 있다.</li>\n<li>이것은 http client error 4xx server error 5xx 해당하는 http status 코드를 처리하는데 일반적인 스프링 익셉션으로 사용한다.</li>\n<li>적절하게 응답코드에 status 코드를 설정가능하지만 바디에는 어떠한 설정도 불가능하다. 또한 rest api에게 status code를 제공하기에는 충분한 정보를 제시하지 못한다.</li>\n<li>등등</li>\n</ul>\n</li>\n</ul>\n<h3>해결방법 3. @ControllerAdvice</h3>\n<p>@ControllerAdvice는 글로벌로 @ExceptionHandler를 지원한다. 아래는 server 내부에러나 resource를 찾지 못했을때 응답해줄 수 있는 핸들러이다. 아래와같이 특정 컨트롤러에 @ControllerAdvice를 추가하여 에러가 발생시 throw 처리를 통해 특정 handler로 응답처리를 손쉽게 해줄 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ControllerAdvice</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ControllerStatusAdvice</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler</span>(value = &#123; HttpServerException.class &#125;)</span><br><span class=\"line\">    <span class=\"meta\">@ResponseStatus</span>(HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> ErrorMessage <span class=\"title\">handleConflict</span><span class=\"params\">(RuntimeException ex, WebRequest request)</span> </span>&#123;</span><br><span class=\"line\">    \tErrorMessage er = <span class=\"keyword\">new</span> ErrorMessage();</span><br><span class=\"line\">    \ter.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());</span><br><span class=\"line\">    \ter.setMessage(ex.getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> er;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ExceptionHandler</span>(value = &#123;HttpNotFoundException.class &#125;)</span><br><span class=\"line\">    <span class=\"meta\">@ResponseStatus</span>(HttpStatus.NOT_FOUND)</span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> ErrorMessage <span class=\"title\">handleNotfound</span><span class=\"params\">(RuntimeException ex, WebRequest request)</span> </span>&#123;</span><br><span class=\"line\">    \tErrorMessage er = <span class=\"keyword\">new</span> ErrorMessage();</span><br><span class=\"line\">    \ter.setStatus(HttpStatus.NOT_FOUND.value());</span><br><span class=\"line\">    \ter.setMessage(ex.getMessage());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> er;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@RequestMapping</span>(value=<span class=\"string\">\"/test\"</span>)</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">ExecuteException</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> HttpServerException(<span class=\"string\">\"TEST\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>참고<br></p>\n<ul>\n<li><a href=\"http://www.baeldung.com/exception-handling-for-rest-with-spring\" target=\"_blank\" rel=\"noopener\">Baeldung</a><br></li>\n<li><a href=\"http://hyeonstorage.tistory.com/199\" target=\"_blank\" rel=\"noopener\">개발이하고싶어요</a></li>\n</ul>\n"},{"title":"Spring에서 Exception 발생시 Trasaction 처리 주의","catalog":true,"date":"2017-10-06T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n# Spring에서 Exception 발생시 Trasaction 처리 주의\n<br>\n\n자바에서는 총 3개의  Exception이 존재한다. Error, Checked Exception, Unchecked Exception\n![](https://i.imgur.com/Nc1vuAD.png)\n\n## Error\n\n첫째는 java.lang.Error 클래스의 서브 클래스들이다. 에러는 시스템에 뭔가 비정상적인 상황이 발생했을 경우에 사용된다. 주로 VM에서 발생시키는 것이고 애플리케이션 코드에서 잡으려고 하면 안된다. 대부분 컴파일시 발견될 수 있는 예외이다.\n\n## Checked Exception\n\njava.lang.Exception 클래스와 그 아들 클래스로 정의되는 예외들은 에러와 달리 개발자들이 만든 애플리케이션 코드의 작업 중에 예외상황이 발생했을 경우에 사용된다.\nException클래스는 다시 체크 예외와 언체크 예외로 구분 된다. 체크 예외는 Exception클래스의 아들클래스이면서 RuntimeException 클래스를 상속하지 않는 것들이고, 언체크 예외는 RuntimeException을 상속한 클래스들을 말한다.\n체크 예외가 발생할 수 있는 메서드를 사용할 경우 반드시 예외를 처리하는 코드를 함께 작성해야 한다. 사용할 메서드가 체크 예외를 던진다면 이를 catch 문으로 잡든지 아니면 다시 throws를 정의해서 메서드 밖으로 던져야 한다.\n\n## Unchecked Exception\n\njava.lang.RuntimeException 클래스를 상속한 예외들은 명시적인 예외처리를 강제하지 않기 때문에 언체크 예외라고 불린다. 에러와 마찬가지로 이 런타임 예외는 catch 문으로 잡거나 throws로 선언하지 않아도 된다. 물론 잡거나 throws로 선언해줘도 상관없다.\n런타임 예외는 주로 프로그램의 오류가 있을 때 발생하도록 의도된 것들이다. 대표적으로 오브젝트를 할당하지 않는 레퍼런스 변수를 사용하려고 시도했을 때 발생하는 NullPointerException이나 허용되지 않는 값을 사용해서 메서드를 호출할 때 발생하는 IllegalArgumentException 등이 있다. 피할 수 있지만 개발자가 부주의해서 발생할 수 있는 경우에 발생하도록 만든 것이 런타임 예외이다. 따라서 런타임 예외는 예상하지 못했던 예외상황에서 발생하는 게 아니기 때문에 굳이 catch나 throws를 사용하지 않아도 되도록 만든 것이다.\n\n## 결론\n\nSpring에서 선언적 트랜잭션은 기본적으로 Unchecked Exception에서만 발생한다. 하지만 강제적으로 이 방법을 해결하기 위해서는 Runtime Exception을 상속받거나 트랜잭션 전파 방식 설정을 아래와 같이 @Transactional(rollbackFor = Exception.class)로 설정함으로써 어떤 Exception도 롤백처리를 설정할 수 있게 하는 방법이 있다.\n\n```java\n@Transactional(rollbackFor={Exception.class})\npublic User getUser(){\n   ...\n}\n```\n\n<br>하지만 무턱대고 Exception을 흘리고 롤백 하는 것보다는 Exception을 잡아 runtime Exception으로 throw를 하든지 관리자나 개발자에게 Exception상황을 알리는게 낫다고 생각한다.\n\n\n참고문헌<br>\n* [Spring Document](https://docs.spring.io/spring/docs/2.5.x/reference/transaction.html#transaction-declarative)<br>\n* [머루의개발블로그](http://aoruqjfu.fun25.co.kr/index.php/post/1542)<br>\n","source":"_posts/2017-10-07-spring-Transaction,Exception.md","raw":"---\ntitle: Spring에서 Exception 발생시 Trasaction 처리 주의\ncatalog: true\ndate: 2017-10-07\nsubtitle:\nheader-img:\ntags:\n- Spring\n- Java\n\n---\n\n# Spring에서 Exception 발생시 Trasaction 처리 주의\n<br>\n\n자바에서는 총 3개의  Exception이 존재한다. Error, Checked Exception, Unchecked Exception\n![](https://i.imgur.com/Nc1vuAD.png)\n\n## Error\n\n첫째는 java.lang.Error 클래스의 서브 클래스들이다. 에러는 시스템에 뭔가 비정상적인 상황이 발생했을 경우에 사용된다. 주로 VM에서 발생시키는 것이고 애플리케이션 코드에서 잡으려고 하면 안된다. 대부분 컴파일시 발견될 수 있는 예외이다.\n\n## Checked Exception\n\njava.lang.Exception 클래스와 그 아들 클래스로 정의되는 예외들은 에러와 달리 개발자들이 만든 애플리케이션 코드의 작업 중에 예외상황이 발생했을 경우에 사용된다.\nException클래스는 다시 체크 예외와 언체크 예외로 구분 된다. 체크 예외는 Exception클래스의 아들클래스이면서 RuntimeException 클래스를 상속하지 않는 것들이고, 언체크 예외는 RuntimeException을 상속한 클래스들을 말한다.\n체크 예외가 발생할 수 있는 메서드를 사용할 경우 반드시 예외를 처리하는 코드를 함께 작성해야 한다. 사용할 메서드가 체크 예외를 던진다면 이를 catch 문으로 잡든지 아니면 다시 throws를 정의해서 메서드 밖으로 던져야 한다.\n\n## Unchecked Exception\n\njava.lang.RuntimeException 클래스를 상속한 예외들은 명시적인 예외처리를 강제하지 않기 때문에 언체크 예외라고 불린다. 에러와 마찬가지로 이 런타임 예외는 catch 문으로 잡거나 throws로 선언하지 않아도 된다. 물론 잡거나 throws로 선언해줘도 상관없다.\n런타임 예외는 주로 프로그램의 오류가 있을 때 발생하도록 의도된 것들이다. 대표적으로 오브젝트를 할당하지 않는 레퍼런스 변수를 사용하려고 시도했을 때 발생하는 NullPointerException이나 허용되지 않는 값을 사용해서 메서드를 호출할 때 발생하는 IllegalArgumentException 등이 있다. 피할 수 있지만 개발자가 부주의해서 발생할 수 있는 경우에 발생하도록 만든 것이 런타임 예외이다. 따라서 런타임 예외는 예상하지 못했던 예외상황에서 발생하는 게 아니기 때문에 굳이 catch나 throws를 사용하지 않아도 되도록 만든 것이다.\n\n## 결론\n\nSpring에서 선언적 트랜잭션은 기본적으로 Unchecked Exception에서만 발생한다. 하지만 강제적으로 이 방법을 해결하기 위해서는 Runtime Exception을 상속받거나 트랜잭션 전파 방식 설정을 아래와 같이 @Transactional(rollbackFor = Exception.class)로 설정함으로써 어떤 Exception도 롤백처리를 설정할 수 있게 하는 방법이 있다.\n\n```java\n@Transactional(rollbackFor={Exception.class})\npublic User getUser(){\n   ...\n}\n```\n\n<br>하지만 무턱대고 Exception을 흘리고 롤백 하는 것보다는 Exception을 잡아 runtime Exception으로 throw를 하든지 관리자나 개발자에게 Exception상황을 알리는게 낫다고 생각한다.\n\n\n참고문헌<br>\n* [Spring Document](https://docs.spring.io/spring/docs/2.5.x/reference/transaction.html#transaction-declarative)<br>\n* [머루의개발블로그](http://aoruqjfu.fun25.co.kr/index.php/post/1542)<br>\n","slug":"2017-10-07-spring-Transaction,Exception","published":1,"updated":"2018-06-20T16:05:18.215Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27b6000cjjpen0xyrqqw","content":"<h1><span id=\"spring에서-exception-발생시-trasaction-처리-주의\">Spring에서 Exception 발생시 Trasaction 처리 주의</span></h1>\n<br>\n<p>자바에서는 총 3개의  Exception이 존재한다. Error, Checked Exception, Unchecked Exception<br>\n<img src=\"https://i.imgur.com/Nc1vuAD.png\" alt=\"\"></p>\n<h2><span id=\"error\">Error</span></h2>\n<p>첫째는 java.lang.Error 클래스의 서브 클래스들이다. 에러는 시스템에 뭔가 비정상적인 상황이 발생했을 경우에 사용된다. 주로 VM에서 발생시키는 것이고 애플리케이션 코드에서 잡으려고 하면 안된다. 대부분 컴파일시 발견될 수 있는 예외이다.</p>\n<h2><span id=\"checked-exception\">Checked Exception</span></h2>\n<p>java.lang.Exception 클래스와 그 아들 클래스로 정의되는 예외들은 에러와 달리 개발자들이 만든 애플리케이션 코드의 작업 중에 예외상황이 발생했을 경우에 사용된다.<br>\nException클래스는 다시 체크 예외와 언체크 예외로 구분 된다. 체크 예외는 Exception클래스의 아들클래스이면서 RuntimeException 클래스를 상속하지 않는 것들이고, 언체크 예외는 RuntimeException을 상속한 클래스들을 말한다.<br>\n체크 예외가 발생할 수 있는 메서드를 사용할 경우 반드시 예외를 처리하는 코드를 함께 작성해야 한다. 사용할 메서드가 체크 예외를 던진다면 이를 catch 문으로 잡든지 아니면 다시 throws를 정의해서 메서드 밖으로 던져야 한다.</p>\n<h2><span id=\"unchecked-exception\">Unchecked Exception</span></h2>\n<p>java.lang.RuntimeException 클래스를 상속한 예외들은 명시적인 예외처리를 강제하지 않기 때문에 언체크 예외라고 불린다. 에러와 마찬가지로 이 런타임 예외는 catch 문으로 잡거나 throws로 선언하지 않아도 된다. 물론 잡거나 throws로 선언해줘도 상관없다.<br>\n런타임 예외는 주로 프로그램의 오류가 있을 때 발생하도록 의도된 것들이다. 대표적으로 오브젝트를 할당하지 않는 레퍼런스 변수를 사용하려고 시도했을 때 발생하는 NullPointerException이나 허용되지 않는 값을 사용해서 메서드를 호출할 때 발생하는 IllegalArgumentException 등이 있다. 피할 수 있지만 개발자가 부주의해서 발생할 수 있는 경우에 발생하도록 만든 것이 런타임 예외이다. 따라서 런타임 예외는 예상하지 못했던 예외상황에서 발생하는 게 아니기 때문에 굳이 catch나 throws를 사용하지 않아도 되도록 만든 것이다.</p>\n<h2><span id=\"결론\">결론</span></h2>\n<p>Spring에서 선언적 트랜잭션은 기본적으로 Unchecked Exception에서만 발생한다. 하지만 강제적으로 이 방법을 해결하기 위해서는 Runtime Exception을 상속받거나 트랜잭션 전파 방식 설정을 아래와 같이 @Transactional(rollbackFor = Exception.class)로 설정함으로써 어떤 Exception도 롤백처리를 설정할 수 있게 하는 방법이 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span>(rollbackFor=&#123;Exception.class&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">getUser</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><br>하지만 무턱대고 Exception을 흘리고 롤백 하는 것보다는 Exception을 잡아 runtime Exception으로 throw를 하든지 관리자나 개발자에게 Exception상황을 알리는게 낫다고 생각한다.</p>\n<p>참고문헌<br></p>\n<ul>\n<li><a href=\"https://docs.spring.io/spring/docs/2.5.x/reference/transaction.html#transaction-declarative\" target=\"_blank\" rel=\"noopener\">Spring Document</a><br></li>\n<li><a href=\"http://aoruqjfu.fun25.co.kr/index.php/post/1542\" target=\"_blank\" rel=\"noopener\">머루의개발블로그</a><br></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>Spring에서 Exception 발생시 Trasaction 처리 주의</h1>\n<br>\n<p>자바에서는 총 3개의  Exception이 존재한다. Error, Checked Exception, Unchecked Exception<br>\n<img src=\"https://i.imgur.com/Nc1vuAD.png\" alt=\"\"></p>\n<h2>Error</h2>\n<p>첫째는 java.lang.Error 클래스의 서브 클래스들이다. 에러는 시스템에 뭔가 비정상적인 상황이 발생했을 경우에 사용된다. 주로 VM에서 발생시키는 것이고 애플리케이션 코드에서 잡으려고 하면 안된다. 대부분 컴파일시 발견될 수 있는 예외이다.</p>\n<h2>Checked Exception</h2>\n<p>java.lang.Exception 클래스와 그 아들 클래스로 정의되는 예외들은 에러와 달리 개발자들이 만든 애플리케이션 코드의 작업 중에 예외상황이 발생했을 경우에 사용된다.<br>\nException클래스는 다시 체크 예외와 언체크 예외로 구분 된다. 체크 예외는 Exception클래스의 아들클래스이면서 RuntimeException 클래스를 상속하지 않는 것들이고, 언체크 예외는 RuntimeException을 상속한 클래스들을 말한다.<br>\n체크 예외가 발생할 수 있는 메서드를 사용할 경우 반드시 예외를 처리하는 코드를 함께 작성해야 한다. 사용할 메서드가 체크 예외를 던진다면 이를 catch 문으로 잡든지 아니면 다시 throws를 정의해서 메서드 밖으로 던져야 한다.</p>\n<h2>Unchecked Exception</h2>\n<p>java.lang.RuntimeException 클래스를 상속한 예외들은 명시적인 예외처리를 강제하지 않기 때문에 언체크 예외라고 불린다. 에러와 마찬가지로 이 런타임 예외는 catch 문으로 잡거나 throws로 선언하지 않아도 된다. 물론 잡거나 throws로 선언해줘도 상관없다.<br>\n런타임 예외는 주로 프로그램의 오류가 있을 때 발생하도록 의도된 것들이다. 대표적으로 오브젝트를 할당하지 않는 레퍼런스 변수를 사용하려고 시도했을 때 발생하는 NullPointerException이나 허용되지 않는 값을 사용해서 메서드를 호출할 때 발생하는 IllegalArgumentException 등이 있다. 피할 수 있지만 개발자가 부주의해서 발생할 수 있는 경우에 발생하도록 만든 것이 런타임 예외이다. 따라서 런타임 예외는 예상하지 못했던 예외상황에서 발생하는 게 아니기 때문에 굳이 catch나 throws를 사용하지 않아도 되도록 만든 것이다.</p>\n<h2>결론</h2>\n<p>Spring에서 선언적 트랜잭션은 기본적으로 Unchecked Exception에서만 발생한다. 하지만 강제적으로 이 방법을 해결하기 위해서는 Runtime Exception을 상속받거나 트랜잭션 전파 방식 설정을 아래와 같이 @Transactional(rollbackFor = Exception.class)로 설정함으로써 어떤 Exception도 롤백처리를 설정할 수 있게 하는 방법이 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional</span>(rollbackFor=&#123;Exception.class&#125;)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">getUser</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><br>하지만 무턱대고 Exception을 흘리고 롤백 하는 것보다는 Exception을 잡아 runtime Exception으로 throw를 하든지 관리자나 개발자에게 Exception상황을 알리는게 낫다고 생각한다.</p>\n<p>참고문헌<br></p>\n<ul>\n<li><a href=\"https://docs.spring.io/spring/docs/2.5.x/reference/transaction.html#transaction-declarative\" target=\"_blank\" rel=\"noopener\">Spring Document</a><br></li>\n<li><a href=\"http://aoruqjfu.fun25.co.kr/index.php/post/1542\" target=\"_blank\" rel=\"noopener\">머루의개발블로그</a><br></li>\n</ul>\n"},{"title":"Angular 데이터 바인딩 원리","catalog":true,"date":"2017-08-05T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n# Angular 데이터 바인딩 원리\nAngural는 angular context가 존재한다. angular context 내에는 digest loop가 존재하는것을 볼 수 있다. 이 digest loop는 watch list를 루프를 돌며 $watch를 통해 모델의 변경을 체크하고 변경되었을경우 뷰를 업데이트한다.\n![](http://i.imgur.com/Gv8puCF.png)\n\nAngular js에서 데이터 바인딩 전략은 Model을 변경했을때 어떻게 이벤트를 발생시키도록 할까가 아니라, 언제 Model이 변경되는가 이다.\n\n* 뷰에서 사용자 입력이 일어나면 모델이 변경된다.\n ![](http://mblogthumb1.phinf.naver.net/20131217_232/jjoommnn_1387286496086d7B0U_JPEG/binding01.jpeg?type=w2)\n\n*  어떤식으로든 모델의 변경이 되었다는것을 알리는 이벤트가 있어야한다\n![](http://mblogthumb3.phinf.naver.net/20131217_14/jjoommnn_13872865126980kkcM_JPEG/binding02.jpeg?type=w2)\n\n* 여기에서 중요한점은 Model은 HTML이 아니라 Javascript객체이기 때문에 이벤트가 발생할 일이 없다.\n\n**Angular에서는 모델이 언제 변경되는지를 체크한다.**\n  * HTML 이벤트 헨들러가 일어났을 때 (ng-click, ng-change 등)\n  * ajax통신의 결과가 도착했을 때 ($http등)\n  * timer에 의해 발생된 tick 이벤트가 발생했을 때($timer등)\n\n* 위에 경우에 관해서 angular js가  Model을 View 에 반영시키도록 하는과정을 digest loop라고한다.\n![](http://mblogthumb1.phinf.naver.net/20131217_272/jjoommnn_1387286559370YEt27_JPEG/binding03.jpeg?type=w2)\n\n* 위그림에서 보듯이 scope에 등록된 watch가 model을 view에 반영하는 코드가되고 watch등 주기적으로 실행하는것을 dijest loop라고한다.\n\n* 여기에서 중요한점은 digest loop가 작동시키는것은 angularjs이므로 위에 3가지외에 방법으로 처리하게되면 digetstloop가 발생하지않는다.(jquery 이벤트를 처리할경우이다.)\n\n```html\n<body ng-controller=\"fooCtrl\">\n    <div>{{text}}</div>\n    <input id=\"btn1\" type=\"button\" value=\"버튼\" ng-click=\"btnClick()\" />\n    <input id=\"btn2\" type=\"button\" value=\"버튼\" />\n</body>\n\n```\n\n```javascript\n\nfunction fooCtrl( $scope )\n{\n    $scope.text = \"\";\n    $scope.btnClick = function()\n    {\n        $scope.text = \"btn1 click\"; //변경 내용이 화면에 나타남\n    }\n\n    jQuery( \"#btn2\" ).click( function()\n    {\n        $scope.text = \"btn2 click\"; //변경 내용이 화면에 나타나지 않음\n    });\n}\n\n```\n\n그래서 이것을 digest loop를 강제로 동작시켜주는것이 $scope.$apply()이다.\n\n```javascript\nfunction fooCtrl( $scope )\n{\n    ...\n    jQuery( \"#btn2\" ).click( function()\n    {\n        $scope.text = \"btn2 click\";\n        $scope.$apply();\n    }\n}\n\n```\n\nangularjs는 Model 하나하나의 개별적인 이벤트에 대해 처리하는 것이 아니라, 모든 Model을 전체적으로 한꺼번에 다루게 되는 구조가 된다.즉 위에3가지 경우가 발생하면, 등록된 모든 watch에 대해 digest loop가 수행되게 된다.\n\n* 물론 watch를 등록할 때 데이터 표현식(해당 모델지정)을 넣어서 해당 데이터가 변경된 경우에만 핸들러가 수행하기도하지만 그래도 watch을 실행시킬경우 다른 watch들도 실행되기때문에 쓸데없이 많은 watch를 등록하지 말아야한다.\n\n\n참고<br>\n* [조대협의 블로그](http://bcho.tistory.com/851)<br>\n* [백발의 개발자](http://m.blog.naver.com/jjoommnn/130181901609)\n","source":"_posts/2017-08-06-data-binding-principle.md","raw":"---\ntitle: Angular 데이터 바인딩 원리\ncatalog: true\ndate: 2017-08-06\nsubtitle:\nheader-img:\ntags:\n- Angular\n- Javascript\n---\n\n# Angular 데이터 바인딩 원리\nAngural는 angular context가 존재한다. angular context 내에는 digest loop가 존재하는것을 볼 수 있다. 이 digest loop는 watch list를 루프를 돌며 $watch를 통해 모델의 변경을 체크하고 변경되었을경우 뷰를 업데이트한다.\n![](http://i.imgur.com/Gv8puCF.png)\n\nAngular js에서 데이터 바인딩 전략은 Model을 변경했을때 어떻게 이벤트를 발생시키도록 할까가 아니라, 언제 Model이 변경되는가 이다.\n\n* 뷰에서 사용자 입력이 일어나면 모델이 변경된다.\n ![](http://mblogthumb1.phinf.naver.net/20131217_232/jjoommnn_1387286496086d7B0U_JPEG/binding01.jpeg?type=w2)\n\n*  어떤식으로든 모델의 변경이 되었다는것을 알리는 이벤트가 있어야한다\n![](http://mblogthumb3.phinf.naver.net/20131217_14/jjoommnn_13872865126980kkcM_JPEG/binding02.jpeg?type=w2)\n\n* 여기에서 중요한점은 Model은 HTML이 아니라 Javascript객체이기 때문에 이벤트가 발생할 일이 없다.\n\n**Angular에서는 모델이 언제 변경되는지를 체크한다.**\n  * HTML 이벤트 헨들러가 일어났을 때 (ng-click, ng-change 등)\n  * ajax통신의 결과가 도착했을 때 ($http등)\n  * timer에 의해 발생된 tick 이벤트가 발생했을 때($timer등)\n\n* 위에 경우에 관해서 angular js가  Model을 View 에 반영시키도록 하는과정을 digest loop라고한다.\n![](http://mblogthumb1.phinf.naver.net/20131217_272/jjoommnn_1387286559370YEt27_JPEG/binding03.jpeg?type=w2)\n\n* 위그림에서 보듯이 scope에 등록된 watch가 model을 view에 반영하는 코드가되고 watch등 주기적으로 실행하는것을 dijest loop라고한다.\n\n* 여기에서 중요한점은 digest loop가 작동시키는것은 angularjs이므로 위에 3가지외에 방법으로 처리하게되면 digetstloop가 발생하지않는다.(jquery 이벤트를 처리할경우이다.)\n\n```html\n<body ng-controller=\"fooCtrl\">\n    <div>{{text}}</div>\n    <input id=\"btn1\" type=\"button\" value=\"버튼\" ng-click=\"btnClick()\" />\n    <input id=\"btn2\" type=\"button\" value=\"버튼\" />\n</body>\n\n```\n\n```javascript\n\nfunction fooCtrl( $scope )\n{\n    $scope.text = \"\";\n    $scope.btnClick = function()\n    {\n        $scope.text = \"btn1 click\"; //변경 내용이 화면에 나타남\n    }\n\n    jQuery( \"#btn2\" ).click( function()\n    {\n        $scope.text = \"btn2 click\"; //변경 내용이 화면에 나타나지 않음\n    });\n}\n\n```\n\n그래서 이것을 digest loop를 강제로 동작시켜주는것이 $scope.$apply()이다.\n\n```javascript\nfunction fooCtrl( $scope )\n{\n    ...\n    jQuery( \"#btn2\" ).click( function()\n    {\n        $scope.text = \"btn2 click\";\n        $scope.$apply();\n    }\n}\n\n```\n\nangularjs는 Model 하나하나의 개별적인 이벤트에 대해 처리하는 것이 아니라, 모든 Model을 전체적으로 한꺼번에 다루게 되는 구조가 된다.즉 위에3가지 경우가 발생하면, 등록된 모든 watch에 대해 digest loop가 수행되게 된다.\n\n* 물론 watch를 등록할 때 데이터 표현식(해당 모델지정)을 넣어서 해당 데이터가 변경된 경우에만 핸들러가 수행하기도하지만 그래도 watch을 실행시킬경우 다른 watch들도 실행되기때문에 쓸데없이 많은 watch를 등록하지 말아야한다.\n\n\n참고<br>\n* [조대협의 블로그](http://bcho.tistory.com/851)<br>\n* [백발의 개발자](http://m.blog.naver.com/jjoommnn/130181901609)\n","slug":"2017-08-06-data-binding-principle","published":1,"updated":"2018-06-20T16:05:18.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27b9000fjjpeki7g0mf5","content":"<h1><span id=\"angular-데이터-바인딩-원리\">Angular 데이터 바인딩 원리</span></h1>\n<p>Angural는 angular context가 존재한다. angular context 내에는 digest loop가 존재하는것을 볼 수 있다. 이 digest loop는 watch list를 루프를 돌며 $watch를 통해 모델의 변경을 체크하고 변경되었을경우 뷰를 업데이트한다.<br>\n<img src=\"http://i.imgur.com/Gv8puCF.png\" alt=\"\"></p>\n<p>Angular js에서 데이터 바인딩 전략은 Model을 변경했을때 어떻게 이벤트를 발생시키도록 할까가 아니라, 언제 Model이 변경되는가 이다.</p>\n<ul>\n<li>\n<p>뷰에서 사용자 입력이 일어나면 모델이 변경된다.<br>\n<img src=\"http://mblogthumb1.phinf.naver.net/20131217_232/jjoommnn_1387286496086d7B0U_JPEG/binding01.jpeg?type=w2\" alt=\"\"></p>\n</li>\n<li>\n<p>어떤식으로든 모델의 변경이 되었다는것을 알리는 이벤트가 있어야한다<br>\n<img src=\"http://mblogthumb3.phinf.naver.net/20131217_14/jjoommnn_13872865126980kkcM_JPEG/binding02.jpeg?type=w2\" alt=\"\"></p>\n</li>\n<li>\n<p>여기에서 중요한점은 Model은 HTML이 아니라 Javascript객체이기 때문에 이벤트가 발생할 일이 없다.</p>\n</li>\n</ul>\n<p><strong>Angular에서는 모델이 언제 변경되는지를 체크한다.</strong></p>\n<ul>\n<li>\n<p>HTML 이벤트 헨들러가 일어났을 때 (ng-click, ng-change 등)</p>\n</li>\n<li>\n<p>ajax통신의 결과가 도착했을 때 ($http등)</p>\n</li>\n<li>\n<p>timer에 의해 발생된 tick 이벤트가 발생했을 때($timer등)</p>\n</li>\n<li>\n<p>위에 경우에 관해서 angular js가  Model을 View 에 반영시키도록 하는과정을 digest loop라고한다.<br>\n<img src=\"http://mblogthumb1.phinf.naver.net/20131217_272/jjoommnn_1387286559370YEt27_JPEG/binding03.jpeg?type=w2\" alt=\"\"></p>\n</li>\n<li>\n<p>위그림에서 보듯이 scope에 등록된 watch가 model을 view에 반영하는 코드가되고 watch등 주기적으로 실행하는것을 dijest loop라고한다.</p>\n</li>\n<li>\n<p>여기에서 중요한점은 digest loop가 작동시키는것은 angularjs이므로 위에 3가지외에 방법으로 처리하게되면 digetstloop가 발생하지않는다.(jquery 이벤트를 처리할경우이다.)</p>\n</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">ng-controller</span>=<span class=\"string\">\"fooCtrl\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;text&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"btn1\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"버튼\"</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"btnClick()\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"btn2\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"버튼\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fooCtrl</span>(<span class=\"params\"> $scope </span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    $scope.text = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    $scope.btnClick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        $scope.text = <span class=\"string\">\"btn1 click\"</span>; <span class=\"comment\">//변경 내용이 화면에 나타남</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    jQuery( <span class=\"string\">\"#btn2\"</span> ).click( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        $scope.text = <span class=\"string\">\"btn2 click\"</span>; <span class=\"comment\">//변경 내용이 화면에 나타나지 않음</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그래서 이것을 digest loop를 강제로 동작시켜주는것이 $scope.$apply()이다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fooCtrl</span>(<span class=\"params\"> $scope </span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    jQuery( <span class=\"string\">\"#btn2\"</span> ).click( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        $scope.text = <span class=\"string\">\"btn2 click\"</span>;</span><br><span class=\"line\">        $scope.$apply();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>angularjs는 Model 하나하나의 개별적인 이벤트에 대해 처리하는 것이 아니라, 모든 Model을 전체적으로 한꺼번에 다루게 되는 구조가 된다.즉 위에3가지 경우가 발생하면, 등록된 모든 watch에 대해 digest loop가 수행되게 된다.</p>\n<ul>\n<li>물론 watch를 등록할 때 데이터 표현식(해당 모델지정)을 넣어서 해당 데이터가 변경된 경우에만 핸들러가 수행하기도하지만 그래도 watch을 실행시킬경우 다른 watch들도 실행되기때문에 쓸데없이 많은 watch를 등록하지 말아야한다.</li>\n</ul>\n<p>참고<br></p>\n<ul>\n<li><a href=\"http://bcho.tistory.com/851\" target=\"_blank\" rel=\"noopener\">조대협의 블로그</a><br></li>\n<li><a href=\"http://m.blog.naver.com/jjoommnn/130181901609\" target=\"_blank\" rel=\"noopener\">백발의 개발자</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>Angular 데이터 바인딩 원리</h1>\n<p>Angural는 angular context가 존재한다. angular context 내에는 digest loop가 존재하는것을 볼 수 있다. 이 digest loop는 watch list를 루프를 돌며 $watch를 통해 모델의 변경을 체크하고 변경되었을경우 뷰를 업데이트한다.<br>\n<img src=\"http://i.imgur.com/Gv8puCF.png\" alt=\"\"></p>\n<p>Angular js에서 데이터 바인딩 전략은 Model을 변경했을때 어떻게 이벤트를 발생시키도록 할까가 아니라, 언제 Model이 변경되는가 이다.</p>\n<ul>\n<li>\n<p>뷰에서 사용자 입력이 일어나면 모델이 변경된다.<br>\n<img src=\"http://mblogthumb1.phinf.naver.net/20131217_232/jjoommnn_1387286496086d7B0U_JPEG/binding01.jpeg?type=w2\" alt=\"\"></p>\n</li>\n<li>\n<p>어떤식으로든 모델의 변경이 되었다는것을 알리는 이벤트가 있어야한다<br>\n<img src=\"http://mblogthumb3.phinf.naver.net/20131217_14/jjoommnn_13872865126980kkcM_JPEG/binding02.jpeg?type=w2\" alt=\"\"></p>\n</li>\n<li>\n<p>여기에서 중요한점은 Model은 HTML이 아니라 Javascript객체이기 때문에 이벤트가 발생할 일이 없다.</p>\n</li>\n</ul>\n<p><strong>Angular에서는 모델이 언제 변경되는지를 체크한다.</strong></p>\n<ul>\n<li>\n<p>HTML 이벤트 헨들러가 일어났을 때 (ng-click, ng-change 등)</p>\n</li>\n<li>\n<p>ajax통신의 결과가 도착했을 때 ($http등)</p>\n</li>\n<li>\n<p>timer에 의해 발생된 tick 이벤트가 발생했을 때($timer등)</p>\n</li>\n<li>\n<p>위에 경우에 관해서 angular js가  Model을 View 에 반영시키도록 하는과정을 digest loop라고한다.<br>\n<img src=\"http://mblogthumb1.phinf.naver.net/20131217_272/jjoommnn_1387286559370YEt27_JPEG/binding03.jpeg?type=w2\" alt=\"\"></p>\n</li>\n<li>\n<p>위그림에서 보듯이 scope에 등록된 watch가 model을 view에 반영하는 코드가되고 watch등 주기적으로 실행하는것을 dijest loop라고한다.</p>\n</li>\n<li>\n<p>여기에서 중요한점은 digest loop가 작동시키는것은 angularjs이므로 위에 3가지외에 방법으로 처리하게되면 digetstloop가 발생하지않는다.(jquery 이벤트를 처리할경우이다.)</p>\n</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">ng-controller</span>=<span class=\"string\">\"fooCtrl\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;&#123;text&#125;&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"btn1\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"버튼\"</span> <span class=\"attr\">ng-click</span>=<span class=\"string\">\"btnClick()\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"btn2\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"button\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"버튼\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fooCtrl</span>(<span class=\"params\"> $scope </span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    $scope.text = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    $scope.btnClick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        $scope.text = <span class=\"string\">\"btn1 click\"</span>; <span class=\"comment\">//변경 내용이 화면에 나타남</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    jQuery( <span class=\"string\">\"#btn2\"</span> ).click( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        $scope.text = <span class=\"string\">\"btn2 click\"</span>; <span class=\"comment\">//변경 내용이 화면에 나타나지 않음</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그래서 이것을 digest loop를 강제로 동작시켜주는것이 $scope.$apply()이다.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fooCtrl</span>(<span class=\"params\"> $scope </span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    jQuery( <span class=\"string\">\"#btn2\"</span> ).click( <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        $scope.text = <span class=\"string\">\"btn2 click\"</span>;</span><br><span class=\"line\">        $scope.$apply();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>angularjs는 Model 하나하나의 개별적인 이벤트에 대해 처리하는 것이 아니라, 모든 Model을 전체적으로 한꺼번에 다루게 되는 구조가 된다.즉 위에3가지 경우가 발생하면, 등록된 모든 watch에 대해 digest loop가 수행되게 된다.</p>\n<ul>\n<li>물론 watch를 등록할 때 데이터 표현식(해당 모델지정)을 넣어서 해당 데이터가 변경된 경우에만 핸들러가 수행하기도하지만 그래도 watch을 실행시킬경우 다른 watch들도 실행되기때문에 쓸데없이 많은 watch를 등록하지 말아야한다.</li>\n</ul>\n<p>참고<br></p>\n<ul>\n<li><a href=\"http://bcho.tistory.com/851\" target=\"_blank\" rel=\"noopener\">조대협의 블로그</a><br></li>\n<li><a href=\"http://m.blog.naver.com/jjoommnn/130181901609\" target=\"_blank\" rel=\"noopener\">백발의 개발자</a></li>\n</ul>\n"},{"title":"Spring-RememberMe","catalog":true,"date":"2017-08-05T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n\n# Spring-RememberMe 구현\n<br>\n\n일반적으로 우리는 브라우저를 닫는순간 세션이 끊기고 브라우저를 다시 켜게되면 로그인을 통해 세션을 연결해준다.하지만 rememberme 기능을 이용하면 브라우저를 열면 자동 로그인을 하게 된다.  일반적으로 브라우저로 쿠키를 보냄으로써 세션에 의해 쿠키가 발견되고 자동적으로 로그인이 일어날것이다. spring security 에서는 2가지방식을 제공한다.  하나는 쿠키기반의 token의 안전을 보호하기위해 hashing 사용, 다른 하나는 스토리지나,데이터베이스에 만들어진 토큰을 저장하여 사용한다. 두개의 구현방식은 Spring security UserDetailsService을 요구한다.\n\n## 1. Simple Hash-Based Token Approach(Hashing 방법)\n쿠키는 인증을 성공하자마자 브라우저로 다음과 같은형식의 쿠키를 전송한다\n\n```\nbase64(username + \":\" + expirationTime + \":\" +\nmd5Hex(username + \":\" + expirationTime + \":\" password + \":\" + key))\n```\n\nusername : UserDetailsService에서 식별가능\npassword : 이것은 UserDetailsService에서 검색하는것과 같은값의 비번이다.\nexpirationTime : token이 만료되는 시간\nkey : rememberme token의 수정을 막는 개인키\n\nrememberme토큰은 특정기간동안만 유효하고 username,password,key는 변경되지 않는다. rememberme을 사용하기위해서는 그냥 추가하면된다. 아래 element를 추가하면된다.\n\n```xml\n<http>\n  <remember-me key=\"myAppKey\"/>\n</http>\n```\n\n쿠키방식에는 TokenBasedRememberMeServices(구현체)가 있다. 14일정도 유효하다. (보안성이 좋지는 않다고한다.)\n\n## 2. Persistent Token Approach(데이터베이스 사용방법)\npersistentTokenBasedRememberMeService 을 hash-based기반으로도 구현할수있지만 그러나 일반적으로 토큰을 저장하기위해 PersistentTokentRepository Interface 을 구현하여 사용한다. 일반적으로 persistentTokenBasedRememberMeService의 일반생성자는 deprecated 되었고 생성자로 세개의 파라미터로 필요로한다. key,userDetailsService,persistentTokenRepository 3개의 파라미터가 필요로한다. 여기에서 persistentTokentRepository인터페이스는 두가지의 구현캘래스를 제공하는데 , InMemoryTokenRepositoryImpl, JdbcTokenRepositoryImpl을 제공한다.\n\n```sql\ncreate table persistent_logins (username varchar(64) not null,\n                                series varchar(64) primary key,\n                                token varchar(64) not null,\n                                last_used timestamp not null);\n```\n데이터베이스가 존재해야한다. persistent_logins는 token키와 series키를 만든다. 유저가 remember-me을 체크하면 브라우저에 \"remember me\"cookie가 저장된다. 브라우저에 유효한 \"remember me\"cookie가 존재한다면 자동적으로 로그인될것이다. 유저가 \"remeber me\"쿠키를 통해 로그인하게 된다면 user details는 변경하지 못한다.(도난 당한 쿠키로 정보를 변경하지 못하게하지 못하는 좋은 예이다.)\n\n이솔루션은 유저를 유니크한 series식별자로 유저를 구별한다. 이것은 유저가 로그인할때마다 토큰이 랜덤하게 다시 생성된다.\n\n\nSPRING_SECURITY_REMEMBER_ME의 이름으로 쿠키에저장되며 브라우저의 내부에 hash기반의 만들어진 토큰으로 저장되어진다.\n\n결론\n```\n체크박스 remember-me(true) 체크 ->userDetailsService 유저네임조회 -> 토큰생성;\n홈페이지이동 -> userDetailsService 유저네임조회 -> 토큰검사후 - 자동로그인 처리\n```\n\n\n참고<br>\n* [Nirman's Tech Blog](http://technirman.blogspot.kr/2014/01/spring-security-remember-me-example.html)<br>\n* [https://docs.spring.io](https://docs.spring.io/spring-security/site/docs/3.0.x/reference/remember-me.html)\n","source":"_posts/2017-08-06-spring-remember-me.md","raw":"---\ntitle: Spring-RememberMe\ncatalog: true\ndate: 2017-08-06\nsubtitle:\nheader-img:\ntags:\n- Spring\n- Java\n---\n\n\n# Spring-RememberMe 구현\n<br>\n\n일반적으로 우리는 브라우저를 닫는순간 세션이 끊기고 브라우저를 다시 켜게되면 로그인을 통해 세션을 연결해준다.하지만 rememberme 기능을 이용하면 브라우저를 열면 자동 로그인을 하게 된다.  일반적으로 브라우저로 쿠키를 보냄으로써 세션에 의해 쿠키가 발견되고 자동적으로 로그인이 일어날것이다. spring security 에서는 2가지방식을 제공한다.  하나는 쿠키기반의 token의 안전을 보호하기위해 hashing 사용, 다른 하나는 스토리지나,데이터베이스에 만들어진 토큰을 저장하여 사용한다. 두개의 구현방식은 Spring security UserDetailsService을 요구한다.\n\n## 1. Simple Hash-Based Token Approach(Hashing 방법)\n쿠키는 인증을 성공하자마자 브라우저로 다음과 같은형식의 쿠키를 전송한다\n\n```\nbase64(username + \":\" + expirationTime + \":\" +\nmd5Hex(username + \":\" + expirationTime + \":\" password + \":\" + key))\n```\n\nusername : UserDetailsService에서 식별가능\npassword : 이것은 UserDetailsService에서 검색하는것과 같은값의 비번이다.\nexpirationTime : token이 만료되는 시간\nkey : rememberme token의 수정을 막는 개인키\n\nrememberme토큰은 특정기간동안만 유효하고 username,password,key는 변경되지 않는다. rememberme을 사용하기위해서는 그냥 추가하면된다. 아래 element를 추가하면된다.\n\n```xml\n<http>\n  <remember-me key=\"myAppKey\"/>\n</http>\n```\n\n쿠키방식에는 TokenBasedRememberMeServices(구현체)가 있다. 14일정도 유효하다. (보안성이 좋지는 않다고한다.)\n\n## 2. Persistent Token Approach(데이터베이스 사용방법)\npersistentTokenBasedRememberMeService 을 hash-based기반으로도 구현할수있지만 그러나 일반적으로 토큰을 저장하기위해 PersistentTokentRepository Interface 을 구현하여 사용한다. 일반적으로 persistentTokenBasedRememberMeService의 일반생성자는 deprecated 되었고 생성자로 세개의 파라미터로 필요로한다. key,userDetailsService,persistentTokenRepository 3개의 파라미터가 필요로한다. 여기에서 persistentTokentRepository인터페이스는 두가지의 구현캘래스를 제공하는데 , InMemoryTokenRepositoryImpl, JdbcTokenRepositoryImpl을 제공한다.\n\n```sql\ncreate table persistent_logins (username varchar(64) not null,\n                                series varchar(64) primary key,\n                                token varchar(64) not null,\n                                last_used timestamp not null);\n```\n데이터베이스가 존재해야한다. persistent_logins는 token키와 series키를 만든다. 유저가 remember-me을 체크하면 브라우저에 \"remember me\"cookie가 저장된다. 브라우저에 유효한 \"remember me\"cookie가 존재한다면 자동적으로 로그인될것이다. 유저가 \"remeber me\"쿠키를 통해 로그인하게 된다면 user details는 변경하지 못한다.(도난 당한 쿠키로 정보를 변경하지 못하게하지 못하는 좋은 예이다.)\n\n이솔루션은 유저를 유니크한 series식별자로 유저를 구별한다. 이것은 유저가 로그인할때마다 토큰이 랜덤하게 다시 생성된다.\n\n\nSPRING_SECURITY_REMEMBER_ME의 이름으로 쿠키에저장되며 브라우저의 내부에 hash기반의 만들어진 토큰으로 저장되어진다.\n\n결론\n```\n체크박스 remember-me(true) 체크 ->userDetailsService 유저네임조회 -> 토큰생성;\n홈페이지이동 -> userDetailsService 유저네임조회 -> 토큰검사후 - 자동로그인 처리\n```\n\n\n참고<br>\n* [Nirman's Tech Blog](http://technirman.blogspot.kr/2014/01/spring-security-remember-me-example.html)<br>\n* [https://docs.spring.io](https://docs.spring.io/spring-security/site/docs/3.0.x/reference/remember-me.html)\n","slug":"2017-08-06-spring-remember-me","published":1,"updated":"2018-06-20T16:05:18.268Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27bb000hjjpeabhv5fb4","content":"<h1><span id=\"spring-rememberme-구현\">Spring-RememberMe 구현</span></h1>\n<br>\n<p>일반적으로 우리는 브라우저를 닫는순간 세션이 끊기고 브라우저를 다시 켜게되면 로그인을 통해 세션을 연결해준다.하지만 rememberme 기능을 이용하면 브라우저를 열면 자동 로그인을 하게 된다.  일반적으로 브라우저로 쿠키를 보냄으로써 세션에 의해 쿠키가 발견되고 자동적으로 로그인이 일어날것이다. spring security 에서는 2가지방식을 제공한다.  하나는 쿠키기반의 token의 안전을 보호하기위해 hashing 사용, 다른 하나는 스토리지나,데이터베이스에 만들어진 토큰을 저장하여 사용한다. 두개의 구현방식은 Spring security UserDetailsService을 요구한다.</p>\n<h2><span id=\"1-simple-hash-based-token-approachhashing-방법\">1. Simple Hash-Based Token Approach(Hashing 방법)</span></h2>\n<p>쿠키는 인증을 성공하자마자 브라우저로 다음과 같은형식의 쿠키를 전송한다</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">base64(username + &quot;:&quot; + expirationTime + &quot;:&quot; +</span><br><span class=\"line\">md5Hex(username + &quot;:&quot; + expirationTime + &quot;:&quot; password + &quot;:&quot; + key))</span><br></pre></td></tr></table></figure>\n<p>username : UserDetailsService에서 식별가능<br>\npassword : 이것은 UserDetailsService에서 검색하는것과 같은값의 비번이다.<br>\nexpirationTime : token이 만료되는 시간<br>\nkey : rememberme token의 수정을 막는 개인키</p>\n<p>rememberme토큰은 특정기간동안만 유효하고 username,password,key는 변경되지 않는다. rememberme을 사용하기위해서는 그냥 추가하면된다. 아래 element를 추가하면된다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">http</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">remember-me</span> <span class=\"attr\">key</span>=<span class=\"string\">\"myAppKey\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">http</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>쿠키방식에는 TokenBasedRememberMeServices(구현체)가 있다. 14일정도 유효하다. (보안성이 좋지는 않다고한다.)</p>\n<h2><span id=\"2-persistent-token-approach데이터베이스-사용방법\">2. Persistent Token Approach(데이터베이스 사용방법)</span></h2>\n<p>persistentTokenBasedRememberMeService 을 hash-based기반으로도 구현할수있지만 그러나 일반적으로 토큰을 저장하기위해 PersistentTokentRepository Interface 을 구현하여 사용한다. 일반적으로 persistentTokenBasedRememberMeService의 일반생성자는 deprecated 되었고 생성자로 세개의 파라미터로 필요로한다. key,userDetailsService,persistentTokenRepository 3개의 파라미터가 필요로한다. 여기에서 persistentTokentRepository인터페이스는 두가지의 구현캘래스를 제공하는데 , InMemoryTokenRepositoryImpl, JdbcTokenRepositoryImpl을 제공한다.</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> persistent_logins (username <span class=\"built_in\">varchar</span>(<span class=\"number\">64</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">                                series <span class=\"built_in\">varchar</span>(<span class=\"number\">64</span>) primary <span class=\"keyword\">key</span>,</span><br><span class=\"line\">                                token <span class=\"built_in\">varchar</span>(<span class=\"number\">64</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">                                last_used <span class=\"keyword\">timestamp</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span>);</span><br></pre></td></tr></table></figure>\n<p>데이터베이스가 존재해야한다. persistent_logins는 token키와 series키를 만든다. 유저가 remember-me을 체크하면 브라우저에 &quot;remember me&quot;cookie가 저장된다. 브라우저에 유효한 &quot;remember me&quot;cookie가 존재한다면 자동적으로 로그인될것이다. 유저가 &quot;remeber me&quot;쿠키를 통해 로그인하게 된다면 user details는 변경하지 못한다.(도난 당한 쿠키로 정보를 변경하지 못하게하지 못하는 좋은 예이다.)</p>\n<p>이솔루션은 유저를 유니크한 series식별자로 유저를 구별한다. 이것은 유저가 로그인할때마다 토큰이 랜덤하게 다시 생성된다.</p>\n<p>SPRING_SECURITY_REMEMBER_ME의 이름으로 쿠키에저장되며 브라우저의 내부에 hash기반의 만들어진 토큰으로 저장되어진다.</p>\n<p>결론</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">체크박스 remember-me(true) 체크 -&gt;userDetailsService 유저네임조회 -&gt; 토큰생성;</span><br><span class=\"line\">홈페이지이동 -&gt; userDetailsService 유저네임조회 -&gt; 토큰검사후 - 자동로그인 처리</span><br></pre></td></tr></table></figure>\n<p>참고<br></p>\n<ul>\n<li><a href=\"http://technirman.blogspot.kr/2014/01/spring-security-remember-me-example.html\" target=\"_blank\" rel=\"noopener\">Nirman’s Tech Blog</a><br></li>\n<li><a href=\"https://docs.spring.io/spring-security/site/docs/3.0.x/reference/remember-me.html\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>Spring-RememberMe 구현</h1>\n<br>\n<p>일반적으로 우리는 브라우저를 닫는순간 세션이 끊기고 브라우저를 다시 켜게되면 로그인을 통해 세션을 연결해준다.하지만 rememberme 기능을 이용하면 브라우저를 열면 자동 로그인을 하게 된다.  일반적으로 브라우저로 쿠키를 보냄으로써 세션에 의해 쿠키가 발견되고 자동적으로 로그인이 일어날것이다. spring security 에서는 2가지방식을 제공한다.  하나는 쿠키기반의 token의 안전을 보호하기위해 hashing 사용, 다른 하나는 스토리지나,데이터베이스에 만들어진 토큰을 저장하여 사용한다. 두개의 구현방식은 Spring security UserDetailsService을 요구한다.</p>\n<h2>1. Simple Hash-Based Token Approach(Hashing 방법)</h2>\n<p>쿠키는 인증을 성공하자마자 브라우저로 다음과 같은형식의 쿠키를 전송한다</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">base64(username + &quot;:&quot; + expirationTime + &quot;:&quot; +</span><br><span class=\"line\">md5Hex(username + &quot;:&quot; + expirationTime + &quot;:&quot; password + &quot;:&quot; + key))</span><br></pre></td></tr></table></figure>\n<p>username : UserDetailsService에서 식별가능<br>\npassword : 이것은 UserDetailsService에서 검색하는것과 같은값의 비번이다.<br>\nexpirationTime : token이 만료되는 시간<br>\nkey : rememberme token의 수정을 막는 개인키</p>\n<p>rememberme토큰은 특정기간동안만 유효하고 username,password,key는 변경되지 않는다. rememberme을 사용하기위해서는 그냥 추가하면된다. 아래 element를 추가하면된다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">http</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">remember-me</span> <span class=\"attr\">key</span>=<span class=\"string\">\"myAppKey\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">http</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>쿠키방식에는 TokenBasedRememberMeServices(구현체)가 있다. 14일정도 유효하다. (보안성이 좋지는 않다고한다.)</p>\n<h2>2. Persistent Token Approach(데이터베이스 사용방법)</h2>\n<p>persistentTokenBasedRememberMeService 을 hash-based기반으로도 구현할수있지만 그러나 일반적으로 토큰을 저장하기위해 PersistentTokentRepository Interface 을 구현하여 사용한다. 일반적으로 persistentTokenBasedRememberMeService의 일반생성자는 deprecated 되었고 생성자로 세개의 파라미터로 필요로한다. key,userDetailsService,persistentTokenRepository 3개의 파라미터가 필요로한다. 여기에서 persistentTokentRepository인터페이스는 두가지의 구현캘래스를 제공하는데 , InMemoryTokenRepositoryImpl, JdbcTokenRepositoryImpl을 제공한다.</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> persistent_logins (username <span class=\"built_in\">varchar</span>(<span class=\"number\">64</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">                                series <span class=\"built_in\">varchar</span>(<span class=\"number\">64</span>) primary <span class=\"keyword\">key</span>,</span><br><span class=\"line\">                                token <span class=\"built_in\">varchar</span>(<span class=\"number\">64</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">                                last_used <span class=\"keyword\">timestamp</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span>);</span><br></pre></td></tr></table></figure>\n<p>데이터베이스가 존재해야한다. persistent_logins는 token키와 series키를 만든다. 유저가 remember-me을 체크하면 브라우저에 &quot;remember me&quot;cookie가 저장된다. 브라우저에 유효한 &quot;remember me&quot;cookie가 존재한다면 자동적으로 로그인될것이다. 유저가 &quot;remeber me&quot;쿠키를 통해 로그인하게 된다면 user details는 변경하지 못한다.(도난 당한 쿠키로 정보를 변경하지 못하게하지 못하는 좋은 예이다.)</p>\n<p>이솔루션은 유저를 유니크한 series식별자로 유저를 구별한다. 이것은 유저가 로그인할때마다 토큰이 랜덤하게 다시 생성된다.</p>\n<p>SPRING_SECURITY_REMEMBER_ME의 이름으로 쿠키에저장되며 브라우저의 내부에 hash기반의 만들어진 토큰으로 저장되어진다.</p>\n<p>결론</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">체크박스 remember-me(true) 체크 -&gt;userDetailsService 유저네임조회 -&gt; 토큰생성;</span><br><span class=\"line\">홈페이지이동 -&gt; userDetailsService 유저네임조회 -&gt; 토큰검사후 - 자동로그인 처리</span><br></pre></td></tr></table></figure>\n<p>참고<br></p>\n<ul>\n<li><a href=\"http://technirman.blogspot.kr/2014/01/spring-security-remember-me-example.html\" target=\"_blank\" rel=\"noopener\">Nirman’s Tech Blog</a><br></li>\n<li><a href=\"https://docs.spring.io/spring-security/site/docs/3.0.x/reference/remember-me.html\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io</a></li>\n</ul>\n"},{"title":"Spring-AOP, Proxy 란?","catalog":true,"date":"2017-10-28T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n\n# Spring-AOP, Proxy 란?\n\n## AOP란 ?<br>\n\nAOP는 문제를 해결하기 위한 핵심 관심 사항과 전체에 적용되는 공통 모듈 사항을 기준으로 프로그래밍 함으로써 공통 모듈을 여러 코드에 쉽게 적용할 수 있도록 도와주는 역할을 합니다. AOP를 구현하는 다양한 방법이 존재하지만, 기본적인 개념은 아래 그림과 같이 공통 관심 사항 코드를 비즈니스 로직을 구현한 코드안에 삽입하는 것입니다.\n![](https://i.imgur.com/a0AFbrG.png)\n위에 그림에서 공통기능은 직접적으로 호출되지 않습니다. 핵심로직을 구현한 코드를 컴파일하거나, 컴파일된 클래스를 로딩하거나, 또는 로딩한 클래스의 객체를 생성할 때, Proxy객체를 통해 호출할 때 AOP가 적용됩니다.\n\n## AOP용어\n\n```\n-Joinpoint\nAdvice를 적용 가능한 지점을 의미합니다. 메소드호출, 필드값 변경 등이 Joinpoint에 해당 합니다.\n-Pointcut\nJoinpoint의 부분집합으로서 실제로 Advice가 적용되는 Joinpoint를 나타냅니다. 스프링에서는 정규 표현식이나 AspectJ의 문법을 이용하여 Poincut을 재정의 할 수 있습니다.\n-Advice\n언제 공통 관심 기능을 핵심로직에 적용할 지를 정의하고 있습니다. 예를들어, '메서드를 호출 하기전에 트랜잭션 시작' 기능을 적용한다는 것을 정의하고 있는 것입니다.\n-Weaving\nAdvice를 핵심로직코드에 적용하는것을 weaving이라고 한다라고 합니다. 즉 공통코드를 핵심로직코드에 삽입하는것을 weaving이라고 합니다.\n-Aspect\n여러 객체에 공통으로 적용되는 기능을 Aspect라고 합니다. 트랜잭션이나, 보안등이 Aspect의 좋은 예입니다.\n```\n\n## 3가지 Weaving 방식\nAdvice를 Weaving하는 방식에는 세가지 방식이 존재합니다.\n\n1. 컴파일시에 Weaving하기\n2. 클래스 로딩 시에 Weaving하기\n3. 런타임시에 Weaving하기\n\n일반적으로 컴파일시와 클래스 로딩 시에는 weaving하는 방식은 AspectJ라이브러리를 추가하여 구현할때 사용됩니다. 런타임시에 weaving하는 방식은 Spring-AOP에서 사용하는 방식인데 소스코드나 클래스 정보 자체를 변경하지 않습니다. 대신 프록시를 생성하여 AOP를 적용합니다. 프록시 기반의 AOP는 핵심 로직을 구현할 객체에 직접 접근하는것이 아니라 아래 그림과 같이 중간에 프록시를 생성하여 프록시를 통해 핵심 로직의 객체에 접근하는 것입니다.\n![](https://i.imgur.com/bFfetFM.jpg)\n이때 프록시는 핵심 로직을 실행하기 전 또는 후에 공통 모듈 기능을 적용하는 방식으로 AOP를 구현하게 됩니다.\n\n## Spring-AOP란?\n스프링은 자체적으로 프록시 기반의 AOP를 지원하고 있습니다. 따라서 스프링 AOP는 메서드 호출 Joinpoint만을 지원합니다. 필드 값 변경과 같은 Joinpoint를 사용하고 싶다면 AspectJ와 같이 다양한 Joinpoint를 지원하는 AOP프레임워크를 사용해야 합니다.\n\n스프링은 크게 3가지 방식으로 AOP를 제공합니다.\n\n1. XML 스키마 기반의 POJO클래스를 이용한 AOP구현\n2. AspectJ에서 정의한 @Aspect 애노테이션 기반의 AOP구현\n3. 스프링 API를 이용한 AOP구현\n\n어떤 방식을 사용하더라도 내부적으로 프록시를 이용하여 AOP가 구현되기 때문에 프록시를 통한 메소드호출만 AOP를 적용할 수 있다는 것을 유의 해야 합니다. 예를 들어 내부클래스내에서 다른 메소드를 호출한다고 하면 그것은 프록시를 거쳐 가는것이 아니기 때문에 AOP가 적용되지 않습니다.\n\n## 프록시를 이용한 AOP 구현\n스프링은 프록시를 이용하여 AOP를 구현합니다. 스프링은 Aspect의 적용대상이 되는 객체에 대한 프록시를 만들어 제공합니다. 비지니스 로직에 접근할 때 대상 객체로 바로 접근하는 게 아닌 프록시를 통해서 간접적으로 접근하게 됩니다. 이 과정에서 프록시는 공통 기능을 실행한 뒤 대상 객체의 실제 메서드를 호출하거나 또는 대상객체의 실제 메소드를 호출한 후에 공통기능을 실행합니다.\n![](https://i.imgur.com/63YMS1o.png)\n대상 타겟은 결국 빈 객체가 생성 되는데, 런타임시에 오브젝트 생성 설정에 따라서 스프링 컨테이너가 지정한 빈 객체 대한 프록시 객체를 생성하고, 원본 빈 객체 대신에 프록시 객체를 사용하게 합니다.\n\n프록시 객체를 생성하는 방식은 대상 객체가 인터페이스를 구현하고 있느냐 없느냐 여부에 따라 달라집니다. 2가지 방식이 존재하는데 JDK Dynamic Proxy, CGLIB를 이용하여 프록시를 생성하는 방식이 있습니다.\n\n### JDK Dynamic Proxy\n스프링은 자바 리플렉션 API가 제공하는 java.lang.reflect.Proxy를 이용하여 프록시 객체를 생성합니다. 아래 그림과 NConnectionMaker,DConnectionMaker와 같이 동일한 인터페이스를 구현하게되면 UserDao와 같은 클라이언트는 인터페이스를 통해서 필요한 메서드를 호출하게 됩니다. 하지만, ***인터페이스를 기반으로 프록시 객체를 생성하기 때문에 인터페이스에 정의되어 있지 않은 메서드에 대해서는 AOP가 적용되지 않는 점에 유의해야합니다.***\n![](https://i.imgur.com/gX6THnw.png)\n\n### CGLIB\n대상객체가 인터페이스를 구현하고 있지 않고 바로 클래스를 사용한다면, 스프링은 CGLIB를 이용하여 클래스에 대한 프록시 객체를 생성합니다. CGLIB는 대상 클래스를 상속 받아 프록시를 구현합니다. 따라서 클래스가 final인경우에는 프록시를 생성할 수 없습니다.\n\n#### 강제로 CGLIB를 이용하여 Proxy를 생성하는 방법\n\n@EnableAspectJAutoProxy 어노테이션 속성으로 proxyTaretClass란 것이 있습니다. 위에서 말한대로 Spirng AOP는 Proxy class를 생성함으로 AOP를 구현 합니다. AOP의 대상이 되는 클래스가 Interface를 구현하고 있을 경우 Spring은 Interface를 이용하는 JDK Dynamic Proxy를 만들어서 AOP를 구현하고 Interface를 구현하지 않고 클래스에 대해서는 CG-LIB를 이용한 대상클래스의 상속을받아 서브클래스를 만들어 이를 Proxy삼아 AOP 구현하게 됩니다. 이 속성 값을 주지 않으면 기본값은 false이기 때문에 대상이 되는 클래스가 interface를 이용한것은 자동으로 JDK Dynamic Proxy를 이용해서 AOP를 생성하고 아닌경우에는 CG-LIB를 이용해 클래스  Proxy로 AOP를 구현하게 됩니다. 이 속성을 true로 주게되면 인터페이스 또한 CG-LIB를 이용하여 서브클래스 생성하는 방식으로 AOP의 프록시를 구현하게 됩니다.\n\n\n출처 <br>\n* [최범균](http://book.naver.com/bookdb/book_detail.nhn?bid=7918153) <br>\n* [Spring document](https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html)<br>\n","source":"_posts/2017-10-29-Spring-AOP-Proxy.md","raw":"---\ntitle: Spring-AOP, Proxy 란?\ncatalog: true\ndate: 2017-10-29\nsubtitle:\nheader-img:\ntags:\n- Spring\n- Java\n---\n\n\n# Spring-AOP, Proxy 란?\n\n## AOP란 ?<br>\n\nAOP는 문제를 해결하기 위한 핵심 관심 사항과 전체에 적용되는 공통 모듈 사항을 기준으로 프로그래밍 함으로써 공통 모듈을 여러 코드에 쉽게 적용할 수 있도록 도와주는 역할을 합니다. AOP를 구현하는 다양한 방법이 존재하지만, 기본적인 개념은 아래 그림과 같이 공통 관심 사항 코드를 비즈니스 로직을 구현한 코드안에 삽입하는 것입니다.\n![](https://i.imgur.com/a0AFbrG.png)\n위에 그림에서 공통기능은 직접적으로 호출되지 않습니다. 핵심로직을 구현한 코드를 컴파일하거나, 컴파일된 클래스를 로딩하거나, 또는 로딩한 클래스의 객체를 생성할 때, Proxy객체를 통해 호출할 때 AOP가 적용됩니다.\n\n## AOP용어\n\n```\n-Joinpoint\nAdvice를 적용 가능한 지점을 의미합니다. 메소드호출, 필드값 변경 등이 Joinpoint에 해당 합니다.\n-Pointcut\nJoinpoint의 부분집합으로서 실제로 Advice가 적용되는 Joinpoint를 나타냅니다. 스프링에서는 정규 표현식이나 AspectJ의 문법을 이용하여 Poincut을 재정의 할 수 있습니다.\n-Advice\n언제 공통 관심 기능을 핵심로직에 적용할 지를 정의하고 있습니다. 예를들어, '메서드를 호출 하기전에 트랜잭션 시작' 기능을 적용한다는 것을 정의하고 있는 것입니다.\n-Weaving\nAdvice를 핵심로직코드에 적용하는것을 weaving이라고 한다라고 합니다. 즉 공통코드를 핵심로직코드에 삽입하는것을 weaving이라고 합니다.\n-Aspect\n여러 객체에 공통으로 적용되는 기능을 Aspect라고 합니다. 트랜잭션이나, 보안등이 Aspect의 좋은 예입니다.\n```\n\n## 3가지 Weaving 방식\nAdvice를 Weaving하는 방식에는 세가지 방식이 존재합니다.\n\n1. 컴파일시에 Weaving하기\n2. 클래스 로딩 시에 Weaving하기\n3. 런타임시에 Weaving하기\n\n일반적으로 컴파일시와 클래스 로딩 시에는 weaving하는 방식은 AspectJ라이브러리를 추가하여 구현할때 사용됩니다. 런타임시에 weaving하는 방식은 Spring-AOP에서 사용하는 방식인데 소스코드나 클래스 정보 자체를 변경하지 않습니다. 대신 프록시를 생성하여 AOP를 적용합니다. 프록시 기반의 AOP는 핵심 로직을 구현할 객체에 직접 접근하는것이 아니라 아래 그림과 같이 중간에 프록시를 생성하여 프록시를 통해 핵심 로직의 객체에 접근하는 것입니다.\n![](https://i.imgur.com/bFfetFM.jpg)\n이때 프록시는 핵심 로직을 실행하기 전 또는 후에 공통 모듈 기능을 적용하는 방식으로 AOP를 구현하게 됩니다.\n\n## Spring-AOP란?\n스프링은 자체적으로 프록시 기반의 AOP를 지원하고 있습니다. 따라서 스프링 AOP는 메서드 호출 Joinpoint만을 지원합니다. 필드 값 변경과 같은 Joinpoint를 사용하고 싶다면 AspectJ와 같이 다양한 Joinpoint를 지원하는 AOP프레임워크를 사용해야 합니다.\n\n스프링은 크게 3가지 방식으로 AOP를 제공합니다.\n\n1. XML 스키마 기반의 POJO클래스를 이용한 AOP구현\n2. AspectJ에서 정의한 @Aspect 애노테이션 기반의 AOP구현\n3. 스프링 API를 이용한 AOP구현\n\n어떤 방식을 사용하더라도 내부적으로 프록시를 이용하여 AOP가 구현되기 때문에 프록시를 통한 메소드호출만 AOP를 적용할 수 있다는 것을 유의 해야 합니다. 예를 들어 내부클래스내에서 다른 메소드를 호출한다고 하면 그것은 프록시를 거쳐 가는것이 아니기 때문에 AOP가 적용되지 않습니다.\n\n## 프록시를 이용한 AOP 구현\n스프링은 프록시를 이용하여 AOP를 구현합니다. 스프링은 Aspect의 적용대상이 되는 객체에 대한 프록시를 만들어 제공합니다. 비지니스 로직에 접근할 때 대상 객체로 바로 접근하는 게 아닌 프록시를 통해서 간접적으로 접근하게 됩니다. 이 과정에서 프록시는 공통 기능을 실행한 뒤 대상 객체의 실제 메서드를 호출하거나 또는 대상객체의 실제 메소드를 호출한 후에 공통기능을 실행합니다.\n![](https://i.imgur.com/63YMS1o.png)\n대상 타겟은 결국 빈 객체가 생성 되는데, 런타임시에 오브젝트 생성 설정에 따라서 스프링 컨테이너가 지정한 빈 객체 대한 프록시 객체를 생성하고, 원본 빈 객체 대신에 프록시 객체를 사용하게 합니다.\n\n프록시 객체를 생성하는 방식은 대상 객체가 인터페이스를 구현하고 있느냐 없느냐 여부에 따라 달라집니다. 2가지 방식이 존재하는데 JDK Dynamic Proxy, CGLIB를 이용하여 프록시를 생성하는 방식이 있습니다.\n\n### JDK Dynamic Proxy\n스프링은 자바 리플렉션 API가 제공하는 java.lang.reflect.Proxy를 이용하여 프록시 객체를 생성합니다. 아래 그림과 NConnectionMaker,DConnectionMaker와 같이 동일한 인터페이스를 구현하게되면 UserDao와 같은 클라이언트는 인터페이스를 통해서 필요한 메서드를 호출하게 됩니다. 하지만, ***인터페이스를 기반으로 프록시 객체를 생성하기 때문에 인터페이스에 정의되어 있지 않은 메서드에 대해서는 AOP가 적용되지 않는 점에 유의해야합니다.***\n![](https://i.imgur.com/gX6THnw.png)\n\n### CGLIB\n대상객체가 인터페이스를 구현하고 있지 않고 바로 클래스를 사용한다면, 스프링은 CGLIB를 이용하여 클래스에 대한 프록시 객체를 생성합니다. CGLIB는 대상 클래스를 상속 받아 프록시를 구현합니다. 따라서 클래스가 final인경우에는 프록시를 생성할 수 없습니다.\n\n#### 강제로 CGLIB를 이용하여 Proxy를 생성하는 방법\n\n@EnableAspectJAutoProxy 어노테이션 속성으로 proxyTaretClass란 것이 있습니다. 위에서 말한대로 Spirng AOP는 Proxy class를 생성함으로 AOP를 구현 합니다. AOP의 대상이 되는 클래스가 Interface를 구현하고 있을 경우 Spring은 Interface를 이용하는 JDK Dynamic Proxy를 만들어서 AOP를 구현하고 Interface를 구현하지 않고 클래스에 대해서는 CG-LIB를 이용한 대상클래스의 상속을받아 서브클래스를 만들어 이를 Proxy삼아 AOP 구현하게 됩니다. 이 속성 값을 주지 않으면 기본값은 false이기 때문에 대상이 되는 클래스가 interface를 이용한것은 자동으로 JDK Dynamic Proxy를 이용해서 AOP를 생성하고 아닌경우에는 CG-LIB를 이용해 클래스  Proxy로 AOP를 구현하게 됩니다. 이 속성을 true로 주게되면 인터페이스 또한 CG-LIB를 이용하여 서브클래스 생성하는 방식으로 AOP의 프록시를 구현하게 됩니다.\n\n\n출처 <br>\n* [최범균](http://book.naver.com/bookdb/book_detail.nhn?bid=7918153) <br>\n* [Spring document](https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html)<br>\n","slug":"2017-10-29-Spring-AOP-Proxy","published":1,"updated":"2018-06-20T16:05:18.383Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27be000kjjpere3osvpl","content":"<h1><span id=\"spring-aop-proxy-란\">Spring-AOP, Proxy 란?</span></h1>\n<h2><span id=\"aop란\">AOP란 ?<br></span></h2>\n<p>AOP는 문제를 해결하기 위한 핵심 관심 사항과 전체에 적용되는 공통 모듈 사항을 기준으로 프로그래밍 함으로써 공통 모듈을 여러 코드에 쉽게 적용할 수 있도록 도와주는 역할을 합니다. AOP를 구현하는 다양한 방법이 존재하지만, 기본적인 개념은 아래 그림과 같이 공통 관심 사항 코드를 비즈니스 로직을 구현한 코드안에 삽입하는 것입니다.<br>\n<img src=\"https://i.imgur.com/a0AFbrG.png\" alt=\"\"><br>\n위에 그림에서 공통기능은 직접적으로 호출되지 않습니다. 핵심로직을 구현한 코드를 컴파일하거나, 컴파일된 클래스를 로딩하거나, 또는 로딩한 클래스의 객체를 생성할 때, Proxy객체를 통해 호출할 때 AOP가 적용됩니다.</p>\n<h2><span id=\"aop용어\">AOP용어</span></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-Joinpoint</span><br><span class=\"line\">Advice를 적용 가능한 지점을 의미합니다. 메소드호출, 필드값 변경 등이 Joinpoint에 해당 합니다.</span><br><span class=\"line\">-Pointcut</span><br><span class=\"line\">Joinpoint의 부분집합으로서 실제로 Advice가 적용되는 Joinpoint를 나타냅니다. 스프링에서는 정규 표현식이나 AspectJ의 문법을 이용하여 Poincut을 재정의 할 수 있습니다.</span><br><span class=\"line\">-Advice</span><br><span class=\"line\">언제 공통 관심 기능을 핵심로직에 적용할 지를 정의하고 있습니다. 예를들어, &apos;메서드를 호출 하기전에 트랜잭션 시작&apos; 기능을 적용한다는 것을 정의하고 있는 것입니다.</span><br><span class=\"line\">-Weaving</span><br><span class=\"line\">Advice를 핵심로직코드에 적용하는것을 weaving이라고 한다라고 합니다. 즉 공통코드를 핵심로직코드에 삽입하는것을 weaving이라고 합니다.</span><br><span class=\"line\">-Aspect</span><br><span class=\"line\">여러 객체에 공통으로 적용되는 기능을 Aspect라고 합니다. 트랜잭션이나, 보안등이 Aspect의 좋은 예입니다.</span><br></pre></td></tr></table></figure>\n<h2><span id=\"3가지-weaving-방식\">3가지 Weaving 방식</span></h2>\n<p>Advice를 Weaving하는 방식에는 세가지 방식이 존재합니다.</p>\n<ol>\n<li>컴파일시에 Weaving하기</li>\n<li>클래스 로딩 시에 Weaving하기</li>\n<li>런타임시에 Weaving하기</li>\n</ol>\n<p>일반적으로 컴파일시와 클래스 로딩 시에는 weaving하는 방식은 AspectJ라이브러리를 추가하여 구현할때 사용됩니다. 런타임시에 weaving하는 방식은 Spring-AOP에서 사용하는 방식인데 소스코드나 클래스 정보 자체를 변경하지 않습니다. 대신 프록시를 생성하여 AOP를 적용합니다. 프록시 기반의 AOP는 핵심 로직을 구현할 객체에 직접 접근하는것이 아니라 아래 그림과 같이 중간에 프록시를 생성하여 프록시를 통해 핵심 로직의 객체에 접근하는 것입니다.<br>\n<img src=\"https://i.imgur.com/bFfetFM.jpg\" alt=\"\"><br>\n이때 프록시는 핵심 로직을 실행하기 전 또는 후에 공통 모듈 기능을 적용하는 방식으로 AOP를 구현하게 됩니다.</p>\n<h2><span id=\"spring-aop란\">Spring-AOP란?</span></h2>\n<p>스프링은 자체적으로 프록시 기반의 AOP를 지원하고 있습니다. 따라서 스프링 AOP는 메서드 호출 Joinpoint만을 지원합니다. 필드 값 변경과 같은 Joinpoint를 사용하고 싶다면 AspectJ와 같이 다양한 Joinpoint를 지원하는 AOP프레임워크를 사용해야 합니다.</p>\n<p>스프링은 크게 3가지 방식으로 AOP를 제공합니다.</p>\n<ol>\n<li>XML 스키마 기반의 POJO클래스를 이용한 AOP구현</li>\n<li>AspectJ에서 정의한 @Aspect 애노테이션 기반의 AOP구현</li>\n<li>스프링 API를 이용한 AOP구현</li>\n</ol>\n<p>어떤 방식을 사용하더라도 내부적으로 프록시를 이용하여 AOP가 구현되기 때문에 프록시를 통한 메소드호출만 AOP를 적용할 수 있다는 것을 유의 해야 합니다. 예를 들어 내부클래스내에서 다른 메소드를 호출한다고 하면 그것은 프록시를 거쳐 가는것이 아니기 때문에 AOP가 적용되지 않습니다.</p>\n<h2><span id=\"프록시를-이용한-aop-구현\">프록시를 이용한 AOP 구현</span></h2>\n<p>스프링은 프록시를 이용하여 AOP를 구현합니다. 스프링은 Aspect의 적용대상이 되는 객체에 대한 프록시를 만들어 제공합니다. 비지니스 로직에 접근할 때 대상 객체로 바로 접근하는 게 아닌 프록시를 통해서 간접적으로 접근하게 됩니다. 이 과정에서 프록시는 공통 기능을 실행한 뒤 대상 객체의 실제 메서드를 호출하거나 또는 대상객체의 실제 메소드를 호출한 후에 공통기능을 실행합니다.<br>\n<img src=\"https://i.imgur.com/63YMS1o.png\" alt=\"\"><br>\n대상 타겟은 결국 빈 객체가 생성 되는데, 런타임시에 오브젝트 생성 설정에 따라서 스프링 컨테이너가 지정한 빈 객체 대한 프록시 객체를 생성하고, 원본 빈 객체 대신에 프록시 객체를 사용하게 합니다.</p>\n<p>프록시 객체를 생성하는 방식은 대상 객체가 인터페이스를 구현하고 있느냐 없느냐 여부에 따라 달라집니다. 2가지 방식이 존재하는데 JDK Dynamic Proxy, CGLIB를 이용하여 프록시를 생성하는 방식이 있습니다.</p>\n<h3><span id=\"jdk-dynamic-proxy\">JDK Dynamic Proxy</span></h3>\n<p>스프링은 자바 리플렉션 API가 제공하는 java.lang.reflect.Proxy를 이용하여 프록시 객체를 생성합니다. 아래 그림과 NConnectionMaker,DConnectionMaker와 같이 동일한 인터페이스를 구현하게되면 UserDao와 같은 클라이언트는 인터페이스를 통해서 필요한 메서드를 호출하게 됩니다. 하지만, <strong><em>인터페이스를 기반으로 프록시 객체를 생성하기 때문에 인터페이스에 정의되어 있지 않은 메서드에 대해서는 AOP가 적용되지 않는 점에 유의해야합니다.</em></strong><br>\n<img src=\"https://i.imgur.com/gX6THnw.png\" alt=\"\"></p>\n<h3><span id=\"cglib\">CGLIB</span></h3>\n<p>대상객체가 인터페이스를 구현하고 있지 않고 바로 클래스를 사용한다면, 스프링은 CGLIB를 이용하여 클래스에 대한 프록시 객체를 생성합니다. CGLIB는 대상 클래스를 상속 받아 프록시를 구현합니다. 따라서 클래스가 final인경우에는 프록시를 생성할 수 없습니다.</p>\n<h4><span id=\"강제로-cglib를-이용하여-proxy를-생성하는-방법\">강제로 CGLIB를 이용하여 Proxy를 생성하는 방법</span></h4>\n<p>@EnableAspectJAutoProxy 어노테이션 속성으로 proxyTaretClass란 것이 있습니다. 위에서 말한대로 Spirng AOP는 Proxy class를 생성함으로 AOP를 구현 합니다. AOP의 대상이 되는 클래스가 Interface를 구현하고 있을 경우 Spring은 Interface를 이용하는 JDK Dynamic Proxy를 만들어서 AOP를 구현하고 Interface를 구현하지 않고 클래스에 대해서는 CG-LIB를 이용한 대상클래스의 상속을받아 서브클래스를 만들어 이를 Proxy삼아 AOP 구현하게 됩니다. 이 속성 값을 주지 않으면 기본값은 false이기 때문에 대상이 되는 클래스가 interface를 이용한것은 자동으로 JDK Dynamic Proxy를 이용해서 AOP를 생성하고 아닌경우에는 CG-LIB를 이용해 클래스  Proxy로 AOP를 구현하게 됩니다. 이 속성을 true로 주게되면 인터페이스 또한 CG-LIB를 이용하여 서브클래스 생성하는 방식으로 AOP의 프록시를 구현하게 됩니다.</p>\n<p>출처 <br></p>\n<ul>\n<li><a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=7918153\" target=\"_blank\" rel=\"noopener\">최범균</a> <br></li>\n<li><a href=\"https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html\" target=\"_blank\" rel=\"noopener\">Spring document</a><br></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>Spring-AOP, Proxy 란?</h1>\n<h2>AOP란 ?<br></h2>\n<p>AOP는 문제를 해결하기 위한 핵심 관심 사항과 전체에 적용되는 공통 모듈 사항을 기준으로 프로그래밍 함으로써 공통 모듈을 여러 코드에 쉽게 적용할 수 있도록 도와주는 역할을 합니다. AOP를 구현하는 다양한 방법이 존재하지만, 기본적인 개념은 아래 그림과 같이 공통 관심 사항 코드를 비즈니스 로직을 구현한 코드안에 삽입하는 것입니다.<br>\n<img src=\"https://i.imgur.com/a0AFbrG.png\" alt=\"\"><br>\n위에 그림에서 공통기능은 직접적으로 호출되지 않습니다. 핵심로직을 구현한 코드를 컴파일하거나, 컴파일된 클래스를 로딩하거나, 또는 로딩한 클래스의 객체를 생성할 때, Proxy객체를 통해 호출할 때 AOP가 적용됩니다.</p>\n<h2>AOP용어</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-Joinpoint</span><br><span class=\"line\">Advice를 적용 가능한 지점을 의미합니다. 메소드호출, 필드값 변경 등이 Joinpoint에 해당 합니다.</span><br><span class=\"line\">-Pointcut</span><br><span class=\"line\">Joinpoint의 부분집합으로서 실제로 Advice가 적용되는 Joinpoint를 나타냅니다. 스프링에서는 정규 표현식이나 AspectJ의 문법을 이용하여 Poincut을 재정의 할 수 있습니다.</span><br><span class=\"line\">-Advice</span><br><span class=\"line\">언제 공통 관심 기능을 핵심로직에 적용할 지를 정의하고 있습니다. 예를들어, &apos;메서드를 호출 하기전에 트랜잭션 시작&apos; 기능을 적용한다는 것을 정의하고 있는 것입니다.</span><br><span class=\"line\">-Weaving</span><br><span class=\"line\">Advice를 핵심로직코드에 적용하는것을 weaving이라고 한다라고 합니다. 즉 공통코드를 핵심로직코드에 삽입하는것을 weaving이라고 합니다.</span><br><span class=\"line\">-Aspect</span><br><span class=\"line\">여러 객체에 공통으로 적용되는 기능을 Aspect라고 합니다. 트랜잭션이나, 보안등이 Aspect의 좋은 예입니다.</span><br></pre></td></tr></table></figure>\n<h2>3가지 Weaving 방식</h2>\n<p>Advice를 Weaving하는 방식에는 세가지 방식이 존재합니다.</p>\n<ol>\n<li>컴파일시에 Weaving하기</li>\n<li>클래스 로딩 시에 Weaving하기</li>\n<li>런타임시에 Weaving하기</li>\n</ol>\n<p>일반적으로 컴파일시와 클래스 로딩 시에는 weaving하는 방식은 AspectJ라이브러리를 추가하여 구현할때 사용됩니다. 런타임시에 weaving하는 방식은 Spring-AOP에서 사용하는 방식인데 소스코드나 클래스 정보 자체를 변경하지 않습니다. 대신 프록시를 생성하여 AOP를 적용합니다. 프록시 기반의 AOP는 핵심 로직을 구현할 객체에 직접 접근하는것이 아니라 아래 그림과 같이 중간에 프록시를 생성하여 프록시를 통해 핵심 로직의 객체에 접근하는 것입니다.<br>\n<img src=\"https://i.imgur.com/bFfetFM.jpg\" alt=\"\"><br>\n이때 프록시는 핵심 로직을 실행하기 전 또는 후에 공통 모듈 기능을 적용하는 방식으로 AOP를 구현하게 됩니다.</p>\n<h2>Spring-AOP란?</h2>\n<p>스프링은 자체적으로 프록시 기반의 AOP를 지원하고 있습니다. 따라서 스프링 AOP는 메서드 호출 Joinpoint만을 지원합니다. 필드 값 변경과 같은 Joinpoint를 사용하고 싶다면 AspectJ와 같이 다양한 Joinpoint를 지원하는 AOP프레임워크를 사용해야 합니다.</p>\n<p>스프링은 크게 3가지 방식으로 AOP를 제공합니다.</p>\n<ol>\n<li>XML 스키마 기반의 POJO클래스를 이용한 AOP구현</li>\n<li>AspectJ에서 정의한 @Aspect 애노테이션 기반의 AOP구현</li>\n<li>스프링 API를 이용한 AOP구현</li>\n</ol>\n<p>어떤 방식을 사용하더라도 내부적으로 프록시를 이용하여 AOP가 구현되기 때문에 프록시를 통한 메소드호출만 AOP를 적용할 수 있다는 것을 유의 해야 합니다. 예를 들어 내부클래스내에서 다른 메소드를 호출한다고 하면 그것은 프록시를 거쳐 가는것이 아니기 때문에 AOP가 적용되지 않습니다.</p>\n<h2>프록시를 이용한 AOP 구현</h2>\n<p>스프링은 프록시를 이용하여 AOP를 구현합니다. 스프링은 Aspect의 적용대상이 되는 객체에 대한 프록시를 만들어 제공합니다. 비지니스 로직에 접근할 때 대상 객체로 바로 접근하는 게 아닌 프록시를 통해서 간접적으로 접근하게 됩니다. 이 과정에서 프록시는 공통 기능을 실행한 뒤 대상 객체의 실제 메서드를 호출하거나 또는 대상객체의 실제 메소드를 호출한 후에 공통기능을 실행합니다.<br>\n<img src=\"https://i.imgur.com/63YMS1o.png\" alt=\"\"><br>\n대상 타겟은 결국 빈 객체가 생성 되는데, 런타임시에 오브젝트 생성 설정에 따라서 스프링 컨테이너가 지정한 빈 객체 대한 프록시 객체를 생성하고, 원본 빈 객체 대신에 프록시 객체를 사용하게 합니다.</p>\n<p>프록시 객체를 생성하는 방식은 대상 객체가 인터페이스를 구현하고 있느냐 없느냐 여부에 따라 달라집니다. 2가지 방식이 존재하는데 JDK Dynamic Proxy, CGLIB를 이용하여 프록시를 생성하는 방식이 있습니다.</p>\n<h3>JDK Dynamic Proxy</h3>\n<p>스프링은 자바 리플렉션 API가 제공하는 java.lang.reflect.Proxy를 이용하여 프록시 객체를 생성합니다. 아래 그림과 NConnectionMaker,DConnectionMaker와 같이 동일한 인터페이스를 구현하게되면 UserDao와 같은 클라이언트는 인터페이스를 통해서 필요한 메서드를 호출하게 됩니다. 하지만, <strong><em>인터페이스를 기반으로 프록시 객체를 생성하기 때문에 인터페이스에 정의되어 있지 않은 메서드에 대해서는 AOP가 적용되지 않는 점에 유의해야합니다.</em></strong><br>\n<img src=\"https://i.imgur.com/gX6THnw.png\" alt=\"\"></p>\n<h3>CGLIB</h3>\n<p>대상객체가 인터페이스를 구현하고 있지 않고 바로 클래스를 사용한다면, 스프링은 CGLIB를 이용하여 클래스에 대한 프록시 객체를 생성합니다. CGLIB는 대상 클래스를 상속 받아 프록시를 구현합니다. 따라서 클래스가 final인경우에는 프록시를 생성할 수 없습니다.</p>\n<h4>강제로 CGLIB를 이용하여 Proxy를 생성하는 방법</h4>\n<p>@EnableAspectJAutoProxy 어노테이션 속성으로 proxyTaretClass란 것이 있습니다. 위에서 말한대로 Spirng AOP는 Proxy class를 생성함으로 AOP를 구현 합니다. AOP의 대상이 되는 클래스가 Interface를 구현하고 있을 경우 Spring은 Interface를 이용하는 JDK Dynamic Proxy를 만들어서 AOP를 구현하고 Interface를 구현하지 않고 클래스에 대해서는 CG-LIB를 이용한 대상클래스의 상속을받아 서브클래스를 만들어 이를 Proxy삼아 AOP 구현하게 됩니다. 이 속성 값을 주지 않으면 기본값은 false이기 때문에 대상이 되는 클래스가 interface를 이용한것은 자동으로 JDK Dynamic Proxy를 이용해서 AOP를 생성하고 아닌경우에는 CG-LIB를 이용해 클래스  Proxy로 AOP를 구현하게 됩니다. 이 속성을 true로 주게되면 인터페이스 또한 CG-LIB를 이용하여 서브클래스 생성하는 방식으로 AOP의 프록시를 구현하게 됩니다.</p>\n<p>출처 <br></p>\n<ul>\n<li><a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=7918153\" target=\"_blank\" rel=\"noopener\">최범균</a> <br></li>\n<li><a href=\"https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html\" target=\"_blank\" rel=\"noopener\">Spring document</a><br></li>\n</ul>\n"},{"title":"서블릿 컨테이너와 스프링 컨테이너","catalog":true,"date":"2017-10-07T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n# 서블릿 컨테이너와 스프링 컨테이너\n\n## 서블릿 컨테이너\n서블릿 컨테이너는 개발자가 웹서버와 통신하기 위하여 소켓을 생성하고, 특정 포트에 리스닝하고, 스트림을 생성하는 등의 복잡한 일들을 할 필요가 없게 해준다. 컨테이너는 servlet의 생성부터 소멸까지의 일련의 과정(Lifer Cycle)을 관리한다. 서블릿 컨테이너는 요청이 들어올 때마다 새로운 자바 스레드를 만든다. 우리가 알고 있는 대표적인 Servlet Container가 Tomcat 이다. 톰켓같은 was가 java파일을 컴파일해서 Class로 만들고 메모리에 올려 servlet객체를 만든다.\n\nServlet 동작과정\n\n![](https://i.imgur.com/alHA0zr.jpg)\n\n1. 사용자가 URL을 클릭하면 HTTP Request를 Servlet Container에 보낸다.<br>\n2. Servlet Container는 HttpServletRequest, HttpServletResponse 두 객체를 생성한다.<br>\n3. 사용자가 요청한 URL을 분석하여 어느 서블릿에 대한 요청인지 찾는다.<br>\n4. 컨테이너는 서블릿 service() 메소드를 호출하며, POST, GET여부에 따라 doGet() 또는 doPost()가 호출된다.<br>\n5. doGet() or doPost() 메소드는 동적인 페이지를 생성한 후 HttpServletResponse객체에 응답을 보낸다.<br>\n6. 응답이 완료되면 HttpServletRequest, HttpServletResponse 두 객체를 소멸시킨다.<br>\n\n### 서블릿 생명주기\ninit() - 서버가 켜질때 한번만 실행\nservice - 모든 유저들의 요청을들을 받는다.\ndestroy() - 서버가 꺼질대 한번만실행\n\n![](http://i.imgur.com/JaIUPwx.jpg)\n\n## Spring Container\n먼저 Spring Container를 이해하기위해서는 IOC와 DI를 이해해야한다.\n\n\n| 이름     | 설명     |\n| :------------- | :------------- |\n| IoC(Inversion of Control)       | 개발자는 JAVA코딩시 New연산자, 인터페이스 호출,팩토리 호출방식으로 객체를 생성하고 소멸시킨다. IOC란 인스턴스의 생성부터 소멸까지의 객체 생명주기 관리를 개발자가하는 대신 스프링(컨테이너)가 관리한다     |\n| DI(Dependency Injection) | IoC를 실제로 구현하는 방법으로서 의존성있는 컴포넌트들 간의 관계를 개발자가 직접 코드로 명시하지 않고 컨테이너인 Spring이 런타임에 찾아서 연결해주게 하는 것이다. |\n\nSpring Container는 Bean들의 생명주기를 관리한다. Spring Container는 어플리케이션을 구성하는 Bean들을 관리하기위해 IOC를 사용한다. Spring 컨테이너 종류에는 BeanFactory와 이를 상속한ApplicationContext가 존재한다. 이 두개의 컨테이너로 의존성 주입된 빈들을 제어하고 관리할 수 있다. 아래는 스프링 웹어플리케이션 동작원리이다.\n\n\n\n\n## 웹어플리케이션 동작원리\n\n![](https://i.imgur.com/PlDF42i.png)\n\n1. 웹 애플리케이션이 실행되면 Tomcat(WAS)에 의해 web.xml이 loading된다.\n2. web.xml에 등록되어 있는 ContextLoaderListener(Java Class)가 생성된다. ContextLoaderListener 클래스는 ServletContextListener 인터페이스를 구현하고 있으며, ApplicationContext를 생성하는 역할을 수행한다.\n3. 생성된 ContextLoaderListener는 root-context.xml을 loading한다.\n4. root-context.xml에 등록되어 있는 Spring Container가 구동된다. 이 때 개발자가 작성한 비즈니스 로직에 대한 부분과 DAO, VO 객체들이 생성된다.\n5. 클라이언트로부터 웹 애플리케이션이 요청이 온다.\n6. DispatcherServlet(Servlet)이 생성된다. DispatcherServlet은 FrontController의 역할을 수행한다. 클라이언트로부터 요청 온 메시지를 분석하여 알맞은 PageController에게 전달하고 응답을 받아 요청에 따른 응답을 어떻게 할 지 결정만한다. 실질적은 작업은 PageController에서 이루어지기 때문이다. 이러한 클래스들을 HandlerMapping, ViewResolver 클래스라고 한다.\n7. DispatcherServlet은 servlet-context.xml을 loading 한다.\n8. 두번째 Spring Container가 구동되며 응답에 맞는 PageController 들이 동작한다. 이 때 첫번째 Spring Container 가 구동되면서 생성된 DAO, VO, ServiceImpl 클래스들과 협업하여 알맞은 작업을 처리하게 된다.\n\n\n\n참고<br>\n* [Old Lisper](http://anster.tistory.com/128)<br>\n* [고물라디오 같은 블로그](http://10albatross.tistory.com/4)<br>\n* [기억보단 기록을](http://jojoldu.tistory.com/28)<br>\n* [Devlog](http://asfirstalways.tistory.com/334)<br>\n* [Spring Document](https://docs.spring.io/spring/docs/2.5.x/reference/transaction.html#transaction-declarative)<br>\n","source":"_posts/2017-10-08-Spring-Container,Servlet-Container.md","raw":"---\ntitle: 서블릿 컨테이너와 스프링 컨테이너\ncatalog: true\ndate: 2017-10-08\nsubtitle:\nheader-img:\ntags:\n- Spring\n- Java\n\n---\n\n# 서블릿 컨테이너와 스프링 컨테이너\n\n## 서블릿 컨테이너\n서블릿 컨테이너는 개발자가 웹서버와 통신하기 위하여 소켓을 생성하고, 특정 포트에 리스닝하고, 스트림을 생성하는 등의 복잡한 일들을 할 필요가 없게 해준다. 컨테이너는 servlet의 생성부터 소멸까지의 일련의 과정(Lifer Cycle)을 관리한다. 서블릿 컨테이너는 요청이 들어올 때마다 새로운 자바 스레드를 만든다. 우리가 알고 있는 대표적인 Servlet Container가 Tomcat 이다. 톰켓같은 was가 java파일을 컴파일해서 Class로 만들고 메모리에 올려 servlet객체를 만든다.\n\nServlet 동작과정\n\n![](https://i.imgur.com/alHA0zr.jpg)\n\n1. 사용자가 URL을 클릭하면 HTTP Request를 Servlet Container에 보낸다.<br>\n2. Servlet Container는 HttpServletRequest, HttpServletResponse 두 객체를 생성한다.<br>\n3. 사용자가 요청한 URL을 분석하여 어느 서블릿에 대한 요청인지 찾는다.<br>\n4. 컨테이너는 서블릿 service() 메소드를 호출하며, POST, GET여부에 따라 doGet() 또는 doPost()가 호출된다.<br>\n5. doGet() or doPost() 메소드는 동적인 페이지를 생성한 후 HttpServletResponse객체에 응답을 보낸다.<br>\n6. 응답이 완료되면 HttpServletRequest, HttpServletResponse 두 객체를 소멸시킨다.<br>\n\n### 서블릿 생명주기\ninit() - 서버가 켜질때 한번만 실행\nservice - 모든 유저들의 요청을들을 받는다.\ndestroy() - 서버가 꺼질대 한번만실행\n\n![](http://i.imgur.com/JaIUPwx.jpg)\n\n## Spring Container\n먼저 Spring Container를 이해하기위해서는 IOC와 DI를 이해해야한다.\n\n\n| 이름     | 설명     |\n| :------------- | :------------- |\n| IoC(Inversion of Control)       | 개발자는 JAVA코딩시 New연산자, 인터페이스 호출,팩토리 호출방식으로 객체를 생성하고 소멸시킨다. IOC란 인스턴스의 생성부터 소멸까지의 객체 생명주기 관리를 개발자가하는 대신 스프링(컨테이너)가 관리한다     |\n| DI(Dependency Injection) | IoC를 실제로 구현하는 방법으로서 의존성있는 컴포넌트들 간의 관계를 개발자가 직접 코드로 명시하지 않고 컨테이너인 Spring이 런타임에 찾아서 연결해주게 하는 것이다. |\n\nSpring Container는 Bean들의 생명주기를 관리한다. Spring Container는 어플리케이션을 구성하는 Bean들을 관리하기위해 IOC를 사용한다. Spring 컨테이너 종류에는 BeanFactory와 이를 상속한ApplicationContext가 존재한다. 이 두개의 컨테이너로 의존성 주입된 빈들을 제어하고 관리할 수 있다. 아래는 스프링 웹어플리케이션 동작원리이다.\n\n\n\n\n## 웹어플리케이션 동작원리\n\n![](https://i.imgur.com/PlDF42i.png)\n\n1. 웹 애플리케이션이 실행되면 Tomcat(WAS)에 의해 web.xml이 loading된다.\n2. web.xml에 등록되어 있는 ContextLoaderListener(Java Class)가 생성된다. ContextLoaderListener 클래스는 ServletContextListener 인터페이스를 구현하고 있으며, ApplicationContext를 생성하는 역할을 수행한다.\n3. 생성된 ContextLoaderListener는 root-context.xml을 loading한다.\n4. root-context.xml에 등록되어 있는 Spring Container가 구동된다. 이 때 개발자가 작성한 비즈니스 로직에 대한 부분과 DAO, VO 객체들이 생성된다.\n5. 클라이언트로부터 웹 애플리케이션이 요청이 온다.\n6. DispatcherServlet(Servlet)이 생성된다. DispatcherServlet은 FrontController의 역할을 수행한다. 클라이언트로부터 요청 온 메시지를 분석하여 알맞은 PageController에게 전달하고 응답을 받아 요청에 따른 응답을 어떻게 할 지 결정만한다. 실질적은 작업은 PageController에서 이루어지기 때문이다. 이러한 클래스들을 HandlerMapping, ViewResolver 클래스라고 한다.\n7. DispatcherServlet은 servlet-context.xml을 loading 한다.\n8. 두번째 Spring Container가 구동되며 응답에 맞는 PageController 들이 동작한다. 이 때 첫번째 Spring Container 가 구동되면서 생성된 DAO, VO, ServiceImpl 클래스들과 협업하여 알맞은 작업을 처리하게 된다.\n\n\n\n참고<br>\n* [Old Lisper](http://anster.tistory.com/128)<br>\n* [고물라디오 같은 블로그](http://10albatross.tistory.com/4)<br>\n* [기억보단 기록을](http://jojoldu.tistory.com/28)<br>\n* [Devlog](http://asfirstalways.tistory.com/334)<br>\n* [Spring Document](https://docs.spring.io/spring/docs/2.5.x/reference/transaction.html#transaction-declarative)<br>\n","slug":"2017-10-08-Spring-Container,Servlet-Container","published":1,"updated":"2018-06-20T16:05:18.304Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27bf000mjjpef6b835wu","content":"<h1><span id=\"서블릿-컨테이너와-스프링-컨테이너\">서블릿 컨테이너와 스프링 컨테이너</span></h1>\n<h2><span id=\"서블릿-컨테이너\">서블릿 컨테이너</span></h2>\n<p>서블릿 컨테이너는 개발자가 웹서버와 통신하기 위하여 소켓을 생성하고, 특정 포트에 리스닝하고, 스트림을 생성하는 등의 복잡한 일들을 할 필요가 없게 해준다. 컨테이너는 servlet의 생성부터 소멸까지의 일련의 과정(Lifer Cycle)을 관리한다. 서블릿 컨테이너는 요청이 들어올 때마다 새로운 자바 스레드를 만든다. 우리가 알고 있는 대표적인 Servlet Container가 Tomcat 이다. 톰켓같은 was가 java파일을 컴파일해서 Class로 만들고 메모리에 올려 servlet객체를 만든다.</p>\n<p>Servlet 동작과정</p>\n<p><img src=\"https://i.imgur.com/alHA0zr.jpg\" alt=\"\"></p>\n<ol>\n<li>사용자가 URL을 클릭하면 HTTP Request를 Servlet Container에 보낸다.<br></li>\n<li>Servlet Container는 HttpServletRequest, HttpServletResponse 두 객체를 생성한다.<br></li>\n<li>사용자가 요청한 URL을 분석하여 어느 서블릿에 대한 요청인지 찾는다.<br></li>\n<li>컨테이너는 서블릿 service() 메소드를 호출하며, POST, GET여부에 따라 doGet() 또는 doPost()가 호출된다.<br></li>\n<li>doGet() or doPost() 메소드는 동적인 페이지를 생성한 후 HttpServletResponse객체에 응답을 보낸다.<br></li>\n<li>응답이 완료되면 HttpServletRequest, HttpServletResponse 두 객체를 소멸시킨다.<br></li>\n</ol>\n<h3><span id=\"서블릿-생명주기\">서블릿 생명주기</span></h3>\n<p>init() - 서버가 켜질때 한번만 실행<br>\nservice - 모든 유저들의 요청을들을 받는다.<br>\ndestroy() - 서버가 꺼질대 한번만실행</p>\n<p><img src=\"http://i.imgur.com/JaIUPwx.jpg\" alt=\"\"></p>\n<h2><span id=\"spring-container\">Spring Container</span></h2>\n<p>먼저 Spring Container를 이해하기위해서는 IOC와 DI를 이해해야한다.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">이름</th>\n<th style=\"text-align:left\">설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">IoC(Inversion of Control)</td>\n<td style=\"text-align:left\">개발자는 JAVA코딩시 New연산자, 인터페이스 호출,팩토리 호출방식으로 객체를 생성하고 소멸시킨다. IOC란 인스턴스의 생성부터 소멸까지의 객체 생명주기 관리를 개발자가하는 대신 스프링(컨테이너)가 관리한다</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DI(Dependency Injection)</td>\n<td style=\"text-align:left\">IoC를 실제로 구현하는 방법으로서 의존성있는 컴포넌트들 간의 관계를 개발자가 직접 코드로 명시하지 않고 컨테이너인 Spring이 런타임에 찾아서 연결해주게 하는 것이다.</td>\n</tr>\n</tbody>\n</table>\n<p>Spring Container는 Bean들의 생명주기를 관리한다. Spring Container는 어플리케이션을 구성하는 Bean들을 관리하기위해 IOC를 사용한다. Spring 컨테이너 종류에는 BeanFactory와 이를 상속한ApplicationContext가 존재한다. 이 두개의 컨테이너로 의존성 주입된 빈들을 제어하고 관리할 수 있다. 아래는 스프링 웹어플리케이션 동작원리이다.</p>\n<h2><span id=\"웹어플리케이션-동작원리\">웹어플리케이션 동작원리</span></h2>\n<p><img src=\"https://i.imgur.com/PlDF42i.png\" alt=\"\"></p>\n<ol>\n<li>웹 애플리케이션이 실행되면 Tomcat(WAS)에 의해 web.xml이 loading된다.</li>\n<li>web.xml에 등록되어 있는 ContextLoaderListener(Java Class)가 생성된다. ContextLoaderListener 클래스는 ServletContextListener 인터페이스를 구현하고 있으며, ApplicationContext를 생성하는 역할을 수행한다.</li>\n<li>생성된 ContextLoaderListener는 root-context.xml을 loading한다.</li>\n<li>root-context.xml에 등록되어 있는 Spring Container가 구동된다. 이 때 개발자가 작성한 비즈니스 로직에 대한 부분과 DAO, VO 객체들이 생성된다.</li>\n<li>클라이언트로부터 웹 애플리케이션이 요청이 온다.</li>\n<li>DispatcherServlet(Servlet)이 생성된다. DispatcherServlet은 FrontController의 역할을 수행한다. 클라이언트로부터 요청 온 메시지를 분석하여 알맞은 PageController에게 전달하고 응답을 받아 요청에 따른 응답을 어떻게 할 지 결정만한다. 실질적은 작업은 PageController에서 이루어지기 때문이다. 이러한 클래스들을 HandlerMapping, ViewResolver 클래스라고 한다.</li>\n<li>DispatcherServlet은 servlet-context.xml을 loading 한다.</li>\n<li>두번째 Spring Container가 구동되며 응답에 맞는 PageController 들이 동작한다. 이 때 첫번째 Spring Container 가 구동되면서 생성된 DAO, VO, ServiceImpl 클래스들과 협업하여 알맞은 작업을 처리하게 된다.</li>\n</ol>\n<p>참고<br></p>\n<ul>\n<li><a href=\"http://anster.tistory.com/128\" target=\"_blank\" rel=\"noopener\">Old Lisper</a><br></li>\n<li><a href=\"http://10albatross.tistory.com/4\" target=\"_blank\" rel=\"noopener\">고물라디오 같은 블로그</a><br></li>\n<li><a href=\"http://jojoldu.tistory.com/28\" target=\"_blank\" rel=\"noopener\">기억보단 기록을</a><br></li>\n<li><a href=\"http://asfirstalways.tistory.com/334\" target=\"_blank\" rel=\"noopener\">Devlog</a><br></li>\n<li><a href=\"https://docs.spring.io/spring/docs/2.5.x/reference/transaction.html#transaction-declarative\" target=\"_blank\" rel=\"noopener\">Spring Document</a><br></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>서블릿 컨테이너와 스프링 컨테이너</h1>\n<h2>서블릿 컨테이너</h2>\n<p>서블릿 컨테이너는 개발자가 웹서버와 통신하기 위하여 소켓을 생성하고, 특정 포트에 리스닝하고, 스트림을 생성하는 등의 복잡한 일들을 할 필요가 없게 해준다. 컨테이너는 servlet의 생성부터 소멸까지의 일련의 과정(Lifer Cycle)을 관리한다. 서블릿 컨테이너는 요청이 들어올 때마다 새로운 자바 스레드를 만든다. 우리가 알고 있는 대표적인 Servlet Container가 Tomcat 이다. 톰켓같은 was가 java파일을 컴파일해서 Class로 만들고 메모리에 올려 servlet객체를 만든다.</p>\n<p>Servlet 동작과정</p>\n<p><img src=\"https://i.imgur.com/alHA0zr.jpg\" alt=\"\"></p>\n<ol>\n<li>사용자가 URL을 클릭하면 HTTP Request를 Servlet Container에 보낸다.<br></li>\n<li>Servlet Container는 HttpServletRequest, HttpServletResponse 두 객체를 생성한다.<br></li>\n<li>사용자가 요청한 URL을 분석하여 어느 서블릿에 대한 요청인지 찾는다.<br></li>\n<li>컨테이너는 서블릿 service() 메소드를 호출하며, POST, GET여부에 따라 doGet() 또는 doPost()가 호출된다.<br></li>\n<li>doGet() or doPost() 메소드는 동적인 페이지를 생성한 후 HttpServletResponse객체에 응답을 보낸다.<br></li>\n<li>응답이 완료되면 HttpServletRequest, HttpServletResponse 두 객체를 소멸시킨다.<br></li>\n</ol>\n<h3>서블릿 생명주기</h3>\n<p>init() - 서버가 켜질때 한번만 실행<br>\nservice - 모든 유저들의 요청을들을 받는다.<br>\ndestroy() - 서버가 꺼질대 한번만실행</p>\n<p><img src=\"http://i.imgur.com/JaIUPwx.jpg\" alt=\"\"></p>\n<h2>Spring Container</h2>\n<p>먼저 Spring Container를 이해하기위해서는 IOC와 DI를 이해해야한다.</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">이름</th>\n<th style=\"text-align:left\">설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">IoC(Inversion of Control)</td>\n<td style=\"text-align:left\">개발자는 JAVA코딩시 New연산자, 인터페이스 호출,팩토리 호출방식으로 객체를 생성하고 소멸시킨다. IOC란 인스턴스의 생성부터 소멸까지의 객체 생명주기 관리를 개발자가하는 대신 스프링(컨테이너)가 관리한다</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">DI(Dependency Injection)</td>\n<td style=\"text-align:left\">IoC를 실제로 구현하는 방법으로서 의존성있는 컴포넌트들 간의 관계를 개발자가 직접 코드로 명시하지 않고 컨테이너인 Spring이 런타임에 찾아서 연결해주게 하는 것이다.</td>\n</tr>\n</tbody>\n</table>\n<p>Spring Container는 Bean들의 생명주기를 관리한다. Spring Container는 어플리케이션을 구성하는 Bean들을 관리하기위해 IOC를 사용한다. Spring 컨테이너 종류에는 BeanFactory와 이를 상속한ApplicationContext가 존재한다. 이 두개의 컨테이너로 의존성 주입된 빈들을 제어하고 관리할 수 있다. 아래는 스프링 웹어플리케이션 동작원리이다.</p>\n<h2>웹어플리케이션 동작원리</h2>\n<p><img src=\"https://i.imgur.com/PlDF42i.png\" alt=\"\"></p>\n<ol>\n<li>웹 애플리케이션이 실행되면 Tomcat(WAS)에 의해 web.xml이 loading된다.</li>\n<li>web.xml에 등록되어 있는 ContextLoaderListener(Java Class)가 생성된다. ContextLoaderListener 클래스는 ServletContextListener 인터페이스를 구현하고 있으며, ApplicationContext를 생성하는 역할을 수행한다.</li>\n<li>생성된 ContextLoaderListener는 root-context.xml을 loading한다.</li>\n<li>root-context.xml에 등록되어 있는 Spring Container가 구동된다. 이 때 개발자가 작성한 비즈니스 로직에 대한 부분과 DAO, VO 객체들이 생성된다.</li>\n<li>클라이언트로부터 웹 애플리케이션이 요청이 온다.</li>\n<li>DispatcherServlet(Servlet)이 생성된다. DispatcherServlet은 FrontController의 역할을 수행한다. 클라이언트로부터 요청 온 메시지를 분석하여 알맞은 PageController에게 전달하고 응답을 받아 요청에 따른 응답을 어떻게 할 지 결정만한다. 실질적은 작업은 PageController에서 이루어지기 때문이다. 이러한 클래스들을 HandlerMapping, ViewResolver 클래스라고 한다.</li>\n<li>DispatcherServlet은 servlet-context.xml을 loading 한다.</li>\n<li>두번째 Spring Container가 구동되며 응답에 맞는 PageController 들이 동작한다. 이 때 첫번째 Spring Container 가 구동되면서 생성된 DAO, VO, ServiceImpl 클래스들과 협업하여 알맞은 작업을 처리하게 된다.</li>\n</ol>\n<p>참고<br></p>\n<ul>\n<li><a href=\"http://anster.tistory.com/128\" target=\"_blank\" rel=\"noopener\">Old Lisper</a><br></li>\n<li><a href=\"http://10albatross.tistory.com/4\" target=\"_blank\" rel=\"noopener\">고물라디오 같은 블로그</a><br></li>\n<li><a href=\"http://jojoldu.tistory.com/28\" target=\"_blank\" rel=\"noopener\">기억보단 기록을</a><br></li>\n<li><a href=\"http://asfirstalways.tistory.com/334\" target=\"_blank\" rel=\"noopener\">Devlog</a><br></li>\n<li><a href=\"https://docs.spring.io/spring/docs/2.5.x/reference/transaction.html#transaction-declarative\" target=\"_blank\" rel=\"noopener\">Spring Document</a><br></li>\n</ul>\n"},{"title":"AspectJ를 사용해서 같은 클래스내에도 새로운 트랜잭션 만들기","catalog":true,"date":"2017-10-28T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n# AspectJ를 사용해서 같은 클래스내에도 새로운 트랜잭션 만들기\n\n<br>\n스프링에서 트랜잭션을 처리하기 위해서는 일반적인 방법은 Proxy 클래스를 이용해 트랜잭션을 처리하는 것입니다. Spring AOP는 두 가지 Type의 Proxy를 지원하고 있습니다. 그 첫번째는 interface를 이용한 JDK Dynamic Proxy 기능을 이용하는 것이고, 두번째 방법은 CGLIB를 이용해서 서브 클래스를 생성하여 AOP를 구현하는 것입니다. 하지만 두 방법다 내부에서 @Transactional(propagation = Propagation.REQUIRES_NEW) 설정된 메소드를 호출하게 되면 그 전 트랜잭션과 동일한 트랜잭션으로 묶이게 됩니다. 먼저 아래의 소스를 보시겠습니다.\n\n```java\n@Service\npublic class TestService {\n\n\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n\tpublic void testTransaction1(){\n\t\tSystem.out.println(TransactionSynchronizationManager.getCurrentTransactionName()); //com.example.demo.TestService.testTransaction1\n\t\ttestTransaction2();\n\n\t}\n\n\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n\tpublic void testTransaction2(){\n\t\tSystem.out.println(TransactionSynchronizationManager.getCurrentTransactionName()); //com.example.demo.TestService.testTransaction1\n\t}\n\n}\n```\n\n위와같이 2번째 메소드를 호출했음에도 불구하고 같은 트랜잭션으로 묶이게 됩니다. 이러한 문제를 해결하기 위해서는 스프링에서 일반적으로 사용하는 AOP를 사용하는게 아닌 AspectJ 라이브러리를 추가하여 사용해야 합니다. 이 AspectJ를 구현하는  방법은 2가지 방법이 있는데 Load-Time Weaver방식과 Compile-Time Weaver이 존재 합니다.\n\n## Load-Time Weaver\n\n```\n객체를 Load 할때, AspectJ에 의해서 wearving된 객체를 넘겨주는 방식입니다. 아래와 같은 방식으로 동작하게 됩니다.\n\napplication context에 로드된 객체의 loading\naspectj weaver에 의한 객체 weaving (@Transaction annotation이 있는 class, method에 대한 transaction 처리가 된 객체로 변경)\n객체의 이용\n위 순서를 보시면 아실 수 있듯이, 이는 객체의 사용에 대해서 약간의 performance의 하락을 가지고 오게 됩니다. application context에서 객체를 load 할 때, aspectj weaver에서 하는 또 다른 일들을 지정하게 됩니다.\n```\n\n## Compile-Time Weaver\n\n```\n객체를 Load 할 때, 위와 같은 문제가 있기 때문에, compile 시에 aspectj에서 간섭해서 필요한 객체에 weaving을 시켜서 class를 만들어내는 방식입니다. 이렇게 되면, application context의 load시에 다른 절차가 없기 때문에, performance의 하락도 없는 거의 완벽한 방법으로 구성이 가능합니다.\n\n주의사항\nlombok과 같은 compile시에 간섭하는 여러 plugin들과의 매우 다채로운 충돌이 발생한다. 특히 lombok과는 같이 사용하지 못한다고 생각해도 과언이 아니다.\n```\n\n현재 사용하려는것은 Compile-Time Weaver의 AspectJ 주입입니다. AspectJ를 사용하기 위해서는 아래와 같이 메이븐을 추가해야합니다.\n\n```xml\n<!-- Spring AOP + AspectJ -->\n<dependency>\n<groupId>org.springframework</groupId>\n<artifactId>spring-aop</artifactId>\n</dependency>\n\n<dependency>\n<groupId>org.aspectj</groupId>\n<artifactId>aspectjrt</artifactId>\n</dependency>\n\n<dependency>\n<groupId>org.aspectj</groupId>\n<artifactId>aspectjweaver</artifactId>\n</dependency>\n\n\n\n<plugin>\n      <groupId>org.codehaus.mojo</groupId>\n      <artifactId>aspectj-maven-plugin</artifactId>\n      <version>1.6</version>\n      <executions>\n          <execution>\n              <goals>\n                  <goal>compile</goal>\n                  <!-- <goal>test-compile</goal> -->\n              </goals>\n          </execution>\n      </executions>\n      <configuration>\n          <complianceLevel>1.7</complianceLevel>\n          <forceAjcCompile>true</forceAjcCompile>\n          <weaveDirectories>\n              <weaveDirectory>${project.build.outputDirectory}</weaveDirectory>\n          </weaveDirectories>\n          <aspectLibraries>\n              <aspectLibrary>\n                  <groupId>org.springframework</groupId>\n                  <artifactId>spring-aspects</artifactId>\n              </aspectLibrary>\n          </aspectLibraries>\n      </configuration>\n  </plugin>\n```\n만약 위의 플러그인을 사용하지 않는다면 compile시 weaving을 하지 않을것입니다. 그럼으로 필수로 플로그인을 넣어줘야합니다.\n\n```java\n@Configuration\n@EnableTransactionManagement(proxyTargetClass = true, mode = AdviceMode.ASPECTJ)\n@EnableAspectJAutoProxy\n@ComponentScan({ \"com.example\"})\npublic class AppConfig {\n}\n\n```\n그 다음 추가된 AspectJ를 사용하기위해서는 Spring Configuration을 설정해줘야 합니다. @EnableAspectJAutoProxy을 설정하여 Aspect을 적용 시킵니다. 물론 여기서 proxyTargetClass = ture로 설정함으로 CGLIB를 사용한다는 설정 또한 해줘야합니다. AOP 모드 또한 proxy모드에서 ASPECTJ로 변경해줍니다. 이렇게 설정하고 아까의 소스를 다시 실행시키면 트랜잭션이 분리된 모습을 확인할 수 있습니다.\n\n\n```java\n@Service\npublic class TestService {\n\n\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n\tpublic void testTransaction1(){\n\t\tSystem.out.println(TransactionSynchronizationManager.getCurrentTransactionName()); //com.example.demo.TestService.testTransaction1\n\t\ttestTransaction2();\n\n\t}\n\n\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n\tpublic void testTransaction2(){\n\t\tSystem.out.println(TransactionSynchronizationManager.getCurrentTransactionName()); //com.example.demo.TestService.testTransaction2\n\t}\n\n}\n```\n\n-Weaving<br>\nAdvice를 핵심로직코드에 적용하는것을 weaving이라고 한다. 즉 공통코드를 핵심로직코드에 삽입하는것을 weaving이라고한다\n\n출처 <br>\n* [Programming is Fun](http://netframework.tistory.com/entry/LTW-CTW를-이용한-Transactional의-사용)<br>\n* [Spring document](https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html)\n","source":"_posts/2017-10-29-Spring-Transaction,AspectJ-Compile.md","raw":"---\ntitle: AspectJ를 사용해서 같은 클래스내에도 새로운 트랜잭션 만들기\ncatalog: true\ndate: 2017-10-29\nsubtitle:\nheader-img:\ntags:\n- Spring\n- Java\n\n---\n\n# AspectJ를 사용해서 같은 클래스내에도 새로운 트랜잭션 만들기\n\n<br>\n스프링에서 트랜잭션을 처리하기 위해서는 일반적인 방법은 Proxy 클래스를 이용해 트랜잭션을 처리하는 것입니다. Spring AOP는 두 가지 Type의 Proxy를 지원하고 있습니다. 그 첫번째는 interface를 이용한 JDK Dynamic Proxy 기능을 이용하는 것이고, 두번째 방법은 CGLIB를 이용해서 서브 클래스를 생성하여 AOP를 구현하는 것입니다. 하지만 두 방법다 내부에서 @Transactional(propagation = Propagation.REQUIRES_NEW) 설정된 메소드를 호출하게 되면 그 전 트랜잭션과 동일한 트랜잭션으로 묶이게 됩니다. 먼저 아래의 소스를 보시겠습니다.\n\n```java\n@Service\npublic class TestService {\n\n\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n\tpublic void testTransaction1(){\n\t\tSystem.out.println(TransactionSynchronizationManager.getCurrentTransactionName()); //com.example.demo.TestService.testTransaction1\n\t\ttestTransaction2();\n\n\t}\n\n\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n\tpublic void testTransaction2(){\n\t\tSystem.out.println(TransactionSynchronizationManager.getCurrentTransactionName()); //com.example.demo.TestService.testTransaction1\n\t}\n\n}\n```\n\n위와같이 2번째 메소드를 호출했음에도 불구하고 같은 트랜잭션으로 묶이게 됩니다. 이러한 문제를 해결하기 위해서는 스프링에서 일반적으로 사용하는 AOP를 사용하는게 아닌 AspectJ 라이브러리를 추가하여 사용해야 합니다. 이 AspectJ를 구현하는  방법은 2가지 방법이 있는데 Load-Time Weaver방식과 Compile-Time Weaver이 존재 합니다.\n\n## Load-Time Weaver\n\n```\n객체를 Load 할때, AspectJ에 의해서 wearving된 객체를 넘겨주는 방식입니다. 아래와 같은 방식으로 동작하게 됩니다.\n\napplication context에 로드된 객체의 loading\naspectj weaver에 의한 객체 weaving (@Transaction annotation이 있는 class, method에 대한 transaction 처리가 된 객체로 변경)\n객체의 이용\n위 순서를 보시면 아실 수 있듯이, 이는 객체의 사용에 대해서 약간의 performance의 하락을 가지고 오게 됩니다. application context에서 객체를 load 할 때, aspectj weaver에서 하는 또 다른 일들을 지정하게 됩니다.\n```\n\n## Compile-Time Weaver\n\n```\n객체를 Load 할 때, 위와 같은 문제가 있기 때문에, compile 시에 aspectj에서 간섭해서 필요한 객체에 weaving을 시켜서 class를 만들어내는 방식입니다. 이렇게 되면, application context의 load시에 다른 절차가 없기 때문에, performance의 하락도 없는 거의 완벽한 방법으로 구성이 가능합니다.\n\n주의사항\nlombok과 같은 compile시에 간섭하는 여러 plugin들과의 매우 다채로운 충돌이 발생한다. 특히 lombok과는 같이 사용하지 못한다고 생각해도 과언이 아니다.\n```\n\n현재 사용하려는것은 Compile-Time Weaver의 AspectJ 주입입니다. AspectJ를 사용하기 위해서는 아래와 같이 메이븐을 추가해야합니다.\n\n```xml\n<!-- Spring AOP + AspectJ -->\n<dependency>\n<groupId>org.springframework</groupId>\n<artifactId>spring-aop</artifactId>\n</dependency>\n\n<dependency>\n<groupId>org.aspectj</groupId>\n<artifactId>aspectjrt</artifactId>\n</dependency>\n\n<dependency>\n<groupId>org.aspectj</groupId>\n<artifactId>aspectjweaver</artifactId>\n</dependency>\n\n\n\n<plugin>\n      <groupId>org.codehaus.mojo</groupId>\n      <artifactId>aspectj-maven-plugin</artifactId>\n      <version>1.6</version>\n      <executions>\n          <execution>\n              <goals>\n                  <goal>compile</goal>\n                  <!-- <goal>test-compile</goal> -->\n              </goals>\n          </execution>\n      </executions>\n      <configuration>\n          <complianceLevel>1.7</complianceLevel>\n          <forceAjcCompile>true</forceAjcCompile>\n          <weaveDirectories>\n              <weaveDirectory>${project.build.outputDirectory}</weaveDirectory>\n          </weaveDirectories>\n          <aspectLibraries>\n              <aspectLibrary>\n                  <groupId>org.springframework</groupId>\n                  <artifactId>spring-aspects</artifactId>\n              </aspectLibrary>\n          </aspectLibraries>\n      </configuration>\n  </plugin>\n```\n만약 위의 플러그인을 사용하지 않는다면 compile시 weaving을 하지 않을것입니다. 그럼으로 필수로 플로그인을 넣어줘야합니다.\n\n```java\n@Configuration\n@EnableTransactionManagement(proxyTargetClass = true, mode = AdviceMode.ASPECTJ)\n@EnableAspectJAutoProxy\n@ComponentScan({ \"com.example\"})\npublic class AppConfig {\n}\n\n```\n그 다음 추가된 AspectJ를 사용하기위해서는 Spring Configuration을 설정해줘야 합니다. @EnableAspectJAutoProxy을 설정하여 Aspect을 적용 시킵니다. 물론 여기서 proxyTargetClass = ture로 설정함으로 CGLIB를 사용한다는 설정 또한 해줘야합니다. AOP 모드 또한 proxy모드에서 ASPECTJ로 변경해줍니다. 이렇게 설정하고 아까의 소스를 다시 실행시키면 트랜잭션이 분리된 모습을 확인할 수 있습니다.\n\n\n```java\n@Service\npublic class TestService {\n\n\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n\tpublic void testTransaction1(){\n\t\tSystem.out.println(TransactionSynchronizationManager.getCurrentTransactionName()); //com.example.demo.TestService.testTransaction1\n\t\ttestTransaction2();\n\n\t}\n\n\t@Transactional(propagation = Propagation.REQUIRES_NEW)\n\tpublic void testTransaction2(){\n\t\tSystem.out.println(TransactionSynchronizationManager.getCurrentTransactionName()); //com.example.demo.TestService.testTransaction2\n\t}\n\n}\n```\n\n-Weaving<br>\nAdvice를 핵심로직코드에 적용하는것을 weaving이라고 한다. 즉 공통코드를 핵심로직코드에 삽입하는것을 weaving이라고한다\n\n출처 <br>\n* [Programming is Fun](http://netframework.tistory.com/entry/LTW-CTW를-이용한-Transactional의-사용)<br>\n* [Spring document](https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html)\n","slug":"2017-10-29-Spring-Transaction,AspectJ-Compile","published":1,"updated":"2018-06-20T16:05:18.255Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27bi000pjjpe57qfacuw","content":"<h1><span id=\"aspectj를-사용해서-같은-클래스내에도-새로운-트랜잭션-만들기\">AspectJ를 사용해서 같은 클래스내에도 새로운 트랜잭션 만들기</span></h1>\n<br>\n스프링에서 트랜잭션을 처리하기 위해서는 일반적인 방법은 Proxy 클래스를 이용해 트랜잭션을 처리하는 것입니다. Spring AOP는 두 가지 Type의 Proxy를 지원하고 있습니다. 그 첫번째는 interface를 이용한 JDK Dynamic Proxy 기능을 이용하는 것이고, 두번째 방법은 CGLIB를 이용해서 서브 클래스를 생성하여 AOP를 구현하는 것입니다. 하지만 두 방법다 내부에서 @Transactional(propagation = Propagation.REQUIRES_NEW) 설정된 메소드를 호출하게 되면 그 전 트랜잭션과 동일한 트랜잭션으로 묶이게 됩니다. 먼저 아래의 소스를 보시겠습니다.\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testTransaction1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(TransactionSynchronizationManager.getCurrentTransactionName()); <span class=\"comment\">//com.example.demo.TestService.testTransaction1</span></span><br><span class=\"line\">\t\ttestTransaction2();</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testTransaction2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(TransactionSynchronizationManager.getCurrentTransactionName()); <span class=\"comment\">//com.example.demo.TestService.testTransaction1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위와같이 2번째 메소드를 호출했음에도 불구하고 같은 트랜잭션으로 묶이게 됩니다. 이러한 문제를 해결하기 위해서는 스프링에서 일반적으로 사용하는 AOP를 사용하는게 아닌 AspectJ 라이브러리를 추가하여 사용해야 합니다. 이 AspectJ를 구현하는  방법은 2가지 방법이 있는데 Load-Time Weaver방식과 Compile-Time Weaver이 존재 합니다.</p>\n<h2><span id=\"load-time-weaver\">Load-Time Weaver</span></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">객체를 Load 할때, AspectJ에 의해서 wearving된 객체를 넘겨주는 방식입니다. 아래와 같은 방식으로 동작하게 됩니다.</span><br><span class=\"line\"></span><br><span class=\"line\">application context에 로드된 객체의 loading</span><br><span class=\"line\">aspectj weaver에 의한 객체 weaving (@Transaction annotation이 있는 class, method에 대한 transaction 처리가 된 객체로 변경)</span><br><span class=\"line\">객체의 이용</span><br><span class=\"line\">위 순서를 보시면 아실 수 있듯이, 이는 객체의 사용에 대해서 약간의 performance의 하락을 가지고 오게 됩니다. application context에서 객체를 load 할 때, aspectj weaver에서 하는 또 다른 일들을 지정하게 됩니다.</span><br></pre></td></tr></table></figure>\n<h2><span id=\"compile-time-weaver\">Compile-Time Weaver</span></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">객체를 Load 할 때, 위와 같은 문제가 있기 때문에, compile 시에 aspectj에서 간섭해서 필요한 객체에 weaving을 시켜서 class를 만들어내는 방식입니다. 이렇게 되면, application context의 load시에 다른 절차가 없기 때문에, performance의 하락도 없는 거의 완벽한 방법으로 구성이 가능합니다.</span><br><span class=\"line\"></span><br><span class=\"line\">주의사항</span><br><span class=\"line\">lombok과 같은 compile시에 간섭하는 여러 plugin들과의 매우 다채로운 충돌이 발생한다. 특히 lombok과는 같이 사용하지 못한다고 생각해도 과언이 아니다.</span><br></pre></td></tr></table></figure>\n<p>현재 사용하려는것은 Compile-Time Weaver의 AspectJ 주입입니다. AspectJ를 사용하기 위해서는 아래와 같이 메이븐을 추가해야합니다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- Spring AOP + AspectJ --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-aop<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjrt<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjweaver<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.codehaus.mojo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectj-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                  <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>compile<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">                  <span class=\"comment\">&lt;!-- &lt;goal&gt;test-compile&lt;/goal&gt; --&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">complianceLevel</span>&gt;</span>1.7<span class=\"tag\">&lt;/<span class=\"name\">complianceLevel</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">forceAjcCompile</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">forceAjcCompile</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">weaveDirectories</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">weaveDirectory</span>&gt;</span>$&#123;project.build.outputDirectory&#125;<span class=\"tag\">&lt;/<span class=\"name\">weaveDirectory</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">weaveDirectories</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">aspectLibraries</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">aspectLibrary</span>&gt;</span></span><br><span class=\"line\">                  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-aspects<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;/<span class=\"name\">aspectLibrary</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">aspectLibraries</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>만약 위의 플러그인을 사용하지 않는다면 compile시 weaving을 하지 않을것입니다. 그럼으로 필수로 플로그인을 넣어줘야합니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableTransactionManagement</span>(proxyTargetClass = <span class=\"keyword\">true</span>, mode = AdviceMode.ASPECTJ)</span><br><span class=\"line\"><span class=\"meta\">@EnableAspectJAutoProxy</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(&#123; <span class=\"string\">\"com.example\"</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppConfig</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그 다음 추가된 AspectJ를 사용하기위해서는 Spring Configuration을 설정해줘야 합니다. @EnableAspectJAutoProxy을 설정하여 Aspect을 적용 시킵니다. 물론 여기서 proxyTargetClass = ture로 설정함으로 CGLIB를 사용한다는 설정 또한 해줘야합니다. AOP 모드 또한 proxy모드에서 ASPECTJ로 변경해줍니다. 이렇게 설정하고 아까의 소스를 다시 실행시키면 트랜잭션이 분리된 모습을 확인할 수 있습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testTransaction1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(TransactionSynchronizationManager.getCurrentTransactionName()); <span class=\"comment\">//com.example.demo.TestService.testTransaction1</span></span><br><span class=\"line\">\t\ttestTransaction2();</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testTransaction2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(TransactionSynchronizationManager.getCurrentTransactionName()); <span class=\"comment\">//com.example.demo.TestService.testTransaction2</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>-Weaving<br><br>\nAdvice를 핵심로직코드에 적용하는것을 weaving이라고 한다. 즉 공통코드를 핵심로직코드에 삽입하는것을 weaving이라고한다</p>\n<p>출처 <br></p>\n<ul>\n<li><a href=\"http://netframework.tistory.com/entry/LTW-CTW%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Transactional%EC%9D%98-%EC%82%AC%EC%9A%A9\" target=\"_blank\" rel=\"noopener\">Programming is Fun</a><br></li>\n<li><a href=\"https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html\" target=\"_blank\" rel=\"noopener\">Spring document</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>AspectJ를 사용해서 같은 클래스내에도 새로운 트랜잭션 만들기</h1>\n<br>\n스프링에서 트랜잭션을 처리하기 위해서는 일반적인 방법은 Proxy 클래스를 이용해 트랜잭션을 처리하는 것입니다. Spring AOP는 두 가지 Type의 Proxy를 지원하고 있습니다. 그 첫번째는 interface를 이용한 JDK Dynamic Proxy 기능을 이용하는 것이고, 두번째 방법은 CGLIB를 이용해서 서브 클래스를 생성하여 AOP를 구현하는 것입니다. 하지만 두 방법다 내부에서 @Transactional(propagation = Propagation.REQUIRES_NEW) 설정된 메소드를 호출하게 되면 그 전 트랜잭션과 동일한 트랜잭션으로 묶이게 됩니다. 먼저 아래의 소스를 보시겠습니다.\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testTransaction1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(TransactionSynchronizationManager.getCurrentTransactionName()); <span class=\"comment\">//com.example.demo.TestService.testTransaction1</span></span><br><span class=\"line\">\t\ttestTransaction2();</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testTransaction2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(TransactionSynchronizationManager.getCurrentTransactionName()); <span class=\"comment\">//com.example.demo.TestService.testTransaction1</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위와같이 2번째 메소드를 호출했음에도 불구하고 같은 트랜잭션으로 묶이게 됩니다. 이러한 문제를 해결하기 위해서는 스프링에서 일반적으로 사용하는 AOP를 사용하는게 아닌 AspectJ 라이브러리를 추가하여 사용해야 합니다. 이 AspectJ를 구현하는  방법은 2가지 방법이 있는데 Load-Time Weaver방식과 Compile-Time Weaver이 존재 합니다.</p>\n<h2>Load-Time Weaver</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">객체를 Load 할때, AspectJ에 의해서 wearving된 객체를 넘겨주는 방식입니다. 아래와 같은 방식으로 동작하게 됩니다.</span><br><span class=\"line\"></span><br><span class=\"line\">application context에 로드된 객체의 loading</span><br><span class=\"line\">aspectj weaver에 의한 객체 weaving (@Transaction annotation이 있는 class, method에 대한 transaction 처리가 된 객체로 변경)</span><br><span class=\"line\">객체의 이용</span><br><span class=\"line\">위 순서를 보시면 아실 수 있듯이, 이는 객체의 사용에 대해서 약간의 performance의 하락을 가지고 오게 됩니다. application context에서 객체를 load 할 때, aspectj weaver에서 하는 또 다른 일들을 지정하게 됩니다.</span><br></pre></td></tr></table></figure>\n<h2>Compile-Time Weaver</h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">객체를 Load 할 때, 위와 같은 문제가 있기 때문에, compile 시에 aspectj에서 간섭해서 필요한 객체에 weaving을 시켜서 class를 만들어내는 방식입니다. 이렇게 되면, application context의 load시에 다른 절차가 없기 때문에, performance의 하락도 없는 거의 완벽한 방법으로 구성이 가능합니다.</span><br><span class=\"line\"></span><br><span class=\"line\">주의사항</span><br><span class=\"line\">lombok과 같은 compile시에 간섭하는 여러 plugin들과의 매우 다채로운 충돌이 발생한다. 특히 lombok과는 같이 사용하지 못한다고 생각해도 과언이 아니다.</span><br></pre></td></tr></table></figure>\n<p>현재 사용하려는것은 Compile-Time Weaver의 AspectJ 주입입니다. AspectJ를 사용하기 위해서는 아래와 같이 메이븐을 추가해야합니다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- Spring AOP + AspectJ --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-aop<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjrt<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjweaver<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.codehaus.mojo<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectj-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">                  <span class=\"tag\">&lt;<span class=\"name\">goal</span>&gt;</span>compile<span class=\"tag\">&lt;/<span class=\"name\">goal</span>&gt;</span></span><br><span class=\"line\">                  <span class=\"comment\">&lt;!-- &lt;goal&gt;test-compile&lt;/goal&gt; --&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;/<span class=\"name\">goals</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">execution</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">executions</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">complianceLevel</span>&gt;</span>1.7<span class=\"tag\">&lt;/<span class=\"name\">complianceLevel</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">forceAjcCompile</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">forceAjcCompile</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">weaveDirectories</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">weaveDirectory</span>&gt;</span>$&#123;project.build.outputDirectory&#125;<span class=\"tag\">&lt;/<span class=\"name\">weaveDirectory</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">weaveDirectories</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">aspectLibraries</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;<span class=\"name\">aspectLibrary</span>&gt;</span></span><br><span class=\"line\">                  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-aspects<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">              <span class=\"tag\">&lt;/<span class=\"name\">aspectLibrary</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;/<span class=\"name\">aspectLibraries</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">configuration</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>만약 위의 플러그인을 사용하지 않는다면 compile시 weaving을 하지 않을것입니다. 그럼으로 필수로 플로그인을 넣어줘야합니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableTransactionManagement</span>(proxyTargetClass = <span class=\"keyword\">true</span>, mode = AdviceMode.ASPECTJ)</span><br><span class=\"line\"><span class=\"meta\">@EnableAspectJAutoProxy</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan</span>(&#123; <span class=\"string\">\"com.example\"</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppConfig</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그 다음 추가된 AspectJ를 사용하기위해서는 Spring Configuration을 설정해줘야 합니다. @EnableAspectJAutoProxy을 설정하여 Aspect을 적용 시킵니다. 물론 여기서 proxyTargetClass = ture로 설정함으로 CGLIB를 사용한다는 설정 또한 해줘야합니다. AOP 모드 또한 proxy모드에서 ASPECTJ로 변경해줍니다. 이렇게 설정하고 아까의 소스를 다시 실행시키면 트랜잭션이 분리된 모습을 확인할 수 있습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testTransaction1</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(TransactionSynchronizationManager.getCurrentTransactionName()); <span class=\"comment\">//com.example.demo.TestService.testTransaction1</span></span><br><span class=\"line\">\t\ttestTransaction2();</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testTransaction2</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(TransactionSynchronizationManager.getCurrentTransactionName()); <span class=\"comment\">//com.example.demo.TestService.testTransaction2</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>-Weaving<br><br>\nAdvice를 핵심로직코드에 적용하는것을 weaving이라고 한다. 즉 공통코드를 핵심로직코드에 삽입하는것을 weaving이라고한다</p>\n<p>출처 <br></p>\n<ul>\n<li><a href=\"http://netframework.tistory.com/entry/LTW-CTW%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Transactional%EC%9D%98-%EC%82%AC%EC%9A%A9\" target=\"_blank\" rel=\"noopener\">Programming is Fun</a><br></li>\n<li><a href=\"https://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/transaction.html\" target=\"_blank\" rel=\"noopener\">Spring document</a></li>\n</ul>\n"},{"title":"Class Diagram","catalog":true,"date":"2018-02-03T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n\n### Class Diagram이란?\nClass Diagram은 UML의 한종류이다. UML은 프로그램 설계를 표현하기 위해 사용하는, 주로 그림으로 된 표기법을 의미한다. 객체지향 언어와 밀접한 관려이 있기에 객체지향 모델링 언어라고도한다. 소프트웨어 시스템, 업무모델링, 시스템의 산출물을 규정하고 문서화하는 언어이고 이 UML종류중 하나가 클래스 다이어그램이다. 클래스 다이어그램은 클래스들간의 관계를 보여주는 구조 다이어그램이다.\n\n### 특징\n클래스 다이어그램은 클래스 내부의 정적인 내용이나 클래스 사이의 관계를 표기하는 다이어그램으로 시스템의 일부 또는 전체의 구조를 나타낼수 있다. 클래스다이어그램은 클래스들의 관계를 쉽게 보고, 의존관계를 쉽게 파악하게 해준다.\n\n### 클래스간의 관계\n아래 그림은 클래스간의 관계를 표현할때 사용하는 표기법이다.\n\n![](https://i.imgur.com/mtZAoJB.png)\n\n**종류**\n- Dependency (의존)\n- Generalization (일반화)\n- Realization (실체화)\n- Association (연관)\n  - Aggregation (집합 연관)\n  - Composition (복합 연관)\n\n위는 Class다이어그램에서 가장 많이사용되는 표기법이다.\n\n#### 1. Dependency Relationship (의존관계)\nDependency는 클래스 다이어그램에서 일반적으로 제일 많이 사용되는 관계로서, 어떤 클래스가 다른 클래스를 참조하는 것을 말한다. 아래는 카카오 노티를 보내기 위해서는 카카오 서비스를 이용해야 하기 때문에 카카오 서비스에 의존하고 있는 그림이다. 아래의 그림은 Intelij의 Class Diagram으로 보면 점선과 화살표로 표현되는 것을 볼 수 있다.\n![](https://i.imgur.com/Og7BM9s.png)\n참조의 형태는 메서드 내에서 대상 클래스의 객체 생성, 객체 사용, 메서드 호출, 객체 리턴, 매개변수로 해당 객체를 받는 것 등을 말하며 해당 객체의 참조를 계속 유지하지는 않는다.\n\n#### 2. Generalization (일반화 관계)\nGeneralization은 슈퍼(부모)클래스와 서브(자식)클래스간의 Inheritance(상속) 관계를 나타낸다. 여기서 Generalization이란 서브 클래스가 주체가 되어 서브 클래스를 슈퍼 클래스로 Generalize 하는 것을 말하고 반대의 개념은 슈퍼 클래스를 서브 클래스로 Specialize(구체화) 하는 것이다. 상속은 슈퍼 클래스의 필드 및 메서드를 사용하며 구체화 하여 필드 및 메서드를 추가 하거나 필요에 따라 메서드를 overriding(오버라이딩) 하여 재정의 한다. 또는 슈퍼 클래스가 추상 클래스인 경우에는 인터페이스의 메서드 구현과 같이 추상 메서드를 반드시 오버라이딩 하여 구현하여야 한다. 아래의 그림은 Intelij의 Class Diagram으로 보면 실선과 화살표로 표현 되는것을 볼 수있다.\n\n![](https://i.imgur.com/l3Uz7Ur.png)\n\n\n#### 3. Realization (실체화)\nRealization은 interface의 spec(명세, 정의)만 있는 메서드를 오버라이딩 하여 실제 기능으로 구현 하는 것1을 말한다. 아래의 그림은 Intelij의 Class Diagram으로 보면 실선과 화살표로 표현 되는것을 볼 수있다.\n![](https://i.imgur.com/9nrYUEx.png)\n\n#### 4. Association (연관), Directed Association(방향성 있는 연관)\n클래스 다이어그램에서의 Association은 보통 다른 객체의 참조를 가지는 멤버 필드를 의미한다. 아래 클래스 다이어그램은 두 가지 형태의 Association을 나타내고 있다.\n![](https://i.imgur.com/YGwa7w7.png)\n첫 번째 다이어그램은 일반적인 Association으로 단지 실선 하나로 클래스를 연결하여 표기하고 두 번째 다이어그램은 Directed Association으로 클래스를 실선으로 연결 후 실선 끝에 화살표를 추가한것이다. Association과 Directed Association의 차이는 화살표가 의미하는 navigability(방향성)인데 이것에 따라 참조 하는 쪽과 참조 당하는 쪽을 구분한다.\n\n#### 5. Aggregation (집합 연관)\nAggregation은 Shared Aggregation이라고도 하며 Composition(Composite Aggregation)과 함께 Association 관계를 조금 더 특수하게 나타낸 것으로 whole(전체)와 part(부분)의 관계를 나타낸다. Association은 집합이라는 의미를 내포하고 있지 않지만 Aggregation은 집합이라는 의미를 가지고 있다.\n![](https://i.imgur.com/5mfvp7k.png)\n표기법은 위와 같이 whole과 part를 실선으로 연결 후 whole쪽에 비어있는 다이아몬드를 표기한다. Part쪽에는 화살표를 명시하여도 되고 명시하지 않아도 된다. 두 번째 다이어그램은 User에서 Address 쪽으로 화살표가 있으므로 User가 Address를 참조하는 것을 의미한다. Navigability가 없는 Association은 명시되지 않은 것으로 User가 Address를 참조할 수도, Address가 User를 참조할 수도, 또는 둘 다일 수도 있는 것을 의미한다. 그런데 코드를 보면 위에서 보았던 Association의 코드와 똑같다. Association과 Aggregation은 집합이라는 개념적인 차이는 있지만 코드에서는 이 차이를 구분하기 힘들다. Intelij 에서는 그냥 연관들은 복합연관으로 다처리하는 것 같다. 이유는 잘모르겠다.\n\n\n#### 6. Composition (복합 연관)\nComposition(또는 Composite Aggregation)도 Aggregation과 비슷하게 whole(전체)와 part(부분)의 집합 관계를 나타내지만 개념적으로 Aggregation보다 더 강한 집합을 의미한다.\n![](https://i.imgur.com/OhRl7vZ.png)\nComposition은 Aggregation보다 강한 집합이라고 했다. 여기서 강한 집합이란 part가 whole에 종속적이어서 part가 whole의 소유입니다. 반면 Aggregation은 part가 whole에 대해 독립적이어서 whole이 part를 빌려 쓰는 것과 비슷합니다. 이러한 의미 때문에 Aggregation과는 다르게 명확하게 나타나는 점이 있다\n\n* 첫 번째, part를 가지는 whole 인스턴스가 part 인스턴스의 전체 수명을 책임진다.\n* 두 번째, part에 해당하는 인스턴스는 공유 될 수 없다.\n\n### 결론\n애플리케이션 규모가 커지면 커질수록 클래스 다이어그램을 이용해서 관리를 해야겠다는 생각이 점점 든다. Intelij Class Diagram 정도로만 관리를 해도 클래스 다이어그램은 클래스들의 관계를 쉽게 보고, 의존관계를 쉽게 파악하게 관리할 수 있을 것 같다. 그런데 Intelij에서는 Association과 관련하여 그냥 복합 연관으로 만 관리하는 것 같은데, 왜 그런지에 대해서는 좀 더 알아봐야 할 것 같다.\n\n참고 사이트\n\n* [킈킈킈!!](http://ysmanse.tistory.com/31)\n* [Nextree](http://www.nextree.co.kr/p6753/)\n* [_jbee](http://asfirstalways.tistory.com/95)","source":"_posts/2018-02-04-Class-Diagram.md","raw":"---\ntitle: Class Diagram\ncatalog: true\ndate: 2018-02-04\nsubtitle:\nheader-img:\ntags:\n- Java\n- ETC\n---\n\n\n### Class Diagram이란?\nClass Diagram은 UML의 한종류이다. UML은 프로그램 설계를 표현하기 위해 사용하는, 주로 그림으로 된 표기법을 의미한다. 객체지향 언어와 밀접한 관려이 있기에 객체지향 모델링 언어라고도한다. 소프트웨어 시스템, 업무모델링, 시스템의 산출물을 규정하고 문서화하는 언어이고 이 UML종류중 하나가 클래스 다이어그램이다. 클래스 다이어그램은 클래스들간의 관계를 보여주는 구조 다이어그램이다.\n\n### 특징\n클래스 다이어그램은 클래스 내부의 정적인 내용이나 클래스 사이의 관계를 표기하는 다이어그램으로 시스템의 일부 또는 전체의 구조를 나타낼수 있다. 클래스다이어그램은 클래스들의 관계를 쉽게 보고, 의존관계를 쉽게 파악하게 해준다.\n\n### 클래스간의 관계\n아래 그림은 클래스간의 관계를 표현할때 사용하는 표기법이다.\n\n![](https://i.imgur.com/mtZAoJB.png)\n\n**종류**\n- Dependency (의존)\n- Generalization (일반화)\n- Realization (실체화)\n- Association (연관)\n  - Aggregation (집합 연관)\n  - Composition (복합 연관)\n\n위는 Class다이어그램에서 가장 많이사용되는 표기법이다.\n\n#### 1. Dependency Relationship (의존관계)\nDependency는 클래스 다이어그램에서 일반적으로 제일 많이 사용되는 관계로서, 어떤 클래스가 다른 클래스를 참조하는 것을 말한다. 아래는 카카오 노티를 보내기 위해서는 카카오 서비스를 이용해야 하기 때문에 카카오 서비스에 의존하고 있는 그림이다. 아래의 그림은 Intelij의 Class Diagram으로 보면 점선과 화살표로 표현되는 것을 볼 수 있다.\n![](https://i.imgur.com/Og7BM9s.png)\n참조의 형태는 메서드 내에서 대상 클래스의 객체 생성, 객체 사용, 메서드 호출, 객체 리턴, 매개변수로 해당 객체를 받는 것 등을 말하며 해당 객체의 참조를 계속 유지하지는 않는다.\n\n#### 2. Generalization (일반화 관계)\nGeneralization은 슈퍼(부모)클래스와 서브(자식)클래스간의 Inheritance(상속) 관계를 나타낸다. 여기서 Generalization이란 서브 클래스가 주체가 되어 서브 클래스를 슈퍼 클래스로 Generalize 하는 것을 말하고 반대의 개념은 슈퍼 클래스를 서브 클래스로 Specialize(구체화) 하는 것이다. 상속은 슈퍼 클래스의 필드 및 메서드를 사용하며 구체화 하여 필드 및 메서드를 추가 하거나 필요에 따라 메서드를 overriding(오버라이딩) 하여 재정의 한다. 또는 슈퍼 클래스가 추상 클래스인 경우에는 인터페이스의 메서드 구현과 같이 추상 메서드를 반드시 오버라이딩 하여 구현하여야 한다. 아래의 그림은 Intelij의 Class Diagram으로 보면 실선과 화살표로 표현 되는것을 볼 수있다.\n\n![](https://i.imgur.com/l3Uz7Ur.png)\n\n\n#### 3. Realization (실체화)\nRealization은 interface의 spec(명세, 정의)만 있는 메서드를 오버라이딩 하여 실제 기능으로 구현 하는 것1을 말한다. 아래의 그림은 Intelij의 Class Diagram으로 보면 실선과 화살표로 표현 되는것을 볼 수있다.\n![](https://i.imgur.com/9nrYUEx.png)\n\n#### 4. Association (연관), Directed Association(방향성 있는 연관)\n클래스 다이어그램에서의 Association은 보통 다른 객체의 참조를 가지는 멤버 필드를 의미한다. 아래 클래스 다이어그램은 두 가지 형태의 Association을 나타내고 있다.\n![](https://i.imgur.com/YGwa7w7.png)\n첫 번째 다이어그램은 일반적인 Association으로 단지 실선 하나로 클래스를 연결하여 표기하고 두 번째 다이어그램은 Directed Association으로 클래스를 실선으로 연결 후 실선 끝에 화살표를 추가한것이다. Association과 Directed Association의 차이는 화살표가 의미하는 navigability(방향성)인데 이것에 따라 참조 하는 쪽과 참조 당하는 쪽을 구분한다.\n\n#### 5. Aggregation (집합 연관)\nAggregation은 Shared Aggregation이라고도 하며 Composition(Composite Aggregation)과 함께 Association 관계를 조금 더 특수하게 나타낸 것으로 whole(전체)와 part(부분)의 관계를 나타낸다. Association은 집합이라는 의미를 내포하고 있지 않지만 Aggregation은 집합이라는 의미를 가지고 있다.\n![](https://i.imgur.com/5mfvp7k.png)\n표기법은 위와 같이 whole과 part를 실선으로 연결 후 whole쪽에 비어있는 다이아몬드를 표기한다. Part쪽에는 화살표를 명시하여도 되고 명시하지 않아도 된다. 두 번째 다이어그램은 User에서 Address 쪽으로 화살표가 있으므로 User가 Address를 참조하는 것을 의미한다. Navigability가 없는 Association은 명시되지 않은 것으로 User가 Address를 참조할 수도, Address가 User를 참조할 수도, 또는 둘 다일 수도 있는 것을 의미한다. 그런데 코드를 보면 위에서 보았던 Association의 코드와 똑같다. Association과 Aggregation은 집합이라는 개념적인 차이는 있지만 코드에서는 이 차이를 구분하기 힘들다. Intelij 에서는 그냥 연관들은 복합연관으로 다처리하는 것 같다. 이유는 잘모르겠다.\n\n\n#### 6. Composition (복합 연관)\nComposition(또는 Composite Aggregation)도 Aggregation과 비슷하게 whole(전체)와 part(부분)의 집합 관계를 나타내지만 개념적으로 Aggregation보다 더 강한 집합을 의미한다.\n![](https://i.imgur.com/OhRl7vZ.png)\nComposition은 Aggregation보다 강한 집합이라고 했다. 여기서 강한 집합이란 part가 whole에 종속적이어서 part가 whole의 소유입니다. 반면 Aggregation은 part가 whole에 대해 독립적이어서 whole이 part를 빌려 쓰는 것과 비슷합니다. 이러한 의미 때문에 Aggregation과는 다르게 명확하게 나타나는 점이 있다\n\n* 첫 번째, part를 가지는 whole 인스턴스가 part 인스턴스의 전체 수명을 책임진다.\n* 두 번째, part에 해당하는 인스턴스는 공유 될 수 없다.\n\n### 결론\n애플리케이션 규모가 커지면 커질수록 클래스 다이어그램을 이용해서 관리를 해야겠다는 생각이 점점 든다. Intelij Class Diagram 정도로만 관리를 해도 클래스 다이어그램은 클래스들의 관계를 쉽게 보고, 의존관계를 쉽게 파악하게 관리할 수 있을 것 같다. 그런데 Intelij에서는 Association과 관련하여 그냥 복합 연관으로 만 관리하는 것 같은데, 왜 그런지에 대해서는 좀 더 알아봐야 할 것 같다.\n\n참고 사이트\n\n* [킈킈킈!!](http://ysmanse.tistory.com/31)\n* [Nextree](http://www.nextree.co.kr/p6753/)\n* [_jbee](http://asfirstalways.tistory.com/95)","slug":"2018-02-04-Class-Diagram","published":1,"updated":"2018-06-20T16:05:18.334Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27bk000rjjpezx4gpvse","content":"<h3><span id=\"class-diagram이란\">Class Diagram이란?</span></h3>\n<p>Class Diagram은 UML의 한종류이다. UML은 프로그램 설계를 표현하기 위해 사용하는, 주로 그림으로 된 표기법을 의미한다. 객체지향 언어와 밀접한 관려이 있기에 객체지향 모델링 언어라고도한다. 소프트웨어 시스템, 업무모델링, 시스템의 산출물을 규정하고 문서화하는 언어이고 이 UML종류중 하나가 클래스 다이어그램이다. 클래스 다이어그램은 클래스들간의 관계를 보여주는 구조 다이어그램이다.</p>\n<h3><span id=\"특징\">특징</span></h3>\n<p>클래스 다이어그램은 클래스 내부의 정적인 내용이나 클래스 사이의 관계를 표기하는 다이어그램으로 시스템의 일부 또는 전체의 구조를 나타낼수 있다. 클래스다이어그램은 클래스들의 관계를 쉽게 보고, 의존관계를 쉽게 파악하게 해준다.</p>\n<h3><span id=\"클래스간의-관계\">클래스간의 관계</span></h3>\n<p>아래 그림은 클래스간의 관계를 표현할때 사용하는 표기법이다.</p>\n<p><img src=\"https://i.imgur.com/mtZAoJB.png\" alt=\"\"></p>\n<p><strong>종류</strong></p>\n<ul>\n<li>Dependency (의존)</li>\n<li>Generalization (일반화)</li>\n<li>Realization (실체화)</li>\n<li>Association (연관)\n<ul>\n<li>Aggregation (집합 연관)</li>\n<li>Composition (복합 연관)</li>\n</ul>\n</li>\n</ul>\n<p>위는 Class다이어그램에서 가장 많이사용되는 표기법이다.</p>\n<h4><span id=\"1-dependency-relationship-의존관계\">1. Dependency Relationship (의존관계)</span></h4>\n<p>Dependency는 클래스 다이어그램에서 일반적으로 제일 많이 사용되는 관계로서, 어떤 클래스가 다른 클래스를 참조하는 것을 말한다. 아래는 카카오 노티를 보내기 위해서는 카카오 서비스를 이용해야 하기 때문에 카카오 서비스에 의존하고 있는 그림이다. 아래의 그림은 Intelij의 Class Diagram으로 보면 점선과 화살표로 표현되는 것을 볼 수 있다.<br>\n<img src=\"https://i.imgur.com/Og7BM9s.png\" alt=\"\"><br>\n참조의 형태는 메서드 내에서 대상 클래스의 객체 생성, 객체 사용, 메서드 호출, 객체 리턴, 매개변수로 해당 객체를 받는 것 등을 말하며 해당 객체의 참조를 계속 유지하지는 않는다.</p>\n<h4><span id=\"2-generalization-일반화-관계\">2. Generalization (일반화 관계)</span></h4>\n<p>Generalization은 슈퍼(부모)클래스와 서브(자식)클래스간의 Inheritance(상속) 관계를 나타낸다. 여기서 Generalization이란 서브 클래스가 주체가 되어 서브 클래스를 슈퍼 클래스로 Generalize 하는 것을 말하고 반대의 개념은 슈퍼 클래스를 서브 클래스로 Specialize(구체화) 하는 것이다. 상속은 슈퍼 클래스의 필드 및 메서드를 사용하며 구체화 하여 필드 및 메서드를 추가 하거나 필요에 따라 메서드를 overriding(오버라이딩) 하여 재정의 한다. 또는 슈퍼 클래스가 추상 클래스인 경우에는 인터페이스의 메서드 구현과 같이 추상 메서드를 반드시 오버라이딩 하여 구현하여야 한다. 아래의 그림은 Intelij의 Class Diagram으로 보면 실선과 화살표로 표현 되는것을 볼 수있다.</p>\n<p><img src=\"https://i.imgur.com/l3Uz7Ur.png\" alt=\"\"></p>\n<h4><span id=\"3-realization-실체화\">3. Realization (실체화)</span></h4>\n<p>Realization은 interface의 spec(명세, 정의)만 있는 메서드를 오버라이딩 하여 실제 기능으로 구현 하는 것1을 말한다. 아래의 그림은 Intelij의 Class Diagram으로 보면 실선과 화살표로 표현 되는것을 볼 수있다.<br>\n<img src=\"https://i.imgur.com/9nrYUEx.png\" alt=\"\"></p>\n<h4><span id=\"4-association-연관-directed-association방향성-있는-연관\">4. Association (연관), Directed Association(방향성 있는 연관)</span></h4>\n<p>클래스 다이어그램에서의 Association은 보통 다른 객체의 참조를 가지는 멤버 필드를 의미한다. 아래 클래스 다이어그램은 두 가지 형태의 Association을 나타내고 있다.<br>\n<img src=\"https://i.imgur.com/YGwa7w7.png\" alt=\"\"><br>\n첫 번째 다이어그램은 일반적인 Association으로 단지 실선 하나로 클래스를 연결하여 표기하고 두 번째 다이어그램은 Directed Association으로 클래스를 실선으로 연결 후 실선 끝에 화살표를 추가한것이다. Association과 Directed Association의 차이는 화살표가 의미하는 navigability(방향성)인데 이것에 따라 참조 하는 쪽과 참조 당하는 쪽을 구분한다.</p>\n<h4><span id=\"5-aggregation-집합-연관\">5. Aggregation (집합 연관)</span></h4>\n<p>Aggregation은 Shared Aggregation이라고도 하며 Composition(Composite Aggregation)과 함께 Association 관계를 조금 더 특수하게 나타낸 것으로 whole(전체)와 part(부분)의 관계를 나타낸다. Association은 집합이라는 의미를 내포하고 있지 않지만 Aggregation은 집합이라는 의미를 가지고 있다.<br>\n<img src=\"https://i.imgur.com/5mfvp7k.png\" alt=\"\"><br>\n표기법은 위와 같이 whole과 part를 실선으로 연결 후 whole쪽에 비어있는 다이아몬드를 표기한다. Part쪽에는 화살표를 명시하여도 되고 명시하지 않아도 된다. 두 번째 다이어그램은 User에서 Address 쪽으로 화살표가 있으므로 User가 Address를 참조하는 것을 의미한다. Navigability가 없는 Association은 명시되지 않은 것으로 User가 Address를 참조할 수도, Address가 User를 참조할 수도, 또는 둘 다일 수도 있는 것을 의미한다. 그런데 코드를 보면 위에서 보았던 Association의 코드와 똑같다. Association과 Aggregation은 집합이라는 개념적인 차이는 있지만 코드에서는 이 차이를 구분하기 힘들다. Intelij 에서는 그냥 연관들은 복합연관으로 다처리하는 것 같다. 이유는 잘모르겠다.</p>\n<h4><span id=\"6-composition-복합-연관\">6. Composition (복합 연관)</span></h4>\n<p>Composition(또는 Composite Aggregation)도 Aggregation과 비슷하게 whole(전체)와 part(부분)의 집합 관계를 나타내지만 개념적으로 Aggregation보다 더 강한 집합을 의미한다.<br>\n<img src=\"https://i.imgur.com/OhRl7vZ.png\" alt=\"\"><br>\nComposition은 Aggregation보다 강한 집합이라고 했다. 여기서 강한 집합이란 part가 whole에 종속적이어서 part가 whole의 소유입니다. 반면 Aggregation은 part가 whole에 대해 독립적이어서 whole이 part를 빌려 쓰는 것과 비슷합니다. 이러한 의미 때문에 Aggregation과는 다르게 명확하게 나타나는 점이 있다</p>\n<ul>\n<li>첫 번째, part를 가지는 whole 인스턴스가 part 인스턴스의 전체 수명을 책임진다.</li>\n<li>두 번째, part에 해당하는 인스턴스는 공유 될 수 없다.</li>\n</ul>\n<h3><span id=\"결론\">결론</span></h3>\n<p>애플리케이션 규모가 커지면 커질수록 클래스 다이어그램을 이용해서 관리를 해야겠다는 생각이 점점 든다. Intelij Class Diagram 정도로만 관리를 해도 클래스 다이어그램은 클래스들의 관계를 쉽게 보고, 의존관계를 쉽게 파악하게 관리할 수 있을 것 같다. 그런데 Intelij에서는 Association과 관련하여 그냥 복합 연관으로 만 관리하는 것 같은데, 왜 그런지에 대해서는 좀 더 알아봐야 할 것 같다.</p>\n<p>참고 사이트</p>\n<ul>\n<li><a href=\"http://ysmanse.tistory.com/31\" target=\"_blank\" rel=\"noopener\">킈킈킈!!</a></li>\n<li><a href=\"http://www.nextree.co.kr/p6753/\" target=\"_blank\" rel=\"noopener\">Nextree</a></li>\n<li><a href=\"http://asfirstalways.tistory.com/95\" target=\"_blank\" rel=\"noopener\">_jbee</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3>Class Diagram이란?</h3>\n<p>Class Diagram은 UML의 한종류이다. UML은 프로그램 설계를 표현하기 위해 사용하는, 주로 그림으로 된 표기법을 의미한다. 객체지향 언어와 밀접한 관려이 있기에 객체지향 모델링 언어라고도한다. 소프트웨어 시스템, 업무모델링, 시스템의 산출물을 규정하고 문서화하는 언어이고 이 UML종류중 하나가 클래스 다이어그램이다. 클래스 다이어그램은 클래스들간의 관계를 보여주는 구조 다이어그램이다.</p>\n<h3>특징</h3>\n<p>클래스 다이어그램은 클래스 내부의 정적인 내용이나 클래스 사이의 관계를 표기하는 다이어그램으로 시스템의 일부 또는 전체의 구조를 나타낼수 있다. 클래스다이어그램은 클래스들의 관계를 쉽게 보고, 의존관계를 쉽게 파악하게 해준다.</p>\n<h3>클래스간의 관계</h3>\n<p>아래 그림은 클래스간의 관계를 표현할때 사용하는 표기법이다.</p>\n<p><img src=\"https://i.imgur.com/mtZAoJB.png\" alt=\"\"></p>\n<p><strong>종류</strong></p>\n<ul>\n<li>Dependency (의존)</li>\n<li>Generalization (일반화)</li>\n<li>Realization (실체화)</li>\n<li>Association (연관)\n<ul>\n<li>Aggregation (집합 연관)</li>\n<li>Composition (복합 연관)</li>\n</ul>\n</li>\n</ul>\n<p>위는 Class다이어그램에서 가장 많이사용되는 표기법이다.</p>\n<h4>1. Dependency Relationship (의존관계)</h4>\n<p>Dependency는 클래스 다이어그램에서 일반적으로 제일 많이 사용되는 관계로서, 어떤 클래스가 다른 클래스를 참조하는 것을 말한다. 아래는 카카오 노티를 보내기 위해서는 카카오 서비스를 이용해야 하기 때문에 카카오 서비스에 의존하고 있는 그림이다. 아래의 그림은 Intelij의 Class Diagram으로 보면 점선과 화살표로 표현되는 것을 볼 수 있다.<br>\n<img src=\"https://i.imgur.com/Og7BM9s.png\" alt=\"\"><br>\n참조의 형태는 메서드 내에서 대상 클래스의 객체 생성, 객체 사용, 메서드 호출, 객체 리턴, 매개변수로 해당 객체를 받는 것 등을 말하며 해당 객체의 참조를 계속 유지하지는 않는다.</p>\n<h4>2. Generalization (일반화 관계)</h4>\n<p>Generalization은 슈퍼(부모)클래스와 서브(자식)클래스간의 Inheritance(상속) 관계를 나타낸다. 여기서 Generalization이란 서브 클래스가 주체가 되어 서브 클래스를 슈퍼 클래스로 Generalize 하는 것을 말하고 반대의 개념은 슈퍼 클래스를 서브 클래스로 Specialize(구체화) 하는 것이다. 상속은 슈퍼 클래스의 필드 및 메서드를 사용하며 구체화 하여 필드 및 메서드를 추가 하거나 필요에 따라 메서드를 overriding(오버라이딩) 하여 재정의 한다. 또는 슈퍼 클래스가 추상 클래스인 경우에는 인터페이스의 메서드 구현과 같이 추상 메서드를 반드시 오버라이딩 하여 구현하여야 한다. 아래의 그림은 Intelij의 Class Diagram으로 보면 실선과 화살표로 표현 되는것을 볼 수있다.</p>\n<p><img src=\"https://i.imgur.com/l3Uz7Ur.png\" alt=\"\"></p>\n<h4>3. Realization (실체화)</h4>\n<p>Realization은 interface의 spec(명세, 정의)만 있는 메서드를 오버라이딩 하여 실제 기능으로 구현 하는 것1을 말한다. 아래의 그림은 Intelij의 Class Diagram으로 보면 실선과 화살표로 표현 되는것을 볼 수있다.<br>\n<img src=\"https://i.imgur.com/9nrYUEx.png\" alt=\"\"></p>\n<h4>4. Association (연관), Directed Association(방향성 있는 연관)</h4>\n<p>클래스 다이어그램에서의 Association은 보통 다른 객체의 참조를 가지는 멤버 필드를 의미한다. 아래 클래스 다이어그램은 두 가지 형태의 Association을 나타내고 있다.<br>\n<img src=\"https://i.imgur.com/YGwa7w7.png\" alt=\"\"><br>\n첫 번째 다이어그램은 일반적인 Association으로 단지 실선 하나로 클래스를 연결하여 표기하고 두 번째 다이어그램은 Directed Association으로 클래스를 실선으로 연결 후 실선 끝에 화살표를 추가한것이다. Association과 Directed Association의 차이는 화살표가 의미하는 navigability(방향성)인데 이것에 따라 참조 하는 쪽과 참조 당하는 쪽을 구분한다.</p>\n<h4>5. Aggregation (집합 연관)</h4>\n<p>Aggregation은 Shared Aggregation이라고도 하며 Composition(Composite Aggregation)과 함께 Association 관계를 조금 더 특수하게 나타낸 것으로 whole(전체)와 part(부분)의 관계를 나타낸다. Association은 집합이라는 의미를 내포하고 있지 않지만 Aggregation은 집합이라는 의미를 가지고 있다.<br>\n<img src=\"https://i.imgur.com/5mfvp7k.png\" alt=\"\"><br>\n표기법은 위와 같이 whole과 part를 실선으로 연결 후 whole쪽에 비어있는 다이아몬드를 표기한다. Part쪽에는 화살표를 명시하여도 되고 명시하지 않아도 된다. 두 번째 다이어그램은 User에서 Address 쪽으로 화살표가 있으므로 User가 Address를 참조하는 것을 의미한다. Navigability가 없는 Association은 명시되지 않은 것으로 User가 Address를 참조할 수도, Address가 User를 참조할 수도, 또는 둘 다일 수도 있는 것을 의미한다. 그런데 코드를 보면 위에서 보았던 Association의 코드와 똑같다. Association과 Aggregation은 집합이라는 개념적인 차이는 있지만 코드에서는 이 차이를 구분하기 힘들다. Intelij 에서는 그냥 연관들은 복합연관으로 다처리하는 것 같다. 이유는 잘모르겠다.</p>\n<h4>6. Composition (복합 연관)</h4>\n<p>Composition(또는 Composite Aggregation)도 Aggregation과 비슷하게 whole(전체)와 part(부분)의 집합 관계를 나타내지만 개념적으로 Aggregation보다 더 강한 집합을 의미한다.<br>\n<img src=\"https://i.imgur.com/OhRl7vZ.png\" alt=\"\"><br>\nComposition은 Aggregation보다 강한 집합이라고 했다. 여기서 강한 집합이란 part가 whole에 종속적이어서 part가 whole의 소유입니다. 반면 Aggregation은 part가 whole에 대해 독립적이어서 whole이 part를 빌려 쓰는 것과 비슷합니다. 이러한 의미 때문에 Aggregation과는 다르게 명확하게 나타나는 점이 있다</p>\n<ul>\n<li>첫 번째, part를 가지는 whole 인스턴스가 part 인스턴스의 전체 수명을 책임진다.</li>\n<li>두 번째, part에 해당하는 인스턴스는 공유 될 수 없다.</li>\n</ul>\n<h3>결론</h3>\n<p>애플리케이션 규모가 커지면 커질수록 클래스 다이어그램을 이용해서 관리를 해야겠다는 생각이 점점 든다. Intelij Class Diagram 정도로만 관리를 해도 클래스 다이어그램은 클래스들의 관계를 쉽게 보고, 의존관계를 쉽게 파악하게 관리할 수 있을 것 같다. 그런데 Intelij에서는 Association과 관련하여 그냥 복합 연관으로 만 관리하는 것 같은데, 왜 그런지에 대해서는 좀 더 알아봐야 할 것 같다.</p>\n<p>참고 사이트</p>\n<ul>\n<li><a href=\"http://ysmanse.tistory.com/31\" target=\"_blank\" rel=\"noopener\">킈킈킈!!</a></li>\n<li><a href=\"http://www.nextree.co.kr/p6753/\" target=\"_blank\" rel=\"noopener\">Nextree</a></li>\n<li><a href=\"http://asfirstalways.tistory.com/95\" target=\"_blank\" rel=\"noopener\">_jbee</a></li>\n</ul>\n"},{"title":"HMAC란","catalog":true,"date":"2018-05-27T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n## HMAC\n### HMAC란?\n해싱 기법을 적용하여 메시지의 위변조를 방지하는 기법을 HMAC (Hash-based Message Authentication) 이라고 한다. 좀더 상세히 설명하면 Sender와 Recipient는 서로 API를 주고 받아야한다. 그럴때 이메시지가 Sender 가보낸 메시지인지 인증을 해야한다. 뿐만 아니라 이 메시지가 변조가 되었는지 확인을 해야한다. 이러한 문제점을 해결하는것이 HMAC이다. Sender는 메시지를 보내기전에 공유된 Secret키와 메시지를 기반으로 해쉬값을 만든다. 그리고 이해쉬값을 헤더값에 포함하여 전달해준다. 그리고 Recipient는 그 받은 메시지를 기반으로 또 자신이 가지고있는 공유된 Secret를 이용하여 해쉬를 만들어내고 헤더값에 넘어온 키를 대조한다. 이것이 일치하면 Sender에대한 인증, 메시지의 무결성을 확인할 수 있다.\n\n만약 중간에 해커가 메시지를 가로챈다고 하더라도 시크릿키를 알수 없기때문에 메시지를 변조할 수 없다. 그리고 보통 메시지 Body값에는 Timestamp를 넣는것이 일반적이다. 이렇게하면 서버에서 호출시간을 알 수 있고 이렇게 함으로써 좀더 보안성을 높여 사용할 수 있다. 아래는 HMAC의 예제 그림이다.\n\n![](https://i.imgur.com/a5IsX06.jpg)\n\n### HMAC Example(Java)\n다음은 자바 소스를 이용한 예제이다. 다음은 SHA-256알고리즘을 이용하여 해쉬를 만든것이다. 그안에서 인코딩방법*  16진수방법과 base64 방법이 존재한다.\n\n```java\npublic class HMACAuthentication {\n\n    public void verifySignature(String secret, String payload, String signature) {\n        try {\n            final String resultHex = getHexHash(secret, payload);\n            if (!resultHex.equals(signature))\n                throw new RuntimeException(\"HMAC does not match.\");\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n    }\n\n    private String getHexHash(String secret, String payload) throws NoSuchAlgorithmException, InvalidKeyException {\n        final String hmacSHA256 = \"HmacSHA256\";\n        final Mac hasher = Mac.getInstance(hmacSHA256);\n        hasher.init(new SecretKeySpec(secret.getBytes(), hmacSHA256));\n        final byte[] hash = hasher.doFinal(payload.getBytes());\n\n//            String resultBase = DatatypeConverter.printBase64Binary(hash); // to base64\n        return DatatypeConverter.printHexBinary(hash).toLowerCase(); // to hex\n    }\n\n\n}\n```\n\n[예제 소스](https://github.com/minwan1/blog-example/tree/master/HMAC)\n\n참고\n* [DOG발](http://sunphiz.me/wp/archives/tag/hmac)\n","source":"_posts/2018-05-28-HMAC.md","raw":"---\ntitle: HMAC란\ncatalog: true\ndate: 2018-05-28\nsubtitle:\nheader-img:\ntags:\n- Java\n- ETC\n\n\n---\n\n## HMAC\n### HMAC란?\n해싱 기법을 적용하여 메시지의 위변조를 방지하는 기법을 HMAC (Hash-based Message Authentication) 이라고 한다. 좀더 상세히 설명하면 Sender와 Recipient는 서로 API를 주고 받아야한다. 그럴때 이메시지가 Sender 가보낸 메시지인지 인증을 해야한다. 뿐만 아니라 이 메시지가 변조가 되었는지 확인을 해야한다. 이러한 문제점을 해결하는것이 HMAC이다. Sender는 메시지를 보내기전에 공유된 Secret키와 메시지를 기반으로 해쉬값을 만든다. 그리고 이해쉬값을 헤더값에 포함하여 전달해준다. 그리고 Recipient는 그 받은 메시지를 기반으로 또 자신이 가지고있는 공유된 Secret를 이용하여 해쉬를 만들어내고 헤더값에 넘어온 키를 대조한다. 이것이 일치하면 Sender에대한 인증, 메시지의 무결성을 확인할 수 있다.\n\n만약 중간에 해커가 메시지를 가로챈다고 하더라도 시크릿키를 알수 없기때문에 메시지를 변조할 수 없다. 그리고 보통 메시지 Body값에는 Timestamp를 넣는것이 일반적이다. 이렇게하면 서버에서 호출시간을 알 수 있고 이렇게 함으로써 좀더 보안성을 높여 사용할 수 있다. 아래는 HMAC의 예제 그림이다.\n\n![](https://i.imgur.com/a5IsX06.jpg)\n\n### HMAC Example(Java)\n다음은 자바 소스를 이용한 예제이다. 다음은 SHA-256알고리즘을 이용하여 해쉬를 만든것이다. 그안에서 인코딩방법*  16진수방법과 base64 방법이 존재한다.\n\n```java\npublic class HMACAuthentication {\n\n    public void verifySignature(String secret, String payload, String signature) {\n        try {\n            final String resultHex = getHexHash(secret, payload);\n            if (!resultHex.equals(signature))\n                throw new RuntimeException(\"HMAC does not match.\");\n        } catch (Exception e) {\n          throw new RuntimeException(e);\n        }\n    }\n\n    private String getHexHash(String secret, String payload) throws NoSuchAlgorithmException, InvalidKeyException {\n        final String hmacSHA256 = \"HmacSHA256\";\n        final Mac hasher = Mac.getInstance(hmacSHA256);\n        hasher.init(new SecretKeySpec(secret.getBytes(), hmacSHA256));\n        final byte[] hash = hasher.doFinal(payload.getBytes());\n\n//            String resultBase = DatatypeConverter.printBase64Binary(hash); // to base64\n        return DatatypeConverter.printHexBinary(hash).toLowerCase(); // to hex\n    }\n\n\n}\n```\n\n[예제 소스](https://github.com/minwan1/blog-example/tree/master/HMAC)\n\n참고\n* [DOG발](http://sunphiz.me/wp/archives/tag/hmac)\n","slug":"2018-05-28-HMAC","published":1,"updated":"2018-06-20T16:05:18.205Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27bn000ujjpeewqean6b","content":"<h2><span id=\"hmac\">HMAC</span></h2>\n<h3><span id=\"hmac란\">HMAC란?</span></h3>\n<p>해싱 기법을 적용하여 메시지의 위변조를 방지하는 기법을 HMAC (Hash-based Message Authentication) 이라고 한다. 좀더 상세히 설명하면 Sender와 Recipient는 서로 API를 주고 받아야한다. 그럴때 이메시지가 Sender 가보낸 메시지인지 인증을 해야한다. 뿐만 아니라 이 메시지가 변조가 되었는지 확인을 해야한다. 이러한 문제점을 해결하는것이 HMAC이다. Sender는 메시지를 보내기전에 공유된 Secret키와 메시지를 기반으로 해쉬값을 만든다. 그리고 이해쉬값을 헤더값에 포함하여 전달해준다. 그리고 Recipient는 그 받은 메시지를 기반으로 또 자신이 가지고있는 공유된 Secret를 이용하여 해쉬를 만들어내고 헤더값에 넘어온 키를 대조한다. 이것이 일치하면 Sender에대한 인증, 메시지의 무결성을 확인할 수 있다.</p>\n<p>만약 중간에 해커가 메시지를 가로챈다고 하더라도 시크릿키를 알수 없기때문에 메시지를 변조할 수 없다. 그리고 보통 메시지 Body값에는 Timestamp를 넣는것이 일반적이다. 이렇게하면 서버에서 호출시간을 알 수 있고 이렇게 함으로써 좀더 보안성을 높여 사용할 수 있다. 아래는 HMAC의 예제 그림이다.</p>\n<p><img src=\"https://i.imgur.com/a5IsX06.jpg\" alt=\"\"></p>\n<h3><span id=\"hmac-examplejava\">HMAC Example(Java)</span></h3>\n<p>다음은 자바 소스를 이용한 예제이다. 다음은 SHA-256알고리즘을 이용하여 해쉬를 만든것이다. 그안에서 인코딩방법*  16진수방법과 base64 방법이 존재한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HMACAuthentication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">verifySignature</span><span class=\"params\">(String secret, String payload, String signature)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> String resultHex = getHexHash(secret, payload);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!resultHex.equals(signature))</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"HMAC does not match.\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getHexHash</span><span class=\"params\">(String secret, String payload)</span> <span class=\"keyword\">throws</span> NoSuchAlgorithmException, InvalidKeyException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> String hmacSHA256 = <span class=\"string\">\"HmacSHA256\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Mac hasher = Mac.getInstance(hmacSHA256);</span><br><span class=\"line\">        hasher.init(<span class=\"keyword\">new</span> SecretKeySpec(secret.getBytes(), hmacSHA256));</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] hash = hasher.doFinal(payload.getBytes());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//            String resultBase = DatatypeConverter.printBase64Binary(hash); // to base64</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> DatatypeConverter.printHexBinary(hash).toLowerCase(); <span class=\"comment\">// to hex</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/minwan1/blog-example/tree/master/HMAC\" target=\"_blank\" rel=\"noopener\">예제 소스</a></p>\n<p>참고</p>\n<ul>\n<li><a href=\"http://sunphiz.me/wp/archives/tag/hmac\" target=\"_blank\" rel=\"noopener\">DOG발</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>HMAC</h2>\n<h3>HMAC란?</h3>\n<p>해싱 기법을 적용하여 메시지의 위변조를 방지하는 기법을 HMAC (Hash-based Message Authentication) 이라고 한다. 좀더 상세히 설명하면 Sender와 Recipient는 서로 API를 주고 받아야한다. 그럴때 이메시지가 Sender 가보낸 메시지인지 인증을 해야한다. 뿐만 아니라 이 메시지가 변조가 되었는지 확인을 해야한다. 이러한 문제점을 해결하는것이 HMAC이다. Sender는 메시지를 보내기전에 공유된 Secret키와 메시지를 기반으로 해쉬값을 만든다. 그리고 이해쉬값을 헤더값에 포함하여 전달해준다. 그리고 Recipient는 그 받은 메시지를 기반으로 또 자신이 가지고있는 공유된 Secret를 이용하여 해쉬를 만들어내고 헤더값에 넘어온 키를 대조한다. 이것이 일치하면 Sender에대한 인증, 메시지의 무결성을 확인할 수 있다.</p>\n<p>만약 중간에 해커가 메시지를 가로챈다고 하더라도 시크릿키를 알수 없기때문에 메시지를 변조할 수 없다. 그리고 보통 메시지 Body값에는 Timestamp를 넣는것이 일반적이다. 이렇게하면 서버에서 호출시간을 알 수 있고 이렇게 함으로써 좀더 보안성을 높여 사용할 수 있다. 아래는 HMAC의 예제 그림이다.</p>\n<p><img src=\"https://i.imgur.com/a5IsX06.jpg\" alt=\"\"></p>\n<h3>HMAC Example(Java)</h3>\n<p>다음은 자바 소스를 이용한 예제이다. 다음은 SHA-256알고리즘을 이용하여 해쉬를 만든것이다. 그안에서 인코딩방법*  16진수방법과 base64 방법이 존재한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HMACAuthentication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">verifySignature</span><span class=\"params\">(String secret, String payload, String signature)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> String resultHex = getHexHash(secret, payload);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!resultHex.equals(signature))</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">\"HMAC does not match.\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getHexHash</span><span class=\"params\">(String secret, String payload)</span> <span class=\"keyword\">throws</span> NoSuchAlgorithmException, InvalidKeyException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> String hmacSHA256 = <span class=\"string\">\"HmacSHA256\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Mac hasher = Mac.getInstance(hmacSHA256);</span><br><span class=\"line\">        hasher.init(<span class=\"keyword\">new</span> SecretKeySpec(secret.getBytes(), hmacSHA256));</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">byte</span>[] hash = hasher.doFinal(payload.getBytes());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//            String resultBase = DatatypeConverter.printBase64Binary(hash); // to base64</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> DatatypeConverter.printHexBinary(hash).toLowerCase(); <span class=\"comment\">// to hex</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/minwan1/blog-example/tree/master/HMAC\" target=\"_blank\" rel=\"noopener\">예제 소스</a></p>\n<p>참고</p>\n<ul>\n<li><a href=\"http://sunphiz.me/wp/archives/tag/hmac\" target=\"_blank\" rel=\"noopener\">DOG발</a></li>\n</ul>\n"},{"title":"Spring Web MVC 구조","catalog":true,"date":"2018-05-27T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n## Spring Web MVC 구조\n\n### MVC\n먼저 Spring Web MVC를 알기 전에 MVC 단어를 살펴보자. MVC(Model View Controller)란 비즈니스 규칙은 표현하는 도메인 모델(Model)과 프레젠테이션을 표현하는 View를 분리하기 위하여 양측 사이에 컨트롤러를 배치하도록 설계한 디자인 패턴이다. Spring Web MVC 모듈의 전체적인 구조는 이 패턴을 중심으로 만들어졌다. 아래는 그림으로 표현한 MVC 모델이다.\n\n![](https://i.imgur.com/pm2EhxT.png)\n\n### Spring DispatcherServlet\nSpring은 이러한 MVC 패턴을 구현하기 위해 다른 웹 MVC 프레임워크처럼 Front Controller 패턴을 사용하며 프레임워크의 여러 가지 기능을 제공하는 servlet 중심으로 설계되어 있다. 스프링에서 Front Controller 역할을 하는 것이 바로 DispatcherServlet이다. 스프링의 DispatcherServlet은 단순히 Front Controller 기능만 하는 게 아니라 스프링 IoC 컨테이너와 완전히 통합되어 스프링이 가진 모든 다른 기능을 사용할 수 있게 한다. Spring DispatcherServlet은 Spring MVC의 핵심 요소이다. DispatcherServlet은 Spring MVC의 웹 요청 Life Cycle을 주관한다 할 수 있다.\n\n>FrontController 패턴이란 모든 Web Application에 대한 요청들을 FrontController로 받고 그 요청을 Controller로 분배해주는 패턴을 의미한다.\n\n>서블릿이란 클라이언트 요청을 처리하고 그 결과를 다시 클라이언트에게 전송하는 Servlet 클래스의 구현 규칙을 지킨 자바 프로그램이다.\n\n아래는 스프링 DispatcherServlet의 역할을 그림으로 표현한 것이다.\n![](https://i.imgur.com/7xlCWY9.png)\n\n아래 그림은 위그림의 동작 순서의 그림이다.\n![](https://i.imgur.com/eWjZX8j.png)\n\n\n스프링 부트에서 DispatcherServlet설정은 WebApplicationInitializer를 구현함으로써 설정해 줄 수있다.\n```java\npublic class MyWebApplicationInitializer implements WebApplicationInitializer {\n\n    @Override\n    public void onStartup(ServletContext container) {\n        ServletRegistration.Dynamic registration = container.addServlet(\"dispatcher\", new DispatcherServlet());\n        registration.setLoadOnStartup(1);\n        registration.addMapping(\"/*\");\n    }\n\n}\n```\n위 소스는 Web Application에 들어오는 어떤 요청도 DispatcherServlet을 통해 관리 될 것이다. AbstractDispatcherServletInitializer라는 추상 클래스를 사용하면 DispatcherServlet을 좀 더 쉽게 설정할 수 있다.\n\n### DispatcherServlet, ContextLoaderListener\n그럼 스프링에 위 DispatcherServlet이 언제 등록되는지 알아보자. 가장 먼저 Servlet container(톰켓)(3.0+)이 실행되어야 한다. 그 이후에 Servlet container는 ServletContainerInitializer를 구현한 SpringServletContainerInitializer를 실행시킨다. SpringServletContainerInitializer는 WebApplicationInitializer를 implements한 class를 찾아내어 onStartup 메소드를 실행시킨다.\n\n이 과정에서 DispatcherServlet 설정뿐만 아니라 ContextLoaderListener를 등록해야 한다. 스프링이 기본적으로 구동되면서 DispatcherServlet이 생성하는 Context를 포함하여 2가지의 Context를 필요로 한다. 먼저 생성 되는 하나는 ContextLoaderListener에 의해서 만들어지는 Root WebApplicationContext이고 그다음으로 생성되는 것은 DispatcherServlet에 의해서 만들어지는 WebApplicationContext이다. 전자는 보통 서비스계층과 DAO를 포함한, 웹 환경에 독립적인 빈 들을 담아두고 후자는 DispatcherServlet이 직접 사용하는 컨트롤러를 포함한 웹 관련 빈을 등록하는 데 사용한다. 그리고 이 둘이 parent-child ApplicationContext 관계로 맺어진다.\n\n\n* RootWebApplicationContext와(parent): 서비스,레파지토리등 [ContextLoaderListener]\n* ChildWebApplicationContext의(child): 컨트롤러, 스프링 MVC 관련 설정 [DispatcherServlet]\n\n아래는 RootWebApplicationContext와 ChildWebApplicationContext의 관계를 표현한 그림이다.\n\n![](https://i.imgur.com/IUf4orm.png)\n\n\n\n### 스프링 MVC Reuqest 생명주기\n\n아래는 Spring MVC Request의 전체적인 생명주기 그림이다. onStartup 메소드로 넘어오는 ServletContext로 필터 등을 등록하고 적용할 수 있다.\n![](https://i.imgur.com/G8y0Pqa.jpg)\n\n\n\n\n 참고<br>\n\n* [헤르메스 LIFE](http://hermeslog.tistory.com/156)<br>\n\n* [장인개발자를 꿈꾸는 :: 기록하는 공간](http://devbox.tistory.com/entry/Spring-스프링-MVC-패턴-개요)<br>\n\n * [풍풍풍](https://m.blog.naver.com/PostView.nhn?blogId=sorkelf&logNo=40136444536&proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F)<br>\n\n* [토비님 블로그](http://toby.epril.com/?p=934)<br>\n* [Springdocs](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html)\n* [jhyoon0801](http://jhyoon0801.github.io/blogs/blogs/spring-mvc-base-1/)<br>\n* [LOGICBIG.COM](https://www.logicbig.com/tutorials/spring-framework/spring-web-mvc/spring-servlet-container-initializer.html)\n","source":"_posts/2018-05-28-spring-mvc.md","raw":"---\ntitle: Spring Web MVC 구조\ncatalog: true\ndate: 2018-05-28\nsubtitle:\nheader-img:\ntags:\n- Spring\n- Java\n\n\n---\n\n## Spring Web MVC 구조\n\n### MVC\n먼저 Spring Web MVC를 알기 전에 MVC 단어를 살펴보자. MVC(Model View Controller)란 비즈니스 규칙은 표현하는 도메인 모델(Model)과 프레젠테이션을 표현하는 View를 분리하기 위하여 양측 사이에 컨트롤러를 배치하도록 설계한 디자인 패턴이다. Spring Web MVC 모듈의 전체적인 구조는 이 패턴을 중심으로 만들어졌다. 아래는 그림으로 표현한 MVC 모델이다.\n\n![](https://i.imgur.com/pm2EhxT.png)\n\n### Spring DispatcherServlet\nSpring은 이러한 MVC 패턴을 구현하기 위해 다른 웹 MVC 프레임워크처럼 Front Controller 패턴을 사용하며 프레임워크의 여러 가지 기능을 제공하는 servlet 중심으로 설계되어 있다. 스프링에서 Front Controller 역할을 하는 것이 바로 DispatcherServlet이다. 스프링의 DispatcherServlet은 단순히 Front Controller 기능만 하는 게 아니라 스프링 IoC 컨테이너와 완전히 통합되어 스프링이 가진 모든 다른 기능을 사용할 수 있게 한다. Spring DispatcherServlet은 Spring MVC의 핵심 요소이다. DispatcherServlet은 Spring MVC의 웹 요청 Life Cycle을 주관한다 할 수 있다.\n\n>FrontController 패턴이란 모든 Web Application에 대한 요청들을 FrontController로 받고 그 요청을 Controller로 분배해주는 패턴을 의미한다.\n\n>서블릿이란 클라이언트 요청을 처리하고 그 결과를 다시 클라이언트에게 전송하는 Servlet 클래스의 구현 규칙을 지킨 자바 프로그램이다.\n\n아래는 스프링 DispatcherServlet의 역할을 그림으로 표현한 것이다.\n![](https://i.imgur.com/7xlCWY9.png)\n\n아래 그림은 위그림의 동작 순서의 그림이다.\n![](https://i.imgur.com/eWjZX8j.png)\n\n\n스프링 부트에서 DispatcherServlet설정은 WebApplicationInitializer를 구현함으로써 설정해 줄 수있다.\n```java\npublic class MyWebApplicationInitializer implements WebApplicationInitializer {\n\n    @Override\n    public void onStartup(ServletContext container) {\n        ServletRegistration.Dynamic registration = container.addServlet(\"dispatcher\", new DispatcherServlet());\n        registration.setLoadOnStartup(1);\n        registration.addMapping(\"/*\");\n    }\n\n}\n```\n위 소스는 Web Application에 들어오는 어떤 요청도 DispatcherServlet을 통해 관리 될 것이다. AbstractDispatcherServletInitializer라는 추상 클래스를 사용하면 DispatcherServlet을 좀 더 쉽게 설정할 수 있다.\n\n### DispatcherServlet, ContextLoaderListener\n그럼 스프링에 위 DispatcherServlet이 언제 등록되는지 알아보자. 가장 먼저 Servlet container(톰켓)(3.0+)이 실행되어야 한다. 그 이후에 Servlet container는 ServletContainerInitializer를 구현한 SpringServletContainerInitializer를 실행시킨다. SpringServletContainerInitializer는 WebApplicationInitializer를 implements한 class를 찾아내어 onStartup 메소드를 실행시킨다.\n\n이 과정에서 DispatcherServlet 설정뿐만 아니라 ContextLoaderListener를 등록해야 한다. 스프링이 기본적으로 구동되면서 DispatcherServlet이 생성하는 Context를 포함하여 2가지의 Context를 필요로 한다. 먼저 생성 되는 하나는 ContextLoaderListener에 의해서 만들어지는 Root WebApplicationContext이고 그다음으로 생성되는 것은 DispatcherServlet에 의해서 만들어지는 WebApplicationContext이다. 전자는 보통 서비스계층과 DAO를 포함한, 웹 환경에 독립적인 빈 들을 담아두고 후자는 DispatcherServlet이 직접 사용하는 컨트롤러를 포함한 웹 관련 빈을 등록하는 데 사용한다. 그리고 이 둘이 parent-child ApplicationContext 관계로 맺어진다.\n\n\n* RootWebApplicationContext와(parent): 서비스,레파지토리등 [ContextLoaderListener]\n* ChildWebApplicationContext의(child): 컨트롤러, 스프링 MVC 관련 설정 [DispatcherServlet]\n\n아래는 RootWebApplicationContext와 ChildWebApplicationContext의 관계를 표현한 그림이다.\n\n![](https://i.imgur.com/IUf4orm.png)\n\n\n\n### 스프링 MVC Reuqest 생명주기\n\n아래는 Spring MVC Request의 전체적인 생명주기 그림이다. onStartup 메소드로 넘어오는 ServletContext로 필터 등을 등록하고 적용할 수 있다.\n![](https://i.imgur.com/G8y0Pqa.jpg)\n\n\n\n\n 참고<br>\n\n* [헤르메스 LIFE](http://hermeslog.tistory.com/156)<br>\n\n* [장인개발자를 꿈꾸는 :: 기록하는 공간](http://devbox.tistory.com/entry/Spring-스프링-MVC-패턴-개요)<br>\n\n * [풍풍풍](https://m.blog.naver.com/PostView.nhn?blogId=sorkelf&logNo=40136444536&proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F)<br>\n\n* [토비님 블로그](http://toby.epril.com/?p=934)<br>\n* [Springdocs](https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html)\n* [jhyoon0801](http://jhyoon0801.github.io/blogs/blogs/spring-mvc-base-1/)<br>\n* [LOGICBIG.COM](https://www.logicbig.com/tutorials/spring-framework/spring-web-mvc/spring-servlet-container-initializer.html)\n","slug":"2018-05-28-spring-mvc","published":1,"updated":"2018-06-20T16:05:18.222Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27bp000wjjpen02u3c1m","content":"<h2><span id=\"spring-web-mvc-구조\">Spring Web MVC 구조</span></h2>\n<h3><span id=\"mvc\">MVC</span></h3>\n<p>먼저 Spring Web MVC를 알기 전에 MVC 단어를 살펴보자. MVC(Model View Controller)란 비즈니스 규칙은 표현하는 도메인 모델(Model)과 프레젠테이션을 표현하는 View를 분리하기 위하여 양측 사이에 컨트롤러를 배치하도록 설계한 디자인 패턴이다. Spring Web MVC 모듈의 전체적인 구조는 이 패턴을 중심으로 만들어졌다. 아래는 그림으로 표현한 MVC 모델이다.</p>\n<p><img src=\"https://i.imgur.com/pm2EhxT.png\" alt=\"\"></p>\n<h3><span id=\"spring-dispatcherservlet\">Spring DispatcherServlet</span></h3>\n<p>Spring은 이러한 MVC 패턴을 구현하기 위해 다른 웹 MVC 프레임워크처럼 Front Controller 패턴을 사용하며 프레임워크의 여러 가지 기능을 제공하는 servlet 중심으로 설계되어 있다. 스프링에서 Front Controller 역할을 하는 것이 바로 DispatcherServlet이다. 스프링의 DispatcherServlet은 단순히 Front Controller 기능만 하는 게 아니라 스프링 IoC 컨테이너와 완전히 통합되어 스프링이 가진 모든 다른 기능을 사용할 수 있게 한다. Spring DispatcherServlet은 Spring MVC의 핵심 요소이다. DispatcherServlet은 Spring MVC의 웹 요청 Life Cycle을 주관한다 할 수 있다.</p>\n<blockquote>\n<p>FrontController 패턴이란 모든 Web Application에 대한 요청들을 FrontController로 받고 그 요청을 Controller로 분배해주는 패턴을 의미한다.</p>\n</blockquote>\n<blockquote>\n<p>서블릿이란 클라이언트 요청을 처리하고 그 결과를 다시 클라이언트에게 전송하는 Servlet 클래스의 구현 규칙을 지킨 자바 프로그램이다.</p>\n</blockquote>\n<p>아래는 스프링 DispatcherServlet의 역할을 그림으로 표현한 것이다.<br>\n<img src=\"https://i.imgur.com/7xlCWY9.png\" alt=\"\"></p>\n<p>아래 그림은 위그림의 동작 순서의 그림이다.<br>\n<img src=\"https://i.imgur.com/eWjZX8j.png\" alt=\"\"></p>\n<p>스프링 부트에서 DispatcherServlet설정은 WebApplicationInitializer를 구현함으로써 설정해 줄 수있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyWebApplicationInitializer</span> <span class=\"keyword\">implements</span> <span class=\"title\">WebApplicationInitializer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStartup</span><span class=\"params\">(ServletContext container)</span> </span>&#123;</span><br><span class=\"line\">        ServletRegistration.Dynamic registration = container.addServlet(<span class=\"string\">\"dispatcher\"</span>, <span class=\"keyword\">new</span> DispatcherServlet());</span><br><span class=\"line\">        registration.setLoadOnStartup(<span class=\"number\">1</span>);</span><br><span class=\"line\">        registration.addMapping(<span class=\"string\">\"/*\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위 소스는 Web Application에 들어오는 어떤 요청도 DispatcherServlet을 통해 관리 될 것이다. AbstractDispatcherServletInitializer라는 추상 클래스를 사용하면 DispatcherServlet을 좀 더 쉽게 설정할 수 있다.</p>\n<h3><span id=\"dispatcherservlet-contextloaderlistener\">DispatcherServlet, ContextLoaderListener</span></h3>\n<p>그럼 스프링에 위 DispatcherServlet이 언제 등록되는지 알아보자. 가장 먼저 Servlet container(톰켓)(3.0+)이 실행되어야 한다. 그 이후에 Servlet container는 ServletContainerInitializer를 구현한 SpringServletContainerInitializer를 실행시킨다. SpringServletContainerInitializer는 WebApplicationInitializer를 implements한 class를 찾아내어 onStartup 메소드를 실행시킨다.</p>\n<p>이 과정에서 DispatcherServlet 설정뿐만 아니라 ContextLoaderListener를 등록해야 한다. 스프링이 기본적으로 구동되면서 DispatcherServlet이 생성하는 Context를 포함하여 2가지의 Context를 필요로 한다. 먼저 생성 되는 하나는 ContextLoaderListener에 의해서 만들어지는 Root WebApplicationContext이고 그다음으로 생성되는 것은 DispatcherServlet에 의해서 만들어지는 WebApplicationContext이다. 전자는 보통 서비스계층과 DAO를 포함한, 웹 환경에 독립적인 빈 들을 담아두고 후자는 DispatcherServlet이 직접 사용하는 컨트롤러를 포함한 웹 관련 빈을 등록하는 데 사용한다. 그리고 이 둘이 parent-child ApplicationContext 관계로 맺어진다.</p>\n<ul>\n<li>RootWebApplicationContext와(parent): 서비스,레파지토리등 [ContextLoaderListener]</li>\n<li>ChildWebApplicationContext의(child): 컨트롤러, 스프링 MVC 관련 설정 [DispatcherServlet]</li>\n</ul>\n<p>아래는 RootWebApplicationContext와 ChildWebApplicationContext의 관계를 표현한 그림이다.</p>\n<p><img src=\"https://i.imgur.com/IUf4orm.png\" alt=\"\"></p>\n<h3><span id=\"스프링-mvc-reuqest-생명주기\">스프링 MVC Reuqest 생명주기</span></h3>\n<p>아래는 Spring MVC Request의 전체적인 생명주기 그림이다. onStartup 메소드로 넘어오는 ServletContext로 필터 등을 등록하고 적용할 수 있다.<br>\n<img src=\"https://i.imgur.com/G8y0Pqa.jpg\" alt=\"\"></p>\n<p>참고<br></p>\n<ul>\n<li>\n<p><a href=\"http://hermeslog.tistory.com/156\" target=\"_blank\" rel=\"noopener\">헤르메스 LIFE</a><br></p>\n</li>\n<li>\n<p><a href=\"http://devbox.tistory.com/entry/Spring-%EC%8A%A4%ED%94%84%EB%A7%81-MVC-%ED%8C%A8%ED%84%B4-%EA%B0%9C%EC%9A%94\" target=\"_blank\" rel=\"noopener\">장인개발자를 꿈꾸는 :: 기록하는 공간</a><br></p>\n</li>\n<li>\n<p><a href=\"https://m.blog.naver.com/PostView.nhn?blogId=sorkelf&amp;logNo=40136444536&amp;proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F\" target=\"_blank\" rel=\"noopener\">풍풍풍</a><br></p>\n</li>\n<li>\n<p><a href=\"http://toby.epril.com/?p=934\" target=\"_blank\" rel=\"noopener\">토비님 블로그</a><br></p>\n</li>\n<li>\n<p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html\" target=\"_blank\" rel=\"noopener\">Springdocs</a></p>\n</li>\n<li>\n<p><a href=\"http://jhyoon0801.github.io/blogs/blogs/spring-mvc-base-1/\" target=\"_blank\" rel=\"noopener\">jhyoon0801</a><br></p>\n</li>\n<li>\n<p><a href=\"https://www.logicbig.com/tutorials/spring-framework/spring-web-mvc/spring-servlet-container-initializer.html\" target=\"_blank\" rel=\"noopener\">LOGICBIG.COM</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>Spring Web MVC 구조</h2>\n<h3>MVC</h3>\n<p>먼저 Spring Web MVC를 알기 전에 MVC 단어를 살펴보자. MVC(Model View Controller)란 비즈니스 규칙은 표현하는 도메인 모델(Model)과 프레젠테이션을 표현하는 View를 분리하기 위하여 양측 사이에 컨트롤러를 배치하도록 설계한 디자인 패턴이다. Spring Web MVC 모듈의 전체적인 구조는 이 패턴을 중심으로 만들어졌다. 아래는 그림으로 표현한 MVC 모델이다.</p>\n<p><img src=\"https://i.imgur.com/pm2EhxT.png\" alt=\"\"></p>\n<h3>Spring DispatcherServlet</h3>\n<p>Spring은 이러한 MVC 패턴을 구현하기 위해 다른 웹 MVC 프레임워크처럼 Front Controller 패턴을 사용하며 프레임워크의 여러 가지 기능을 제공하는 servlet 중심으로 설계되어 있다. 스프링에서 Front Controller 역할을 하는 것이 바로 DispatcherServlet이다. 스프링의 DispatcherServlet은 단순히 Front Controller 기능만 하는 게 아니라 스프링 IoC 컨테이너와 완전히 통합되어 스프링이 가진 모든 다른 기능을 사용할 수 있게 한다. Spring DispatcherServlet은 Spring MVC의 핵심 요소이다. DispatcherServlet은 Spring MVC의 웹 요청 Life Cycle을 주관한다 할 수 있다.</p>\n<blockquote>\n<p>FrontController 패턴이란 모든 Web Application에 대한 요청들을 FrontController로 받고 그 요청을 Controller로 분배해주는 패턴을 의미한다.</p>\n</blockquote>\n<blockquote>\n<p>서블릿이란 클라이언트 요청을 처리하고 그 결과를 다시 클라이언트에게 전송하는 Servlet 클래스의 구현 규칙을 지킨 자바 프로그램이다.</p>\n</blockquote>\n<p>아래는 스프링 DispatcherServlet의 역할을 그림으로 표현한 것이다.<br>\n<img src=\"https://i.imgur.com/7xlCWY9.png\" alt=\"\"></p>\n<p>아래 그림은 위그림의 동작 순서의 그림이다.<br>\n<img src=\"https://i.imgur.com/eWjZX8j.png\" alt=\"\"></p>\n<p>스프링 부트에서 DispatcherServlet설정은 WebApplicationInitializer를 구현함으로써 설정해 줄 수있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyWebApplicationInitializer</span> <span class=\"keyword\">implements</span> <span class=\"title\">WebApplicationInitializer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStartup</span><span class=\"params\">(ServletContext container)</span> </span>&#123;</span><br><span class=\"line\">        ServletRegistration.Dynamic registration = container.addServlet(<span class=\"string\">\"dispatcher\"</span>, <span class=\"keyword\">new</span> DispatcherServlet());</span><br><span class=\"line\">        registration.setLoadOnStartup(<span class=\"number\">1</span>);</span><br><span class=\"line\">        registration.addMapping(<span class=\"string\">\"/*\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위 소스는 Web Application에 들어오는 어떤 요청도 DispatcherServlet을 통해 관리 될 것이다. AbstractDispatcherServletInitializer라는 추상 클래스를 사용하면 DispatcherServlet을 좀 더 쉽게 설정할 수 있다.</p>\n<h3>DispatcherServlet, ContextLoaderListener</h3>\n<p>그럼 스프링에 위 DispatcherServlet이 언제 등록되는지 알아보자. 가장 먼저 Servlet container(톰켓)(3.0+)이 실행되어야 한다. 그 이후에 Servlet container는 ServletContainerInitializer를 구현한 SpringServletContainerInitializer를 실행시킨다. SpringServletContainerInitializer는 WebApplicationInitializer를 implements한 class를 찾아내어 onStartup 메소드를 실행시킨다.</p>\n<p>이 과정에서 DispatcherServlet 설정뿐만 아니라 ContextLoaderListener를 등록해야 한다. 스프링이 기본적으로 구동되면서 DispatcherServlet이 생성하는 Context를 포함하여 2가지의 Context를 필요로 한다. 먼저 생성 되는 하나는 ContextLoaderListener에 의해서 만들어지는 Root WebApplicationContext이고 그다음으로 생성되는 것은 DispatcherServlet에 의해서 만들어지는 WebApplicationContext이다. 전자는 보통 서비스계층과 DAO를 포함한, 웹 환경에 독립적인 빈 들을 담아두고 후자는 DispatcherServlet이 직접 사용하는 컨트롤러를 포함한 웹 관련 빈을 등록하는 데 사용한다. 그리고 이 둘이 parent-child ApplicationContext 관계로 맺어진다.</p>\n<ul>\n<li>RootWebApplicationContext와(parent): 서비스,레파지토리등 [ContextLoaderListener]</li>\n<li>ChildWebApplicationContext의(child): 컨트롤러, 스프링 MVC 관련 설정 [DispatcherServlet]</li>\n</ul>\n<p>아래는 RootWebApplicationContext와 ChildWebApplicationContext의 관계를 표현한 그림이다.</p>\n<p><img src=\"https://i.imgur.com/IUf4orm.png\" alt=\"\"></p>\n<h3>스프링 MVC Reuqest 생명주기</h3>\n<p>아래는 Spring MVC Request의 전체적인 생명주기 그림이다. onStartup 메소드로 넘어오는 ServletContext로 필터 등을 등록하고 적용할 수 있다.<br>\n<img src=\"https://i.imgur.com/G8y0Pqa.jpg\" alt=\"\"></p>\n<p>참고<br></p>\n<ul>\n<li>\n<p><a href=\"http://hermeslog.tistory.com/156\" target=\"_blank\" rel=\"noopener\">헤르메스 LIFE</a><br></p>\n</li>\n<li>\n<p><a href=\"http://devbox.tistory.com/entry/Spring-%EC%8A%A4%ED%94%84%EB%A7%81-MVC-%ED%8C%A8%ED%84%B4-%EA%B0%9C%EC%9A%94\" target=\"_blank\" rel=\"noopener\">장인개발자를 꿈꾸는 :: 기록하는 공간</a><br></p>\n</li>\n<li>\n<p><a href=\"https://m.blog.naver.com/PostView.nhn?blogId=sorkelf&amp;logNo=40136444536&amp;proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F\" target=\"_blank\" rel=\"noopener\">풍풍풍</a><br></p>\n</li>\n<li>\n<p><a href=\"http://toby.epril.com/?p=934\" target=\"_blank\" rel=\"noopener\">토비님 블로그</a><br></p>\n</li>\n<li>\n<p><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html\" target=\"_blank\" rel=\"noopener\">Springdocs</a></p>\n</li>\n<li>\n<p><a href=\"http://jhyoon0801.github.io/blogs/blogs/spring-mvc-base-1/\" target=\"_blank\" rel=\"noopener\">jhyoon0801</a><br></p>\n</li>\n<li>\n<p><a href=\"https://www.logicbig.com/tutorials/spring-framework/spring-web-mvc/spring-servlet-container-initializer.html\" target=\"_blank\" rel=\"noopener\">LOGICBIG.COM</a></p>\n</li>\n</ul>\n"},{"title":"String, StringBuffer, StringBuilder 차이","catalog":true,"date":"2018-06-10T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n## String, StringBuffer, StringBuilder 차이\n\n### String\nString 클래스는 변경이 불가능한 immutable 클래스이다. String 클래스를 사용하여 String의 문자열을 추가할 때 기존 할당된 메모리 힙영역에 문자열을 수정할 수 없다. 예를 들어 String 문자열에 +를 하여 문자열을 추가 할경우에 내부적으로 새로운 객체를 생성하게 된다.\n\n```java\nString data = \"ABC\";\ndata += \"DEF\";\n```\n\n예를 들어 \"ABC\" 에 \"DEF\"가 추가되었기 때문에 한개의 String 객체가 사용되었다고 생각할 수 있지만, String 객체는 내부 데이터를 수정할 수 없으므로 새로운 객체를 생성하여 기존 data변수에 새로 생성된 String 객체를 생성한다. 아래는 그림으로 위 내용을 표현한 것이다.\n\n![](https://i.imgur.com/UwKv9YE.png)\n\n문자열을 결합하는 +연산자를 많이 사용할수록 String의 객체수가 늘어나기 때문에 프로그램 성능을 느리게하는 요인이 될 수 있다. 문자열에 많은 변화가 필요한경우에는 StringBuffer또는 Stringbuilder 클래스를 사용해야 한다.\n\n### StringBuffer, Stringbuilder\nStringBuffer 클래스는 변경이 가능한 mutable 클래스이다. 이 두 클래스는 내부적으로 Buffer에 문자열을 저장해두고 그안에서 추가, 수정, 삭제 작업을 할 수 있도록 설계되어 있다. String 처럼 새로운 객체를 만들지 않고도 문자열을 조작할 수 있는 것 이다.\n\n\n#### StringBuffer, Stringbuilder 차이\n그럼 StringBuffer와 Stringbuilder의 차이는 무엇일까.. StringBuffer는 각 메서드 별로 Synchronized 가 존재하여, 멀티스레드 환경에서도 동기화를 지원한다. 하지만, StringBuilder는 동기화를 보장하지 않는다. 그렇기 때문에 멀티스레드 환경이라면 값 동기화 보장을 위해 StringBuffer를 사용하고, 단일 스레드 환경이라면 StringBuilder를 사용하는 것이 좋다. 단일스레드환경에서 StringBuffer를 사용한다고 문제가 되는 것은 아니지만, 동기화 관련 처리로 인해 StringBuilder에 비해 성능이 좋지 않다.\n\n\n\n참고\n* [이것이자바다](http://www.hanbit.co.kr/store/books/look.php?p_code=B1460673937)\n* [이러쿵저러쿵](http://ooz.co.kr/298)\n","source":"_posts/2018-06-11-String-StringBuffer-StringBuilder.md","raw":"---\ntitle: String, StringBuffer, StringBuilder 차이\ncatalog: true\ndate: 2018-06-11\nsubtitle:\nheader-img:\ntags:\n- Java\n\n\n---\n\n## String, StringBuffer, StringBuilder 차이\n\n### String\nString 클래스는 변경이 불가능한 immutable 클래스이다. String 클래스를 사용하여 String의 문자열을 추가할 때 기존 할당된 메모리 힙영역에 문자열을 수정할 수 없다. 예를 들어 String 문자열에 +를 하여 문자열을 추가 할경우에 내부적으로 새로운 객체를 생성하게 된다.\n\n```java\nString data = \"ABC\";\ndata += \"DEF\";\n```\n\n예를 들어 \"ABC\" 에 \"DEF\"가 추가되었기 때문에 한개의 String 객체가 사용되었다고 생각할 수 있지만, String 객체는 내부 데이터를 수정할 수 없으므로 새로운 객체를 생성하여 기존 data변수에 새로 생성된 String 객체를 생성한다. 아래는 그림으로 위 내용을 표현한 것이다.\n\n![](https://i.imgur.com/UwKv9YE.png)\n\n문자열을 결합하는 +연산자를 많이 사용할수록 String의 객체수가 늘어나기 때문에 프로그램 성능을 느리게하는 요인이 될 수 있다. 문자열에 많은 변화가 필요한경우에는 StringBuffer또는 Stringbuilder 클래스를 사용해야 한다.\n\n### StringBuffer, Stringbuilder\nStringBuffer 클래스는 변경이 가능한 mutable 클래스이다. 이 두 클래스는 내부적으로 Buffer에 문자열을 저장해두고 그안에서 추가, 수정, 삭제 작업을 할 수 있도록 설계되어 있다. String 처럼 새로운 객체를 만들지 않고도 문자열을 조작할 수 있는 것 이다.\n\n\n#### StringBuffer, Stringbuilder 차이\n그럼 StringBuffer와 Stringbuilder의 차이는 무엇일까.. StringBuffer는 각 메서드 별로 Synchronized 가 존재하여, 멀티스레드 환경에서도 동기화를 지원한다. 하지만, StringBuilder는 동기화를 보장하지 않는다. 그렇기 때문에 멀티스레드 환경이라면 값 동기화 보장을 위해 StringBuffer를 사용하고, 단일 스레드 환경이라면 StringBuilder를 사용하는 것이 좋다. 단일스레드환경에서 StringBuffer를 사용한다고 문제가 되는 것은 아니지만, 동기화 관련 처리로 인해 StringBuilder에 비해 성능이 좋지 않다.\n\n\n\n참고\n* [이것이자바다](http://www.hanbit.co.kr/store/books/look.php?p_code=B1460673937)\n* [이러쿵저러쿵](http://ooz.co.kr/298)\n","slug":"2018-06-11-String-StringBuffer-StringBuilder","published":1,"updated":"2018-06-20T16:05:18.389Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27bq000zjjpeg9koei6x","content":"<h2><span id=\"string-stringbuffer-stringbuilder-차이\">String, StringBuffer, StringBuilder 차이</span></h2>\n<h3><span id=\"string\">String</span></h3>\n<p>String 클래스는 변경이 불가능한 immutable 클래스이다. String 클래스를 사용하여 String의 문자열을 추가할 때 기존 할당된 메모리 힙영역에 문자열을 수정할 수 없다. 예를 들어 String 문자열에 +를 하여 문자열을 추가 할경우에 내부적으로 새로운 객체를 생성하게 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">String data = <span class=\"string\">\"ABC\"</span>;</span><br><span class=\"line\">data += <span class=\"string\">\"DEF\"</span>;</span><br></pre></td></tr></table></figure>\n<p>예를 들어 “ABC” 에 &quot;DEF&quot;가 추가되었기 때문에 한개의 String 객체가 사용되었다고 생각할 수 있지만, String 객체는 내부 데이터를 수정할 수 없으므로 새로운 객체를 생성하여 기존 data변수에 새로 생성된 String 객체를 생성한다. 아래는 그림으로 위 내용을 표현한 것이다.</p>\n<p><img src=\"https://i.imgur.com/UwKv9YE.png\" alt=\"\"></p>\n<p>문자열을 결합하는 +연산자를 많이 사용할수록 String의 객체수가 늘어나기 때문에 프로그램 성능을 느리게하는 요인이 될 수 있다. 문자열에 많은 변화가 필요한경우에는 StringBuffer또는 Stringbuilder 클래스를 사용해야 한다.</p>\n<h3><span id=\"stringbuffer-stringbuilder\">StringBuffer, Stringbuilder</span></h3>\n<p>StringBuffer 클래스는 변경이 가능한 mutable 클래스이다. 이 두 클래스는 내부적으로 Buffer에 문자열을 저장해두고 그안에서 추가, 수정, 삭제 작업을 할 수 있도록 설계되어 있다. String 처럼 새로운 객체를 만들지 않고도 문자열을 조작할 수 있는 것 이다.</p>\n<h4><span id=\"stringbuffer-stringbuilder-차이\">StringBuffer, Stringbuilder 차이</span></h4>\n<p>그럼 StringBuffer와 Stringbuilder의 차이는 무엇일까… StringBuffer는 각 메서드 별로 Synchronized 가 존재하여, 멀티스레드 환경에서도 동기화를 지원한다. 하지만, StringBuilder는 동기화를 보장하지 않는다. 그렇기 때문에 멀티스레드 환경이라면 값 동기화 보장을 위해 StringBuffer를 사용하고, 단일 스레드 환경이라면 StringBuilder를 사용하는 것이 좋다. 단일스레드환경에서 StringBuffer를 사용한다고 문제가 되는 것은 아니지만, 동기화 관련 처리로 인해 StringBuilder에 비해 성능이 좋지 않다.</p>\n<p>참고</p>\n<ul>\n<li><a href=\"http://www.hanbit.co.kr/store/books/look.php?p_code=B1460673937\" target=\"_blank\" rel=\"noopener\">이것이자바다</a></li>\n<li><a href=\"http://ooz.co.kr/298\" target=\"_blank\" rel=\"noopener\">이러쿵저러쿵</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>String, StringBuffer, StringBuilder 차이</h2>\n<h3>String</h3>\n<p>String 클래스는 변경이 불가능한 immutable 클래스이다. String 클래스를 사용하여 String의 문자열을 추가할 때 기존 할당된 메모리 힙영역에 문자열을 수정할 수 없다. 예를 들어 String 문자열에 +를 하여 문자열을 추가 할경우에 내부적으로 새로운 객체를 생성하게 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">String data = <span class=\"string\">\"ABC\"</span>;</span><br><span class=\"line\">data += <span class=\"string\">\"DEF\"</span>;</span><br></pre></td></tr></table></figure>\n<p>예를 들어 “ABC” 에 &quot;DEF&quot;가 추가되었기 때문에 한개의 String 객체가 사용되었다고 생각할 수 있지만, String 객체는 내부 데이터를 수정할 수 없으므로 새로운 객체를 생성하여 기존 data변수에 새로 생성된 String 객체를 생성한다. 아래는 그림으로 위 내용을 표현한 것이다.</p>\n<p><img src=\"https://i.imgur.com/UwKv9YE.png\" alt=\"\"></p>\n<p>문자열을 결합하는 +연산자를 많이 사용할수록 String의 객체수가 늘어나기 때문에 프로그램 성능을 느리게하는 요인이 될 수 있다. 문자열에 많은 변화가 필요한경우에는 StringBuffer또는 Stringbuilder 클래스를 사용해야 한다.</p>\n<h3>StringBuffer, Stringbuilder</h3>\n<p>StringBuffer 클래스는 변경이 가능한 mutable 클래스이다. 이 두 클래스는 내부적으로 Buffer에 문자열을 저장해두고 그안에서 추가, 수정, 삭제 작업을 할 수 있도록 설계되어 있다. String 처럼 새로운 객체를 만들지 않고도 문자열을 조작할 수 있는 것 이다.</p>\n<h4>StringBuffer, Stringbuilder 차이</h4>\n<p>그럼 StringBuffer와 Stringbuilder의 차이는 무엇일까… StringBuffer는 각 메서드 별로 Synchronized 가 존재하여, 멀티스레드 환경에서도 동기화를 지원한다. 하지만, StringBuilder는 동기화를 보장하지 않는다. 그렇기 때문에 멀티스레드 환경이라면 값 동기화 보장을 위해 StringBuffer를 사용하고, 단일 스레드 환경이라면 StringBuilder를 사용하는 것이 좋다. 단일스레드환경에서 StringBuffer를 사용한다고 문제가 되는 것은 아니지만, 동기화 관련 처리로 인해 StringBuilder에 비해 성능이 좋지 않다.</p>\n<p>참고</p>\n<ul>\n<li><a href=\"http://www.hanbit.co.kr/store/books/look.php?p_code=B1460673937\" target=\"_blank\" rel=\"noopener\">이것이자바다</a></li>\n<li><a href=\"http://ooz.co.kr/298\" target=\"_blank\" rel=\"noopener\">이러쿵저러쿵</a></li>\n</ul>\n"},{"title":"아스키코드, 유니코드란?","catalog":true,"date":"2018-06-08T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n## 아스키코드(ASCII)\n\n>아스키 코드는 미국 ANSI에서 표준화한 정보교환용 7비트 부호체계이다. 컴퓨터의 언어는 결국 숫자이다. 따라서 프로그램이나 다른 컴퓨터와 통신하려면 컴퓨터에서 문자와 기호가 해당 숫자 표현으로 변환되어야야하는 필요가 생겼다.<br>\n이필요성이 대두됨에 따라 1960년대에 ASCII(American Standard Code for Information Interchange)(아스키로 발음) 코드가 개발되었다. ASCII 표에는 128개의 숫자가 해당 문자에 할당되어 있다. ASCII 코드를 통해 컴퓨터 간에 또는 컴퓨터와 프로그램 간에 데이터를 저장하고 교환할 수 있게 되었다.\nASCII는 0x00부터 0x7F까지의 총 127개 문자(제어 문자, 특수 문자, 숫자, 알파벳 등)로 이루어져 있다.\n\n아래는 아스키코드 표이다.\n![](https://i.imgur.com/VpDNjzJ.jpg)\n\n사진 출처 - [asciicharstable](www.asciicharstable.com)\n## 유니코드(Unicode)\n\n>시간이 지나가면서 영어나 숫자 그리고 기본적인 기호뿐만 아니라 그 나라, 그 언어에서 쓰는 다양한 문자들을 처리하려면 1바이트로 정의된 아스키 코드를 확장할 필요가 있게 되었다. 유니코드는 이런 아스키코드의 한계성을 해소할 수 있는 체계로 만들어진 코드이다.\n각 나라별 언어를 모두 표현하기 위해 나온 코드 체계가 유니코드(Unicode)이다. 유니코드는 사용중인 운영체제, 프로그램, 언어에 관계없이 문자마다 고유한 코드 값을 제공하는 새로운 개념의 코드이다. 언어와 상관없이 모든 문자를 16비트로 표현하므로 최대 65,536자까지 표현할 수 있다.\n유니코드 인코딩 방식으로는 UTF-7, UTF-8, UTF-16, UTF-32 인코딩 등이 있다.\n\n참고\n* [과일가게 개발자](http://fruitdev.tistory.com/83)\n* [D2](https://d2.naver.com/helloworld/19187)","source":"_posts/2018-06-09-ASCII-Unicode.md","raw":"---\ntitle: 아스키코드, 유니코드란?\ncatalog: true\ndate: 2018-06-09\nsubtitle:\nheader-img:\ntags:\n- ETC\n\n\n---\n\n## 아스키코드(ASCII)\n\n>아스키 코드는 미국 ANSI에서 표준화한 정보교환용 7비트 부호체계이다. 컴퓨터의 언어는 결국 숫자이다. 따라서 프로그램이나 다른 컴퓨터와 통신하려면 컴퓨터에서 문자와 기호가 해당 숫자 표현으로 변환되어야야하는 필요가 생겼다.<br>\n이필요성이 대두됨에 따라 1960년대에 ASCII(American Standard Code for Information Interchange)(아스키로 발음) 코드가 개발되었다. ASCII 표에는 128개의 숫자가 해당 문자에 할당되어 있다. ASCII 코드를 통해 컴퓨터 간에 또는 컴퓨터와 프로그램 간에 데이터를 저장하고 교환할 수 있게 되었다.\nASCII는 0x00부터 0x7F까지의 총 127개 문자(제어 문자, 특수 문자, 숫자, 알파벳 등)로 이루어져 있다.\n\n아래는 아스키코드 표이다.\n![](https://i.imgur.com/VpDNjzJ.jpg)\n\n사진 출처 - [asciicharstable](www.asciicharstable.com)\n## 유니코드(Unicode)\n\n>시간이 지나가면서 영어나 숫자 그리고 기본적인 기호뿐만 아니라 그 나라, 그 언어에서 쓰는 다양한 문자들을 처리하려면 1바이트로 정의된 아스키 코드를 확장할 필요가 있게 되었다. 유니코드는 이런 아스키코드의 한계성을 해소할 수 있는 체계로 만들어진 코드이다.\n각 나라별 언어를 모두 표현하기 위해 나온 코드 체계가 유니코드(Unicode)이다. 유니코드는 사용중인 운영체제, 프로그램, 언어에 관계없이 문자마다 고유한 코드 값을 제공하는 새로운 개념의 코드이다. 언어와 상관없이 모든 문자를 16비트로 표현하므로 최대 65,536자까지 표현할 수 있다.\n유니코드 인코딩 방식으로는 UTF-7, UTF-8, UTF-16, UTF-32 인코딩 등이 있다.\n\n참고\n* [과일가게 개발자](http://fruitdev.tistory.com/83)\n* [D2](https://d2.naver.com/helloworld/19187)","slug":"2018-06-09-ASCII-Unicode","published":1,"updated":"2018-06-20T16:05:18.277Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27bs0011jjpesujlvxmk","content":"<h2><span id=\"아스키코드ascii\">아스키코드(ASCII)</span></h2>\n<blockquote>\n<p>아스키 코드는 미국 ANSI에서 표준화한 정보교환용 7비트 부호체계이다. 컴퓨터의 언어는 결국 숫자이다. 따라서 프로그램이나 다른 컴퓨터와 통신하려면 컴퓨터에서 문자와 기호가 해당 숫자 표현으로 변환되어야야하는 필요가 생겼다.<br><br>\n이필요성이 대두됨에 따라 1960년대에 ASCII(American Standard Code for Information Interchange)(아스키로 발음) 코드가 개발되었다. ASCII 표에는 128개의 숫자가 해당 문자에 할당되어 있다. ASCII 코드를 통해 컴퓨터 간에 또는 컴퓨터와 프로그램 간에 데이터를 저장하고 교환할 수 있게 되었다.<br>\nASCII는 0x00부터 0x7F까지의 총 127개 문자(제어 문자, 특수 문자, 숫자, 알파벳 등)로 이루어져 있다.</p>\n</blockquote>\n<p>아래는 아스키코드 표이다.<br>\n<img src=\"https://i.imgur.com/VpDNjzJ.jpg\" alt=\"\"></p>\n<p>사진 출처 - <a href=\"www.asciicharstable.com\">asciicharstable</a></p>\n<h2><span id=\"유니코드unicode\">유니코드(Unicode)</span></h2>\n<blockquote>\n<p>시간이 지나가면서 영어나 숫자 그리고 기본적인 기호뿐만 아니라 그 나라, 그 언어에서 쓰는 다양한 문자들을 처리하려면 1바이트로 정의된 아스키 코드를 확장할 필요가 있게 되었다. 유니코드는 이런 아스키코드의 한계성을 해소할 수 있는 체계로 만들어진 코드이다.<br>\n각 나라별 언어를 모두 표현하기 위해 나온 코드 체계가 유니코드(Unicode)이다. 유니코드는 사용중인 운영체제, 프로그램, 언어에 관계없이 문자마다 고유한 코드 값을 제공하는 새로운 개념의 코드이다. 언어와 상관없이 모든 문자를 16비트로 표현하므로 최대 65,536자까지 표현할 수 있다.<br>\n유니코드 인코딩 방식으로는 UTF-7, UTF-8, UTF-16, UTF-32 인코딩 등이 있다.</p>\n</blockquote>\n<p>참고</p>\n<ul>\n<li><a href=\"http://fruitdev.tistory.com/83\" target=\"_blank\" rel=\"noopener\">과일가게 개발자</a></li>\n<li><a href=\"https://d2.naver.com/helloworld/19187\" target=\"_blank\" rel=\"noopener\">D2</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>아스키코드(ASCII)</h2>\n<blockquote>\n<p>아스키 코드는 미국 ANSI에서 표준화한 정보교환용 7비트 부호체계이다. 컴퓨터의 언어는 결국 숫자이다. 따라서 프로그램이나 다른 컴퓨터와 통신하려면 컴퓨터에서 문자와 기호가 해당 숫자 표현으로 변환되어야야하는 필요가 생겼다.<br><br>\n이필요성이 대두됨에 따라 1960년대에 ASCII(American Standard Code for Information Interchange)(아스키로 발음) 코드가 개발되었다. ASCII 표에는 128개의 숫자가 해당 문자에 할당되어 있다. ASCII 코드를 통해 컴퓨터 간에 또는 컴퓨터와 프로그램 간에 데이터를 저장하고 교환할 수 있게 되었다.<br>\nASCII는 0x00부터 0x7F까지의 총 127개 문자(제어 문자, 특수 문자, 숫자, 알파벳 등)로 이루어져 있다.</p>\n</blockquote>\n<p>아래는 아스키코드 표이다.<br>\n<img src=\"https://i.imgur.com/VpDNjzJ.jpg\" alt=\"\"></p>\n<p>사진 출처 - <a href=\"www.asciicharstable.com\">asciicharstable</a></p>\n<h2>유니코드(Unicode)</h2>\n<blockquote>\n<p>시간이 지나가면서 영어나 숫자 그리고 기본적인 기호뿐만 아니라 그 나라, 그 언어에서 쓰는 다양한 문자들을 처리하려면 1바이트로 정의된 아스키 코드를 확장할 필요가 있게 되었다. 유니코드는 이런 아스키코드의 한계성을 해소할 수 있는 체계로 만들어진 코드이다.<br>\n각 나라별 언어를 모두 표현하기 위해 나온 코드 체계가 유니코드(Unicode)이다. 유니코드는 사용중인 운영체제, 프로그램, 언어에 관계없이 문자마다 고유한 코드 값을 제공하는 새로운 개념의 코드이다. 언어와 상관없이 모든 문자를 16비트로 표현하므로 최대 65,536자까지 표현할 수 있다.<br>\n유니코드 인코딩 방식으로는 UTF-7, UTF-8, UTF-16, UTF-32 인코딩 등이 있다.</p>\n</blockquote>\n<p>참고</p>\n<ul>\n<li><a href=\"http://fruitdev.tistory.com/83\" target=\"_blank\" rel=\"noopener\">과일가게 개발자</a></li>\n<li><a href=\"https://d2.naver.com/helloworld/19187\" target=\"_blank\" rel=\"noopener\">D2</a></li>\n</ul>\n"},{"title":"EntityManagerFactory, EntityManager, PersistenceContext란?","catalog":true,"date":"2018-06-13T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n## EntityManagerFactory, EntityManager, PersistenceContext란?\n\n### EntityManagerFactory란\n데이터베이스를 하나만 사용하는 애플리케이션들은 일반적으로 EntityManagerFactory를 한개만 생성한다. 이 엔터티 매니저 팩토리로 엔터티 매니저를 생성할 수 있다. EntityManagerFactory는 Thread Safe해서 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드간에 공유해새 사용한다.\n\n#### EntityManagerFactory 정리\n* Hibernate에서는 SessionFactory(EntityManagerFactory)\n* 엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하다.(thread-safe)\n* EntityManager를 생성한다.\n\n\n### EntityManager란\n엔터티 매니저는 엔터티를 저장하는 메모리상의 데이터베이스라고 생각하면 될 것같다. 엔터티 매니저는 엔터티를 저장하고 수정하고 삭제하고 조회하는 등 엔터티와 관련된 모든일을 한다. 하지만 위의 EntityManagerFactory는 달리 Thread Safe하지 않기때문에 동시성 문제가 발생하므로 스레드간에 절대 공유하면 안 된다. 그래서 일반적으로 EntityManager를 EntityManagerFactory를 이용하여 생성한것을 사용하는것이 아닌 스프링에서 관리하는 EntityManager를 아래와 같이 선언하여 사용한다. 이렇게되면 스프링에서 알아서 EntityManager를 Proxy로 깜싼 EntityManager를 생성 하여 주입해주기 때문에 Thread-Safety를 보장 한다.\n\n```java\n@PersistenceContext\nprivate EntityManager entityManager;\n```\n#### EntityManager 정리\n* Hibernate에서는 Session(EntityManager)으로 불리운다.\n* 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유하면 안된다.\n\n\n### PersistenceContext(영속성 컨텍스트)란\n* 영속성 컨텍스트란 엔티티(Entity)를 영구 저장 하는 환경을 말한다. 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.\n* 영속성 컨텍스트는 엔티티 매니저(Session)를 생성할 때 하나 만들어진다. 그리고 엔티티 매니저(Session)를 통해서 영속성 컨텍스트에 접근할 수 있고 영속성 컨텍스트를 관리 할 수 있다.\n* 여러 엔티티 매니저(Session)가 같은 영속성 컨텍스트에 접근할 수도 있다.\n\n\n참조\n* [자바 ORM 표준 JPA 프로그래밍](http://book.naver.com/bookdb/book_detail.nhn?bid=9252528)\n\n","source":"_posts/2018-06-14-EntityManagerFactory, EntityManager, PersistenceContext란.md","raw":"---\ntitle: EntityManagerFactory, EntityManager, PersistenceContext란?\ncatalog: true\ndate: 2018-06-14\nsubtitle:\nheader-img:\ntags:\n- Java\n- Spring\n- JPA\n\n\n---\n\n## EntityManagerFactory, EntityManager, PersistenceContext란?\n\n### EntityManagerFactory란\n데이터베이스를 하나만 사용하는 애플리케이션들은 일반적으로 EntityManagerFactory를 한개만 생성한다. 이 엔터티 매니저 팩토리로 엔터티 매니저를 생성할 수 있다. EntityManagerFactory는 Thread Safe해서 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드간에 공유해새 사용한다.\n\n#### EntityManagerFactory 정리\n* Hibernate에서는 SessionFactory(EntityManagerFactory)\n* 엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하다.(thread-safe)\n* EntityManager를 생성한다.\n\n\n### EntityManager란\n엔터티 매니저는 엔터티를 저장하는 메모리상의 데이터베이스라고 생각하면 될 것같다. 엔터티 매니저는 엔터티를 저장하고 수정하고 삭제하고 조회하는 등 엔터티와 관련된 모든일을 한다. 하지만 위의 EntityManagerFactory는 달리 Thread Safe하지 않기때문에 동시성 문제가 발생하므로 스레드간에 절대 공유하면 안 된다. 그래서 일반적으로 EntityManager를 EntityManagerFactory를 이용하여 생성한것을 사용하는것이 아닌 스프링에서 관리하는 EntityManager를 아래와 같이 선언하여 사용한다. 이렇게되면 스프링에서 알아서 EntityManager를 Proxy로 깜싼 EntityManager를 생성 하여 주입해주기 때문에 Thread-Safety를 보장 한다.\n\n```java\n@PersistenceContext\nprivate EntityManager entityManager;\n```\n#### EntityManager 정리\n* Hibernate에서는 Session(EntityManager)으로 불리운다.\n* 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유하면 안된다.\n\n\n### PersistenceContext(영속성 컨텍스트)란\n* 영속성 컨텍스트란 엔티티(Entity)를 영구 저장 하는 환경을 말한다. 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.\n* 영속성 컨텍스트는 엔티티 매니저(Session)를 생성할 때 하나 만들어진다. 그리고 엔티티 매니저(Session)를 통해서 영속성 컨텍스트에 접근할 수 있고 영속성 컨텍스트를 관리 할 수 있다.\n* 여러 엔티티 매니저(Session)가 같은 영속성 컨텍스트에 접근할 수도 있다.\n\n\n참조\n* [자바 ORM 표준 JPA 프로그래밍](http://book.naver.com/bookdb/book_detail.nhn?bid=9252528)\n\n","slug":"2018-06-14-EntityManagerFactory, EntityManager, PersistenceContext란","published":1,"updated":"2018-06-20T16:08:54.223Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27bt0014jjpeod23vu4b","content":"<h2><span id=\"entitymanagerfactory-entitymanager-persistencecontext란\">EntityManagerFactory, EntityManager, PersistenceContext란?</span></h2>\n<h3><span id=\"entitymanagerfactory란\">EntityManagerFactory란</span></h3>\n<p>데이터베이스를 하나만 사용하는 애플리케이션들은 일반적으로 EntityManagerFactory를 한개만 생성한다. 이 엔터티 매니저 팩토리로 엔터티 매니저를 생성할 수 있다. EntityManagerFactory는 Thread Safe해서 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드간에 공유해새 사용한다.</p>\n<h4><span id=\"entitymanagerfactory-정리\">EntityManagerFactory 정리</span></h4>\n<ul>\n<li>Hibernate에서는 SessionFactory(EntityManagerFactory)</li>\n<li>엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하다.(thread-safe)</li>\n<li>EntityManager를 생성한다.</li>\n</ul>\n<h3><span id=\"entitymanager란\">EntityManager란</span></h3>\n<p>엔터티 매니저는 엔터티를 저장하는 메모리상의 데이터베이스라고 생각하면 될 것같다. 엔터티 매니저는 엔터티를 저장하고 수정하고 삭제하고 조회하는 등 엔터티와 관련된 모든일을 한다. 하지만 위의 EntityManagerFactory는 달리 Thread Safe하지 않기때문에 동시성 문제가 발생하므로 스레드간에 절대 공유하면 안 된다. 그래서 일반적으로 EntityManager를 EntityManagerFactory를 이용하여 생성한것을 사용하는것이 아닌 스프링에서 관리하는 EntityManager를 아래와 같이 선언하여 사용한다. 이렇게되면 스프링에서 알아서 EntityManager를 Proxy로 깜싼 EntityManager를 생성 하여 주입해주기 때문에 Thread-Safety를 보장 한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PersistenceContext</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> EntityManager entityManager;</span><br></pre></td></tr></table></figure>\n<h4><span id=\"entitymanager-정리\">EntityManager 정리</span></h4>\n<ul>\n<li>Hibernate에서는 Session(EntityManager)으로 불리운다.</li>\n<li>엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유하면 안된다.</li>\n</ul>\n<h3><span id=\"persistencecontext영속성-컨텍스트란\">PersistenceContext(영속성 컨텍스트)란</span></h3>\n<ul>\n<li>영속성 컨텍스트란 엔티티(Entity)를 영구 저장 하는 환경을 말한다. 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.</li>\n<li>영속성 컨텍스트는 엔티티 매니저(Session)를 생성할 때 하나 만들어진다. 그리고 엔티티 매니저(Session)를 통해서 영속성 컨텍스트에 접근할 수 있고 영속성 컨텍스트를 관리 할 수 있다.</li>\n<li>여러 엔티티 매니저(Session)가 같은 영속성 컨텍스트에 접근할 수도 있다.</li>\n</ul>\n<p>참조</p>\n<ul>\n<li><a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=9252528\" target=\"_blank\" rel=\"noopener\">자바 ORM 표준 JPA 프로그래밍</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>EntityManagerFactory, EntityManager, PersistenceContext란?</h2>\n<h3>EntityManagerFactory란</h3>\n<p>데이터베이스를 하나만 사용하는 애플리케이션들은 일반적으로 EntityManagerFactory를 한개만 생성한다. 이 엔터티 매니저 팩토리로 엔터티 매니저를 생성할 수 있다. EntityManagerFactory는 Thread Safe해서 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드간에 공유해새 사용한다.</p>\n<h4>EntityManagerFactory 정리</h4>\n<ul>\n<li>Hibernate에서는 SessionFactory(EntityManagerFactory)</li>\n<li>엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하다.(thread-safe)</li>\n<li>EntityManager를 생성한다.</li>\n</ul>\n<h3>EntityManager란</h3>\n<p>엔터티 매니저는 엔터티를 저장하는 메모리상의 데이터베이스라고 생각하면 될 것같다. 엔터티 매니저는 엔터티를 저장하고 수정하고 삭제하고 조회하는 등 엔터티와 관련된 모든일을 한다. 하지만 위의 EntityManagerFactory는 달리 Thread Safe하지 않기때문에 동시성 문제가 발생하므로 스레드간에 절대 공유하면 안 된다. 그래서 일반적으로 EntityManager를 EntityManagerFactory를 이용하여 생성한것을 사용하는것이 아닌 스프링에서 관리하는 EntityManager를 아래와 같이 선언하여 사용한다. 이렇게되면 스프링에서 알아서 EntityManager를 Proxy로 깜싼 EntityManager를 생성 하여 주입해주기 때문에 Thread-Safety를 보장 한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PersistenceContext</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> EntityManager entityManager;</span><br></pre></td></tr></table></figure>\n<h4>EntityManager 정리</h4>\n<ul>\n<li>Hibernate에서는 Session(EntityManager)으로 불리운다.</li>\n<li>엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유하면 안된다.</li>\n</ul>\n<h3>PersistenceContext(영속성 컨텍스트)란</h3>\n<ul>\n<li>영속성 컨텍스트란 엔티티(Entity)를 영구 저장 하는 환경을 말한다. 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다.</li>\n<li>영속성 컨텍스트는 엔티티 매니저(Session)를 생성할 때 하나 만들어진다. 그리고 엔티티 매니저(Session)를 통해서 영속성 컨텍스트에 접근할 수 있고 영속성 컨텍스트를 관리 할 수 있다.</li>\n<li>여러 엔티티 매니저(Session)가 같은 영속성 컨텍스트에 접근할 수도 있다.</li>\n</ul>\n<p>참조</p>\n<ul>\n<li><a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=9252528\" target=\"_blank\" rel=\"noopener\">자바 ORM 표준 JPA 프로그래밍</a></li>\n</ul>\n"},{"title":"Intellij로 효율적으로 개발하기(1) - Intellij Refactoring 기능","catalog":true,"date":"2018-07-25T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n## Intellij로 효율적으로 개발하기(1) - Intellij Refactoring 기능\n개발을 하다보면 Intellij의 리팩토링을 정말 많이 사용합니다. 가장 대표적인 예가 클래스나 변수명 등 네이밍 변경 같은 경우가 될 수 있습니다. 만약 프로젝트 내에 모든 클래스를 변경하는데 손수 하나하나 네이밍을 변경하게 된다면 엄청난 시간을 허비해야 할 것입니다.\n\n하지만 Intelij에서 Rename과 같은 기능을 이용한다면 한 번에 효율적으로 모든 네이밍을 변경할 수 있습니다. 이러한 네이밍 변경과 같이 효율적인 리팩토링 기능이 어떤 것들이 있는지 알아보겠습니다.\n\n키보드는 맥 기준으로 설명해드리겠습니다. 윈도우같은경우 스크린샷안에 내용을 참조해주시면 감사하겠습니다.\n\n\n### Rename 기능\n변수, 클래스, 메소드명을 한 번에 변경해야할 때 사용되는 기능입니다. \n단축키 : ⇧F6\n\n![](https://media.giphy.com/media/2ZYF2T6oZhwRQSOc9U/giphy.gif)\n\nCalculator2라는 클래스명을 변경했습니다. 변경 후 뜨는 창은 현재 Calclator2클래스를 사용하고 있는 변수들도 변경할지 물어보는 창입니다. 같이 선택을 하게 되면 사용되는 변수들도 함께 Calculator로 변경이 됩니다.\n\n\n### 시그니처(파라미터) 변경 기능\n이기능은 클래스또는 메소드에 관련된 있는 있는 시그니처(파라미터)를 동시에 변경하고자할 때 사용되는 기능입니다. 예를들어 오버라이딩된 클래스, implements한 클래스, 호출되어지는 메소드 등이 대상입니다. \n\n단축키 : ⌘F6\n\n![](https://media.giphy.com/media/g4M2XpYWQzyvZIKpog/giphy.gif)\n\n### 메소드 추출하기\n이기능은 기존 메소드내에 기능이 2개라고 생각할 때 다른 메소드로 분리해내는 기능입니다.\n단축키 : ⌥⌘M\n![](https://media.giphy.com/media/cI43RnYZYe4F3Crg5s/giphy.gif)\n다음과 같이 계산하는 메소드가 있다고 했을때 여기에서 더하기 기능을 메소드로 빼내고싶다면 위와같이 추출해낼 수 있습니다.\n\n\n### inline 기능 사용하기\n이기능은 두개의 라인이 하나의 라인으로 합쳐져도 무방할 때 사용하는 기능입니다. 예를들어 다음과같이 Calculator클래스의 add라는 함수를 사용했을 때 c라는 결과값이 나오게됩니다. 그리고 c를 return하여 할수를 종료합니다. 하지만 여기에서 바로 add(a,b)를 리턴할 수 있습니다. 이렇게 하나의 라인으로 합치려고할때 사용할 수 있습니다.\n\n단축키 : ⌥⌘N\n![](https://media.giphy.com/media/8FGM8CmvLj1DzGgkUl/giphy.gif)\n\n### 변수 추출하기\n다음 기능은 변수가 선언되지 않은 연산을 변수로 추출해낼 떄 사용하는 기능입니다. \n단축키 : ⌥⌘V\n![](https://media.giphy.com/media/3MfkF5HSKKDXtKJnkD/giphy.gif)\n\n### 필드 변수로 추출하기\n다음기능은 로컬변수를 필드변수로 뽑아낼 때 사용하는 기능입니다.\n단축키 : ⌥⌘F\n![](https://media.giphy.com/media/3FlLs9iLtklaDrUdD2/giphy.gif)\n\n### 파라미터 추출하기\n다음은 메소드나, 생성자에 있는 파라미터에 필드를 추가하고싶을 때 사용 하는 기능이다. \n\n단축키 : ⌥⌘P\n![](https://media.giphy.com/media/1gTQTENa4OtKhwBnEz/giphy.gif)\n\n\n### 클래스 추출하기\n다음은 하나의 클래스의 기능이 너무커지거나 메소드의 기능이 너무 커질때 해당 기능을 클래스로 분리해내는 기능입니다. \n단축키 : ⌃T -> 9.Delegate\n![](https://media.giphy.com/media/xUb9f91b5mCZlptTzd/giphy.gif)\n\n\n### 사용되지 않는 내용 삭제하기\n다음은 사용되지 않는 변수, 클래스, 메소드등 삭제할 때 해당 기능을 안전하게 제거하는 기능입니다. 그림과 같이 사용되지 않는 곳에가서 ⌥enter 클릭하게되면 Intellij에서 safe-delete를 제안해줍니다. Minus가 어디에서 호출되지는 않지만 Minus와 관련된 변수, 메소드가있는경우 스샷과 같이 Intellij에서 관련된것들도 같이 삭제할건지 물어보게됩니다. 이과정을 검토한후 삭제를 하게되면 안전하게 소스를 지우실 수 있습니다. 이기능을 이용하면 사용되지 않는 소스들을 깔끔하게 지우실 수 있습니다.\n단축키 : ⌥enter -> safe-delete\n![](https://media.giphy.com/media/21S3x4GAh4XeHZDqZq/giphy.gif)\n\n\n### ⌃T, ⌥enter 사용하기\n리팩토링 하려고 하는 대상으로 가셔서 ⌃T, ⌥enter 둘중 하나를 클릭하시면 좀더 많은 기능들의 intellij의 리팩토링을 이용하 실 수 있습니다. ⌃T는 입력하시면 Intellij에서 미리 목록화 해놓은 리팩토링 기능의 목록을 보실 수 있습니다. ⌥enter 같은 경우에는 Intellij에서 해당 소스를 파악하고 제안해주는 리팩토링 기능을 확인하실 수 있습니다. 물론 intellij에서 refactoring할 대상을 찾지 못한다면 제안 되는 리팩토링기능은 없을것입니다.\n\n\n\n참고\n* [Yun-blog](https://cheese10yun.github.io/intellij-refactoring/)\n* [Jetbrain](https://www.jetbrains.com/)","source":"_posts/2018-07-26-intellij.md","raw":"---\ntitle: Intellij로 효율적으로 개발하기(1) - Intellij Refactoring 기능\ncatalog: true\ndate: 2018-07-26\nsubtitle:\nheader-img:\ntags:\n- Intellij\n- Java\n\n\n---\n\n## Intellij로 효율적으로 개발하기(1) - Intellij Refactoring 기능\n개발을 하다보면 Intellij의 리팩토링을 정말 많이 사용합니다. 가장 대표적인 예가 클래스나 변수명 등 네이밍 변경 같은 경우가 될 수 있습니다. 만약 프로젝트 내에 모든 클래스를 변경하는데 손수 하나하나 네이밍을 변경하게 된다면 엄청난 시간을 허비해야 할 것입니다.\n\n하지만 Intelij에서 Rename과 같은 기능을 이용한다면 한 번에 효율적으로 모든 네이밍을 변경할 수 있습니다. 이러한 네이밍 변경과 같이 효율적인 리팩토링 기능이 어떤 것들이 있는지 알아보겠습니다.\n\n키보드는 맥 기준으로 설명해드리겠습니다. 윈도우같은경우 스크린샷안에 내용을 참조해주시면 감사하겠습니다.\n\n\n### Rename 기능\n변수, 클래스, 메소드명을 한 번에 변경해야할 때 사용되는 기능입니다. \n단축키 : ⇧F6\n\n![](https://media.giphy.com/media/2ZYF2T6oZhwRQSOc9U/giphy.gif)\n\nCalculator2라는 클래스명을 변경했습니다. 변경 후 뜨는 창은 현재 Calclator2클래스를 사용하고 있는 변수들도 변경할지 물어보는 창입니다. 같이 선택을 하게 되면 사용되는 변수들도 함께 Calculator로 변경이 됩니다.\n\n\n### 시그니처(파라미터) 변경 기능\n이기능은 클래스또는 메소드에 관련된 있는 있는 시그니처(파라미터)를 동시에 변경하고자할 때 사용되는 기능입니다. 예를들어 오버라이딩된 클래스, implements한 클래스, 호출되어지는 메소드 등이 대상입니다. \n\n단축키 : ⌘F6\n\n![](https://media.giphy.com/media/g4M2XpYWQzyvZIKpog/giphy.gif)\n\n### 메소드 추출하기\n이기능은 기존 메소드내에 기능이 2개라고 생각할 때 다른 메소드로 분리해내는 기능입니다.\n단축키 : ⌥⌘M\n![](https://media.giphy.com/media/cI43RnYZYe4F3Crg5s/giphy.gif)\n다음과 같이 계산하는 메소드가 있다고 했을때 여기에서 더하기 기능을 메소드로 빼내고싶다면 위와같이 추출해낼 수 있습니다.\n\n\n### inline 기능 사용하기\n이기능은 두개의 라인이 하나의 라인으로 합쳐져도 무방할 때 사용하는 기능입니다. 예를들어 다음과같이 Calculator클래스의 add라는 함수를 사용했을 때 c라는 결과값이 나오게됩니다. 그리고 c를 return하여 할수를 종료합니다. 하지만 여기에서 바로 add(a,b)를 리턴할 수 있습니다. 이렇게 하나의 라인으로 합치려고할때 사용할 수 있습니다.\n\n단축키 : ⌥⌘N\n![](https://media.giphy.com/media/8FGM8CmvLj1DzGgkUl/giphy.gif)\n\n### 변수 추출하기\n다음 기능은 변수가 선언되지 않은 연산을 변수로 추출해낼 떄 사용하는 기능입니다. \n단축키 : ⌥⌘V\n![](https://media.giphy.com/media/3MfkF5HSKKDXtKJnkD/giphy.gif)\n\n### 필드 변수로 추출하기\n다음기능은 로컬변수를 필드변수로 뽑아낼 때 사용하는 기능입니다.\n단축키 : ⌥⌘F\n![](https://media.giphy.com/media/3FlLs9iLtklaDrUdD2/giphy.gif)\n\n### 파라미터 추출하기\n다음은 메소드나, 생성자에 있는 파라미터에 필드를 추가하고싶을 때 사용 하는 기능이다. \n\n단축키 : ⌥⌘P\n![](https://media.giphy.com/media/1gTQTENa4OtKhwBnEz/giphy.gif)\n\n\n### 클래스 추출하기\n다음은 하나의 클래스의 기능이 너무커지거나 메소드의 기능이 너무 커질때 해당 기능을 클래스로 분리해내는 기능입니다. \n단축키 : ⌃T -> 9.Delegate\n![](https://media.giphy.com/media/xUb9f91b5mCZlptTzd/giphy.gif)\n\n\n### 사용되지 않는 내용 삭제하기\n다음은 사용되지 않는 변수, 클래스, 메소드등 삭제할 때 해당 기능을 안전하게 제거하는 기능입니다. 그림과 같이 사용되지 않는 곳에가서 ⌥enter 클릭하게되면 Intellij에서 safe-delete를 제안해줍니다. Minus가 어디에서 호출되지는 않지만 Minus와 관련된 변수, 메소드가있는경우 스샷과 같이 Intellij에서 관련된것들도 같이 삭제할건지 물어보게됩니다. 이과정을 검토한후 삭제를 하게되면 안전하게 소스를 지우실 수 있습니다. 이기능을 이용하면 사용되지 않는 소스들을 깔끔하게 지우실 수 있습니다.\n단축키 : ⌥enter -> safe-delete\n![](https://media.giphy.com/media/21S3x4GAh4XeHZDqZq/giphy.gif)\n\n\n### ⌃T, ⌥enter 사용하기\n리팩토링 하려고 하는 대상으로 가셔서 ⌃T, ⌥enter 둘중 하나를 클릭하시면 좀더 많은 기능들의 intellij의 리팩토링을 이용하 실 수 있습니다. ⌃T는 입력하시면 Intellij에서 미리 목록화 해놓은 리팩토링 기능의 목록을 보실 수 있습니다. ⌥enter 같은 경우에는 Intellij에서 해당 소스를 파악하고 제안해주는 리팩토링 기능을 확인하실 수 있습니다. 물론 intellij에서 refactoring할 대상을 찾지 못한다면 제안 되는 리팩토링기능은 없을것입니다.\n\n\n\n참고\n* [Yun-blog](https://cheese10yun.github.io/intellij-refactoring/)\n* [Jetbrain](https://www.jetbrains.com/)","slug":"2018-07-26-intellij","published":1,"updated":"2018-07-25T15:32:38.011Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27bv0016jjpeztnxg66o","content":"<h2><span id=\"intellij로-효율적으로-개발하기1-intellij-refactoring-기능\">Intellij로 효율적으로 개발하기(1) - Intellij Refactoring 기능</span></h2>\n<p>개발을 하다보면 Intellij의 리팩토링을 정말 많이 사용합니다. 가장 대표적인 예가 클래스나 변수명 등 네이밍 변경 같은 경우가 될 수 있습니다. 만약 프로젝트 내에 모든 클래스를 변경하는데 손수 하나하나 네이밍을 변경하게 된다면 엄청난 시간을 허비해야 할 것입니다.</p>\n<p>하지만 Intelij에서 Rename과 같은 기능을 이용한다면 한 번에 효율적으로 모든 네이밍을 변경할 수 있습니다. 이러한 네이밍 변경과 같이 효율적인 리팩토링 기능이 어떤 것들이 있는지 알아보겠습니다.</p>\n<p>키보드는 맥 기준으로 설명해드리겠습니다. 윈도우같은경우 스크린샷안에 내용을 참조해주시면 감사하겠습니다.</p>\n<h3><span id=\"rename-기능\">Rename 기능</span></h3>\n<p>변수, 클래스, 메소드명을 한 번에 변경해야할 때 사용되는 기능입니다.<br>\n단축키 : ⇧F6</p>\n<p><img src=\"https://media.giphy.com/media/2ZYF2T6oZhwRQSOc9U/giphy.gif\" alt=\"\"></p>\n<p>Calculator2라는 클래스명을 변경했습니다. 변경 후 뜨는 창은 현재 Calclator2클래스를 사용하고 있는 변수들도 변경할지 물어보는 창입니다. 같이 선택을 하게 되면 사용되는 변수들도 함께 Calculator로 변경이 됩니다.</p>\n<h3><span id=\"시그니처파라미터-변경-기능\">시그니처(파라미터) 변경 기능</span></h3>\n<p>이기능은 클래스또는 메소드에 관련된 있는 있는 시그니처(파라미터)를 동시에 변경하고자할 때 사용되는 기능입니다. 예를들어 오버라이딩된 클래스, implements한 클래스, 호출되어지는 메소드 등이 대상입니다.</p>\n<p>단축키 : ⌘F6</p>\n<p><img src=\"https://media.giphy.com/media/g4M2XpYWQzyvZIKpog/giphy.gif\" alt=\"\"></p>\n<h3><span id=\"메소드-추출하기\">메소드 추출하기</span></h3>\n<p>이기능은 기존 메소드내에 기능이 2개라고 생각할 때 다른 메소드로 분리해내는 기능입니다.<br>\n단축키 : ⌥⌘M<br>\n<img src=\"https://media.giphy.com/media/cI43RnYZYe4F3Crg5s/giphy.gif\" alt=\"\"><br>\n다음과 같이 계산하는 메소드가 있다고 했을때 여기에서 더하기 기능을 메소드로 빼내고싶다면 위와같이 추출해낼 수 있습니다.</p>\n<h3><span id=\"inline-기능-사용하기\">inline 기능 사용하기</span></h3>\n<p>이기능은 두개의 라인이 하나의 라인으로 합쳐져도 무방할 때 사용하는 기능입니다. 예를들어 다음과같이 Calculator클래스의 add라는 함수를 사용했을 때 c라는 결과값이 나오게됩니다. 그리고 c를 return하여 할수를 종료합니다. 하지만 여기에서 바로 add(a,b)를 리턴할 수 있습니다. 이렇게 하나의 라인으로 합치려고할때 사용할 수 있습니다.</p>\n<p>단축키 : ⌥⌘N<br>\n<img src=\"https://media.giphy.com/media/8FGM8CmvLj1DzGgkUl/giphy.gif\" alt=\"\"></p>\n<h3><span id=\"변수-추출하기\">변수 추출하기</span></h3>\n<p>다음 기능은 변수가 선언되지 않은 연산을 변수로 추출해낼 떄 사용하는 기능입니다.<br>\n단축키 : ⌥⌘V<br>\n<img src=\"https://media.giphy.com/media/3MfkF5HSKKDXtKJnkD/giphy.gif\" alt=\"\"></p>\n<h3><span id=\"필드-변수로-추출하기\">필드 변수로 추출하기</span></h3>\n<p>다음기능은 로컬변수를 필드변수로 뽑아낼 때 사용하는 기능입니다.<br>\n단축키 : ⌥⌘F<br>\n<img src=\"https://media.giphy.com/media/3FlLs9iLtklaDrUdD2/giphy.gif\" alt=\"\"></p>\n<h3><span id=\"파라미터-추출하기\">파라미터 추출하기</span></h3>\n<p>다음은 메소드나, 생성자에 있는 파라미터에 필드를 추가하고싶을 때 사용 하는 기능이다.</p>\n<p>단축키 : ⌥⌘P<br>\n<img src=\"https://media.giphy.com/media/1gTQTENa4OtKhwBnEz/giphy.gif\" alt=\"\"></p>\n<h3><span id=\"클래스-추출하기\">클래스 추출하기</span></h3>\n<p>다음은 하나의 클래스의 기능이 너무커지거나 메소드의 기능이 너무 커질때 해당 기능을 클래스로 분리해내는 기능입니다.<br>\n단축키 : ⌃T -&gt; 9.Delegate<br>\n<img src=\"https://media.giphy.com/media/xUb9f91b5mCZlptTzd/giphy.gif\" alt=\"\"></p>\n<h3><span id=\"사용되지-않는-내용-삭제하기\">사용되지 않는 내용 삭제하기</span></h3>\n<p>다음은 사용되지 않는 변수, 클래스, 메소드등 삭제할 때 해당 기능을 안전하게 제거하는 기능입니다. 그림과 같이 사용되지 않는 곳에가서 ⌥enter 클릭하게되면 Intellij에서 safe-delete를 제안해줍니다. Minus가 어디에서 호출되지는 않지만 Minus와 관련된 변수, 메소드가있는경우 스샷과 같이 Intellij에서 관련된것들도 같이 삭제할건지 물어보게됩니다. 이과정을 검토한후 삭제를 하게되면 안전하게 소스를 지우실 수 있습니다. 이기능을 이용하면 사용되지 않는 소스들을 깔끔하게 지우실 수 있습니다.<br>\n단축키 : ⌥enter -&gt; safe-delete<br>\n<img src=\"https://media.giphy.com/media/21S3x4GAh4XeHZDqZq/giphy.gif\" alt=\"\"></p>\n<h3><span id=\"t-enter-사용하기\">⌃T, ⌥enter 사용하기</span></h3>\n<p>리팩토링 하려고 하는 대상으로 가셔서 ⌃T, ⌥enter 둘중 하나를 클릭하시면 좀더 많은 기능들의 intellij의 리팩토링을 이용하 실 수 있습니다. ⌃T는 입력하시면 Intellij에서 미리 목록화 해놓은 리팩토링 기능의 목록을 보실 수 있습니다. ⌥enter 같은 경우에는 Intellij에서 해당 소스를 파악하고 제안해주는 리팩토링 기능을 확인하실 수 있습니다. 물론 intellij에서 refactoring할 대상을 찾지 못한다면 제안 되는 리팩토링기능은 없을것입니다.</p>\n<p>참고</p>\n<ul>\n<li><a href=\"https://cheese10yun.github.io/intellij-refactoring/\" target=\"_blank\" rel=\"noopener\">Yun-blog</a></li>\n<li><a href=\"https://www.jetbrains.com/\" target=\"_blank\" rel=\"noopener\">Jetbrain</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>Intellij로 효율적으로 개발하기(1) - Intellij Refactoring 기능</h2>\n<p>개발을 하다보면 Intellij의 리팩토링을 정말 많이 사용합니다. 가장 대표적인 예가 클래스나 변수명 등 네이밍 변경 같은 경우가 될 수 있습니다. 만약 프로젝트 내에 모든 클래스를 변경하는데 손수 하나하나 네이밍을 변경하게 된다면 엄청난 시간을 허비해야 할 것입니다.</p>\n<p>하지만 Intelij에서 Rename과 같은 기능을 이용한다면 한 번에 효율적으로 모든 네이밍을 변경할 수 있습니다. 이러한 네이밍 변경과 같이 효율적인 리팩토링 기능이 어떤 것들이 있는지 알아보겠습니다.</p>\n<p>키보드는 맥 기준으로 설명해드리겠습니다. 윈도우같은경우 스크린샷안에 내용을 참조해주시면 감사하겠습니다.</p>\n<h3>Rename 기능</h3>\n<p>변수, 클래스, 메소드명을 한 번에 변경해야할 때 사용되는 기능입니다.<br>\n단축키 : ⇧F6</p>\n<p><img src=\"https://media.giphy.com/media/2ZYF2T6oZhwRQSOc9U/giphy.gif\" alt=\"\"></p>\n<p>Calculator2라는 클래스명을 변경했습니다. 변경 후 뜨는 창은 현재 Calclator2클래스를 사용하고 있는 변수들도 변경할지 물어보는 창입니다. 같이 선택을 하게 되면 사용되는 변수들도 함께 Calculator로 변경이 됩니다.</p>\n<h3>시그니처(파라미터) 변경 기능</h3>\n<p>이기능은 클래스또는 메소드에 관련된 있는 있는 시그니처(파라미터)를 동시에 변경하고자할 때 사용되는 기능입니다. 예를들어 오버라이딩된 클래스, implements한 클래스, 호출되어지는 메소드 등이 대상입니다.</p>\n<p>단축키 : ⌘F6</p>\n<p><img src=\"https://media.giphy.com/media/g4M2XpYWQzyvZIKpog/giphy.gif\" alt=\"\"></p>\n<h3>메소드 추출하기</h3>\n<p>이기능은 기존 메소드내에 기능이 2개라고 생각할 때 다른 메소드로 분리해내는 기능입니다.<br>\n단축키 : ⌥⌘M<br>\n<img src=\"https://media.giphy.com/media/cI43RnYZYe4F3Crg5s/giphy.gif\" alt=\"\"><br>\n다음과 같이 계산하는 메소드가 있다고 했을때 여기에서 더하기 기능을 메소드로 빼내고싶다면 위와같이 추출해낼 수 있습니다.</p>\n<h3>inline 기능 사용하기</h3>\n<p>이기능은 두개의 라인이 하나의 라인으로 합쳐져도 무방할 때 사용하는 기능입니다. 예를들어 다음과같이 Calculator클래스의 add라는 함수를 사용했을 때 c라는 결과값이 나오게됩니다. 그리고 c를 return하여 할수를 종료합니다. 하지만 여기에서 바로 add(a,b)를 리턴할 수 있습니다. 이렇게 하나의 라인으로 합치려고할때 사용할 수 있습니다.</p>\n<p>단축키 : ⌥⌘N<br>\n<img src=\"https://media.giphy.com/media/8FGM8CmvLj1DzGgkUl/giphy.gif\" alt=\"\"></p>\n<h3>변수 추출하기</h3>\n<p>다음 기능은 변수가 선언되지 않은 연산을 변수로 추출해낼 떄 사용하는 기능입니다.<br>\n단축키 : ⌥⌘V<br>\n<img src=\"https://media.giphy.com/media/3MfkF5HSKKDXtKJnkD/giphy.gif\" alt=\"\"></p>\n<h3>필드 변수로 추출하기</h3>\n<p>다음기능은 로컬변수를 필드변수로 뽑아낼 때 사용하는 기능입니다.<br>\n단축키 : ⌥⌘F<br>\n<img src=\"https://media.giphy.com/media/3FlLs9iLtklaDrUdD2/giphy.gif\" alt=\"\"></p>\n<h3>파라미터 추출하기</h3>\n<p>다음은 메소드나, 생성자에 있는 파라미터에 필드를 추가하고싶을 때 사용 하는 기능이다.</p>\n<p>단축키 : ⌥⌘P<br>\n<img src=\"https://media.giphy.com/media/1gTQTENa4OtKhwBnEz/giphy.gif\" alt=\"\"></p>\n<h3>클래스 추출하기</h3>\n<p>다음은 하나의 클래스의 기능이 너무커지거나 메소드의 기능이 너무 커질때 해당 기능을 클래스로 분리해내는 기능입니다.<br>\n단축키 : ⌃T -&gt; 9.Delegate<br>\n<img src=\"https://media.giphy.com/media/xUb9f91b5mCZlptTzd/giphy.gif\" alt=\"\"></p>\n<h3>사용되지 않는 내용 삭제하기</h3>\n<p>다음은 사용되지 않는 변수, 클래스, 메소드등 삭제할 때 해당 기능을 안전하게 제거하는 기능입니다. 그림과 같이 사용되지 않는 곳에가서 ⌥enter 클릭하게되면 Intellij에서 safe-delete를 제안해줍니다. Minus가 어디에서 호출되지는 않지만 Minus와 관련된 변수, 메소드가있는경우 스샷과 같이 Intellij에서 관련된것들도 같이 삭제할건지 물어보게됩니다. 이과정을 검토한후 삭제를 하게되면 안전하게 소스를 지우실 수 있습니다. 이기능을 이용하면 사용되지 않는 소스들을 깔끔하게 지우실 수 있습니다.<br>\n단축키 : ⌥enter -&gt; safe-delete<br>\n<img src=\"https://media.giphy.com/media/21S3x4GAh4XeHZDqZq/giphy.gif\" alt=\"\"></p>\n<h3>⌃T, ⌥enter 사용하기</h3>\n<p>리팩토링 하려고 하는 대상으로 가셔서 ⌃T, ⌥enter 둘중 하나를 클릭하시면 좀더 많은 기능들의 intellij의 리팩토링을 이용하 실 수 있습니다. ⌃T는 입력하시면 Intellij에서 미리 목록화 해놓은 리팩토링 기능의 목록을 보실 수 있습니다. ⌥enter 같은 경우에는 Intellij에서 해당 소스를 파악하고 제안해주는 리팩토링 기능을 확인하실 수 있습니다. 물론 intellij에서 refactoring할 대상을 찾지 못한다면 제안 되는 리팩토링기능은 없을것입니다.</p>\n<p>참고</p>\n<ul>\n<li><a href=\"https://cheese10yun.github.io/intellij-refactoring/\" target=\"_blank\" rel=\"noopener\">Yun-blog</a></li>\n<li><a href=\"https://www.jetbrains.com/\" target=\"_blank\" rel=\"noopener\">Jetbrain</a></li>\n</ul>\n"},{"title":"온라인 서점 API 만들기로 살펴보는 Spring Boot OOP 1","catalog":true,"date":"2018-07-24T15:00:00.000Z","subtitle":"프로젝트 설계 및 프로젝트 생성","header-img":null,"_content":"\n# Step01 - 프로젝트 설계 및 프로젝트 생성\n\n이장에서는 아래의 내용을 중점으로 살펴볼 것 입니다\n* 어떤 서비스를 만들것인가.\n* 도메인구조, 테이블구조\n* 프로젝트구조\n* Spring boot 프로젝트 생성\n\n# 1. 어떤 서비스를 만들것인가.\n## 온라인 서점에서 한번에 여러개의 책을 주문할 수 있는 주문 시스템 API 서비스 구축\n간단히 말하면 위 소제목과 같은 간단한 API 서버를 만들 것입니다. 좀 더 상세히 말하면 아래와 같을 수 있습니다.\n1. 책을 주문하기 위해서는 Spring boot 온라인 서점 회원이어야 합니다.\n2. 회원은 여러 개의 주문 신청을 할 수 있습니다.\n3. 주문을 할 때 한 번에 여러 개의 책을 주문할 수 있습니다.\n4. 책은 여러 주문의 의해 주문될 수 있습니다.\n5. 주문이 완료된 이후에 배송이 시작됩니다.\n6. 배송을 하기 위해서는 반드시 한 명의 수취인이 필요합니다.\n7. 이러한 주문 상태는 추적이 되어야 합니다\n\n위 요구 사항들 기반으로 어떠한 도메인들이 나올 수 있는지 확인해볼 것입니다. 좀 더 상세한 요구 조건은 실제 구현을 하면서 정의하겠습니다.\n\n\n# 2. 도메인구조, 테이블구조\n\n위 내용을 토대로 크게 아래와 같은 도메인들이 나올 수 있을것입니다.\n\n![](https://i.imgur.com/HQ5kFIO.png)\n\n위 도메인을 기반으로 아래와 같은 테이블 구조가 나올 수 있을것입니다. 물론 추가 요구사항등이 있으면 테이블 구조, 도메인구조는 변경되어질 수 있습니다.(온라인 글 연재에 장점이라고생각합니다. 물론 너무많은 변화는 없도록 노력할것입니다.)\n\n![](https://i.imgur.com/fhDMa1c.png)\n\n위 그림들을 보면 테이블 구조와 객체 도메인 구조가 다르다는것을 보실 수 있습니다. 이러한 이유는 도메인 하나가 테이블 엔터티를 의미하는것이 아니기 때문입니다. JPA 에서 여러개의 도메인은 하나의 테이블에 쉽게 저장할 수 있게 해줍니다. 예를들어 위의 그림처럼 배송, 수취인, 주소의 다른 도메인이 있지만 이것들을 함께 주문테이블에 쉽게 저장할 수 있게 해줍니다.\n\nJPA에서 도메인은 크게 엔터티와 벨류타입으로 나누어질 수 있습니다. JPA에서 엔터티와 벨류타입을 잘 분류해야만 응집력있는 코드를 작성할 수 있습니다. 도메인을 엔터티와 벨류 타입으로 나누는 기준의 큰 차이는 엔터티는 식별자를 가집니다. 반면 벨류타입은 식별자를 가지지않습니다. 이부분은 실제 엔터티와 벨류타입으로 데이터를 생성할 때 좀 더 자세히 알아보겠습니다. \n\n\n\n# 3. 프로젝트 구조\n프로젝트 구조는 다음과 같이 이루어질것입니다.\n\n![](https://i.imgur.com/gkCTUtC.png)\n\n\n\n| 계층               | 설명                                                                                                                                                                                                       |\n| ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **표현영역**           | 클라이언트에 요청을받아 그것을 응용 영역에 전달하고 응용영역에서 처리한값을 클라이언트에게 전달하는 역할을 합니다. 클라이언트로부터 HTTP요청을 받아 처리후 JSON형태로 클라이언트에 전달하는 역할을 합니다. |\n| **응용영역**           | 표현 계층으로부터 전달받은 데이터를 기반으로 비지니스 로직을 수행하기보다는 도메인들한테 시키는 역할을합니다.                                                                                              |\n| **도메인영역**         | 도메인들에 핵심 로직을 구현하는 역할입니다.(객체지향 관점에 맞게 객체한테 시키시킨다고 보시면됩니다.)                                                                                                      |\n| **인프라스트럭쳐영역** | 이 영역은 DB, 외부 api 등에 대한 처리를 하는 영역입니다. 그렇게해야 응용 영역에서 통일된 데이터를 사용할 수 있습니다.                                                                                      | \n\n\n각 계층은 자신의 계층의 책임에만 집중해야합니다. 자신의 영역을 넘어서는 코드를 짜게되면 코드가 복잡해지고 코드의 응집력이 떨어지게됩니다. 결국엔 변화에대한 유연성이 떨어지고 이해하기 힘든코드가되어 유지보수가 힘들어집니다. 그러기때문에 항상 이것을 염두하고 코딩을 해야한다고 생각합니다.\n\n\n# 4.Spring boot 프로젝트 생성\n프로젝트 생성은 intellij 기준으로 설명하겠습니다!\n먼저 NewProject 를 생성한후 아래와 같은 플로우로 프로젝트를 생성하실 수 있습니다.\n\n\n![](https://i.imgur.com/U8e5Hsz.png)\n![](https://i.imgur.com/zSi623M.png)\n기본적으로 프로젝트를 진행하기위해 아래와같은 의존성 라이브러리들을 선택해줘야합니다.\n![](https://i.imgur.com/ZX16NBf.png)\n여기에서 버전을 2.0.3으로되어있는데요. 이프로젝트에서는 1.5.9를 사용합니다. 프로젝트가 만들어진 이후 pom.xml에서 변경하실 수 있습니다.\n\n![](https://i.imgur.com/6Kk0Bj9.png)\n\n최종적으로 Finish를 누르면 프로젝트 생성이됩니다. \n\n# 마치며\n다음장부터 본격적으로 API서버를 만들어보는 시간을 가져보겠습니다!","source":"_posts/2018-07-26-spring-book-1.md","raw":"---\ntitle: 온라인 서점 API 만들기로 살펴보는 Spring Boot OOP 1\ncatalog: true\ndate: 2018-07-25\nsubtitle: 프로젝트 설계 및 프로젝트 생성\nheader-img:\ntags:\n- Java\n- Spring\n- 온라인 서점 API 만들기로 살펴보는 Spring Boot OOP\n\n\n---\n\n# Step01 - 프로젝트 설계 및 프로젝트 생성\n\n이장에서는 아래의 내용을 중점으로 살펴볼 것 입니다\n* 어떤 서비스를 만들것인가.\n* 도메인구조, 테이블구조\n* 프로젝트구조\n* Spring boot 프로젝트 생성\n\n# 1. 어떤 서비스를 만들것인가.\n## 온라인 서점에서 한번에 여러개의 책을 주문할 수 있는 주문 시스템 API 서비스 구축\n간단히 말하면 위 소제목과 같은 간단한 API 서버를 만들 것입니다. 좀 더 상세히 말하면 아래와 같을 수 있습니다.\n1. 책을 주문하기 위해서는 Spring boot 온라인 서점 회원이어야 합니다.\n2. 회원은 여러 개의 주문 신청을 할 수 있습니다.\n3. 주문을 할 때 한 번에 여러 개의 책을 주문할 수 있습니다.\n4. 책은 여러 주문의 의해 주문될 수 있습니다.\n5. 주문이 완료된 이후에 배송이 시작됩니다.\n6. 배송을 하기 위해서는 반드시 한 명의 수취인이 필요합니다.\n7. 이러한 주문 상태는 추적이 되어야 합니다\n\n위 요구 사항들 기반으로 어떠한 도메인들이 나올 수 있는지 확인해볼 것입니다. 좀 더 상세한 요구 조건은 실제 구현을 하면서 정의하겠습니다.\n\n\n# 2. 도메인구조, 테이블구조\n\n위 내용을 토대로 크게 아래와 같은 도메인들이 나올 수 있을것입니다.\n\n![](https://i.imgur.com/HQ5kFIO.png)\n\n위 도메인을 기반으로 아래와 같은 테이블 구조가 나올 수 있을것입니다. 물론 추가 요구사항등이 있으면 테이블 구조, 도메인구조는 변경되어질 수 있습니다.(온라인 글 연재에 장점이라고생각합니다. 물론 너무많은 변화는 없도록 노력할것입니다.)\n\n![](https://i.imgur.com/fhDMa1c.png)\n\n위 그림들을 보면 테이블 구조와 객체 도메인 구조가 다르다는것을 보실 수 있습니다. 이러한 이유는 도메인 하나가 테이블 엔터티를 의미하는것이 아니기 때문입니다. JPA 에서 여러개의 도메인은 하나의 테이블에 쉽게 저장할 수 있게 해줍니다. 예를들어 위의 그림처럼 배송, 수취인, 주소의 다른 도메인이 있지만 이것들을 함께 주문테이블에 쉽게 저장할 수 있게 해줍니다.\n\nJPA에서 도메인은 크게 엔터티와 벨류타입으로 나누어질 수 있습니다. JPA에서 엔터티와 벨류타입을 잘 분류해야만 응집력있는 코드를 작성할 수 있습니다. 도메인을 엔터티와 벨류 타입으로 나누는 기준의 큰 차이는 엔터티는 식별자를 가집니다. 반면 벨류타입은 식별자를 가지지않습니다. 이부분은 실제 엔터티와 벨류타입으로 데이터를 생성할 때 좀 더 자세히 알아보겠습니다. \n\n\n\n# 3. 프로젝트 구조\n프로젝트 구조는 다음과 같이 이루어질것입니다.\n\n![](https://i.imgur.com/gkCTUtC.png)\n\n\n\n| 계층               | 설명                                                                                                                                                                                                       |\n| ------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **표현영역**           | 클라이언트에 요청을받아 그것을 응용 영역에 전달하고 응용영역에서 처리한값을 클라이언트에게 전달하는 역할을 합니다. 클라이언트로부터 HTTP요청을 받아 처리후 JSON형태로 클라이언트에 전달하는 역할을 합니다. |\n| **응용영역**           | 표현 계층으로부터 전달받은 데이터를 기반으로 비지니스 로직을 수행하기보다는 도메인들한테 시키는 역할을합니다.                                                                                              |\n| **도메인영역**         | 도메인들에 핵심 로직을 구현하는 역할입니다.(객체지향 관점에 맞게 객체한테 시키시킨다고 보시면됩니다.)                                                                                                      |\n| **인프라스트럭쳐영역** | 이 영역은 DB, 외부 api 등에 대한 처리를 하는 영역입니다. 그렇게해야 응용 영역에서 통일된 데이터를 사용할 수 있습니다.                                                                                      | \n\n\n각 계층은 자신의 계층의 책임에만 집중해야합니다. 자신의 영역을 넘어서는 코드를 짜게되면 코드가 복잡해지고 코드의 응집력이 떨어지게됩니다. 결국엔 변화에대한 유연성이 떨어지고 이해하기 힘든코드가되어 유지보수가 힘들어집니다. 그러기때문에 항상 이것을 염두하고 코딩을 해야한다고 생각합니다.\n\n\n# 4.Spring boot 프로젝트 생성\n프로젝트 생성은 intellij 기준으로 설명하겠습니다!\n먼저 NewProject 를 생성한후 아래와 같은 플로우로 프로젝트를 생성하실 수 있습니다.\n\n\n![](https://i.imgur.com/U8e5Hsz.png)\n![](https://i.imgur.com/zSi623M.png)\n기본적으로 프로젝트를 진행하기위해 아래와같은 의존성 라이브러리들을 선택해줘야합니다.\n![](https://i.imgur.com/ZX16NBf.png)\n여기에서 버전을 2.0.3으로되어있는데요. 이프로젝트에서는 1.5.9를 사용합니다. 프로젝트가 만들어진 이후 pom.xml에서 변경하실 수 있습니다.\n\n![](https://i.imgur.com/6Kk0Bj9.png)\n\n최종적으로 Finish를 누르면 프로젝트 생성이됩니다. \n\n# 마치며\n다음장부터 본격적으로 API서버를 만들어보는 시간을 가져보겠습니다!","slug":"2018-07-26-spring-book-1","published":1,"updated":"2018-08-01T14:17:48.958Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27bw0019jjpekoyaivj4","content":"<h1><span id=\"step01-프로젝트-설계-및-프로젝트-생성\">Step01 - 프로젝트 설계 및 프로젝트 생성</span></h1>\n<p>이장에서는 아래의 내용을 중점으로 살펴볼 것 입니다</p>\n<ul>\n<li>어떤 서비스를 만들것인가.</li>\n<li>도메인구조, 테이블구조</li>\n<li>프로젝트구조</li>\n<li>Spring boot 프로젝트 생성</li>\n</ul>\n<h1><span id=\"1-어떤-서비스를-만들것인가\">1. 어떤 서비스를 만들것인가.</span></h1>\n<h2><span id=\"온라인-서점에서-한번에-여러개의-책을-주문할-수-있는-주문-시스템-api-서비스-구축\">온라인 서점에서 한번에 여러개의 책을 주문할 수 있는 주문 시스템 API 서비스 구축</span></h2>\n<p>간단히 말하면 위 소제목과 같은 간단한 API 서버를 만들 것입니다. 좀 더 상세히 말하면 아래와 같을 수 있습니다.</p>\n<ol>\n<li>책을 주문하기 위해서는 Spring boot 온라인 서점 회원이어야 합니다.</li>\n<li>회원은 여러 개의 주문 신청을 할 수 있습니다.</li>\n<li>주문을 할 때 한 번에 여러 개의 책을 주문할 수 있습니다.</li>\n<li>책은 여러 주문의 의해 주문될 수 있습니다.</li>\n<li>주문이 완료된 이후에 배송이 시작됩니다.</li>\n<li>배송을 하기 위해서는 반드시 한 명의 수취인이 필요합니다.</li>\n<li>이러한 주문 상태는 추적이 되어야 합니다</li>\n</ol>\n<p>위 요구 사항들 기반으로 어떠한 도메인들이 나올 수 있는지 확인해볼 것입니다. 좀 더 상세한 요구 조건은 실제 구현을 하면서 정의하겠습니다.</p>\n<h1><span id=\"2-도메인구조-테이블구조\">2. 도메인구조, 테이블구조</span></h1>\n<p>위 내용을 토대로 크게 아래와 같은 도메인들이 나올 수 있을것입니다.</p>\n<p><img src=\"https://i.imgur.com/HQ5kFIO.png\" alt=\"\"></p>\n<p>위 도메인을 기반으로 아래와 같은 테이블 구조가 나올 수 있을것입니다. 물론 추가 요구사항등이 있으면 테이블 구조, 도메인구조는 변경되어질 수 있습니다.(온라인 글 연재에 장점이라고생각합니다. 물론 너무많은 변화는 없도록 노력할것입니다.)</p>\n<p><img src=\"https://i.imgur.com/fhDMa1c.png\" alt=\"\"></p>\n<p>위 그림들을 보면 테이블 구조와 객체 도메인 구조가 다르다는것을 보실 수 있습니다. 이러한 이유는 도메인 하나가 테이블 엔터티를 의미하는것이 아니기 때문입니다. JPA 에서 여러개의 도메인은 하나의 테이블에 쉽게 저장할 수 있게 해줍니다. 예를들어 위의 그림처럼 배송, 수취인, 주소의 다른 도메인이 있지만 이것들을 함께 주문테이블에 쉽게 저장할 수 있게 해줍니다.</p>\n<p>JPA에서 도메인은 크게 엔터티와 벨류타입으로 나누어질 수 있습니다. JPA에서 엔터티와 벨류타입을 잘 분류해야만 응집력있는 코드를 작성할 수 있습니다. 도메인을 엔터티와 벨류 타입으로 나누는 기준의 큰 차이는 엔터티는 식별자를 가집니다. 반면 벨류타입은 식별자를 가지지않습니다. 이부분은 실제 엔터티와 벨류타입으로 데이터를 생성할 때 좀 더 자세히 알아보겠습니다.</p>\n<h1><span id=\"3-프로젝트-구조\">3. 프로젝트 구조</span></h1>\n<p>프로젝트 구조는 다음과 같이 이루어질것입니다.</p>\n<p><img src=\"https://i.imgur.com/gkCTUtC.png\" alt=\"\"></p>\n<table>\n<thead>\n<tr>\n<th>계층</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>표현영역</strong></td>\n<td>클라이언트에 요청을받아 그것을 응용 영역에 전달하고 응용영역에서 처리한값을 클라이언트에게 전달하는 역할을 합니다. 클라이언트로부터 HTTP요청을 받아 처리후 JSON형태로 클라이언트에 전달하는 역할을 합니다.</td>\n</tr>\n<tr>\n<td><strong>응용영역</strong></td>\n<td>표현 계층으로부터 전달받은 데이터를 기반으로 비지니스 로직을 수행하기보다는 도메인들한테 시키는 역할을합니다.</td>\n</tr>\n<tr>\n<td><strong>도메인영역</strong></td>\n<td>도메인들에 핵심 로직을 구현하는 역할입니다.(객체지향 관점에 맞게 객체한테 시키시킨다고 보시면됩니다.)</td>\n</tr>\n<tr>\n<td><strong>인프라스트럭쳐영역</strong></td>\n<td>이 영역은 DB, 외부 api 등에 대한 처리를 하는 영역입니다. 그렇게해야 응용 영역에서 통일된 데이터를 사용할 수 있습니다.</td>\n</tr>\n</tbody>\n</table>\n<p>각 계층은 자신의 계층의 책임에만 집중해야합니다. 자신의 영역을 넘어서는 코드를 짜게되면 코드가 복잡해지고 코드의 응집력이 떨어지게됩니다. 결국엔 변화에대한 유연성이 떨어지고 이해하기 힘든코드가되어 유지보수가 힘들어집니다. 그러기때문에 항상 이것을 염두하고 코딩을 해야한다고 생각합니다.</p>\n<h1><span id=\"4spring-boot-프로젝트-생성\">4.Spring boot 프로젝트 생성</span></h1>\n<p>프로젝트 생성은 intellij 기준으로 설명하겠습니다!<br>\n먼저 NewProject 를 생성한후 아래와 같은 플로우로 프로젝트를 생성하실 수 있습니다.</p>\n<p><img src=\"https://i.imgur.com/U8e5Hsz.png\" alt=\"\"><br>\n<img src=\"https://i.imgur.com/zSi623M.png\" alt=\"\"><br>\n기본적으로 프로젝트를 진행하기위해 아래와같은 의존성 라이브러리들을 선택해줘야합니다.<br>\n<img src=\"https://i.imgur.com/ZX16NBf.png\" alt=\"\"><br>\n여기에서 버전을 2.0.3으로되어있는데요. 이프로젝트에서는 1.5.9를 사용합니다. 프로젝트가 만들어진 이후 pom.xml에서 변경하실 수 있습니다.</p>\n<p><img src=\"https://i.imgur.com/6Kk0Bj9.png\" alt=\"\"></p>\n<p>최종적으로 Finish를 누르면 프로젝트 생성이됩니다.</p>\n<h1><span id=\"마치며\">마치며</span></h1>\n<p>다음장부터 본격적으로 API서버를 만들어보는 시간을 가져보겠습니다!</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>Step01 - 프로젝트 설계 및 프로젝트 생성</h1>\n<p>이장에서는 아래의 내용을 중점으로 살펴볼 것 입니다</p>\n<ul>\n<li>어떤 서비스를 만들것인가.</li>\n<li>도메인구조, 테이블구조</li>\n<li>프로젝트구조</li>\n<li>Spring boot 프로젝트 생성</li>\n</ul>\n<h1>1. 어떤 서비스를 만들것인가.</h1>\n<h2>온라인 서점에서 한번에 여러개의 책을 주문할 수 있는 주문 시스템 API 서비스 구축</h2>\n<p>간단히 말하면 위 소제목과 같은 간단한 API 서버를 만들 것입니다. 좀 더 상세히 말하면 아래와 같을 수 있습니다.</p>\n<ol>\n<li>책을 주문하기 위해서는 Spring boot 온라인 서점 회원이어야 합니다.</li>\n<li>회원은 여러 개의 주문 신청을 할 수 있습니다.</li>\n<li>주문을 할 때 한 번에 여러 개의 책을 주문할 수 있습니다.</li>\n<li>책은 여러 주문의 의해 주문될 수 있습니다.</li>\n<li>주문이 완료된 이후에 배송이 시작됩니다.</li>\n<li>배송을 하기 위해서는 반드시 한 명의 수취인이 필요합니다.</li>\n<li>이러한 주문 상태는 추적이 되어야 합니다</li>\n</ol>\n<p>위 요구 사항들 기반으로 어떠한 도메인들이 나올 수 있는지 확인해볼 것입니다. 좀 더 상세한 요구 조건은 실제 구현을 하면서 정의하겠습니다.</p>\n<h1>2. 도메인구조, 테이블구조</h1>\n<p>위 내용을 토대로 크게 아래와 같은 도메인들이 나올 수 있을것입니다.</p>\n<p><img src=\"https://i.imgur.com/HQ5kFIO.png\" alt=\"\"></p>\n<p>위 도메인을 기반으로 아래와 같은 테이블 구조가 나올 수 있을것입니다. 물론 추가 요구사항등이 있으면 테이블 구조, 도메인구조는 변경되어질 수 있습니다.(온라인 글 연재에 장점이라고생각합니다. 물론 너무많은 변화는 없도록 노력할것입니다.)</p>\n<p><img src=\"https://i.imgur.com/fhDMa1c.png\" alt=\"\"></p>\n<p>위 그림들을 보면 테이블 구조와 객체 도메인 구조가 다르다는것을 보실 수 있습니다. 이러한 이유는 도메인 하나가 테이블 엔터티를 의미하는것이 아니기 때문입니다. JPA 에서 여러개의 도메인은 하나의 테이블에 쉽게 저장할 수 있게 해줍니다. 예를들어 위의 그림처럼 배송, 수취인, 주소의 다른 도메인이 있지만 이것들을 함께 주문테이블에 쉽게 저장할 수 있게 해줍니다.</p>\n<p>JPA에서 도메인은 크게 엔터티와 벨류타입으로 나누어질 수 있습니다. JPA에서 엔터티와 벨류타입을 잘 분류해야만 응집력있는 코드를 작성할 수 있습니다. 도메인을 엔터티와 벨류 타입으로 나누는 기준의 큰 차이는 엔터티는 식별자를 가집니다. 반면 벨류타입은 식별자를 가지지않습니다. 이부분은 실제 엔터티와 벨류타입으로 데이터를 생성할 때 좀 더 자세히 알아보겠습니다.</p>\n<h1>3. 프로젝트 구조</h1>\n<p>프로젝트 구조는 다음과 같이 이루어질것입니다.</p>\n<p><img src=\"https://i.imgur.com/gkCTUtC.png\" alt=\"\"></p>\n<table>\n<thead>\n<tr>\n<th>계층</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>표현영역</strong></td>\n<td>클라이언트에 요청을받아 그것을 응용 영역에 전달하고 응용영역에서 처리한값을 클라이언트에게 전달하는 역할을 합니다. 클라이언트로부터 HTTP요청을 받아 처리후 JSON형태로 클라이언트에 전달하는 역할을 합니다.</td>\n</tr>\n<tr>\n<td><strong>응용영역</strong></td>\n<td>표현 계층으로부터 전달받은 데이터를 기반으로 비지니스 로직을 수행하기보다는 도메인들한테 시키는 역할을합니다.</td>\n</tr>\n<tr>\n<td><strong>도메인영역</strong></td>\n<td>도메인들에 핵심 로직을 구현하는 역할입니다.(객체지향 관점에 맞게 객체한테 시키시킨다고 보시면됩니다.)</td>\n</tr>\n<tr>\n<td><strong>인프라스트럭쳐영역</strong></td>\n<td>이 영역은 DB, 외부 api 등에 대한 처리를 하는 영역입니다. 그렇게해야 응용 영역에서 통일된 데이터를 사용할 수 있습니다.</td>\n</tr>\n</tbody>\n</table>\n<p>각 계층은 자신의 계층의 책임에만 집중해야합니다. 자신의 영역을 넘어서는 코드를 짜게되면 코드가 복잡해지고 코드의 응집력이 떨어지게됩니다. 결국엔 변화에대한 유연성이 떨어지고 이해하기 힘든코드가되어 유지보수가 힘들어집니다. 그러기때문에 항상 이것을 염두하고 코딩을 해야한다고 생각합니다.</p>\n<h1>4.Spring boot 프로젝트 생성</h1>\n<p>프로젝트 생성은 intellij 기준으로 설명하겠습니다!<br>\n먼저 NewProject 를 생성한후 아래와 같은 플로우로 프로젝트를 생성하실 수 있습니다.</p>\n<p><img src=\"https://i.imgur.com/U8e5Hsz.png\" alt=\"\"><br>\n<img src=\"https://i.imgur.com/zSi623M.png\" alt=\"\"><br>\n기본적으로 프로젝트를 진행하기위해 아래와같은 의존성 라이브러리들을 선택해줘야합니다.<br>\n<img src=\"https://i.imgur.com/ZX16NBf.png\" alt=\"\"><br>\n여기에서 버전을 2.0.3으로되어있는데요. 이프로젝트에서는 1.5.9를 사용합니다. 프로젝트가 만들어진 이후 pom.xml에서 변경하실 수 있습니다.</p>\n<p><img src=\"https://i.imgur.com/6Kk0Bj9.png\" alt=\"\"></p>\n<p>최종적으로 Finish를 누르면 프로젝트 생성이됩니다.</p>\n<h1>마치며</h1>\n<p>다음장부터 본격적으로 API서버를 만들어보는 시간을 가져보겠습니다!</p>\n"},{"title":"Network-1:허브, 스위치, 공유기, 라우터란 ?","catalog":true,"date":"2018-09-30T15:00:00.000Z","subtitle":"허브, 스위치, 공유기, 라우터란 ?","header-img":null,"_content":"\n\n# 허브, 스위치, 공유기, 라우터란 ?\n<!-- TOC -->\n\n- [허브, 스위치, 라우터란 ?](#허브-스위치-라우터란-)\n    - [허브 (L1)(bit)](#허브-l1bit)\n    - [스위치(L2)(frame)](#스위치l2frame)\n    - [공유기](#공유기)\n    - [라우터(L3)(패킷)](#라우터l3패킷)\n\n<!-- /TOC -->\n\n## 허브 (L1)(bit)\n여러 대의 컴퓨터를 연결해 네트워크를 만들어주는 장비이다. 포트의 개수는 허브에 따라 다양하며, 1개의 포트에 한대의 장비가 할당이 된다. 허브는 단순한 분배 중계기에 불과하기 때문에, 연결되는 컴퓨터 수에 따라 데이터 전송 대역이 분리된다. 예를 들어, 원래 전송 대역이 10Mbps인 네트워크 라인에 허브를 물리고 여기에 5대의 컴퓨터를 연결했다면 각 컴퓨터의 대역폭은 2Mbps가 된다.\n\n허브는 크게 멀티포트와 리피터(Repeater) 기능으로 많이 사용된다. 멀티포트의 의미는 공유기 포트가 모자라면 허브를 추가적으로 설치하는 것을 말한다. 리 피터 같은 경우에는 보통 UTP 케이블 등의 데이터 최대 전송거리가 100 미터인데 이 거리를 넘어서게 되면 통신이 불가능해진다. 이 100미터가 넘는 거리를 연결하려면 두 개의 UTP 선사 이에 허브를 설치하고 리피터 기능을 사용해야 한다. 리피터의 의미는 데이터를 재 전송한다는 뜻이다.\n\n허브는 IP를 할당하는 기능이 없고 단순히 포트를 늘려주는 기능이라고 생각 하면 된다.\n\n## 스위치(L2)(frame)\n한 PC만이 데이터를 보낼 수 있다고 했다. 즉 허브에 연결된 한 PC에서 발생하는 콜리전이 허브에 연결된 모든 영역에 노드들에게 영향을 미쳐서 통신을 하지 못한다. 이러한 문제를 해결하기 위해서 콜리전 도메인을 나누어 줄 수 있는 장비가 나와있는데 이것이 **브릿지, 스위치**이다.\n\n예를 들어 1,2번 사이에 통신이 일어나면 **CSMA/CD**라는 특징 때문에 나머지 모든 PC들은 기다려야만 하는 허브와는 달리 PC들도 동시에 통신이 가능하다. 이것이 위의 허브와 스위치의 가장 큰 차이다. 또한 스위치는 데이터의 전송 에러 등을 복구해주는 기능들을 가진다. 서버의 경우 사용자들이 많기 때문에 허브보다 스위치를 사용하는 것이 좋다.\n\n스위치는 자신에게 연결된 디바이스들의 IP와 MAC 주소를 테이블로 모두 가지고 있다. 따라서 프레임이 자신에게 오면 그것의 목적지가 어디인지를 파악하여 그 디바이스에게 프레임을 보내준다. 트래픽이 훨씬 효율적이 되는 것이다. 다만 스위치는 자신의 테이블에 없는 목적지를 가진 패킷이 오면 그것을 무조건 모든 기계에 포워딩한다. 이런 경우는 허브와 똑같이 동작하는 것이다. \n\n\n## 공유기\nISP(Internet Service provider) 업체에서 제공하는 한 개의 인터넷 IP Address로 여러 대의 컴퓨터, 노트북, 폰 등이 인터넷을 공유할 수 있는 기능을 제공합니다. 주로 가정용으로 사용되는 소용량 라우터를 말한다. 공유기를 사용하면 ISP에서 할당받은 하나의 공인 IP Address를 내부 네트웍에서 여러 개의 IP 주소로 변환 사용가능하기 때문에, 한 대의 컴퓨터에서만 인터넷 접속이나 외부 네트워크와 연결되던 것을 최대 253대까지 동시에 인터넷을 접속할 수 있다. 사실상 라우터의 NAT(Network Address Translation) 기능만 가지고 있다고 해도 무방하다.\n\n## 라우터(L3)(패킷)\n라우터란 둘 혹은 그 이상의 네트워크와 네트워크 간 데이터 전송을 위해 최적 경로를 설정해주며 데이터를 해당 경로를 따라 한 통신망에서 다른 통신망으로 통신할 수 있도록 도와주는 인터넷 접속 장비이다. 네트워크를 통해 정보를 주고 받을 때 데이터에 담긴 수신처의 주소를 읽고 가장 적절한 통신통로를 이용해 다른 통신망으로 전송하는 장치로, 전화국의 교환기와 비슷한 개념이다. \n\n내부 네트워크는 사용하는 컴퓨터 기종이나 OS, 프로토콜 등을 확실히 알 수 있기 때문에 네트워크의 최적화를 이룰 수 있다. 그러나 내부 네트워크를 외부와 연결할 때는 외부 네트워크에서 사용하는 프로토콜이나 컴퓨터 기종 등의 정보를 알 수 없다. 이러한 알 수 없는 임의의 네트워크와 내부 네트워크를 연결하기 위한 네트워크 장비가 바로 라우터이다.\n\n## 참고\n* [나만의 작은 세상](http://ycchoi21.tistory.com/entry/인터넷-공유기-허브-라우터-등의-차이점은)\n* [준이 블로그](http://blog.daum.net/_blog/BlogTypeView.do?blogid=0rR5X&articleno=3&categoryId=0&regdt=20150309011857)\n\n\n","source":"_posts/2018-09-03-network-network-divice.md","raw":"---\ntitle: Network-1:허브, 스위치, 공유기, 라우터란 ?\ncatalog: true\ndate: 2018-10-01\nsubtitle: 허브, 스위치, 공유기, 라우터란 ?\nheader-img:\ntags:\n- Netowork\n\n\n\n---\n\n\n# 허브, 스위치, 공유기, 라우터란 ?\n<!-- TOC -->\n\n- [허브, 스위치, 라우터란 ?](#허브-스위치-라우터란-)\n    - [허브 (L1)(bit)](#허브-l1bit)\n    - [스위치(L2)(frame)](#스위치l2frame)\n    - [공유기](#공유기)\n    - [라우터(L3)(패킷)](#라우터l3패킷)\n\n<!-- /TOC -->\n\n## 허브 (L1)(bit)\n여러 대의 컴퓨터를 연결해 네트워크를 만들어주는 장비이다. 포트의 개수는 허브에 따라 다양하며, 1개의 포트에 한대의 장비가 할당이 된다. 허브는 단순한 분배 중계기에 불과하기 때문에, 연결되는 컴퓨터 수에 따라 데이터 전송 대역이 분리된다. 예를 들어, 원래 전송 대역이 10Mbps인 네트워크 라인에 허브를 물리고 여기에 5대의 컴퓨터를 연결했다면 각 컴퓨터의 대역폭은 2Mbps가 된다.\n\n허브는 크게 멀티포트와 리피터(Repeater) 기능으로 많이 사용된다. 멀티포트의 의미는 공유기 포트가 모자라면 허브를 추가적으로 설치하는 것을 말한다. 리 피터 같은 경우에는 보통 UTP 케이블 등의 데이터 최대 전송거리가 100 미터인데 이 거리를 넘어서게 되면 통신이 불가능해진다. 이 100미터가 넘는 거리를 연결하려면 두 개의 UTP 선사 이에 허브를 설치하고 리피터 기능을 사용해야 한다. 리피터의 의미는 데이터를 재 전송한다는 뜻이다.\n\n허브는 IP를 할당하는 기능이 없고 단순히 포트를 늘려주는 기능이라고 생각 하면 된다.\n\n## 스위치(L2)(frame)\n한 PC만이 데이터를 보낼 수 있다고 했다. 즉 허브에 연결된 한 PC에서 발생하는 콜리전이 허브에 연결된 모든 영역에 노드들에게 영향을 미쳐서 통신을 하지 못한다. 이러한 문제를 해결하기 위해서 콜리전 도메인을 나누어 줄 수 있는 장비가 나와있는데 이것이 **브릿지, 스위치**이다.\n\n예를 들어 1,2번 사이에 통신이 일어나면 **CSMA/CD**라는 특징 때문에 나머지 모든 PC들은 기다려야만 하는 허브와는 달리 PC들도 동시에 통신이 가능하다. 이것이 위의 허브와 스위치의 가장 큰 차이다. 또한 스위치는 데이터의 전송 에러 등을 복구해주는 기능들을 가진다. 서버의 경우 사용자들이 많기 때문에 허브보다 스위치를 사용하는 것이 좋다.\n\n스위치는 자신에게 연결된 디바이스들의 IP와 MAC 주소를 테이블로 모두 가지고 있다. 따라서 프레임이 자신에게 오면 그것의 목적지가 어디인지를 파악하여 그 디바이스에게 프레임을 보내준다. 트래픽이 훨씬 효율적이 되는 것이다. 다만 스위치는 자신의 테이블에 없는 목적지를 가진 패킷이 오면 그것을 무조건 모든 기계에 포워딩한다. 이런 경우는 허브와 똑같이 동작하는 것이다. \n\n\n## 공유기\nISP(Internet Service provider) 업체에서 제공하는 한 개의 인터넷 IP Address로 여러 대의 컴퓨터, 노트북, 폰 등이 인터넷을 공유할 수 있는 기능을 제공합니다. 주로 가정용으로 사용되는 소용량 라우터를 말한다. 공유기를 사용하면 ISP에서 할당받은 하나의 공인 IP Address를 내부 네트웍에서 여러 개의 IP 주소로 변환 사용가능하기 때문에, 한 대의 컴퓨터에서만 인터넷 접속이나 외부 네트워크와 연결되던 것을 최대 253대까지 동시에 인터넷을 접속할 수 있다. 사실상 라우터의 NAT(Network Address Translation) 기능만 가지고 있다고 해도 무방하다.\n\n## 라우터(L3)(패킷)\n라우터란 둘 혹은 그 이상의 네트워크와 네트워크 간 데이터 전송을 위해 최적 경로를 설정해주며 데이터를 해당 경로를 따라 한 통신망에서 다른 통신망으로 통신할 수 있도록 도와주는 인터넷 접속 장비이다. 네트워크를 통해 정보를 주고 받을 때 데이터에 담긴 수신처의 주소를 읽고 가장 적절한 통신통로를 이용해 다른 통신망으로 전송하는 장치로, 전화국의 교환기와 비슷한 개념이다. \n\n내부 네트워크는 사용하는 컴퓨터 기종이나 OS, 프로토콜 등을 확실히 알 수 있기 때문에 네트워크의 최적화를 이룰 수 있다. 그러나 내부 네트워크를 외부와 연결할 때는 외부 네트워크에서 사용하는 프로토콜이나 컴퓨터 기종 등의 정보를 알 수 없다. 이러한 알 수 없는 임의의 네트워크와 내부 네트워크를 연결하기 위한 네트워크 장비가 바로 라우터이다.\n\n## 참고\n* [나만의 작은 세상](http://ycchoi21.tistory.com/entry/인터넷-공유기-허브-라우터-등의-차이점은)\n* [준이 블로그](http://blog.daum.net/_blog/BlogTypeView.do?blogid=0rR5X&articleno=3&categoryId=0&regdt=20150309011857)\n\n\n","slug":"2018-09-03-network-network-divice","published":1,"updated":"2018-09-30T16:43:15.675Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27by001bjjpe7phsrv5x","content":"<h1><span id=\"허브-스위치-공유기-라우터란\">허브, 스위치, 공유기, 라우터란 ?</span></h1>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%ED%97%88%EB%B8%8C-%EC%8A%A4%EC%9C%84%EC%B9%98-%EB%9D%BC%EC%9A%B0%ED%84%B0%EB%9E%80-\">허브, 스위치, 라우터란 ?</a>\n<ul>\n<li><a href=\"#%ED%97%88%EB%B8%8C-l1bit\">허브 (L1)(bit)</a></li>\n<li><a href=\"#%EC%8A%A4%EC%9C%84%EC%B9%98l2frame\">스위치(L2)(frame)</a></li>\n<li><a href=\"#%EA%B3%B5%EC%9C%A0%EA%B8%B0\">공유기</a></li>\n<li><a href=\"#%EB%9D%BC%EC%9A%B0%ED%84%B0l3%ED%8C%A8%ED%82%B7\">라우터(L3)(패킷)</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h2><span id=\"허브-l1bit\">허브 (L1)(bit)</span></h2>\n<p>여러 대의 컴퓨터를 연결해 네트워크를 만들어주는 장비이다. 포트의 개수는 허브에 따라 다양하며, 1개의 포트에 한대의 장비가 할당이 된다. 허브는 단순한 분배 중계기에 불과하기 때문에, 연결되는 컴퓨터 수에 따라 데이터 전송 대역이 분리된다. 예를 들어, 원래 전송 대역이 10Mbps인 네트워크 라인에 허브를 물리고 여기에 5대의 컴퓨터를 연결했다면 각 컴퓨터의 대역폭은 2Mbps가 된다.</p>\n<p>허브는 크게 멀티포트와 리피터(Repeater) 기능으로 많이 사용된다. 멀티포트의 의미는 공유기 포트가 모자라면 허브를 추가적으로 설치하는 것을 말한다. 리 피터 같은 경우에는 보통 UTP 케이블 등의 데이터 최대 전송거리가 100 미터인데 이 거리를 넘어서게 되면 통신이 불가능해진다. 이 100미터가 넘는 거리를 연결하려면 두 개의 UTP 선사 이에 허브를 설치하고 리피터 기능을 사용해야 한다. 리피터의 의미는 데이터를 재 전송한다는 뜻이다.</p>\n<p>허브는 IP를 할당하는 기능이 없고 단순히 포트를 늘려주는 기능이라고 생각 하면 된다.</p>\n<h2><span id=\"스위치l2frame\">스위치(L2)(frame)</span></h2>\n<p>한 PC만이 데이터를 보낼 수 있다고 했다. 즉 허브에 연결된 한 PC에서 발생하는 콜리전이 허브에 연결된 모든 영역에 노드들에게 영향을 미쳐서 통신을 하지 못한다. 이러한 문제를 해결하기 위해서 콜리전 도메인을 나누어 줄 수 있는 장비가 나와있는데 이것이 <strong>브릿지, 스위치</strong>이다.</p>\n<p>예를 들어 1,2번 사이에 통신이 일어나면 <strong>CSMA/CD</strong>라는 특징 때문에 나머지 모든 PC들은 기다려야만 하는 허브와는 달리 PC들도 동시에 통신이 가능하다. 이것이 위의 허브와 스위치의 가장 큰 차이다. 또한 스위치는 데이터의 전송 에러 등을 복구해주는 기능들을 가진다. 서버의 경우 사용자들이 많기 때문에 허브보다 스위치를 사용하는 것이 좋다.</p>\n<p>스위치는 자신에게 연결된 디바이스들의 IP와 MAC 주소를 테이블로 모두 가지고 있다. 따라서 프레임이 자신에게 오면 그것의 목적지가 어디인지를 파악하여 그 디바이스에게 프레임을 보내준다. 트래픽이 훨씬 효율적이 되는 것이다. 다만 스위치는 자신의 테이블에 없는 목적지를 가진 패킷이 오면 그것을 무조건 모든 기계에 포워딩한다. 이런 경우는 허브와 똑같이 동작하는 것이다.</p>\n<h2><span id=\"공유기\">공유기</span></h2>\n<p>ISP(Internet Service provider) 업체에서 제공하는 한 개의 인터넷 IP Address로 여러 대의 컴퓨터, 노트북, 폰 등이 인터넷을 공유할 수 있는 기능을 제공합니다. 주로 가정용으로 사용되는 소용량 라우터를 말한다. 공유기를 사용하면 ISP에서 할당받은 하나의 공인 IP Address를 내부 네트웍에서 여러 개의 IP 주소로 변환 사용가능하기 때문에, 한 대의 컴퓨터에서만 인터넷 접속이나 외부 네트워크와 연결되던 것을 최대 253대까지 동시에 인터넷을 접속할 수 있다. 사실상 라우터의 NAT(Network Address Translation) 기능만 가지고 있다고 해도 무방하다.</p>\n<h2><span id=\"라우터l3패킷\">라우터(L3)(패킷)</span></h2>\n<p>라우터란 둘 혹은 그 이상의 네트워크와 네트워크 간 데이터 전송을 위해 최적 경로를 설정해주며 데이터를 해당 경로를 따라 한 통신망에서 다른 통신망으로 통신할 수 있도록 도와주는 인터넷 접속 장비이다. 네트워크를 통해 정보를 주고 받을 때 데이터에 담긴 수신처의 주소를 읽고 가장 적절한 통신통로를 이용해 다른 통신망으로 전송하는 장치로, 전화국의 교환기와 비슷한 개념이다.</p>\n<p>내부 네트워크는 사용하는 컴퓨터 기종이나 OS, 프로토콜 등을 확실히 알 수 있기 때문에 네트워크의 최적화를 이룰 수 있다. 그러나 내부 네트워크를 외부와 연결할 때는 외부 네트워크에서 사용하는 프로토콜이나 컴퓨터 기종 등의 정보를 알 수 없다. 이러한 알 수 없는 임의의 네트워크와 내부 네트워크를 연결하기 위한 네트워크 장비가 바로 라우터이다.</p>\n<h2><span id=\"참고\">참고</span></h2>\n<ul>\n<li><a href=\"http://ycchoi21.tistory.com/entry/%EC%9D%B8%ED%84%B0%EB%84%B7-%EA%B3%B5%EC%9C%A0%EA%B8%B0-%ED%97%88%EB%B8%8C-%EB%9D%BC%EC%9A%B0%ED%84%B0-%EB%93%B1%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80\" target=\"_blank\" rel=\"noopener\">나만의 작은 세상</a></li>\n<li><a href=\"http://blog.daum.net/_blog/BlogTypeView.do?blogid=0rR5X&amp;articleno=3&amp;categoryId=0&amp;regdt=20150309011857\" target=\"_blank\" rel=\"noopener\">준이 블로그</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>허브, 스위치, 공유기, 라우터란 ?</h1>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%ED%97%88%EB%B8%8C-%EC%8A%A4%EC%9C%84%EC%B9%98-%EB%9D%BC%EC%9A%B0%ED%84%B0%EB%9E%80-\">허브, 스위치, 라우터란 ?</a>\n<ul>\n<li><a href=\"#%ED%97%88%EB%B8%8C-l1bit\">허브 (L1)(bit)</a></li>\n<li><a href=\"#%EC%8A%A4%EC%9C%84%EC%B9%98l2frame\">스위치(L2)(frame)</a></li>\n<li><a href=\"#%EA%B3%B5%EC%9C%A0%EA%B8%B0\">공유기</a></li>\n<li><a href=\"#%EB%9D%BC%EC%9A%B0%ED%84%B0l3%ED%8C%A8%ED%82%B7\">라우터(L3)(패킷)</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h2>허브 (L1)(bit)</h2>\n<p>여러 대의 컴퓨터를 연결해 네트워크를 만들어주는 장비이다. 포트의 개수는 허브에 따라 다양하며, 1개의 포트에 한대의 장비가 할당이 된다. 허브는 단순한 분배 중계기에 불과하기 때문에, 연결되는 컴퓨터 수에 따라 데이터 전송 대역이 분리된다. 예를 들어, 원래 전송 대역이 10Mbps인 네트워크 라인에 허브를 물리고 여기에 5대의 컴퓨터를 연결했다면 각 컴퓨터의 대역폭은 2Mbps가 된다.</p>\n<p>허브는 크게 멀티포트와 리피터(Repeater) 기능으로 많이 사용된다. 멀티포트의 의미는 공유기 포트가 모자라면 허브를 추가적으로 설치하는 것을 말한다. 리 피터 같은 경우에는 보통 UTP 케이블 등의 데이터 최대 전송거리가 100 미터인데 이 거리를 넘어서게 되면 통신이 불가능해진다. 이 100미터가 넘는 거리를 연결하려면 두 개의 UTP 선사 이에 허브를 설치하고 리피터 기능을 사용해야 한다. 리피터의 의미는 데이터를 재 전송한다는 뜻이다.</p>\n<p>허브는 IP를 할당하는 기능이 없고 단순히 포트를 늘려주는 기능이라고 생각 하면 된다.</p>\n<h2>스위치(L2)(frame)</h2>\n<p>한 PC만이 데이터를 보낼 수 있다고 했다. 즉 허브에 연결된 한 PC에서 발생하는 콜리전이 허브에 연결된 모든 영역에 노드들에게 영향을 미쳐서 통신을 하지 못한다. 이러한 문제를 해결하기 위해서 콜리전 도메인을 나누어 줄 수 있는 장비가 나와있는데 이것이 <strong>브릿지, 스위치</strong>이다.</p>\n<p>예를 들어 1,2번 사이에 통신이 일어나면 <strong>CSMA/CD</strong>라는 특징 때문에 나머지 모든 PC들은 기다려야만 하는 허브와는 달리 PC들도 동시에 통신이 가능하다. 이것이 위의 허브와 스위치의 가장 큰 차이다. 또한 스위치는 데이터의 전송 에러 등을 복구해주는 기능들을 가진다. 서버의 경우 사용자들이 많기 때문에 허브보다 스위치를 사용하는 것이 좋다.</p>\n<p>스위치는 자신에게 연결된 디바이스들의 IP와 MAC 주소를 테이블로 모두 가지고 있다. 따라서 프레임이 자신에게 오면 그것의 목적지가 어디인지를 파악하여 그 디바이스에게 프레임을 보내준다. 트래픽이 훨씬 효율적이 되는 것이다. 다만 스위치는 자신의 테이블에 없는 목적지를 가진 패킷이 오면 그것을 무조건 모든 기계에 포워딩한다. 이런 경우는 허브와 똑같이 동작하는 것이다.</p>\n<h2>공유기</h2>\n<p>ISP(Internet Service provider) 업체에서 제공하는 한 개의 인터넷 IP Address로 여러 대의 컴퓨터, 노트북, 폰 등이 인터넷을 공유할 수 있는 기능을 제공합니다. 주로 가정용으로 사용되는 소용량 라우터를 말한다. 공유기를 사용하면 ISP에서 할당받은 하나의 공인 IP Address를 내부 네트웍에서 여러 개의 IP 주소로 변환 사용가능하기 때문에, 한 대의 컴퓨터에서만 인터넷 접속이나 외부 네트워크와 연결되던 것을 최대 253대까지 동시에 인터넷을 접속할 수 있다. 사실상 라우터의 NAT(Network Address Translation) 기능만 가지고 있다고 해도 무방하다.</p>\n<h2>라우터(L3)(패킷)</h2>\n<p>라우터란 둘 혹은 그 이상의 네트워크와 네트워크 간 데이터 전송을 위해 최적 경로를 설정해주며 데이터를 해당 경로를 따라 한 통신망에서 다른 통신망으로 통신할 수 있도록 도와주는 인터넷 접속 장비이다. 네트워크를 통해 정보를 주고 받을 때 데이터에 담긴 수신처의 주소를 읽고 가장 적절한 통신통로를 이용해 다른 통신망으로 전송하는 장치로, 전화국의 교환기와 비슷한 개념이다.</p>\n<p>내부 네트워크는 사용하는 컴퓨터 기종이나 OS, 프로토콜 등을 확실히 알 수 있기 때문에 네트워크의 최적화를 이룰 수 있다. 그러나 내부 네트워크를 외부와 연결할 때는 외부 네트워크에서 사용하는 프로토콜이나 컴퓨터 기종 등의 정보를 알 수 없다. 이러한 알 수 없는 임의의 네트워크와 내부 네트워크를 연결하기 위한 네트워크 장비가 바로 라우터이다.</p>\n<h2>참고</h2>\n<ul>\n<li><a href=\"http://ycchoi21.tistory.com/entry/%EC%9D%B8%ED%84%B0%EB%84%B7-%EA%B3%B5%EC%9C%A0%EA%B8%B0-%ED%97%88%EB%B8%8C-%EB%9D%BC%EC%9A%B0%ED%84%B0-%EB%93%B1%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80\" target=\"_blank\" rel=\"noopener\">나만의 작은 세상</a></li>\n<li><a href=\"http://blog.daum.net/_blog/BlogTypeView.do?blogid=0rR5X&amp;articleno=3&amp;categoryId=0&amp;regdt=20150309011857\" target=\"_blank\" rel=\"noopener\">준이 블로그</a></li>\n</ul>\n"},{"title":"[Hexo] Theme BeanTech","catalog":true,"date":"2017-03-18T01:51:24.000Z","subtitle":"This is hexo theme Demo.","header-img":"Demo.png","catagories":["Hexo test"],"_content":"> Ported Theme of [Hux Blog](https://github.com/Huxpro/huxpro.github.io), Thank [Huxpro](https://github.com/Huxpro) for designing such a flawless theme.\n> \n> This BeanTech theme created by [YuHsuan](http://beantech.org) modified from the original Porter [Kaijun](http://kaijun.rocks/hexo-theme-huxblog/)\n\n# [Live Demo](http://beantech.org)\n---\n![BeanTech Desktop](http://beantech.org/img/beantech-desktop.png)\n\n# Usage\n---\nI publish the whole project for your convenience, so you can just follow the instruction down below, then you can easily customiz your own blog!\n\nLet's begin!!!\n\n## Init\n---\n```bash\ngit clone https://github.com/YenYuHsuan/hexo-theme-beantech.git ./hexo-beantech\ncd hexo-beantech\nnpm install\n```\n\n## Modify\n---\nModify `_config.yml` file with your own info.\nEspecially the section:\n### Deployment\nReplace to your own repo!\n```yml\ndeploy:\n  type: git\n  repo: https://github.com/<yourAccount>/<repo>\n  branch: <your-branch>\n```\n\n### Sidebar settings\nCopy your avatar image to `<root>/img/` and modify the `_config.yml`:\n```yml\nsidebar: true    # whether or not using Sidebar.\nsidebar-about-description: \"<your description>\"\nsidebar-avatar: img/<your avatar path>\n```\nand activate your personal widget you like\n```yml\nwidgets:         # here are widget you can use, you can comment out\n- featured-tags\n- short-about\n- recent-posts\n- friends-blog\n- archive\n- category\n```\nif you want to add sidebar widget, please add at `layout/_widget`.\n### Signature Setup\nCopy your signature image to `<root>/img/signature` and modify the `_config.yml`:\n```yml\nsignature: true   # show signature\nsignature-img: img/signature/<your-signature-ID>\n```\n### Go to top icon Setup\nMy icon is using iron man, you can change to your own icon at `css/image`.\n\n### Post tag\nYou can decide to show post tags or not.\n```yml\nhome_posts_tag: true\n```\n![home_posts_tag-true](home_posts_tag-true.png)\n```yml\nhome_posts_tag: false\n```\n![home_posts_tag-false](home_posts_tag-false.png)\n\n### Markdown render\nMy markdown render engine plugin is [hexo-renderer-markdown-it](https://github.com/celsomiranda/hexo-renderer-markdown-it).\n```yml\n# Markdown-it config\n## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki\nmarkdown:\n  render:\n    html: true\n    xhtmlOut: false\n    breaks: true\n    linkify: true\n    typographer: true\n    quotes: '“”‘’'\n```\nand if you want to change the header anchor 'ℬ', you can go to `layout/post.ejs` to change it.\n```javascript\nasync(\"https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js\",function(){\n        anchors.options = {\n          visible: 'hover',\n          placement: 'left',\n          icon: ℬ // this is the header anchor \"unicode\" icon\n        };\n```\n\n## Hexo Basics\n---\nSome hexo command:\n```bash\nhexo new post \"<post name>\" # you can change post to another layout if you want\nhexo clean && hexo generate # generate the static file\nhexo server # run hexo in local environment\nhexo deploy # hexo will push the static files automatically into the specific branch(gh-pages) of your repo!\n```\n\n# Have fun ^_^ \n---\n<!-- Place this tag in your head or just before your close body tag. -->\n<script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n<!-- Place this tag where you want the button to render. -->\n\nPlease <a class=\"github-button\" href=\"https://github.com/YenYuHsuan/hexo-theme-beantech\" data-icon=\"octicon-star\" aria-label=\"Star YenYuHsuan/hexo-theme-beantech on GitHub\">Star</a> this Project if you like it! <a class=\"github-button\" href=\"https://github.com/YenYuHsuan\" aria-label=\"Follow @YenYuHsuan on GitHub\">Follow</a> would also be appreciated!\nPeace!\n","source":"_posts/hexo-theme-beantech.md","raw":"---\ntitle: \"[Hexo] Theme BeanTech\"\ncatalog: true\ndate: 2017-03-18 10:51:24\nsubtitle: \"This is hexo theme Demo.\"\nheader-img: \"Demo.png\"\ntags:\n- Blog\ncatagories:\n- Hexo test\n---\n> Ported Theme of [Hux Blog](https://github.com/Huxpro/huxpro.github.io), Thank [Huxpro](https://github.com/Huxpro) for designing such a flawless theme.\n> \n> This BeanTech theme created by [YuHsuan](http://beantech.org) modified from the original Porter [Kaijun](http://kaijun.rocks/hexo-theme-huxblog/)\n\n# [Live Demo](http://beantech.org)\n---\n![BeanTech Desktop](http://beantech.org/img/beantech-desktop.png)\n\n# Usage\n---\nI publish the whole project for your convenience, so you can just follow the instruction down below, then you can easily customiz your own blog!\n\nLet's begin!!!\n\n## Init\n---\n```bash\ngit clone https://github.com/YenYuHsuan/hexo-theme-beantech.git ./hexo-beantech\ncd hexo-beantech\nnpm install\n```\n\n## Modify\n---\nModify `_config.yml` file with your own info.\nEspecially the section:\n### Deployment\nReplace to your own repo!\n```yml\ndeploy:\n  type: git\n  repo: https://github.com/<yourAccount>/<repo>\n  branch: <your-branch>\n```\n\n### Sidebar settings\nCopy your avatar image to `<root>/img/` and modify the `_config.yml`:\n```yml\nsidebar: true    # whether or not using Sidebar.\nsidebar-about-description: \"<your description>\"\nsidebar-avatar: img/<your avatar path>\n```\nand activate your personal widget you like\n```yml\nwidgets:         # here are widget you can use, you can comment out\n- featured-tags\n- short-about\n- recent-posts\n- friends-blog\n- archive\n- category\n```\nif you want to add sidebar widget, please add at `layout/_widget`.\n### Signature Setup\nCopy your signature image to `<root>/img/signature` and modify the `_config.yml`:\n```yml\nsignature: true   # show signature\nsignature-img: img/signature/<your-signature-ID>\n```\n### Go to top icon Setup\nMy icon is using iron man, you can change to your own icon at `css/image`.\n\n### Post tag\nYou can decide to show post tags or not.\n```yml\nhome_posts_tag: true\n```\n![home_posts_tag-true](home_posts_tag-true.png)\n```yml\nhome_posts_tag: false\n```\n![home_posts_tag-false](home_posts_tag-false.png)\n\n### Markdown render\nMy markdown render engine plugin is [hexo-renderer-markdown-it](https://github.com/celsomiranda/hexo-renderer-markdown-it).\n```yml\n# Markdown-it config\n## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki\nmarkdown:\n  render:\n    html: true\n    xhtmlOut: false\n    breaks: true\n    linkify: true\n    typographer: true\n    quotes: '“”‘’'\n```\nand if you want to change the header anchor 'ℬ', you can go to `layout/post.ejs` to change it.\n```javascript\nasync(\"https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js\",function(){\n        anchors.options = {\n          visible: 'hover',\n          placement: 'left',\n          icon: ℬ // this is the header anchor \"unicode\" icon\n        };\n```\n\n## Hexo Basics\n---\nSome hexo command:\n```bash\nhexo new post \"<post name>\" # you can change post to another layout if you want\nhexo clean && hexo generate # generate the static file\nhexo server # run hexo in local environment\nhexo deploy # hexo will push the static files automatically into the specific branch(gh-pages) of your repo!\n```\n\n# Have fun ^_^ \n---\n<!-- Place this tag in your head or just before your close body tag. -->\n<script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n<!-- Place this tag where you want the button to render. -->\n\nPlease <a class=\"github-button\" href=\"https://github.com/YenYuHsuan/hexo-theme-beantech\" data-icon=\"octicon-star\" aria-label=\"Star YenYuHsuan/hexo-theme-beantech on GitHub\">Star</a> this Project if you like it! <a class=\"github-button\" href=\"https://github.com/YenYuHsuan\" aria-label=\"Follow @YenYuHsuan on GitHub\">Follow</a> would also be appreciated!\nPeace!\n","slug":"hexo-theme-beantech","published":1,"updated":"2018-06-20T16:08:54.219Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27c0001djjpebt3l6sah","content":"<blockquote>\n<p>Ported Theme of <a href=\"https://github.com/Huxpro/huxpro.github.io\" target=\"_blank\" rel=\"noopener\">Hux Blog</a>, Thank <a href=\"https://github.com/Huxpro\" target=\"_blank\" rel=\"noopener\">Huxpro</a> for designing such a flawless theme.</p>\n<p>This BeanTech theme created by <a href=\"http://beantech.org\" target=\"_blank\" rel=\"noopener\">YuHsuan</a> modified from the original Porter <a href=\"http://kaijun.rocks/hexo-theme-huxblog/\" target=\"_blank\" rel=\"noopener\">Kaijun</a></p>\n</blockquote>\n<h1><span id=\"live-demo\"></span></h1>\n<hr>\n<p><img src=\"http://beantech.org/img/beantech-desktop.png\" alt=\"BeanTech Desktop\"></p>\n<h1><span id=\"usage\">Usage</span></h1>\n<hr>\n<p>I publish the whole project for your convenience, so you can just follow the instruction down below, then you can easily customiz your own blog!</p>\n<p>Let’s begin!!!</p>\n<h2><span id=\"init\">Init</span></h2>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/YenYuHsuan/hexo-theme-beantech.git ./hexo-beantech</span><br><span class=\"line\"><span class=\"built_in\">cd</span> hexo-beantech</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n<h2><span id=\"modify\">Modify</span></h2>\n<hr>\n<p>Modify <code>_config.yml</code> file with your own info.<br>\nEspecially the section:</p>\n<h3><span id=\"deployment\">Deployment</span></h3>\n<p>Replace to your own repo!</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"><span class=\"attr\">  repo:</span> <span class=\"attr\">https://github.com/&lt;yourAccount&gt;/&lt;repo&gt;</span></span><br><span class=\"line\"><span class=\"attr\">  branch:</span> <span class=\"string\">&lt;your-branch&gt;</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"sidebar-settings\">Sidebar settings</span></h3>\n<p>Copy your avatar image to <code>&lt;root&gt;/img/</code> and modify the <code>_config.yml</code>:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">sidebar:</span> <span class=\"literal\">true</span>    <span class=\"comment\"># whether or not using Sidebar.</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-about-description:</span> <span class=\"string\">\"&lt;your description&gt;\"</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-avatar:</span> <span class=\"string\">img/&lt;your</span> <span class=\"string\">avatar</span> <span class=\"string\">path&gt;</span></span><br></pre></td></tr></table></figure>\n<p>and activate your personal widget you like</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">widgets:</span>         <span class=\"comment\"># here are widget you can use, you can comment out</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">featured-tags</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">short-about</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">recent-posts</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">friends-blog</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">archive</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">category</span></span><br></pre></td></tr></table></figure>\n<p>if you want to add sidebar widget, please add at <code>layout/_widget</code>.</p>\n<h3><span id=\"signature-setup\">Signature Setup</span></h3>\n<p>Copy your signature image to <code>&lt;root&gt;/img/signature</code> and modify the <code>_config.yml</code>:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">signature:</span> <span class=\"literal\">true</span>   <span class=\"comment\"># show signature</span></span><br><span class=\"line\"><span class=\"attr\">signature-img:</span> <span class=\"string\">img/signature/&lt;your-signature-ID&gt;</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"go-to-top-icon-setup\">Go to top icon Setup</span></h3>\n<p>My icon is using iron man, you can change to your own icon at <code>css/image</code>.</p>\n<h3><span id=\"post-tag\">Post tag</span></h3>\n<p>You can decide to show post tags or not.</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">home_posts_tag:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"home_posts_tag-true.png\" alt=\"home_posts_tag-true\"></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">home_posts_tag:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"home_posts_tag-false.png\" alt=\"home_posts_tag-false\"></p>\n<h3><span id=\"markdown-render\">Markdown render</span></h3>\n<p>My markdown render engine plugin is <a href=\"https://github.com/celsomiranda/hexo-renderer-markdown-it\" target=\"_blank\" rel=\"noopener\">hexo-renderer-markdown-it</a>.</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Markdown-it config</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span></span><br><span class=\"line\"><span class=\"attr\">markdown:</span></span><br><span class=\"line\"><span class=\"attr\">  render:</span></span><br><span class=\"line\"><span class=\"attr\">    html:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    xhtmlOut:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    breaks:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    linkify:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    typographer:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    quotes:</span> <span class=\"string\">'“”‘’'</span></span><br></pre></td></tr></table></figure>\n<p>and if you want to change the header anchor ‘ℬ’, you can go to <code>layout/post.ejs</code> to change it.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span>(<span class=\"string\">\"https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        anchors.options = &#123;</span><br><span class=\"line\">          visible: <span class=\"string\">'hover'</span>,</span><br><span class=\"line\">          placement: <span class=\"string\">'left'</span>,</span><br><span class=\"line\">          icon: ℬ <span class=\"comment\">// this is the header anchor \"unicode\" icon</span></span><br><span class=\"line\">        &#125;;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"hexo-basics\">Hexo Basics</span></h2>\n<hr>\n<p>Some hexo command:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo new post <span class=\"string\">\"&lt;post name&gt;\"</span> <span class=\"comment\"># you can change post to another layout if you want</span></span><br><span class=\"line\">hexo clean &amp;&amp; hexo generate <span class=\"comment\"># generate the static file</span></span><br><span class=\"line\">hexo server <span class=\"comment\"># run hexo in local environment</span></span><br><span class=\"line\">hexo deploy <span class=\"comment\"># hexo will push the static files automatically into the specific branch(gh-pages) of your repo!</span></span><br></pre></td></tr></table></figure>\n<h1><span id=\"have-fun-_\">Have fun ^_^</span></h1>\n<hr>\n<!-- Place this tag in your head or just before your close body tag. -->\n<script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n<!-- Place this tag where you want the button to render. -->\n<p>Please <a class=\"github-button\" href=\"https://github.com/YenYuHsuan/hexo-theme-beantech\" data-icon=\"octicon-star\" aria-label=\"Star YenYuHsuan/hexo-theme-beantech on GitHub\" target=\"_blank\" rel=\"noopener\">Star</a> this Project if you like it! <a class=\"github-button\" href=\"https://github.com/YenYuHsuan\" aria-label=\"Follow @YenYuHsuan on GitHub\" target=\"_blank\" rel=\"noopener\">Follow</a> would also be appreciated!<br>\nPeace!</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Ported Theme of <a href=\"https://github.com/Huxpro/huxpro.github.io\" target=\"_blank\" rel=\"noopener\">Hux Blog</a>, Thank <a href=\"https://github.com/Huxpro\" target=\"_blank\" rel=\"noopener\">Huxpro</a> for designing such a flawless theme.</p>\n<p>This BeanTech theme created by <a href=\"http://beantech.org\" target=\"_blank\" rel=\"noopener\">YuHsuan</a> modified from the original Porter <a href=\"http://kaijun.rocks/hexo-theme-huxblog/\" target=\"_blank\" rel=\"noopener\">Kaijun</a></p>\n</blockquote>\n<h1><a href=\"http://beantech.org\" target=\"_blank\" rel=\"noopener\">Live Demo</a></h1>\n<hr>\n<p><img src=\"http://beantech.org/img/beantech-desktop.png\" alt=\"BeanTech Desktop\"></p>\n<h1>Usage</h1>\n<hr>\n<p>I publish the whole project for your convenience, so you can just follow the instruction down below, then you can easily customiz your own blog!</p>\n<p>Let’s begin!!!</p>\n<h2>Init</h2>\n<hr>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/YenYuHsuan/hexo-theme-beantech.git ./hexo-beantech</span><br><span class=\"line\"><span class=\"built_in\">cd</span> hexo-beantech</span><br><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n<h2>Modify</h2>\n<hr>\n<p>Modify <code>_config.yml</code> file with your own info.<br>\nEspecially the section:</p>\n<h3>Deployment</h3>\n<p>Replace to your own repo!</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">deploy:</span></span><br><span class=\"line\"><span class=\"attr\">  type:</span> <span class=\"string\">git</span></span><br><span class=\"line\"><span class=\"attr\">  repo:</span> <span class=\"attr\">https://github.com/&lt;yourAccount&gt;/&lt;repo&gt;</span></span><br><span class=\"line\"><span class=\"attr\">  branch:</span> <span class=\"string\">&lt;your-branch&gt;</span></span><br></pre></td></tr></table></figure>\n<h3>Sidebar settings</h3>\n<p>Copy your avatar image to <code>&lt;root&gt;/img/</code> and modify the <code>_config.yml</code>:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">sidebar:</span> <span class=\"literal\">true</span>    <span class=\"comment\"># whether or not using Sidebar.</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-about-description:</span> <span class=\"string\">\"&lt;your description&gt;\"</span></span><br><span class=\"line\"><span class=\"attr\">sidebar-avatar:</span> <span class=\"string\">img/&lt;your</span> <span class=\"string\">avatar</span> <span class=\"string\">path&gt;</span></span><br></pre></td></tr></table></figure>\n<p>and activate your personal widget you like</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">widgets:</span>         <span class=\"comment\"># here are widget you can use, you can comment out</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">featured-tags</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">short-about</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">recent-posts</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">friends-blog</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">archive</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">category</span></span><br></pre></td></tr></table></figure>\n<p>if you want to add sidebar widget, please add at <code>layout/_widget</code>.</p>\n<h3>Signature Setup</h3>\n<p>Copy your signature image to <code>&lt;root&gt;/img/signature</code> and modify the <code>_config.yml</code>:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">signature:</span> <span class=\"literal\">true</span>   <span class=\"comment\"># show signature</span></span><br><span class=\"line\"><span class=\"attr\">signature-img:</span> <span class=\"string\">img/signature/&lt;your-signature-ID&gt;</span></span><br></pre></td></tr></table></figure>\n<h3>Go to top icon Setup</h3>\n<p>My icon is using iron man, you can change to your own icon at <code>css/image</code>.</p>\n<h3>Post tag</h3>\n<p>You can decide to show post tags or not.</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">home_posts_tag:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"home_posts_tag-true.png\" alt=\"home_posts_tag-true\"></p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">home_posts_tag:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"home_posts_tag-false.png\" alt=\"home_posts_tag-false\"></p>\n<h3>Markdown render</h3>\n<p>My markdown render engine plugin is <a href=\"https://github.com/celsomiranda/hexo-renderer-markdown-it\" target=\"_blank\" rel=\"noopener\">hexo-renderer-markdown-it</a>.</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Markdown-it config</span></span><br><span class=\"line\"><span class=\"comment\">## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span></span><br><span class=\"line\"><span class=\"attr\">markdown:</span></span><br><span class=\"line\"><span class=\"attr\">  render:</span></span><br><span class=\"line\"><span class=\"attr\">    html:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    xhtmlOut:</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"attr\">    breaks:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    linkify:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    typographer:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">    quotes:</span> <span class=\"string\">'“”‘’'</span></span><br></pre></td></tr></table></figure>\n<p>and if you want to change the header anchor ‘ℬ’, you can go to <code>layout/post.ejs</code> to change it.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span>(<span class=\"string\">\"https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js\"</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        anchors.options = &#123;</span><br><span class=\"line\">          visible: <span class=\"string\">'hover'</span>,</span><br><span class=\"line\">          placement: <span class=\"string\">'left'</span>,</span><br><span class=\"line\">          icon: ℬ <span class=\"comment\">// this is the header anchor \"unicode\" icon</span></span><br><span class=\"line\">        &#125;;</span><br></pre></td></tr></table></figure>\n<h2>Hexo Basics</h2>\n<hr>\n<p>Some hexo command:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">hexo new post <span class=\"string\">\"&lt;post name&gt;\"</span> <span class=\"comment\"># you can change post to another layout if you want</span></span><br><span class=\"line\">hexo clean &amp;&amp; hexo generate <span class=\"comment\"># generate the static file</span></span><br><span class=\"line\">hexo server <span class=\"comment\"># run hexo in local environment</span></span><br><span class=\"line\">hexo deploy <span class=\"comment\"># hexo will push the static files automatically into the specific branch(gh-pages) of your repo!</span></span><br></pre></td></tr></table></figure>\n<h1>Have fun ^_^</h1>\n<hr>\n<!-- Place this tag in your head or just before your close body tag. -->\n<script async defer src=\"https://buttons.github.io/buttons.js\"></script>\n<!-- Place this tag where you want the button to render. -->\n<p>Please <a class=\"github-button\" href=\"https://github.com/YenYuHsuan/hexo-theme-beantech\" data-icon=\"octicon-star\" aria-label=\"Star YenYuHsuan/hexo-theme-beantech on GitHub\" target=\"_blank\" rel=\"noopener\">Star</a> this Project if you like it! <a class=\"github-button\" href=\"https://github.com/YenYuHsuan\" aria-label=\"Follow @YenYuHsuan on GitHub\" target=\"_blank\" rel=\"noopener\">Follow</a> would also be appreciated!<br>\nPeace!</p>\n"},{"title":"Spring Security 로그인 인증 구현","catalog":true,"date":"2017-04-21T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n# Spring Security 로그인 인증 구현\n\n## 개요\nSpring Security에서 인증 사용할때 최상위 인터페이스 AuthenticationProviderManager Interface를 사용한다. 이인터페이스는 단순하게 아래와같이 정의 되어있다.\n```java\npublic interface authenticationManager{\n  Authentication authenticate(Authentication authetication) throws AuthenticationException;\n}\n```\n이 인터페이스는 로그인을 시도하는 유저의 비밀번호가 일치하는지를 비교해서 인증에 성공하게 되면 Aunthetication 객체를 리턴해주는것을 구현해야하는 인터페이스이다. 그리고 일반적으로 Srping 에서 authenticationManager 구현체로 ProviderManger를 사용하는데 이 ProviderManger는 이권한을 AuthencationProvider Interface에게 권한을 넘긴다. AuthencationProvider의 구현체로 Spring에서 몇가지 기본 구현체를 제고하는데 특수한 상황이 아니면 이것을 사용하면된다.그리고 일반적으로 그구현체로는 DaoAuthenticationProvier를 사용한다. DaoAuthenticationProvier는 인증을 하기위해 내부적으로 UserDetailsService를 이용해서 디비에서 유저정보를 읽어와 유저가 입력한정보를 대조해 인증에 성공하게되면 Authentication을 돌려주게되고 아니면 AuthenticationException이 발생하게 된다.\n\nAuthencationProvider가 : 로그인 인증처리를 구현(비밀번호 대조)\nUserDetailsService : 유저정보를 디비에서 불러오는 역할<br>\n\n\n## security 기본 설정\n### web.xml 설정\n가장먼저 web.xml에 내용을 추가합니다.\n```xml\n<filter-name>springSecurityFilterChain</filter-name>\n<filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class> //filter 처리을 spring security로 위임하는것\n</filter>\n\n<filter-mapping>\n<filter-name>springSecurityFilterChain</filter-name>\n<url-pattern>/*</url-pattern>\n</filter-mapping>\n<filter>\n```\n\nweb.xml에 security-context.xml 추가해준다.\n\n```xml\n<context-param>\n  <param-name>contextConfigLocation</param-name>\n  <param-value>/WEB-INF/spring/security-context.xml</param-value>\n</context-param>\n<listener>\n```\n\n\n그다음 메이븐 의존성을 추가합니다.\n\n### 메이븐 의존성 추가\n```xml\n<dependency>\n  <groupId>org.springframework.security</groupId>\n  <artifactId>spring-security-core</artifactId>\n<version>3.1.3.RELEASE</version>\n</dependency>\n\n<dependency>\n  <groupId>org.springframework.security</groupId>\n  <artifactId>spring-security-taglibs</artifactId>\n  <version>3.1.3.RELEASE</version>\n</dependency>\n\n<dependency>\n  <groupId>org.springframework.security</groupId>\n  <artifactId>spring-security-config</artifactId>\n  <version>3.1.3.RELEASE</version>\n</dependency>\n```\n### spring-security.xml 설정 (로그인 주소,로그아웃주소등 설정)\n\n```xml\n<security:http auto-config=\"true\" use-expressions=\"true\">\n  // expressions을 추가해야 hasRole,permitAll등의 다양한 옵션들을 쓸수 있음\n<security:form-login login-page=\"/loginForm\"/> //로그인 url\n<!-- <security:form-login login-page=\"/loginForm\" authentication-failure-url=\"성공유알엘 \"/> -->\n  <security:intercept-url pattern=\"/admin/**\" access=\"hasAuthority('ROLE_ADMIN')\"/>// 관리자만 들어갈수있음\n<security:intercept-url pattern=\"/manager/**\" access=\"hasRole('ROLE_MANAGER')\"/> //위랑 같은뜻 매니저만 들어갈수있음\n<security:intercept-url pattern=\"/member/**\" access=\"isAuthenticated()\"/> //인증한사람만 들어갈수있음\n<security:intercept-url pattern=\"/user\" access=\"hasRole('ROLE_USER')\" />\n<security:intercept-url pattern=\"/welcome\" access=\"hasRole('ROLE_ADMIN')\" />\n<security:intercept-url pattern=\"/**\" access=\"permitAll\" /> //누구나 다들어갈수 있음\n```\n\n* <security:form-login login-page=\"/loginForm\"/> 로그인실패하면 여기에서 설정해둔 url로 이동하게 된다.\n\n\n**사용자 커스터 마이징**\n아래 표는 우리가 Spring Security을 커스터마이징해서 사용할 수 있는 내용들이다.\n ![](http://i.imgur.com/Hhpxz9N.png)\n\n**화면 input 설정**\n* 아이디를 입력하는 input의 name은 j_username이다\n* 비밀번호를 입력하는 input은  j_password이다.\n* action은 j_spring_security_check이다. (post)\n\n**login 커스터마이징**\n```xml\n<security:form-login\n username-parameter=\"loginid\" //form name 변경할 수 있음\n password-parameter=\"loginpwd\" //form name 변경할 수 있음\n login-page=\"/login\" //권한없는 url접근하면 자동 여기에서 지정한 로그인으로가짐\n default-target-url=\"/welcome\" // 로그인하고 지정한 url이없을떄 defalut로 이동되는 url\n authentication-failure-url=\"/login?fail=true\"//로그인 실패시 이동되는 url 설정\n />\n\n```\n\n* 로그인 실패시 세션에 자동으로에러 메시지를 출력해주는 부분이 있는데 그걸 사용하게되면 로그인을 할때 마다 세션메시지가 계속 출력되게되고 이러다보면 was에 메모리가 가득차 full gc가 지속적으로 발생하게되면서 전반적으로 웹페이지가 느려질 수 있다.\n\n### db 연동\n\n먼저 root-context.xml에 디비정보를 추가해준다.\n```xml\n<!-- Root Context: defines shared resources visible to all other web components -->\n<bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n<property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"></property>\n<property name=\"url\" value=\"jdbc:mysql://디비주소\"></property>\n<property name=\"username\" value=\"디비아이디\"></property>\n<property name=\"password\" value=\"디비비번\"></property>\n</bean>\n```\n\nsecuirty-context.xml에 내용을 추가해준다.\n```xml\n<security:authentication-manager alias=\"authenticationManager\">\n  <security:authentication-provider ref=\"customeAuthenticationProvider\">\n  </security:authentication-provider>\n  <security:authentication-provider user-service-ref=\"customeUserDetailsService\">\n     <security:password-encoder ref=\"passwordEncoder\"></security:password-encoder>\n  </security:authentication-provider>\n</security:authentication-manager>\n```\n\n\n**데이터베이스**\n```sql\nCREATE TABLE `users` (\n  `username` varchar(50) NOT NULL,\n  `password` varchar(100) NOT NULL,\n  `enabled` tinyint(1) NOT NULL,\n  `age` varchar(10) DEFAULT NULL,\n  PRIMARY KEY (`username`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n//이부분은 사용하지 않지만 사용하실분들은 권한설정 테이블을 만드셔도됩니다.\nCREATE TABLE `authorities` (\n  `username` varchar(50) NOT NULL,\n  `authority` varchar(50) NOT NULL,\n  UNIQUE KEY `ix_auth_username` (`username`,`authority`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n```\n\n| 테이블      |           설명          |                                   컬럼                                   |\n|-------------|:-----------------------:|:------------------------------------------------------------------------:|\n| users       | 사용자 이름과 암호 정보 | username:사용자이름(로그인ID) <br>password:인증암호<br> enabled:계정사용가능여부 <br> age:사용자정보 나이 |\n| authorities | 사용자-권한 매핑 정보   | username:사용자 이름(로그인ID)<br> authority:권한\n\nage는 나중에 유저정보를 확인하기위해 넣어습니다. (추가적으로 유저정보를 더넣고싶으면 더넣어도 무방함)\n\n예) user Table\n\n| username | password | enabled | age |\n|----------|:--------:|:-------:|:-------:|\n|   admin  |   1234   |    1    | 33|\n|  bkchoi  |   1234   |    1    |23|\n\n\nauthorities Table\n\n| username |   authority   |\n|----------|:------------:|\n|   admin  |     USER     |\n|   admin  | USER_MANAGER |\n|  bkchoi  |     USER     |\n\n\n### 실제 구현체들 구현\n그다음 customeAuthenticationProvider, customeUserDetailsService을 구현해주면 된다.\n\n```java\n@Service\npublic class CustomUserDetailsService implements UserDetailsService {\n\n\t@Inject\n\tUserDao dao;\n\n\t@Override\n\tpublic user loadUserByUsername(String username) throws UsernameNotFoundException {\n\t\tuser userInfo = null;\n\t\ttry {\n\t\t\tuserInfo = dao.read(username); //디비 정보를 불러와 유저정보 조\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n  }\n}\n```\n\nCustomUserDetailsService 이곳에서 유저가입력한 아이디를 통해 유저정보를 불러와서 CustomAuthenticationProvider class로 정보를 넘겨주게된다.\n\n```java\n@Component\npublic class CustomAuthenticationProvider implements AuthenticationProvider { //authenticationManager\n  @Override\n  public Authentication authenticate(Authentication authentication) throws AuthenticationException {\n    UsernamePasswordAuthenticationToken authToken = (UsernamePasswordAuthenticationToken) authentication; //유저가 입력한 정보를 이이디비번으으로만든다.(로그인한 유저아이디비번정보를담는다)\n\n    user userInfo = customeUserDetailsService.loadUserByUsername(authToken.getName()); //UserDetailsService에서 유저정보를 불러온다.\n    if (userInfo == null) {\n      throw new UsernameNotFoundException(authToken.getName());\n    }\n\n    if (!matchPassword(userInfo.getPassword(), authToken.getCredentials())) {\n      throw new BadCredentialsException(\"not matching username or password\");\n    }\n\n    List<GrantedAuthority> authorities = (List<GrantedAuthority>) userInfo.getAuthorities();\n\n    return new UsernamePasswordAuthenticationToken(userInfo,null,authorities);\n  }\n\n  private boolean matchPassword(String password, Object credentials) {\n    return password.equals(credentials);\n  }\n\n  @Override\n  public boolean supports(Class<?> authentication) {\n    return UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication);\n  }\n\n}\n```\n그럼 CustomAuthenticationProviderclass에서 유저가입력한 정보와 디비에 유저정보를 통해 인증 처리를 하게된다.\n\n\n## 결론\n1. 스프링은 크게 2가지인터페이스를 구현하여 인증/인가 처리를 도와준다. (AuthenticationProvider,UserDetailsService)\n2. UserDetailsService 는 데이터베이스의 유저정보를 불러오는 역활을한다\n3. AuthenticationProvider 는 UserDetailsService에서 리턴해준 유저정보와 사용자가 입력한 유저의 비밀번호를 매칭하여 로그인 인증처리를 한다\n\n[깃허브 예제 소스](https://github.com/minwan1/securitybasis/tree/security-basis)\n\n참고<br>\n* [사랑이 고픈 프로그래머..](http://zgundam.tistory.com/45)<br>\n* [Spring 4.0 프로그래밍](http://storefarm.naver.com/dcvirus/products/458328014?NaPm=ct%3Dj06r6ydk%7Cci%3D1744f23aa4586709889a372fc15683afa2b4928e%7Ctr%3Dsls%7Csn%3D182521%7Chk%3Dab9fe496302792c50421edea06a3e322286ad2b9)<br>\n","source":"_posts/2017-04-22-spring-security-implement.md","raw":"---\ntitle: Spring Security 로그인 인증 구현\ncatalog: true\ndate: 2017-04-22\nsubtitle:\nheader-img:\ntags:\n- Spring\n- Java\n\n---\n\n# Spring Security 로그인 인증 구현\n\n## 개요\nSpring Security에서 인증 사용할때 최상위 인터페이스 AuthenticationProviderManager Interface를 사용한다. 이인터페이스는 단순하게 아래와같이 정의 되어있다.\n```java\npublic interface authenticationManager{\n  Authentication authenticate(Authentication authetication) throws AuthenticationException;\n}\n```\n이 인터페이스는 로그인을 시도하는 유저의 비밀번호가 일치하는지를 비교해서 인증에 성공하게 되면 Aunthetication 객체를 리턴해주는것을 구현해야하는 인터페이스이다. 그리고 일반적으로 Srping 에서 authenticationManager 구현체로 ProviderManger를 사용하는데 이 ProviderManger는 이권한을 AuthencationProvider Interface에게 권한을 넘긴다. AuthencationProvider의 구현체로 Spring에서 몇가지 기본 구현체를 제고하는데 특수한 상황이 아니면 이것을 사용하면된다.그리고 일반적으로 그구현체로는 DaoAuthenticationProvier를 사용한다. DaoAuthenticationProvier는 인증을 하기위해 내부적으로 UserDetailsService를 이용해서 디비에서 유저정보를 읽어와 유저가 입력한정보를 대조해 인증에 성공하게되면 Authentication을 돌려주게되고 아니면 AuthenticationException이 발생하게 된다.\n\nAuthencationProvider가 : 로그인 인증처리를 구현(비밀번호 대조)\nUserDetailsService : 유저정보를 디비에서 불러오는 역할<br>\n\n\n## security 기본 설정\n### web.xml 설정\n가장먼저 web.xml에 내용을 추가합니다.\n```xml\n<filter-name>springSecurityFilterChain</filter-name>\n<filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class> //filter 처리을 spring security로 위임하는것\n</filter>\n\n<filter-mapping>\n<filter-name>springSecurityFilterChain</filter-name>\n<url-pattern>/*</url-pattern>\n</filter-mapping>\n<filter>\n```\n\nweb.xml에 security-context.xml 추가해준다.\n\n```xml\n<context-param>\n  <param-name>contextConfigLocation</param-name>\n  <param-value>/WEB-INF/spring/security-context.xml</param-value>\n</context-param>\n<listener>\n```\n\n\n그다음 메이븐 의존성을 추가합니다.\n\n### 메이븐 의존성 추가\n```xml\n<dependency>\n  <groupId>org.springframework.security</groupId>\n  <artifactId>spring-security-core</artifactId>\n<version>3.1.3.RELEASE</version>\n</dependency>\n\n<dependency>\n  <groupId>org.springframework.security</groupId>\n  <artifactId>spring-security-taglibs</artifactId>\n  <version>3.1.3.RELEASE</version>\n</dependency>\n\n<dependency>\n  <groupId>org.springframework.security</groupId>\n  <artifactId>spring-security-config</artifactId>\n  <version>3.1.3.RELEASE</version>\n</dependency>\n```\n### spring-security.xml 설정 (로그인 주소,로그아웃주소등 설정)\n\n```xml\n<security:http auto-config=\"true\" use-expressions=\"true\">\n  // expressions을 추가해야 hasRole,permitAll등의 다양한 옵션들을 쓸수 있음\n<security:form-login login-page=\"/loginForm\"/> //로그인 url\n<!-- <security:form-login login-page=\"/loginForm\" authentication-failure-url=\"성공유알엘 \"/> -->\n  <security:intercept-url pattern=\"/admin/**\" access=\"hasAuthority('ROLE_ADMIN')\"/>// 관리자만 들어갈수있음\n<security:intercept-url pattern=\"/manager/**\" access=\"hasRole('ROLE_MANAGER')\"/> //위랑 같은뜻 매니저만 들어갈수있음\n<security:intercept-url pattern=\"/member/**\" access=\"isAuthenticated()\"/> //인증한사람만 들어갈수있음\n<security:intercept-url pattern=\"/user\" access=\"hasRole('ROLE_USER')\" />\n<security:intercept-url pattern=\"/welcome\" access=\"hasRole('ROLE_ADMIN')\" />\n<security:intercept-url pattern=\"/**\" access=\"permitAll\" /> //누구나 다들어갈수 있음\n```\n\n* <security:form-login login-page=\"/loginForm\"/> 로그인실패하면 여기에서 설정해둔 url로 이동하게 된다.\n\n\n**사용자 커스터 마이징**\n아래 표는 우리가 Spring Security을 커스터마이징해서 사용할 수 있는 내용들이다.\n ![](http://i.imgur.com/Hhpxz9N.png)\n\n**화면 input 설정**\n* 아이디를 입력하는 input의 name은 j_username이다\n* 비밀번호를 입력하는 input은  j_password이다.\n* action은 j_spring_security_check이다. (post)\n\n**login 커스터마이징**\n```xml\n<security:form-login\n username-parameter=\"loginid\" //form name 변경할 수 있음\n password-parameter=\"loginpwd\" //form name 변경할 수 있음\n login-page=\"/login\" //권한없는 url접근하면 자동 여기에서 지정한 로그인으로가짐\n default-target-url=\"/welcome\" // 로그인하고 지정한 url이없을떄 defalut로 이동되는 url\n authentication-failure-url=\"/login?fail=true\"//로그인 실패시 이동되는 url 설정\n />\n\n```\n\n* 로그인 실패시 세션에 자동으로에러 메시지를 출력해주는 부분이 있는데 그걸 사용하게되면 로그인을 할때 마다 세션메시지가 계속 출력되게되고 이러다보면 was에 메모리가 가득차 full gc가 지속적으로 발생하게되면서 전반적으로 웹페이지가 느려질 수 있다.\n\n### db 연동\n\n먼저 root-context.xml에 디비정보를 추가해준다.\n```xml\n<!-- Root Context: defines shared resources visible to all other web components -->\n<bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n<property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"></property>\n<property name=\"url\" value=\"jdbc:mysql://디비주소\"></property>\n<property name=\"username\" value=\"디비아이디\"></property>\n<property name=\"password\" value=\"디비비번\"></property>\n</bean>\n```\n\nsecuirty-context.xml에 내용을 추가해준다.\n```xml\n<security:authentication-manager alias=\"authenticationManager\">\n  <security:authentication-provider ref=\"customeAuthenticationProvider\">\n  </security:authentication-provider>\n  <security:authentication-provider user-service-ref=\"customeUserDetailsService\">\n     <security:password-encoder ref=\"passwordEncoder\"></security:password-encoder>\n  </security:authentication-provider>\n</security:authentication-manager>\n```\n\n\n**데이터베이스**\n```sql\nCREATE TABLE `users` (\n  `username` varchar(50) NOT NULL,\n  `password` varchar(100) NOT NULL,\n  `enabled` tinyint(1) NOT NULL,\n  `age` varchar(10) DEFAULT NULL,\n  PRIMARY KEY (`username`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n//이부분은 사용하지 않지만 사용하실분들은 권한설정 테이블을 만드셔도됩니다.\nCREATE TABLE `authorities` (\n  `username` varchar(50) NOT NULL,\n  `authority` varchar(50) NOT NULL,\n  UNIQUE KEY `ix_auth_username` (`username`,`authority`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n```\n\n| 테이블      |           설명          |                                   컬럼                                   |\n|-------------|:-----------------------:|:------------------------------------------------------------------------:|\n| users       | 사용자 이름과 암호 정보 | username:사용자이름(로그인ID) <br>password:인증암호<br> enabled:계정사용가능여부 <br> age:사용자정보 나이 |\n| authorities | 사용자-권한 매핑 정보   | username:사용자 이름(로그인ID)<br> authority:권한\n\nage는 나중에 유저정보를 확인하기위해 넣어습니다. (추가적으로 유저정보를 더넣고싶으면 더넣어도 무방함)\n\n예) user Table\n\n| username | password | enabled | age |\n|----------|:--------:|:-------:|:-------:|\n|   admin  |   1234   |    1    | 33|\n|  bkchoi  |   1234   |    1    |23|\n\n\nauthorities Table\n\n| username |   authority   |\n|----------|:------------:|\n|   admin  |     USER     |\n|   admin  | USER_MANAGER |\n|  bkchoi  |     USER     |\n\n\n### 실제 구현체들 구현\n그다음 customeAuthenticationProvider, customeUserDetailsService을 구현해주면 된다.\n\n```java\n@Service\npublic class CustomUserDetailsService implements UserDetailsService {\n\n\t@Inject\n\tUserDao dao;\n\n\t@Override\n\tpublic user loadUserByUsername(String username) throws UsernameNotFoundException {\n\t\tuser userInfo = null;\n\t\ttry {\n\t\t\tuserInfo = dao.read(username); //디비 정보를 불러와 유저정보 조\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n  }\n}\n```\n\nCustomUserDetailsService 이곳에서 유저가입력한 아이디를 통해 유저정보를 불러와서 CustomAuthenticationProvider class로 정보를 넘겨주게된다.\n\n```java\n@Component\npublic class CustomAuthenticationProvider implements AuthenticationProvider { //authenticationManager\n  @Override\n  public Authentication authenticate(Authentication authentication) throws AuthenticationException {\n    UsernamePasswordAuthenticationToken authToken = (UsernamePasswordAuthenticationToken) authentication; //유저가 입력한 정보를 이이디비번으으로만든다.(로그인한 유저아이디비번정보를담는다)\n\n    user userInfo = customeUserDetailsService.loadUserByUsername(authToken.getName()); //UserDetailsService에서 유저정보를 불러온다.\n    if (userInfo == null) {\n      throw new UsernameNotFoundException(authToken.getName());\n    }\n\n    if (!matchPassword(userInfo.getPassword(), authToken.getCredentials())) {\n      throw new BadCredentialsException(\"not matching username or password\");\n    }\n\n    List<GrantedAuthority> authorities = (List<GrantedAuthority>) userInfo.getAuthorities();\n\n    return new UsernamePasswordAuthenticationToken(userInfo,null,authorities);\n  }\n\n  private boolean matchPassword(String password, Object credentials) {\n    return password.equals(credentials);\n  }\n\n  @Override\n  public boolean supports(Class<?> authentication) {\n    return UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication);\n  }\n\n}\n```\n그럼 CustomAuthenticationProviderclass에서 유저가입력한 정보와 디비에 유저정보를 통해 인증 처리를 하게된다.\n\n\n## 결론\n1. 스프링은 크게 2가지인터페이스를 구현하여 인증/인가 처리를 도와준다. (AuthenticationProvider,UserDetailsService)\n2. UserDetailsService 는 데이터베이스의 유저정보를 불러오는 역활을한다\n3. AuthenticationProvider 는 UserDetailsService에서 리턴해준 유저정보와 사용자가 입력한 유저의 비밀번호를 매칭하여 로그인 인증처리를 한다\n\n[깃허브 예제 소스](https://github.com/minwan1/securitybasis/tree/security-basis)\n\n참고<br>\n* [사랑이 고픈 프로그래머..](http://zgundam.tistory.com/45)<br>\n* [Spring 4.0 프로그래밍](http://storefarm.naver.com/dcvirus/products/458328014?NaPm=ct%3Dj06r6ydk%7Cci%3D1744f23aa4586709889a372fc15683afa2b4928e%7Ctr%3Dsls%7Csn%3D182521%7Chk%3Dab9fe496302792c50421edea06a3e322286ad2b9)<br>\n","slug":"2017-04-22-spring-security-implement","published":1,"updated":"2018-06-20T16:05:18.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27d9002bjjpekl3tx2gw","content":"<h1><span id=\"spring-security-로그인-인증-구현\">Spring Security 로그인 인증 구현</span></h1>\n<h2><span id=\"개요\">개요</span></h2>\n<p>Spring Security에서 인증 사용할때 최상위 인터페이스 AuthenticationProviderManager Interface를 사용한다. 이인터페이스는 단순하게 아래와같이 정의 되어있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">authenticationManager</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\">Authentication <span class=\"title\">authenticate</span><span class=\"params\">(Authentication authetication)</span> <span class=\"keyword\">throws</span> AuthenticationException</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이 인터페이스는 로그인을 시도하는 유저의 비밀번호가 일치하는지를 비교해서 인증에 성공하게 되면 Aunthetication 객체를 리턴해주는것을 구현해야하는 인터페이스이다. 그리고 일반적으로 Srping 에서 authenticationManager 구현체로 ProviderManger를 사용하는데 이 ProviderManger는 이권한을 AuthencationProvider Interface에게 권한을 넘긴다. AuthencationProvider의 구현체로 Spring에서 몇가지 기본 구현체를 제고하는데 특수한 상황이 아니면 이것을 사용하면된다.그리고 일반적으로 그구현체로는 DaoAuthenticationProvier를 사용한다. DaoAuthenticationProvier는 인증을 하기위해 내부적으로 UserDetailsService를 이용해서 디비에서 유저정보를 읽어와 유저가 입력한정보를 대조해 인증에 성공하게되면 Authentication을 돌려주게되고 아니면 AuthenticationException이 발생하게 된다.</p>\n<p>AuthencationProvider가 : 로그인 인증처리를 구현(비밀번호 대조)<br>\nUserDetailsService : 유저정보를 디비에서 불러오는 역할<br></p>\n<h2><span id=\"security-기본-설정\">security 기본 설정</span></h2>\n<h3><span id=\"webxml-설정\">web.xml 설정</span></h3>\n<p>가장먼저 web.xml에 내용을 추가합니다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>springSecurityFilterChain<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span> //filter 처리을 spring security로 위임하는것</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>springSecurityFilterChain<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>web.xml에 security-context.xml 추가해준다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>/WEB-INF/spring/security-context.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>그다음 메이븐 의존성을 추가합니다.</p>\n<h3><span id=\"메이븐-의존성-추가\">메이븐 의존성 추가</span></h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.security<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-security-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.1.3.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.security<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-security-taglibs<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.1.3.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.security<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-security-config<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.1.3.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"spring-securityxml-설정-로그인-주소로그아웃주소등-설정\">spring-security.xml 설정 (로그인 주소,로그아웃주소등 설정)</span></h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">security:http</span> <span class=\"attr\">auto-config</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">use-expressions</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\">  // expressions을 추가해야 hasRole,permitAll등의 다양한 옵션들을 쓸수 있음</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">security:form-login</span> <span class=\"attr\">login-page</span>=<span class=\"string\">\"/loginForm\"</span>/&gt;</span> //로그인 url</span><br><span class=\"line\"><span class=\"comment\">&lt;!-- &lt;security:form-login login-page=\"/loginForm\" authentication-failure-url=\"성공유알엘 \"/&gt; --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">security:intercept-url</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"/admin/**\"</span> <span class=\"attr\">access</span>=<span class=\"string\">\"hasAuthority('ROLE_ADMIN')\"</span>/&gt;</span>// 관리자만 들어갈수있음</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">security:intercept-url</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"/manager/**\"</span> <span class=\"attr\">access</span>=<span class=\"string\">\"hasRole('ROLE_MANAGER')\"</span>/&gt;</span> //위랑 같은뜻 매니저만 들어갈수있음</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">security:intercept-url</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"/member/**\"</span> <span class=\"attr\">access</span>=<span class=\"string\">\"isAuthenticated()\"</span>/&gt;</span> //인증한사람만 들어갈수있음</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">security:intercept-url</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"/user\"</span> <span class=\"attr\">access</span>=<span class=\"string\">\"hasRole('ROLE_USER')\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">security:intercept-url</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"/welcome\"</span> <span class=\"attr\">access</span>=<span class=\"string\">\"hasRole('ROLE_ADMIN')\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">security:intercept-url</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"/**\"</span> <span class=\"attr\">access</span>=<span class=\"string\">\"permitAll\"</span> /&gt;</span> //누구나 다들어갈수 있음</span><br></pre></td></tr></table></figure>\n<ul>\n<li>&lt;security:form-login login-page=&quot;/loginForm&quot;/&gt; 로그인실패하면 여기에서 설정해둔 url로 이동하게 된다.</li>\n</ul>\n<p><strong>사용자 커스터 마이징</strong><br>\n아래 표는 우리가 Spring Security을 커스터마이징해서 사용할 수 있는 내용들이다.<br>\n<img src=\"http://i.imgur.com/Hhpxz9N.png\" alt=\"\"></p>\n<p><strong>화면 input 설정</strong></p>\n<ul>\n<li>아이디를 입력하는 input의 name은 j_username이다</li>\n<li>비밀번호를 입력하는 input은  j_password이다.</li>\n<li>action은 j_spring_security_check이다. (post)</li>\n</ul>\n<p><strong>login 커스터마이징</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">security:form-login</span></span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">username-parameter</span>=<span class=\"string\">\"loginid\"</span> //<span class=\"attr\">form</span> <span class=\"attr\">name</span> 변경할 수 있음</span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">password-parameter</span>=<span class=\"string\">\"loginpwd\"</span> //<span class=\"attr\">form</span> <span class=\"attr\">name</span> 변경할 수 있음</span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">login-page</span>=<span class=\"string\">\"/login\"</span> //권한없는 <span class=\"attr\">url</span>접근하면 자동 여기에서 지정한 로그인으로가짐</span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">default-target-url</span>=<span class=\"string\">\"/welcome\"</span> // 로그인하고 지정한 <span class=\"attr\">url</span>이없을떄 <span class=\"attr\">defalut</span>로 이동되는 <span class=\"attr\">url</span></span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">authentication-failure-url</span>=<span class=\"string\">\"/login?fail=true\"</span>//로그인 실패시 이동되는 <span class=\"attr\">url</span> 설정</span></span><br><span class=\"line\"><span class=\"tag\"> /&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>로그인 실패시 세션에 자동으로에러 메시지를 출력해주는 부분이 있는데 그걸 사용하게되면 로그인을 할때 마다 세션메시지가 계속 출력되게되고 이러다보면 was에 메모리가 가득차 full gc가 지속적으로 발생하게되면서 전반적으로 웹페이지가 느려질 수 있다.</li>\n</ul>\n<h3><span id=\"db-연동\">db 연동</span></h3>\n<p>먼저 root-context.xml에 디비정보를 추가해준다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- Root Context: defines shared resources visible to all other web components --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.jdbc.datasource.DriverManagerDataSource\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driverClassName\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.mysql.jdbc.Driver\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"jdbc:mysql://디비주소\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"디비아이디\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"디비비번\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>secuirty-context.xml에 내용을 추가해준다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">security:authentication-manager</span> <span class=\"attr\">alias</span>=<span class=\"string\">\"authenticationManager\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">security:authentication-provider</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"customeAuthenticationProvider\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">security:authentication-provider</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">security:authentication-provider</span> <span class=\"attr\">user-service-ref</span>=<span class=\"string\">\"customeUserDetailsService\"</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">security:password-encoder</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"passwordEncoder\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">security:password-encoder</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">security:authentication-provider</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">security:authentication-manager</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>데이터베이스</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`users`</span> (</span><br><span class=\"line\">  <span class=\"string\">`username`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">50</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`password`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">100</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`enabled`</span> tinyint(<span class=\"number\">1</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`age`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">10</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`username`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8;</span><br><span class=\"line\"></span><br><span class=\"line\">//이부분은 사용하지 않지만 사용하실분들은 권한설정 테이블을 만드셔도됩니다.</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`authorities`</span> (</span><br><span class=\"line\">  <span class=\"string\">`username`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">50</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`authority`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">50</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"keyword\">UNIQUE</span> <span class=\"keyword\">KEY</span> <span class=\"string\">`ix_auth_username`</span> (<span class=\"string\">`username`</span>,<span class=\"string\">`authority`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>테이블</th>\n<th style=\"text-align:center\">설명</th>\n<th style=\"text-align:center\">컬럼</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>users</td>\n<td style=\"text-align:center\">사용자 이름과 암호 정보</td>\n<td style=\"text-align:center\">username:사용자이름(로그인ID) <br>password:인증암호<br> enabled:계정사용가능여부 <br> age:사용자정보 나이</td>\n</tr>\n<tr>\n<td>authorities</td>\n<td style=\"text-align:center\">사용자-권한 매핑 정보</td>\n<td style=\"text-align:center\">username:사용자 이름(로그인ID)<br> authority:권한</td>\n</tr>\n</tbody>\n</table>\n<p>age는 나중에 유저정보를 확인하기위해 넣어습니다. (추가적으로 유저정보를 더넣고싶으면 더넣어도 무방함)</p>\n<p>예) user Table</p>\n<table>\n<thead>\n<tr>\n<th>username</th>\n<th style=\"text-align:center\">password</th>\n<th style=\"text-align:center\">enabled</th>\n<th style=\"text-align:center\">age</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>admin</td>\n<td style=\"text-align:center\">1234</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">33</td>\n</tr>\n<tr>\n<td>bkchoi</td>\n<td style=\"text-align:center\">1234</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">23</td>\n</tr>\n</tbody>\n</table>\n<p>authorities Table</p>\n<table>\n<thead>\n<tr>\n<th>username</th>\n<th style=\"text-align:center\">authority</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>admin</td>\n<td style=\"text-align:center\">USER</td>\n</tr>\n<tr>\n<td>admin</td>\n<td style=\"text-align:center\">USER_MANAGER</td>\n</tr>\n<tr>\n<td>bkchoi</td>\n<td style=\"text-align:center\">USER</td>\n</tr>\n</tbody>\n</table>\n<h3><span id=\"실제-구현체들-구현\">실제 구현체들 구현</span></h3>\n<p>그다음 customeAuthenticationProvider, customeUserDetailsService을 구현해주면 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomUserDetailsService</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserDetailsService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Inject</span></span><br><span class=\"line\">\tUserDao dao;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> user <span class=\"title\">loadUserByUsername</span><span class=\"params\">(String username)</span> <span class=\"keyword\">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class=\"line\">\t\tuser userInfo = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\tuserInfo = dao.read(username); <span class=\"comment\">//디비 정보를 불러와 유저정보 조</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// TODO Auto-generated catch block</span></span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>CustomUserDetailsService 이곳에서 유저가입력한 아이디를 통해 유저정보를 불러와서 CustomAuthenticationProvider class로 정보를 넘겨주게된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomAuthenticationProvider</span> <span class=\"keyword\">implements</span> <span class=\"title\">AuthenticationProvider</span> </span>&#123; <span class=\"comment\">//authenticationManager</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Authentication <span class=\"title\">authenticate</span><span class=\"params\">(Authentication authentication)</span> <span class=\"keyword\">throws</span> AuthenticationException </span>&#123;</span><br><span class=\"line\">    UsernamePasswordAuthenticationToken authToken = (UsernamePasswordAuthenticationToken) authentication; <span class=\"comment\">//유저가 입력한 정보를 이이디비번으으로만든다.(로그인한 유저아이디비번정보를담는다)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    user userInfo = customeUserDetailsService.loadUserByUsername(authToken.getName()); <span class=\"comment\">//UserDetailsService에서 유저정보를 불러온다.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (userInfo == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UsernameNotFoundException(authToken.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!matchPassword(userInfo.getPassword(), authToken.getCredentials())) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BadCredentialsException(<span class=\"string\">\"not matching username or password\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;GrantedAuthority&gt; authorities = (List&lt;GrantedAuthority&gt;) userInfo.getAuthorities();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UsernamePasswordAuthenticationToken(userInfo,<span class=\"keyword\">null</span>,authorities);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matchPassword</span><span class=\"params\">(String password, Object credentials)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> password.equals(credentials);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">supports</span><span class=\"params\">(Class&lt;?&gt; authentication)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그럼 CustomAuthenticationProviderclass에서 유저가입력한 정보와 디비에 유저정보를 통해 인증 처리를 하게된다.</p>\n<h2><span id=\"결론\">결론</span></h2>\n<ol>\n<li>스프링은 크게 2가지인터페이스를 구현하여 인증/인가 처리를 도와준다. (AuthenticationProvider,UserDetailsService)</li>\n<li>UserDetailsService 는 데이터베이스의 유저정보를 불러오는 역활을한다</li>\n<li>AuthenticationProvider 는 UserDetailsService에서 리턴해준 유저정보와 사용자가 입력한 유저의 비밀번호를 매칭하여 로그인 인증처리를 한다</li>\n</ol>\n<p><a href=\"https://github.com/minwan1/securitybasis/tree/security-basis\" target=\"_blank\" rel=\"noopener\">깃허브 예제 소스</a></p>\n<p>참고<br></p>\n<ul>\n<li><a href=\"http://zgundam.tistory.com/45\" target=\"_blank\" rel=\"noopener\">사랑이 고픈 프로그래머…</a><br></li>\n<li><a href=\"http://storefarm.naver.com/dcvirus/products/458328014?NaPm=ct%3Dj06r6ydk%7Cci%3D1744f23aa4586709889a372fc15683afa2b4928e%7Ctr%3Dsls%7Csn%3D182521%7Chk%3Dab9fe496302792c50421edea06a3e322286ad2b9\" target=\"_blank\" rel=\"noopener\">Spring 4.0 프로그래밍</a><br></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>Spring Security 로그인 인증 구현</h1>\n<h2>개요</h2>\n<p>Spring Security에서 인증 사용할때 최상위 인터페이스 AuthenticationProviderManager Interface를 사용한다. 이인터페이스는 단순하게 아래와같이 정의 되어있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">authenticationManager</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\">Authentication <span class=\"title\">authenticate</span><span class=\"params\">(Authentication authetication)</span> <span class=\"keyword\">throws</span> AuthenticationException</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이 인터페이스는 로그인을 시도하는 유저의 비밀번호가 일치하는지를 비교해서 인증에 성공하게 되면 Aunthetication 객체를 리턴해주는것을 구현해야하는 인터페이스이다. 그리고 일반적으로 Srping 에서 authenticationManager 구현체로 ProviderManger를 사용하는데 이 ProviderManger는 이권한을 AuthencationProvider Interface에게 권한을 넘긴다. AuthencationProvider의 구현체로 Spring에서 몇가지 기본 구현체를 제고하는데 특수한 상황이 아니면 이것을 사용하면된다.그리고 일반적으로 그구현체로는 DaoAuthenticationProvier를 사용한다. DaoAuthenticationProvier는 인증을 하기위해 내부적으로 UserDetailsService를 이용해서 디비에서 유저정보를 읽어와 유저가 입력한정보를 대조해 인증에 성공하게되면 Authentication을 돌려주게되고 아니면 AuthenticationException이 발생하게 된다.</p>\n<p>AuthencationProvider가 : 로그인 인증처리를 구현(비밀번호 대조)<br>\nUserDetailsService : 유저정보를 디비에서 불러오는 역할<br></p>\n<h2>security 기본 설정</h2>\n<h3>web.xml 설정</h3>\n<p>가장먼저 web.xml에 내용을 추가합니다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>springSecurityFilterChain<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class=\"tag\">&lt;/<span class=\"name\">filter-class</span>&gt;</span> //filter 처리을 spring security로 위임하는것</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter-name</span>&gt;</span>springSecurityFilterChain<span class=\"tag\">&lt;/<span class=\"name\">filter-name</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/*<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">filter-mapping</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">filter</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>web.xml에 security-context.xml 추가해준다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">param-name</span>&gt;</span>contextConfigLocation<span class=\"tag\">&lt;/<span class=\"name\">param-name</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">param-value</span>&gt;</span>/WEB-INF/spring/security-context.xml<span class=\"tag\">&lt;/<span class=\"name\">param-value</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">context-param</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>그다음 메이븐 의존성을 추가합니다.</p>\n<h3>메이븐 의존성 추가</h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.security<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-security-core<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.1.3.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.security<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-security-taglibs<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.1.3.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.security<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-security-config<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.1.3.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3>spring-security.xml 설정 (로그인 주소,로그아웃주소등 설정)</h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">security:http</span> <span class=\"attr\">auto-config</span>=<span class=\"string\">\"true\"</span> <span class=\"attr\">use-expressions</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\">  // expressions을 추가해야 hasRole,permitAll등의 다양한 옵션들을 쓸수 있음</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">security:form-login</span> <span class=\"attr\">login-page</span>=<span class=\"string\">\"/loginForm\"</span>/&gt;</span> //로그인 url</span><br><span class=\"line\"><span class=\"comment\">&lt;!-- &lt;security:form-login login-page=\"/loginForm\" authentication-failure-url=\"성공유알엘 \"/&gt; --&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">security:intercept-url</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"/admin/**\"</span> <span class=\"attr\">access</span>=<span class=\"string\">\"hasAuthority('ROLE_ADMIN')\"</span>/&gt;</span>// 관리자만 들어갈수있음</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">security:intercept-url</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"/manager/**\"</span> <span class=\"attr\">access</span>=<span class=\"string\">\"hasRole('ROLE_MANAGER')\"</span>/&gt;</span> //위랑 같은뜻 매니저만 들어갈수있음</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">security:intercept-url</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"/member/**\"</span> <span class=\"attr\">access</span>=<span class=\"string\">\"isAuthenticated()\"</span>/&gt;</span> //인증한사람만 들어갈수있음</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">security:intercept-url</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"/user\"</span> <span class=\"attr\">access</span>=<span class=\"string\">\"hasRole('ROLE_USER')\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">security:intercept-url</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"/welcome\"</span> <span class=\"attr\">access</span>=<span class=\"string\">\"hasRole('ROLE_ADMIN')\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">security:intercept-url</span> <span class=\"attr\">pattern</span>=<span class=\"string\">\"/**\"</span> <span class=\"attr\">access</span>=<span class=\"string\">\"permitAll\"</span> /&gt;</span> //누구나 다들어갈수 있음</span><br></pre></td></tr></table></figure>\n<ul>\n<li>&lt;security:form-login login-page=&quot;/loginForm&quot;/&gt; 로그인실패하면 여기에서 설정해둔 url로 이동하게 된다.</li>\n</ul>\n<p><strong>사용자 커스터 마이징</strong><br>\n아래 표는 우리가 Spring Security을 커스터마이징해서 사용할 수 있는 내용들이다.<br>\n<img src=\"http://i.imgur.com/Hhpxz9N.png\" alt=\"\"></p>\n<p><strong>화면 input 설정</strong></p>\n<ul>\n<li>아이디를 입력하는 input의 name은 j_username이다</li>\n<li>비밀번호를 입력하는 input은  j_password이다.</li>\n<li>action은 j_spring_security_check이다. (post)</li>\n</ul>\n<p><strong>login 커스터마이징</strong></p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">security:form-login</span></span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">username-parameter</span>=<span class=\"string\">\"loginid\"</span> //<span class=\"attr\">form</span> <span class=\"attr\">name</span> 변경할 수 있음</span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">password-parameter</span>=<span class=\"string\">\"loginpwd\"</span> //<span class=\"attr\">form</span> <span class=\"attr\">name</span> 변경할 수 있음</span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">login-page</span>=<span class=\"string\">\"/login\"</span> //권한없는 <span class=\"attr\">url</span>접근하면 자동 여기에서 지정한 로그인으로가짐</span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">default-target-url</span>=<span class=\"string\">\"/welcome\"</span> // 로그인하고 지정한 <span class=\"attr\">url</span>이없을떄 <span class=\"attr\">defalut</span>로 이동되는 <span class=\"attr\">url</span></span></span><br><span class=\"line\"><span class=\"tag\"> <span class=\"attr\">authentication-failure-url</span>=<span class=\"string\">\"/login?fail=true\"</span>//로그인 실패시 이동되는 <span class=\"attr\">url</span> 설정</span></span><br><span class=\"line\"><span class=\"tag\"> /&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>로그인 실패시 세션에 자동으로에러 메시지를 출력해주는 부분이 있는데 그걸 사용하게되면 로그인을 할때 마다 세션메시지가 계속 출력되게되고 이러다보면 was에 메모리가 가득차 full gc가 지속적으로 발생하게되면서 전반적으로 웹페이지가 느려질 수 있다.</li>\n</ul>\n<h3>db 연동</h3>\n<p>먼저 root-context.xml에 디비정보를 추가해준다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- Root Context: defines shared resources visible to all other web components --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">\"dataSource\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"org.springframework.jdbc.datasource.DriverManagerDataSource\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"driverClassName\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"com.mysql.jdbc.Driver\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"url\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"jdbc:mysql://디비주소\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"디비아이디\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"디비비번\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>secuirty-context.xml에 내용을 추가해준다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">security:authentication-manager</span> <span class=\"attr\">alias</span>=<span class=\"string\">\"authenticationManager\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">security:authentication-provider</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"customeAuthenticationProvider\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">security:authentication-provider</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">security:authentication-provider</span> <span class=\"attr\">user-service-ref</span>=<span class=\"string\">\"customeUserDetailsService\"</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">security:password-encoder</span> <span class=\"attr\">ref</span>=<span class=\"string\">\"passwordEncoder\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">security:password-encoder</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">security:authentication-provider</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">security:authentication-manager</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><strong>데이터베이스</strong></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`users`</span> (</span><br><span class=\"line\">  <span class=\"string\">`username`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">50</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`password`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">100</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`enabled`</span> tinyint(<span class=\"number\">1</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`age`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">10</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`username`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8;</span><br><span class=\"line\"></span><br><span class=\"line\">//이부분은 사용하지 않지만 사용하실분들은 권한설정 테이블을 만드셔도됩니다.</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`authorities`</span> (</span><br><span class=\"line\">  <span class=\"string\">`username`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">50</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`authority`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">50</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"keyword\">UNIQUE</span> <span class=\"keyword\">KEY</span> <span class=\"string\">`ix_auth_username`</span> (<span class=\"string\">`username`</span>,<span class=\"string\">`authority`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>테이블</th>\n<th style=\"text-align:center\">설명</th>\n<th style=\"text-align:center\">컬럼</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>users</td>\n<td style=\"text-align:center\">사용자 이름과 암호 정보</td>\n<td style=\"text-align:center\">username:사용자이름(로그인ID) <br>password:인증암호<br> enabled:계정사용가능여부 <br> age:사용자정보 나이</td>\n</tr>\n<tr>\n<td>authorities</td>\n<td style=\"text-align:center\">사용자-권한 매핑 정보</td>\n<td style=\"text-align:center\">username:사용자 이름(로그인ID)<br> authority:권한</td>\n</tr>\n</tbody>\n</table>\n<p>age는 나중에 유저정보를 확인하기위해 넣어습니다. (추가적으로 유저정보를 더넣고싶으면 더넣어도 무방함)</p>\n<p>예) user Table</p>\n<table>\n<thead>\n<tr>\n<th>username</th>\n<th style=\"text-align:center\">password</th>\n<th style=\"text-align:center\">enabled</th>\n<th style=\"text-align:center\">age</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>admin</td>\n<td style=\"text-align:center\">1234</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">33</td>\n</tr>\n<tr>\n<td>bkchoi</td>\n<td style=\"text-align:center\">1234</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">23</td>\n</tr>\n</tbody>\n</table>\n<p>authorities Table</p>\n<table>\n<thead>\n<tr>\n<th>username</th>\n<th style=\"text-align:center\">authority</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>admin</td>\n<td style=\"text-align:center\">USER</td>\n</tr>\n<tr>\n<td>admin</td>\n<td style=\"text-align:center\">USER_MANAGER</td>\n</tr>\n<tr>\n<td>bkchoi</td>\n<td style=\"text-align:center\">USER</td>\n</tr>\n</tbody>\n</table>\n<h3>실제 구현체들 구현</h3>\n<p>그다음 customeAuthenticationProvider, customeUserDetailsService을 구현해주면 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomUserDetailsService</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserDetailsService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Inject</span></span><br><span class=\"line\">\tUserDao dao;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> user <span class=\"title\">loadUserByUsername</span><span class=\"params\">(String username)</span> <span class=\"keyword\">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class=\"line\">\t\tuser userInfo = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">\t\t\tuserInfo = dao.read(username); <span class=\"comment\">//디비 정보를 불러와 유저정보 조</span></span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">// TODO Auto-generated catch block</span></span><br><span class=\"line\">\t\t\te.printStackTrace();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>CustomUserDetailsService 이곳에서 유저가입력한 아이디를 통해 유저정보를 불러와서 CustomAuthenticationProvider class로 정보를 넘겨주게된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomAuthenticationProvider</span> <span class=\"keyword\">implements</span> <span class=\"title\">AuthenticationProvider</span> </span>&#123; <span class=\"comment\">//authenticationManager</span></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Authentication <span class=\"title\">authenticate</span><span class=\"params\">(Authentication authentication)</span> <span class=\"keyword\">throws</span> AuthenticationException </span>&#123;</span><br><span class=\"line\">    UsernamePasswordAuthenticationToken authToken = (UsernamePasswordAuthenticationToken) authentication; <span class=\"comment\">//유저가 입력한 정보를 이이디비번으으로만든다.(로그인한 유저아이디비번정보를담는다)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    user userInfo = customeUserDetailsService.loadUserByUsername(authToken.getName()); <span class=\"comment\">//UserDetailsService에서 유저정보를 불러온다.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (userInfo == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UsernameNotFoundException(authToken.getName());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!matchPassword(userInfo.getPassword(), authToken.getCredentials())) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> BadCredentialsException(<span class=\"string\">\"not matching username or password\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    List&lt;GrantedAuthority&gt; authorities = (List&lt;GrantedAuthority&gt;) userInfo.getAuthorities();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UsernamePasswordAuthenticationToken(userInfo,<span class=\"keyword\">null</span>,authorities);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">matchPassword</span><span class=\"params\">(String password, Object credentials)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> password.equals(credentials);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">supports</span><span class=\"params\">(Class&lt;?&gt; authentication)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그럼 CustomAuthenticationProviderclass에서 유저가입력한 정보와 디비에 유저정보를 통해 인증 처리를 하게된다.</p>\n<h2>결론</h2>\n<ol>\n<li>스프링은 크게 2가지인터페이스를 구현하여 인증/인가 처리를 도와준다. (AuthenticationProvider,UserDetailsService)</li>\n<li>UserDetailsService 는 데이터베이스의 유저정보를 불러오는 역활을한다</li>\n<li>AuthenticationProvider 는 UserDetailsService에서 리턴해준 유저정보와 사용자가 입력한 유저의 비밀번호를 매칭하여 로그인 인증처리를 한다</li>\n</ol>\n<p><a href=\"https://github.com/minwan1/securitybasis/tree/security-basis\" target=\"_blank\" rel=\"noopener\">깃허브 예제 소스</a></p>\n<p>참고<br></p>\n<ul>\n<li><a href=\"http://zgundam.tistory.com/45\" target=\"_blank\" rel=\"noopener\">사랑이 고픈 프로그래머…</a><br></li>\n<li><a href=\"http://storefarm.naver.com/dcvirus/products/458328014?NaPm=ct%3Dj06r6ydk%7Cci%3D1744f23aa4586709889a372fc15683afa2b4928e%7Ctr%3Dsls%7Csn%3D182521%7Chk%3Dab9fe496302792c50421edea06a3e322286ad2b9\" target=\"_blank\" rel=\"noopener\">Spring 4.0 프로그래밍</a><br></li>\n</ul>\n"},{"title":"Spring-social-facebook 구현","catalog":true,"date":"2017-04-21T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"# Spring-social-facebook 구현\n## 내용\nSpring social 로그인은 두가지 구현 방법이 있다. Connect Framework/Provider Sign In 방법이 있다.\n\n```\n\"/connection/facebook\" post\n\"/signin/facebook\" post\n```\n\n* Connect 방법은 타임라인에 글을 보거나 쓰는용도로 많이쓰인다.\n* signin은 일반적으로 로그인을 구현할때 많이 사용된다.\n\n지금 구현하려는 방식은 signin방식이다.\n먼저 signin방식을 사용하기위해서 ProviderSignInController을 알아야한다.\nProviderSignInController는 컨트롤러로 구성되어있다. /signin/{provider} (provider는 facebook/twitter etc)\n예를들어 /signin/facebook을 보내주게되면 컨트롤러에서 facebook에 맞는 인증처리 작업을 수행하게된다.\n\n그리고 Spring social에서 지정해준 table을 등록해줘야한다.\n```sql\ncreate table UserConnection (userId varchar(255) not null,\n\tproviderId varchar(255) not null,\n\tproviderUserId varchar(255),\n\trank int not null,\n\tdisplayName varchar(255),\n\tprofileUrl varchar(512),\n\timageUrl varchar(512),\n\taccessToken varchar(512) not null,\n\tsecret varchar(512),\n\trefreshToken varchar(512),\n\texpireTime bigint,\n\tprimary key (userId, providerId, providerUserId));\ncreate unique index UserConnectionRank on UserConnection(userId, providerId, rank);\n```\n\n\n### SocialConfigurerAdapter,SocialConfigurer\nspring social 기본 설정을 해주는 클래스를 구현해줘야한다. SocialConfigurerAdapter 추상클래스를 extends해서 사용해도 되고 SocialConfigurer interface를 구현해도 무방하다.\n\n### ConnectionSignUp\n이 interface는 유저가 처음 로그인할때 어플리케이션(자신이 만들고있는)에 회원가입을 구현할수있는 곳이다. provider에서 로그인이 성공적으로 진행하면 Userconnection테이블에서 현재 페이스북으로 가입한유저가있는지 providerId,providerUserId 을통해 검색한다. 만약 Userconnection테이블에서 유저 정보가 없다면 ConnectionSignUp의 execute(Connection<?> connection) 메소드가 호출된다. 이메소드에서 provider에서 제공해주는 유저의 정보을 얻어 올수 있다. 첫번째 로그인이후에는 userconnection테이블에서 유저을 찾게되면 이메소드는 더이상 호출되지 않는다.\n\n### SignInAdapter\nprovider측에서 인증이 끝난후에 userconnection에 정보가 저장된후에 구현해야할 인터페이스이다. SignInAdapter의 signIn메소드는 어플리케이션의 로그인 로직을 구현하여 로그인 기능을 구현하면된다.\n\n\n### 메이븐 추가\n\n```xml\n<!-- Spring Social -->\n<dependency>\n\t<groupId>org.springframework.social</groupId>\n\t<artifactId>spring-social-web</artifactId>\n\t<version>1.1.1.RELEASE</version>\n</dependency>\n\n<!-- Spring Social Facebook -->\n<dependency>\n\t<groupId>org.springframework.social</groupId>\n\t<artifactId>spring-social-facebook</artifactId>\n\t<version>2.0.3.RELEASE</version>\n</dependency>\n```\n\n### SocialConfigurerAdapter 추상클래스 구현\n```java\n@Configuration\npublic class SocialConfig extends SocialConfigurerAdapter{\n\t@Autowired\n\tprivate Environment environment;\n\t@Autowired\n\tprivate DataSource dataSource;\n\t@Autowired\n\tprivate UserRepository userRepository;\n\n\t@Bean\n\tpublic SignInAdapter signInAdapter() {\n\t\treturn new PostSocialSignInAdapter(userRepository);\n\t}\n\n\t@Override\n\tpublic UsersConnectionRepository getUsersConnectionRepository(ConnectionFactoryLocator connectionFactoryLocator) {\n\t\tJdbcUsersConnectionRepository repository = new JdbcUsersConnectionRepository(dataSource,\n\t\t\t\tconnectionFactoryLocator, Encryptors.text(environment.getProperty(\"social.security.encryptPassword\"),\n\t\t\t\t\t\tenvironment.getProperty(\"social.security.encryptSalt\")));\n\t\trepository.setConnectionSignUp(new SocialImplicitSignUp(userRepository));\n\t\treturn repository;\n\t}\n}\n```\n\n\nJdbcUsersConnectionRepository는 Userconnection테이블과 연결되어지는 spring social로부터 사용되어지는 DAO이다. 어플리케이션이 사용하는 데이터베이스를 연결하려면 필수로 datasource 등을 생성자로 넣어줘야한다. 첫번쨰로는 datasource을 2번째인자로는 provider들을 관리해주는 connectionFactoryLocator을 넣는다. 3번째로는 암호화방식을 넣어준다. Encryptors.noOpText()로 설정하게되면 평문으로 디비에 정보가 저장된다. 만약 provider들을 더 추가하고싶은면 addConnectionFactories 메소드를 추가해서 오버라이딩해서 provider들을 추가해주면 된다. 솔직히 전체적인 로직을 추가하면 provider들을 추가하는건 어렵지않다.\n\n```java\npublic List<String> findUserIdsWithConnection(Connection<?> connection) {\n  ConnectionKey key = connection.getKey();\n  List<String> localUserIds = jdbcTemplate.queryForList(\"select userId from \" + tablePrefix + \"UserConnection where providerId = ? and providerUserId = ?\", String.class, key.getProviderId(), key.getProviderUserId());\n  if (localUserIds.size() == 0 && connectionSignUp != null) {\n    String newUserId = connectionSignUp.execute(connection);\n    if (newUserId != null)\n    {\n      createConnectionRepository(newUserId).addConnection(connection);\n      return Arrays.asList(newUserId);\n    }\n  }\n  return localUserIds;\n}\n```\n\n위는 spring-social 라이브러리 내부인데 providerId = ? and providerUserId = ? 을 통해 userconnection에서 유저정보를 불러와 유저정보가없다면 connectionSignUp을 타게된다. 그렇게되면 아래의 클래스가 실행된다. 그리고 provider에서 보내준 유저정보를 통해 어플리케이션의 회원가입처리를 해준다. 그다음 return 해준값으로 userconnection테이블에 userid에 값이 저장 된다.\n\n### ConnectionSignUp 인터페이스 구현\n```java\npublic class SocialImplicitSignUp implements ConnectionSignUp {\n\tprivate UserRepository userRepository;\n\n\tpublic SocialImplicitSignUp(UserRepository userRepository){\n\t\tthis.userRepository = userRepository;\n\t}\n\n\t@Override\n\tpublic String execute(Connection<?> connection) {\n\t\tUserProfile profile = connection.fetchUserProfile();\n\t\tUser user = new User(profile.getFirstName() + \" \" + profile.getLastName(), profile.getEmail(), \"N/A\",\n\t\t\t\tconnection.getImageUrl());\n\t\tuserRepository.save(user);\n\t\treturn user.getEmail();\n\t}\n}\n```\n\n회원가입처리가 끝나고 밑에 로그인 어댑터를 실행하게된다. security를 사용하면 security로그인처리를 하면되고, 아니라면 아래와같이 로그인 처리를 하면된다.\n\n### SignInAdapter 인터페이스 구현\n```java\npublic class PostSocialSignInAdapter implements SignInAdapter {\n\tprivate UserRepository userRepository;\n\n\t@Inject\n\tpublic PostSocialSignInAdapter(UserRepository userRepository) {\n\t\tthis.userRepository = userRepository;\n\t}\n\n\t@Override\n\tpublic String signIn(String localUserId, Connection<?> connection, NativeWebRequest request) {\n\t\tUserProfile profile = connection.fetchUserProfile();\n\t\tUser user = userRepository.findByEmail(profile.getEmail());\n\t\tHttpServletRequest req = ((ServletWebRequest) request).getRequest();\n\t\treq.getSession().setAttribute(\"loggedUser\", user);\n\t\treturn \"/\"; // will return to postSignInUrl 로그인한이후에 이동될 사이트인듯\n\t}\n\n}\n\n```\n예제에서는 아래의 테이블도 추가해줘야한다.\n```sql\nCREATE TABLE `user` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `email` varchar(128) NOT NULL,\n  `name` varchar(128) NOT NULL,\n  `password` varchar(64) NOT NULL,\n  `thumbnail_url` varchar(255) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;\n```\n\n## 결론\n1. SocialConfigurerAdapter을 통해 기본 spring-social 설정\n2. ConnectionSignUp 회원가입 구현\n3. SignInAdapter 웹어플리케이션 로그인 구현\n\n\n\n[깃허브 예제 소스](https://github.com/minwan1/Spring-social-facebook)\n\n참고<br>\n* [JavaCents](http://javacents.com/adding-social-sign-in-to-a-spring-boot-app/)<br>\n","source":"_posts/2017-04-22-spring-social.md","raw":"---\ntitle: Spring-social-facebook 구현\ncatalog: true\ndate: 2017-04-22\nsubtitle:\nheader-img:\ntags:\n- Spring\n- Java\n\n---\n# Spring-social-facebook 구현\n## 내용\nSpring social 로그인은 두가지 구현 방법이 있다. Connect Framework/Provider Sign In 방법이 있다.\n\n```\n\"/connection/facebook\" post\n\"/signin/facebook\" post\n```\n\n* Connect 방법은 타임라인에 글을 보거나 쓰는용도로 많이쓰인다.\n* signin은 일반적으로 로그인을 구현할때 많이 사용된다.\n\n지금 구현하려는 방식은 signin방식이다.\n먼저 signin방식을 사용하기위해서 ProviderSignInController을 알아야한다.\nProviderSignInController는 컨트롤러로 구성되어있다. /signin/{provider} (provider는 facebook/twitter etc)\n예를들어 /signin/facebook을 보내주게되면 컨트롤러에서 facebook에 맞는 인증처리 작업을 수행하게된다.\n\n그리고 Spring social에서 지정해준 table을 등록해줘야한다.\n```sql\ncreate table UserConnection (userId varchar(255) not null,\n\tproviderId varchar(255) not null,\n\tproviderUserId varchar(255),\n\trank int not null,\n\tdisplayName varchar(255),\n\tprofileUrl varchar(512),\n\timageUrl varchar(512),\n\taccessToken varchar(512) not null,\n\tsecret varchar(512),\n\trefreshToken varchar(512),\n\texpireTime bigint,\n\tprimary key (userId, providerId, providerUserId));\ncreate unique index UserConnectionRank on UserConnection(userId, providerId, rank);\n```\n\n\n### SocialConfigurerAdapter,SocialConfigurer\nspring social 기본 설정을 해주는 클래스를 구현해줘야한다. SocialConfigurerAdapter 추상클래스를 extends해서 사용해도 되고 SocialConfigurer interface를 구현해도 무방하다.\n\n### ConnectionSignUp\n이 interface는 유저가 처음 로그인할때 어플리케이션(자신이 만들고있는)에 회원가입을 구현할수있는 곳이다. provider에서 로그인이 성공적으로 진행하면 Userconnection테이블에서 현재 페이스북으로 가입한유저가있는지 providerId,providerUserId 을통해 검색한다. 만약 Userconnection테이블에서 유저 정보가 없다면 ConnectionSignUp의 execute(Connection<?> connection) 메소드가 호출된다. 이메소드에서 provider에서 제공해주는 유저의 정보을 얻어 올수 있다. 첫번째 로그인이후에는 userconnection테이블에서 유저을 찾게되면 이메소드는 더이상 호출되지 않는다.\n\n### SignInAdapter\nprovider측에서 인증이 끝난후에 userconnection에 정보가 저장된후에 구현해야할 인터페이스이다. SignInAdapter의 signIn메소드는 어플리케이션의 로그인 로직을 구현하여 로그인 기능을 구현하면된다.\n\n\n### 메이븐 추가\n\n```xml\n<!-- Spring Social -->\n<dependency>\n\t<groupId>org.springframework.social</groupId>\n\t<artifactId>spring-social-web</artifactId>\n\t<version>1.1.1.RELEASE</version>\n</dependency>\n\n<!-- Spring Social Facebook -->\n<dependency>\n\t<groupId>org.springframework.social</groupId>\n\t<artifactId>spring-social-facebook</artifactId>\n\t<version>2.0.3.RELEASE</version>\n</dependency>\n```\n\n### SocialConfigurerAdapter 추상클래스 구현\n```java\n@Configuration\npublic class SocialConfig extends SocialConfigurerAdapter{\n\t@Autowired\n\tprivate Environment environment;\n\t@Autowired\n\tprivate DataSource dataSource;\n\t@Autowired\n\tprivate UserRepository userRepository;\n\n\t@Bean\n\tpublic SignInAdapter signInAdapter() {\n\t\treturn new PostSocialSignInAdapter(userRepository);\n\t}\n\n\t@Override\n\tpublic UsersConnectionRepository getUsersConnectionRepository(ConnectionFactoryLocator connectionFactoryLocator) {\n\t\tJdbcUsersConnectionRepository repository = new JdbcUsersConnectionRepository(dataSource,\n\t\t\t\tconnectionFactoryLocator, Encryptors.text(environment.getProperty(\"social.security.encryptPassword\"),\n\t\t\t\t\t\tenvironment.getProperty(\"social.security.encryptSalt\")));\n\t\trepository.setConnectionSignUp(new SocialImplicitSignUp(userRepository));\n\t\treturn repository;\n\t}\n}\n```\n\n\nJdbcUsersConnectionRepository는 Userconnection테이블과 연결되어지는 spring social로부터 사용되어지는 DAO이다. 어플리케이션이 사용하는 데이터베이스를 연결하려면 필수로 datasource 등을 생성자로 넣어줘야한다. 첫번쨰로는 datasource을 2번째인자로는 provider들을 관리해주는 connectionFactoryLocator을 넣는다. 3번째로는 암호화방식을 넣어준다. Encryptors.noOpText()로 설정하게되면 평문으로 디비에 정보가 저장된다. 만약 provider들을 더 추가하고싶은면 addConnectionFactories 메소드를 추가해서 오버라이딩해서 provider들을 추가해주면 된다. 솔직히 전체적인 로직을 추가하면 provider들을 추가하는건 어렵지않다.\n\n```java\npublic List<String> findUserIdsWithConnection(Connection<?> connection) {\n  ConnectionKey key = connection.getKey();\n  List<String> localUserIds = jdbcTemplate.queryForList(\"select userId from \" + tablePrefix + \"UserConnection where providerId = ? and providerUserId = ?\", String.class, key.getProviderId(), key.getProviderUserId());\n  if (localUserIds.size() == 0 && connectionSignUp != null) {\n    String newUserId = connectionSignUp.execute(connection);\n    if (newUserId != null)\n    {\n      createConnectionRepository(newUserId).addConnection(connection);\n      return Arrays.asList(newUserId);\n    }\n  }\n  return localUserIds;\n}\n```\n\n위는 spring-social 라이브러리 내부인데 providerId = ? and providerUserId = ? 을 통해 userconnection에서 유저정보를 불러와 유저정보가없다면 connectionSignUp을 타게된다. 그렇게되면 아래의 클래스가 실행된다. 그리고 provider에서 보내준 유저정보를 통해 어플리케이션의 회원가입처리를 해준다. 그다음 return 해준값으로 userconnection테이블에 userid에 값이 저장 된다.\n\n### ConnectionSignUp 인터페이스 구현\n```java\npublic class SocialImplicitSignUp implements ConnectionSignUp {\n\tprivate UserRepository userRepository;\n\n\tpublic SocialImplicitSignUp(UserRepository userRepository){\n\t\tthis.userRepository = userRepository;\n\t}\n\n\t@Override\n\tpublic String execute(Connection<?> connection) {\n\t\tUserProfile profile = connection.fetchUserProfile();\n\t\tUser user = new User(profile.getFirstName() + \" \" + profile.getLastName(), profile.getEmail(), \"N/A\",\n\t\t\t\tconnection.getImageUrl());\n\t\tuserRepository.save(user);\n\t\treturn user.getEmail();\n\t}\n}\n```\n\n회원가입처리가 끝나고 밑에 로그인 어댑터를 실행하게된다. security를 사용하면 security로그인처리를 하면되고, 아니라면 아래와같이 로그인 처리를 하면된다.\n\n### SignInAdapter 인터페이스 구현\n```java\npublic class PostSocialSignInAdapter implements SignInAdapter {\n\tprivate UserRepository userRepository;\n\n\t@Inject\n\tpublic PostSocialSignInAdapter(UserRepository userRepository) {\n\t\tthis.userRepository = userRepository;\n\t}\n\n\t@Override\n\tpublic String signIn(String localUserId, Connection<?> connection, NativeWebRequest request) {\n\t\tUserProfile profile = connection.fetchUserProfile();\n\t\tUser user = userRepository.findByEmail(profile.getEmail());\n\t\tHttpServletRequest req = ((ServletWebRequest) request).getRequest();\n\t\treq.getSession().setAttribute(\"loggedUser\", user);\n\t\treturn \"/\"; // will return to postSignInUrl 로그인한이후에 이동될 사이트인듯\n\t}\n\n}\n\n```\n예제에서는 아래의 테이블도 추가해줘야한다.\n```sql\nCREATE TABLE `user` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `email` varchar(128) NOT NULL,\n  `name` varchar(128) NOT NULL,\n  `password` varchar(64) NOT NULL,\n  `thumbnail_url` varchar(255) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;\n```\n\n## 결론\n1. SocialConfigurerAdapter을 통해 기본 spring-social 설정\n2. ConnectionSignUp 회원가입 구현\n3. SignInAdapter 웹어플리케이션 로그인 구현\n\n\n\n[깃허브 예제 소스](https://github.com/minwan1/Spring-social-facebook)\n\n참고<br>\n* [JavaCents](http://javacents.com/adding-social-sign-in-to-a-spring-boot-app/)<br>\n","slug":"2017-04-22-spring-social","published":1,"updated":"2018-06-20T16:05:18.236Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27da002cjjpe6ukaux6e","content":"<h1><span id=\"spring-social-facebook-구현\">Spring-social-facebook 구현</span></h1>\n<h2><span id=\"내용\">내용</span></h2>\n<p>Spring social 로그인은 두가지 구현 방법이 있다. Connect Framework/Provider Sign In 방법이 있다.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;/connection/facebook&quot; post</span><br><span class=\"line\">&quot;/signin/facebook&quot; post</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Connect 방법은 타임라인에 글을 보거나 쓰는용도로 많이쓰인다.</li>\n<li>signin은 일반적으로 로그인을 구현할때 많이 사용된다.</li>\n</ul>\n<p>지금 구현하려는 방식은 signin방식이다.<br>\n먼저 signin방식을 사용하기위해서 ProviderSignInController을 알아야한다.<br>\nProviderSignInController는 컨트롤러로 구성되어있다. /signin/{provider} (provider는 facebook/twitter etc)<br>\n예를들어 /signin/facebook을 보내주게되면 컨트롤러에서 facebook에 맞는 인증처리 작업을 수행하게된다.</p>\n<p>그리고 Spring social에서 지정해준 table을 등록해줘야한다.</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> UserConnection (userId <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">\tproviderId <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">\tproviderUserId <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>),</span><br><span class=\"line\">\t<span class=\"keyword\">rank</span> <span class=\"built_in\">int</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">\tdisplayName <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>),</span><br><span class=\"line\">\tprofileUrl <span class=\"built_in\">varchar</span>(<span class=\"number\">512</span>),</span><br><span class=\"line\">\timageUrl <span class=\"built_in\">varchar</span>(<span class=\"number\">512</span>),</span><br><span class=\"line\">\taccessToken <span class=\"built_in\">varchar</span>(<span class=\"number\">512</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">\tsecret <span class=\"built_in\">varchar</span>(<span class=\"number\">512</span>),</span><br><span class=\"line\">\trefreshToken <span class=\"built_in\">varchar</span>(<span class=\"number\">512</span>),</span><br><span class=\"line\">\texpireTime <span class=\"built_in\">bigint</span>,</span><br><span class=\"line\">\tprimary <span class=\"keyword\">key</span> (userId, providerId, providerUserId));</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">unique</span> <span class=\"keyword\">index</span> UserConnectionRank <span class=\"keyword\">on</span> UserConnection(userId, providerId, <span class=\"keyword\">rank</span>);</span><br></pre></td></tr></table></figure>\n<h3><span id=\"socialconfigureradaptersocialconfigurer\">SocialConfigurerAdapter,SocialConfigurer</span></h3>\n<p>spring social 기본 설정을 해주는 클래스를 구현해줘야한다. SocialConfigurerAdapter 추상클래스를 extends해서 사용해도 되고 SocialConfigurer interface를 구현해도 무방하다.</p>\n<h3><span id=\"connectionsignup\">ConnectionSignUp</span></h3>\n<p>이 interface는 유저가 처음 로그인할때 어플리케이션(자신이 만들고있는)에 회원가입을 구현할수있는 곳이다. provider에서 로그인이 성공적으로 진행하면 Userconnection테이블에서 현재 페이스북으로 가입한유저가있는지 providerId,providerUserId 을통해 검색한다. 만약 Userconnection테이블에서 유저 정보가 없다면 ConnectionSignUp의 execute(Connection&lt;?&gt; connection) 메소드가 호출된다. 이메소드에서 provider에서 제공해주는 유저의 정보을 얻어 올수 있다. 첫번째 로그인이후에는 userconnection테이블에서 유저을 찾게되면 이메소드는 더이상 호출되지 않는다.</p>\n<h3><span id=\"signinadapter\">SignInAdapter</span></h3>\n<p>provider측에서 인증이 끝난후에 userconnection에 정보가 저장된후에 구현해야할 인터페이스이다. SignInAdapter의 signIn메소드는 어플리케이션의 로그인 로직을 구현하여 로그인 기능을 구현하면된다.</p>\n<h3><span id=\"메이븐-추가\">메이븐 추가</span></h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- Spring Social --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.social<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-social-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.1.1.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- Spring Social Facebook --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.social<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-social-facebook<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0.3.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3><span id=\"socialconfigureradapter-추상클래스-구현\">SocialConfigurerAdapter 추상클래스 구현</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SocialConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">SocialConfigurerAdapter</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Environment environment;</span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> DataSource dataSource;</span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> SignInAdapter <span class=\"title\">signInAdapter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PostSocialSignInAdapter(userRepository);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> UsersConnectionRepository <span class=\"title\">getUsersConnectionRepository</span><span class=\"params\">(ConnectionFactoryLocator connectionFactoryLocator)</span> </span>&#123;</span><br><span class=\"line\">\t\tJdbcUsersConnectionRepository repository = <span class=\"keyword\">new</span> JdbcUsersConnectionRepository(dataSource,</span><br><span class=\"line\">\t\t\t\tconnectionFactoryLocator, Encryptors.text(environment.getProperty(<span class=\"string\">\"social.security.encryptPassword\"</span>),</span><br><span class=\"line\">\t\t\t\t\t\tenvironment.getProperty(<span class=\"string\">\"social.security.encryptSalt\"</span>)));</span><br><span class=\"line\">\t\trepository.setConnectionSignUp(<span class=\"keyword\">new</span> SocialImplicitSignUp(userRepository));</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> repository;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>JdbcUsersConnectionRepository는 Userconnection테이블과 연결되어지는 spring social로부터 사용되어지는 DAO이다. 어플리케이션이 사용하는 데이터베이스를 연결하려면 필수로 datasource 등을 생성자로 넣어줘야한다. 첫번쨰로는 datasource을 2번째인자로는 provider들을 관리해주는 connectionFactoryLocator을 넣는다. 3번째로는 암호화방식을 넣어준다. Encryptors.noOpText()로 설정하게되면 평문으로 디비에 정보가 저장된다. 만약 provider들을 더 추가하고싶은면 addConnectionFactories 메소드를 추가해서 오버라이딩해서 provider들을 추가해주면 된다. 솔직히 전체적인 로직을 추가하면 provider들을 추가하는건 어렵지않다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">findUserIdsWithConnection</span><span class=\"params\">(Connection&lt;?&gt; connection)</span> </span>&#123;</span><br><span class=\"line\">  ConnectionKey key = connection.getKey();</span><br><span class=\"line\">  List&lt;String&gt; localUserIds = jdbcTemplate.queryForList(<span class=\"string\">\"select userId from \"</span> + tablePrefix + <span class=\"string\">\"UserConnection where providerId = ? and providerUserId = ?\"</span>, String.class, key.getProviderId(), key.getProviderUserId());</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (localUserIds.size() == <span class=\"number\">0</span> &amp;&amp; connectionSignUp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    String newUserId = connectionSignUp.execute(connection);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newUserId != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      createConnectionRepository(newUserId).addConnection(connection);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Arrays.asList(newUserId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> localUserIds;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위는 spring-social 라이브러리 내부인데 providerId = ? and providerUserId = ? 을 통해 userconnection에서 유저정보를 불러와 유저정보가없다면 connectionSignUp을 타게된다. 그렇게되면 아래의 클래스가 실행된다. 그리고 provider에서 보내준 유저정보를 통해 어플리케이션의 회원가입처리를 해준다. 그다음 return 해준값으로 userconnection테이블에 userid에 값이 저장 된다.</p>\n<h3><span id=\"connectionsignup-인터페이스-구현\">ConnectionSignUp 인터페이스 구현</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SocialImplicitSignUp</span> <span class=\"keyword\">implements</span> <span class=\"title\">ConnectionSignUp</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SocialImplicitSignUp</span><span class=\"params\">(UserRepository userRepository)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.userRepository = userRepository;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">execute</span><span class=\"params\">(Connection&lt;?&gt; connection)</span> </span>&#123;</span><br><span class=\"line\">\t\tUserProfile profile = connection.fetchUserProfile();</span><br><span class=\"line\">\t\tUser user = <span class=\"keyword\">new</span> User(profile.getFirstName() + <span class=\"string\">\" \"</span> + profile.getLastName(), profile.getEmail(), <span class=\"string\">\"N/A\"</span>,</span><br><span class=\"line\">\t\t\t\tconnection.getImageUrl());</span><br><span class=\"line\">\t\tuserRepository.save(user);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> user.getEmail();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>회원가입처리가 끝나고 밑에 로그인 어댑터를 실행하게된다. security를 사용하면 security로그인처리를 하면되고, 아니라면 아래와같이 로그인 처리를 하면된다.</p>\n<h3><span id=\"signinadapter-인터페이스-구현\">SignInAdapter 인터페이스 구현</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PostSocialSignInAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">SignInAdapter</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Inject</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PostSocialSignInAdapter</span><span class=\"params\">(UserRepository userRepository)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.userRepository = userRepository;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">signIn</span><span class=\"params\">(String localUserId, Connection&lt;?&gt; connection, NativeWebRequest request)</span> </span>&#123;</span><br><span class=\"line\">\t\tUserProfile profile = connection.fetchUserProfile();</span><br><span class=\"line\">\t\tUser user = userRepository.findByEmail(profile.getEmail());</span><br><span class=\"line\">\t\tHttpServletRequest req = ((ServletWebRequest) request).getRequest();</span><br><span class=\"line\">\t\treq.getSession().setAttribute(<span class=\"string\">\"loggedUser\"</span>, user);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"/\"</span>; <span class=\"comment\">// will return to postSignInUrl 로그인한이후에 이동될 사이트인듯</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>예제에서는 아래의 테이블도 추가해줘야한다.</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`user`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">bigint</span>(<span class=\"number\">20</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`email`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">128</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">128</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`password`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">64</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`thumbnail_url`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">7</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"결론\">결론</span></h2>\n<ol>\n<li>SocialConfigurerAdapter을 통해 기본 spring-social 설정</li>\n<li>ConnectionSignUp 회원가입 구현</li>\n<li>SignInAdapter 웹어플리케이션 로그인 구현</li>\n</ol>\n<p><a href=\"https://github.com/minwan1/Spring-social-facebook\" target=\"_blank\" rel=\"noopener\">깃허브 예제 소스</a></p>\n<p>참고<br></p>\n<ul>\n<li><a href=\"http://javacents.com/adding-social-sign-in-to-a-spring-boot-app/\" target=\"_blank\" rel=\"noopener\">JavaCents</a><br></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>Spring-social-facebook 구현</h1>\n<h2>내용</h2>\n<p>Spring social 로그인은 두가지 구현 방법이 있다. Connect Framework/Provider Sign In 방법이 있다.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&quot;/connection/facebook&quot; post</span><br><span class=\"line\">&quot;/signin/facebook&quot; post</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Connect 방법은 타임라인에 글을 보거나 쓰는용도로 많이쓰인다.</li>\n<li>signin은 일반적으로 로그인을 구현할때 많이 사용된다.</li>\n</ul>\n<p>지금 구현하려는 방식은 signin방식이다.<br>\n먼저 signin방식을 사용하기위해서 ProviderSignInController을 알아야한다.<br>\nProviderSignInController는 컨트롤러로 구성되어있다. /signin/{provider} (provider는 facebook/twitter etc)<br>\n예를들어 /signin/facebook을 보내주게되면 컨트롤러에서 facebook에 맞는 인증처리 작업을 수행하게된다.</p>\n<p>그리고 Spring social에서 지정해준 table을 등록해줘야한다.</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> UserConnection (userId <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">\tproviderId <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">\tproviderUserId <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>),</span><br><span class=\"line\">\t<span class=\"keyword\">rank</span> <span class=\"built_in\">int</span> <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">\tdisplayName <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>),</span><br><span class=\"line\">\tprofileUrl <span class=\"built_in\">varchar</span>(<span class=\"number\">512</span>),</span><br><span class=\"line\">\timageUrl <span class=\"built_in\">varchar</span>(<span class=\"number\">512</span>),</span><br><span class=\"line\">\taccessToken <span class=\"built_in\">varchar</span>(<span class=\"number\">512</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">\tsecret <span class=\"built_in\">varchar</span>(<span class=\"number\">512</span>),</span><br><span class=\"line\">\trefreshToken <span class=\"built_in\">varchar</span>(<span class=\"number\">512</span>),</span><br><span class=\"line\">\texpireTime <span class=\"built_in\">bigint</span>,</span><br><span class=\"line\">\tprimary <span class=\"keyword\">key</span> (userId, providerId, providerUserId));</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">unique</span> <span class=\"keyword\">index</span> UserConnectionRank <span class=\"keyword\">on</span> UserConnection(userId, providerId, <span class=\"keyword\">rank</span>);</span><br></pre></td></tr></table></figure>\n<h3>SocialConfigurerAdapter,SocialConfigurer</h3>\n<p>spring social 기본 설정을 해주는 클래스를 구현해줘야한다. SocialConfigurerAdapter 추상클래스를 extends해서 사용해도 되고 SocialConfigurer interface를 구현해도 무방하다.</p>\n<h3>ConnectionSignUp</h3>\n<p>이 interface는 유저가 처음 로그인할때 어플리케이션(자신이 만들고있는)에 회원가입을 구현할수있는 곳이다. provider에서 로그인이 성공적으로 진행하면 Userconnection테이블에서 현재 페이스북으로 가입한유저가있는지 providerId,providerUserId 을통해 검색한다. 만약 Userconnection테이블에서 유저 정보가 없다면 ConnectionSignUp의 execute(Connection&lt;?&gt; connection) 메소드가 호출된다. 이메소드에서 provider에서 제공해주는 유저의 정보을 얻어 올수 있다. 첫번째 로그인이후에는 userconnection테이블에서 유저을 찾게되면 이메소드는 더이상 호출되지 않는다.</p>\n<h3>SignInAdapter</h3>\n<p>provider측에서 인증이 끝난후에 userconnection에 정보가 저장된후에 구현해야할 인터페이스이다. SignInAdapter의 signIn메소드는 어플리케이션의 로그인 로직을 구현하여 로그인 기능을 구현하면된다.</p>\n<h3>메이븐 추가</h3>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- Spring Social --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.social<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-social-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.1.1.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- Spring Social Facebook --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.social<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-social-facebook<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0.3.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3>SocialConfigurerAdapter 추상클래스 구현</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SocialConfig</span> <span class=\"keyword\">extends</span> <span class=\"title\">SocialConfigurerAdapter</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Environment environment;</span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> DataSource dataSource;</span><br><span class=\"line\">\t<span class=\"meta\">@Autowired</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> SignInAdapter <span class=\"title\">signInAdapter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> PostSocialSignInAdapter(userRepository);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> UsersConnectionRepository <span class=\"title\">getUsersConnectionRepository</span><span class=\"params\">(ConnectionFactoryLocator connectionFactoryLocator)</span> </span>&#123;</span><br><span class=\"line\">\t\tJdbcUsersConnectionRepository repository = <span class=\"keyword\">new</span> JdbcUsersConnectionRepository(dataSource,</span><br><span class=\"line\">\t\t\t\tconnectionFactoryLocator, Encryptors.text(environment.getProperty(<span class=\"string\">\"social.security.encryptPassword\"</span>),</span><br><span class=\"line\">\t\t\t\t\t\tenvironment.getProperty(<span class=\"string\">\"social.security.encryptSalt\"</span>)));</span><br><span class=\"line\">\t\trepository.setConnectionSignUp(<span class=\"keyword\">new</span> SocialImplicitSignUp(userRepository));</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> repository;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>JdbcUsersConnectionRepository는 Userconnection테이블과 연결되어지는 spring social로부터 사용되어지는 DAO이다. 어플리케이션이 사용하는 데이터베이스를 연결하려면 필수로 datasource 등을 생성자로 넣어줘야한다. 첫번쨰로는 datasource을 2번째인자로는 provider들을 관리해주는 connectionFactoryLocator을 넣는다. 3번째로는 암호화방식을 넣어준다. Encryptors.noOpText()로 설정하게되면 평문으로 디비에 정보가 저장된다. 만약 provider들을 더 추가하고싶은면 addConnectionFactories 메소드를 추가해서 오버라이딩해서 provider들을 추가해주면 된다. 솔직히 전체적인 로직을 추가하면 provider들을 추가하는건 어렵지않다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;String&gt; <span class=\"title\">findUserIdsWithConnection</span><span class=\"params\">(Connection&lt;?&gt; connection)</span> </span>&#123;</span><br><span class=\"line\">  ConnectionKey key = connection.getKey();</span><br><span class=\"line\">  List&lt;String&gt; localUserIds = jdbcTemplate.queryForList(<span class=\"string\">\"select userId from \"</span> + tablePrefix + <span class=\"string\">\"UserConnection where providerId = ? and providerUserId = ?\"</span>, String.class, key.getProviderId(), key.getProviderUserId());</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (localUserIds.size() == <span class=\"number\">0</span> &amp;&amp; connectionSignUp != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    String newUserId = connectionSignUp.execute(connection);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newUserId != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      createConnectionRepository(newUserId).addConnection(connection);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> Arrays.asList(newUserId);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> localUserIds;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위는 spring-social 라이브러리 내부인데 providerId = ? and providerUserId = ? 을 통해 userconnection에서 유저정보를 불러와 유저정보가없다면 connectionSignUp을 타게된다. 그렇게되면 아래의 클래스가 실행된다. 그리고 provider에서 보내준 유저정보를 통해 어플리케이션의 회원가입처리를 해준다. 그다음 return 해준값으로 userconnection테이블에 userid에 값이 저장 된다.</p>\n<h3>ConnectionSignUp 인터페이스 구현</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SocialImplicitSignUp</span> <span class=\"keyword\">implements</span> <span class=\"title\">ConnectionSignUp</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SocialImplicitSignUp</span><span class=\"params\">(UserRepository userRepository)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.userRepository = userRepository;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">execute</span><span class=\"params\">(Connection&lt;?&gt; connection)</span> </span>&#123;</span><br><span class=\"line\">\t\tUserProfile profile = connection.fetchUserProfile();</span><br><span class=\"line\">\t\tUser user = <span class=\"keyword\">new</span> User(profile.getFirstName() + <span class=\"string\">\" \"</span> + profile.getLastName(), profile.getEmail(), <span class=\"string\">\"N/A\"</span>,</span><br><span class=\"line\">\t\t\t\tconnection.getImageUrl());</span><br><span class=\"line\">\t\tuserRepository.save(user);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> user.getEmail();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>회원가입처리가 끝나고 밑에 로그인 어댑터를 실행하게된다. security를 사용하면 security로그인처리를 하면되고, 아니라면 아래와같이 로그인 처리를 하면된다.</p>\n<h3>SignInAdapter 인터페이스 구현</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PostSocialSignInAdapter</span> <span class=\"keyword\">implements</span> <span class=\"title\">SignInAdapter</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Inject</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PostSocialSignInAdapter</span><span class=\"params\">(UserRepository userRepository)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.userRepository = userRepository;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">signIn</span><span class=\"params\">(String localUserId, Connection&lt;?&gt; connection, NativeWebRequest request)</span> </span>&#123;</span><br><span class=\"line\">\t\tUserProfile profile = connection.fetchUserProfile();</span><br><span class=\"line\">\t\tUser user = userRepository.findByEmail(profile.getEmail());</span><br><span class=\"line\">\t\tHttpServletRequest req = ((ServletWebRequest) request).getRequest();</span><br><span class=\"line\">\t\treq.getSession().setAttribute(<span class=\"string\">\"loggedUser\"</span>, user);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"string\">\"/\"</span>; <span class=\"comment\">// will return to postSignInUrl 로그인한이후에 이동될 사이트인듯</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>예제에서는 아래의 테이블도 추가해줘야한다.</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`user`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">bigint</span>(<span class=\"number\">20</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`email`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">128</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">128</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`password`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">64</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`thumbnail_url`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">7</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>\n<h2>결론</h2>\n<ol>\n<li>SocialConfigurerAdapter을 통해 기본 spring-social 설정</li>\n<li>ConnectionSignUp 회원가입 구현</li>\n<li>SignInAdapter 웹어플리케이션 로그인 구현</li>\n</ol>\n<p><a href=\"https://github.com/minwan1/Spring-social-facebook\" target=\"_blank\" rel=\"noopener\">깃허브 예제 소스</a></p>\n<p>참고<br></p>\n<ul>\n<li><a href=\"http://javacents.com/adding-social-sign-in-to-a-spring-boot-app/\" target=\"_blank\" rel=\"noopener\">JavaCents</a><br></li>\n</ul>\n"},{"title":"Spring cache","catalog":true,"date":"2018-03-17T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n## Spring cache, ehcache 구현\n\n### Cache\n일반적으로 애플리케이션에서 데이터베이스를 접근하게 되면 많은 시간과 비용을 소비하게 된다. 그래서 반복적으로 일어나면서 많은 양의 데이터를 가지고 와야 하는 작업은 부담이 된다. 그래서 많은 사람들은 이러한 문제를 해결하기 위해서 캐시를 사용한다. 캐시를 사용하면 데이터베이스 접근하는 횟수를 획기적으로 개선할 수 있기 때문이다.\n\n### Spring Cache\n그래서 Spring에서는 이러한 Cache 기능을 지원하기 위해서 Spring caching abstraction을 지원한다. Spring caching abstraction는 다른 캐시 솔루션을 Spring CacheManager를 통해서 쉽게 사용할 수 있도록 해준다. Spring CacheManager는 다양한 캐시의 솔루션들을 코드에 최소의 영향으로 다양한 캐싱 솔루션(라이브러리)을 도입할 수 있게 해준다. Spring caching abstraction은 자바 메소드에 캐싱을 적용한다. 그래서 메소드가 실행될 떄마다 메소드의 넘어온 파라미터에 따라 캐쉬를 적용하게 된다. 예를들어 2초이상걸리는 A라는 메소드를 호출 했을 때 파라미터로 1의 값을 넘겼고, 결과값 으로 2를 받았다고 하면 그다음에 다시 한번 누군가가 A메소드를 1의 파라미터를 넘겼으면 A메소드는 2초의 시간이 걸리지 않고 캐시되어 있는 데이터 2를 바로 리턴해준다. 이것의 범위는 애플리케이션내의 범위이다.\n\n### Spring Cache 다양한 캐시 솔루션 도입방법\nSpring 3.1 부터 간단하게 캐시를 도입할 수 있게 되었다. Spring에서 제공해주는 CacheManager인터페이스만 구현체에 따라 구현 해주면 된다. 다른 캐시 라이브러리들을 추가해서 구현체에 사용할 수 있다.Spring Boot에서 캐시를 사용하기위해서는 spring-boot-starter-cache를 추가하는데 기본적으로 spring-boot-starter-cache 이외에 아무 서드파트 라이브러리를 추가 하지 않는다면 기본설정인 SimpleCacheConfiguration 가 동작하며 CacheManager로는 ConcurrentMapCacheManager가 빈으로 등록이 된다. ConcurrentMapCacheManager는 가벼워서 많이들 사용하지만 Product용으로는 Ehcache 사용하는 것 같다. Ehcache를 사용하면 좀 더 확장적이고 분산시스템등 커스터마이징을 할 수 있기 때문이다.\n\n### Spring Cache 사용방법\n먼저 Spring Cache를 사용하기 위해서는 메이븐에 아래와같이 라이브러리를 추가해줘야한다.\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-cache</artifactId>\n</dependency>\n```\n위와 같이 메이븐에 내용을 추가하고 @EnableCaching 를 선언하게 되면 Spring container에 빈이 등록된다. 기본적으로는 위에서 말햇듯이 ConcurrentMapCacheManager이 등록된다. 하지만 상황에 맞게 다른 캐쉬 구현체를 등록할 수 있다. 그 다음 Cache를 적용하기를 원하는 메소드에 @Cacheable 를 붙이면 된다. 이어노테이션 이외에도 몇개의 어노테이션이 존재한다. 그리고 그 어노테이션에 맞는 몇개의 속성들이 존재한다. 아래는 그 어노테이션과 속성에대한 간단한 설명이 있다.\n\n다음은 스프링 캐시 설정 어노테이션들이다.\n| 어노테이션     | 설명                             |\n| -------------- | -------------------------------- |\n| @Cacheable     | 메소드에 캐시 트리거 설정        |\n| @CachePut      | 메소드 실행과 방해없이 캐시 갱신 |\n| @CacheEvict    | 캐시되있는 데이터 지우기         |\n| @CacheConfig   | 캐쉬 관려설정                    |\n| @EnableCaching | 스프링 캐시활성화                |\n\n다음은 캐시 어노테이션들의 속성이다\n| 어노테이션     | 설명                                                    |\n| -------------- | ------------------------------------------------------- |\n| value          | 캐시의 이름                                             |\n| key            | 캐시할 키를 설정(기본설정하지 않으면 파라미터로 설정됨) |\n| condition      | 특정 조건에 따라 캐시를 할지 않을지 결정                |\n| cacheManager등 | 해당 캐시 매니저 설정가능                               |\n\n좀더 많은 설정들을 확인하기 위해서는 [공식문서](https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/cache.html)를 참조하면 된다.\n\n#### Spring Cache ConcurrentMapCacheManager 적용\n먼저 간단하게 ConcurrentMapCacheManager를 이용해서 캐시를 구현해보자.\n```java\n@SpringBootApplication\n@EnableCaching\npublic class CacheApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(CacheApplication.class, args);\n\t}\n}\n```\n일단 위와 같이 @EnableCaching를 선언함으로 Spring Cache를 사용하겠다고 선언한다. 그리고 사용하고자하는 메소드위에 @Cacheable 어노테이션을 적는다. 이렇게 되면 캐시기능이 적용된다.\n```java\n@Cacheable(value = \"members\")\npublic Member findById(long id){\n        System.out.println(\"test\");\n\n        if(id == 1)\n            return  Member.builder()\n                    .id(1)\n                    .age(15)\n                    .name(\"김철수\")\n                    .build();\n        else\n            return  Member.builder()\n                    .id(2)\n                    .age(17)\n                    .name(\"김아무개\")\n                    .build();\n    }\n```\n이 findById 메소드에 멤버 id로 1이라는 id를 호출한 후에 다시 한번 똑같은 id로 호출하게 되면 이 findById메소드를 타지않고 캐시 되어 있는 데이터를 가지고오는것을 확인할 수 있다. 여기에서 제대로 캐시기능이 적용 되었는지 테스트하기위해서 System.out.println(\"test\")로 로거를 찍었는데 2번이상 1번아이디의 유저를 호출하려고 해도 아래와 같이 한번만 test가 로그에 찍히는 것을 확인할 수 있다.\n![](https://i.imgur.com/KB4IssF.png)\n\n위에 ConcurrentMapCacheManager캐시 관련 소스는 여기 [깃허브](https://github.com/minwan1/blog-example/tree/concurrent-cache-example/cache)에서 확인할 수 있다.\n\n\n#### Spring Cache Ehcache 적용\n이번에는 Ehcache를 적용하는 예제를 구현할 것이다. Ehcache를 사용하기 위해서는 아래와 같이 메이븐을 추가해줘야 한다.\n\n```xml\n<dependency>\n    <groupId>net.sf.ehcache</groupId>\n    <artifactId>ehcache</artifactId>\n    <version>2.10.2.2.21</version>\n</dependency>\n```\n그리고 Ehcache를 사용하기 위해서는 아래와 같이 xml 설정을 해줘야 한다. Ehcache xml 설정에 대한 세부 내용은 [공식 홈페이지](http://www.ehcache.org/)에서 확인할 수 있다.\n```xml\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:noNamespaceSchemaLocation=\"ehcache.xsd\"\n    updateCheck=\"true\"\n    monitoring=\"autodetect\"\n    dynamicConfig=\"true\">\n\n    <diskStore path=\"java.io.tmpdir\" />\n\n    <cache name=\"members\"\n        maxEntriesLocalHeap=\"100\"\n        maxEntriesLocalDisk=\"1000\"\n        eternal=\"false\"\n        timeToIdleSeconds=\"300\"\n        timeToLiveSeconds=\"600\"\n        memoryStoreEvictionPolicy=\"LFU\"\n        transactionalMode=\"off\">\n        <persistence strategy=\"localTempSwap\" />\n    </cache>\n\n</ehcache>\n```\n간단히 위의 내용을 설명하자면 'members'라는 캐시의 이름을 선언했고, 최대 100개의 member들을 heap store에 담을 수 있고, 최대 1천개의 members은 diskStore에(java.io.tmpdir) 보관될 것이다. 이 member는 5분 이상 변화가 없거나 10분 이상 살아있다면 이캐시는 만료 될 것이다.\n\nEhcache XML 설정을 한후 Spring Cache를 등록하면 기본적으로 ConcurrentMapCacheManager가 등록되니까 Ehcache를 사용하기위해서 아래와같이 ehCacheCacheManager 빈을 등록해야한다.\n```java\n@Bean\npublic CacheManager cacheManager() {\n    return new EhCacheCacheManager(ehCacheCacheManager().getObject());\n}\n\n@Bean\npublic EhCacheManagerFactoryBean ehCacheCacheManager() {\n    EhCacheManagerFactoryBean factory = new EhCacheManagerFactoryBean();\n    factory.setConfigLocation(new ClassPathResource(\"ehcache.xml\"));\n    factory.setShared(true);\n    return factory;\n}\n```\n위에 ConcurrentMapCacheManager에서는 member를 조회하는 곳에서만 캐시를 사용했었는데 여기에서는 멤버를 조회하고, 저장된 캐시를 제거하는 예제를 만들 것이다.  먼저 멤버 조회하는 Service는 위의 예제와 동일하게 가지 갈 것이다. 그리고 아래와 같이 member 지웠다고 가정하는 메서드를 만들 것이다.\n\n```java\n@CacheEvict(value = \"members\",key =\"#id\")\n    public void deleteMember(long id){\n        System.out.println(\"deleteMember\");\n    }\n```\nCacheEvict 이어노테이션은 캐시에 저장된 데이터를 지우는 역할을 한다. 예를 들어 아까 1이라는 id의 멤버를 조회했을 경우 id 1로 조회하는 데이터는 캐시가 된것을 볼 수 있었다. 하지만 이메소드를 탄후에 다시 조회하려고 하면 캐시 된 내용이 사라지고 findById 메소드가 실행되는 모습을 볼 수 있다.\n![](https://i.imgur.com/PCwOLfU.png)\n위에 사진은 Member id가 1인유저를 findById 메소드를 이용해 조회했다가,다시 Member id가 1인 유저를 deleteMember 메소드를 호출한후 다시 Member id가 1인유저를 findById 메소드를 이용해 조회한 결과이다. 2번이상 findById를 탔음에도 불구하고 test라는 로그가 2번 찍힌 것을 볼 수 있다. 그 이유는 deleteMember를 탐으로써 캐시된 내용이 삭제되었기 때문이다.\n\nEhcache에대한 소스는 여기 [깃허브](https://github.com/minwan1/blog-example/tree/ehcache-example/cache)에서 확인할 수 있다.\n\n### 마무리하며\n캐시에 대해 많은 내용들이 있지만 먼저 간단하게 캐시를 알아봤다. 캐시를 적용한다면 디비에 접근하는 시간, 비용들을 많이 아낄 수 있을 거라고 생각한다. 그렇다고해서 모든 애플리케이션 내에 캐시를 적용 한다고 해서 좋은 것은 아닐것 같다. 어느 정도 기준을 두고 캐시를 사용해야 한다고 생각한다. 안 그러면 캐시에 의해 과부하가 걸릴 수 있고 관리가 쉽지 않아 보이기 때문이다. 그래서 게시판이나 블로그 등 웹 기반의 애플리케이션은 최근에 사용된 데이터가 또다시 사용되는 경향을 있는 곳에서 사용하면 좋다고 한다. 최범균님 블로그를 보면 80:20 법칙에 따라 20%의 데이터가 전체 조회 건수의 80%를 차지할 경우 캐시를 사용함으로써 성능을 대폭적으로 향상시킬 수 있을 것이라고 말씀하셨다. 이 정도의 기준인 데서 캐시를 쓰면 정말 효율적으로 성능의 폭을 대폭 향상시킬 수 있고 시간, 자원 등을 아낄 수 있을 거라고 생각한다.\n\n\n참고\n* [MKyong](https://www.mkyong.com/spring/spring-caching-and-ehcache-example/) [docs.spring.io](https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache)\n* [머루의 개발블로그](http://wonwoo.ml/index.php/post/1551)\n* [자바 ORM 표준 JPA 프로그래밍](http://book.naver.com/bookdb/book_detail.nhn?bid=9252528)\n* [최범균님 블로그](http://javacan.tistory.com/entry/133)\n","source":"_posts/2018-03-18-Spring-Cache.md","raw":"---\ntitle: Spring cache\ncatalog: true\ndate: 2018-03-18\nsubtitle:\nheader-img:\ntags:\n- Spring\n- Java\n\n---\n\n## Spring cache, ehcache 구현\n\n### Cache\n일반적으로 애플리케이션에서 데이터베이스를 접근하게 되면 많은 시간과 비용을 소비하게 된다. 그래서 반복적으로 일어나면서 많은 양의 데이터를 가지고 와야 하는 작업은 부담이 된다. 그래서 많은 사람들은 이러한 문제를 해결하기 위해서 캐시를 사용한다. 캐시를 사용하면 데이터베이스 접근하는 횟수를 획기적으로 개선할 수 있기 때문이다.\n\n### Spring Cache\n그래서 Spring에서는 이러한 Cache 기능을 지원하기 위해서 Spring caching abstraction을 지원한다. Spring caching abstraction는 다른 캐시 솔루션을 Spring CacheManager를 통해서 쉽게 사용할 수 있도록 해준다. Spring CacheManager는 다양한 캐시의 솔루션들을 코드에 최소의 영향으로 다양한 캐싱 솔루션(라이브러리)을 도입할 수 있게 해준다. Spring caching abstraction은 자바 메소드에 캐싱을 적용한다. 그래서 메소드가 실행될 떄마다 메소드의 넘어온 파라미터에 따라 캐쉬를 적용하게 된다. 예를들어 2초이상걸리는 A라는 메소드를 호출 했을 때 파라미터로 1의 값을 넘겼고, 결과값 으로 2를 받았다고 하면 그다음에 다시 한번 누군가가 A메소드를 1의 파라미터를 넘겼으면 A메소드는 2초의 시간이 걸리지 않고 캐시되어 있는 데이터 2를 바로 리턴해준다. 이것의 범위는 애플리케이션내의 범위이다.\n\n### Spring Cache 다양한 캐시 솔루션 도입방법\nSpring 3.1 부터 간단하게 캐시를 도입할 수 있게 되었다. Spring에서 제공해주는 CacheManager인터페이스만 구현체에 따라 구현 해주면 된다. 다른 캐시 라이브러리들을 추가해서 구현체에 사용할 수 있다.Spring Boot에서 캐시를 사용하기위해서는 spring-boot-starter-cache를 추가하는데 기본적으로 spring-boot-starter-cache 이외에 아무 서드파트 라이브러리를 추가 하지 않는다면 기본설정인 SimpleCacheConfiguration 가 동작하며 CacheManager로는 ConcurrentMapCacheManager가 빈으로 등록이 된다. ConcurrentMapCacheManager는 가벼워서 많이들 사용하지만 Product용으로는 Ehcache 사용하는 것 같다. Ehcache를 사용하면 좀 더 확장적이고 분산시스템등 커스터마이징을 할 수 있기 때문이다.\n\n### Spring Cache 사용방법\n먼저 Spring Cache를 사용하기 위해서는 메이븐에 아래와같이 라이브러리를 추가해줘야한다.\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-cache</artifactId>\n</dependency>\n```\n위와 같이 메이븐에 내용을 추가하고 @EnableCaching 를 선언하게 되면 Spring container에 빈이 등록된다. 기본적으로는 위에서 말햇듯이 ConcurrentMapCacheManager이 등록된다. 하지만 상황에 맞게 다른 캐쉬 구현체를 등록할 수 있다. 그 다음 Cache를 적용하기를 원하는 메소드에 @Cacheable 를 붙이면 된다. 이어노테이션 이외에도 몇개의 어노테이션이 존재한다. 그리고 그 어노테이션에 맞는 몇개의 속성들이 존재한다. 아래는 그 어노테이션과 속성에대한 간단한 설명이 있다.\n\n다음은 스프링 캐시 설정 어노테이션들이다.\n| 어노테이션     | 설명                             |\n| -------------- | -------------------------------- |\n| @Cacheable     | 메소드에 캐시 트리거 설정        |\n| @CachePut      | 메소드 실행과 방해없이 캐시 갱신 |\n| @CacheEvict    | 캐시되있는 데이터 지우기         |\n| @CacheConfig   | 캐쉬 관려설정                    |\n| @EnableCaching | 스프링 캐시활성화                |\n\n다음은 캐시 어노테이션들의 속성이다\n| 어노테이션     | 설명                                                    |\n| -------------- | ------------------------------------------------------- |\n| value          | 캐시의 이름                                             |\n| key            | 캐시할 키를 설정(기본설정하지 않으면 파라미터로 설정됨) |\n| condition      | 특정 조건에 따라 캐시를 할지 않을지 결정                |\n| cacheManager등 | 해당 캐시 매니저 설정가능                               |\n\n좀더 많은 설정들을 확인하기 위해서는 [공식문서](https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/cache.html)를 참조하면 된다.\n\n#### Spring Cache ConcurrentMapCacheManager 적용\n먼저 간단하게 ConcurrentMapCacheManager를 이용해서 캐시를 구현해보자.\n```java\n@SpringBootApplication\n@EnableCaching\npublic class CacheApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(CacheApplication.class, args);\n\t}\n}\n```\n일단 위와 같이 @EnableCaching를 선언함으로 Spring Cache를 사용하겠다고 선언한다. 그리고 사용하고자하는 메소드위에 @Cacheable 어노테이션을 적는다. 이렇게 되면 캐시기능이 적용된다.\n```java\n@Cacheable(value = \"members\")\npublic Member findById(long id){\n        System.out.println(\"test\");\n\n        if(id == 1)\n            return  Member.builder()\n                    .id(1)\n                    .age(15)\n                    .name(\"김철수\")\n                    .build();\n        else\n            return  Member.builder()\n                    .id(2)\n                    .age(17)\n                    .name(\"김아무개\")\n                    .build();\n    }\n```\n이 findById 메소드에 멤버 id로 1이라는 id를 호출한 후에 다시 한번 똑같은 id로 호출하게 되면 이 findById메소드를 타지않고 캐시 되어 있는 데이터를 가지고오는것을 확인할 수 있다. 여기에서 제대로 캐시기능이 적용 되었는지 테스트하기위해서 System.out.println(\"test\")로 로거를 찍었는데 2번이상 1번아이디의 유저를 호출하려고 해도 아래와 같이 한번만 test가 로그에 찍히는 것을 확인할 수 있다.\n![](https://i.imgur.com/KB4IssF.png)\n\n위에 ConcurrentMapCacheManager캐시 관련 소스는 여기 [깃허브](https://github.com/minwan1/blog-example/tree/concurrent-cache-example/cache)에서 확인할 수 있다.\n\n\n#### Spring Cache Ehcache 적용\n이번에는 Ehcache를 적용하는 예제를 구현할 것이다. Ehcache를 사용하기 위해서는 아래와 같이 메이븐을 추가해줘야 한다.\n\n```xml\n<dependency>\n    <groupId>net.sf.ehcache</groupId>\n    <artifactId>ehcache</artifactId>\n    <version>2.10.2.2.21</version>\n</dependency>\n```\n그리고 Ehcache를 사용하기 위해서는 아래와 같이 xml 설정을 해줘야 한다. Ehcache xml 설정에 대한 세부 내용은 [공식 홈페이지](http://www.ehcache.org/)에서 확인할 수 있다.\n```xml\n<ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:noNamespaceSchemaLocation=\"ehcache.xsd\"\n    updateCheck=\"true\"\n    monitoring=\"autodetect\"\n    dynamicConfig=\"true\">\n\n    <diskStore path=\"java.io.tmpdir\" />\n\n    <cache name=\"members\"\n        maxEntriesLocalHeap=\"100\"\n        maxEntriesLocalDisk=\"1000\"\n        eternal=\"false\"\n        timeToIdleSeconds=\"300\"\n        timeToLiveSeconds=\"600\"\n        memoryStoreEvictionPolicy=\"LFU\"\n        transactionalMode=\"off\">\n        <persistence strategy=\"localTempSwap\" />\n    </cache>\n\n</ehcache>\n```\n간단히 위의 내용을 설명하자면 'members'라는 캐시의 이름을 선언했고, 최대 100개의 member들을 heap store에 담을 수 있고, 최대 1천개의 members은 diskStore에(java.io.tmpdir) 보관될 것이다. 이 member는 5분 이상 변화가 없거나 10분 이상 살아있다면 이캐시는 만료 될 것이다.\n\nEhcache XML 설정을 한후 Spring Cache를 등록하면 기본적으로 ConcurrentMapCacheManager가 등록되니까 Ehcache를 사용하기위해서 아래와같이 ehCacheCacheManager 빈을 등록해야한다.\n```java\n@Bean\npublic CacheManager cacheManager() {\n    return new EhCacheCacheManager(ehCacheCacheManager().getObject());\n}\n\n@Bean\npublic EhCacheManagerFactoryBean ehCacheCacheManager() {\n    EhCacheManagerFactoryBean factory = new EhCacheManagerFactoryBean();\n    factory.setConfigLocation(new ClassPathResource(\"ehcache.xml\"));\n    factory.setShared(true);\n    return factory;\n}\n```\n위에 ConcurrentMapCacheManager에서는 member를 조회하는 곳에서만 캐시를 사용했었는데 여기에서는 멤버를 조회하고, 저장된 캐시를 제거하는 예제를 만들 것이다.  먼저 멤버 조회하는 Service는 위의 예제와 동일하게 가지 갈 것이다. 그리고 아래와 같이 member 지웠다고 가정하는 메서드를 만들 것이다.\n\n```java\n@CacheEvict(value = \"members\",key =\"#id\")\n    public void deleteMember(long id){\n        System.out.println(\"deleteMember\");\n    }\n```\nCacheEvict 이어노테이션은 캐시에 저장된 데이터를 지우는 역할을 한다. 예를 들어 아까 1이라는 id의 멤버를 조회했을 경우 id 1로 조회하는 데이터는 캐시가 된것을 볼 수 있었다. 하지만 이메소드를 탄후에 다시 조회하려고 하면 캐시 된 내용이 사라지고 findById 메소드가 실행되는 모습을 볼 수 있다.\n![](https://i.imgur.com/PCwOLfU.png)\n위에 사진은 Member id가 1인유저를 findById 메소드를 이용해 조회했다가,다시 Member id가 1인 유저를 deleteMember 메소드를 호출한후 다시 Member id가 1인유저를 findById 메소드를 이용해 조회한 결과이다. 2번이상 findById를 탔음에도 불구하고 test라는 로그가 2번 찍힌 것을 볼 수 있다. 그 이유는 deleteMember를 탐으로써 캐시된 내용이 삭제되었기 때문이다.\n\nEhcache에대한 소스는 여기 [깃허브](https://github.com/minwan1/blog-example/tree/ehcache-example/cache)에서 확인할 수 있다.\n\n### 마무리하며\n캐시에 대해 많은 내용들이 있지만 먼저 간단하게 캐시를 알아봤다. 캐시를 적용한다면 디비에 접근하는 시간, 비용들을 많이 아낄 수 있을 거라고 생각한다. 그렇다고해서 모든 애플리케이션 내에 캐시를 적용 한다고 해서 좋은 것은 아닐것 같다. 어느 정도 기준을 두고 캐시를 사용해야 한다고 생각한다. 안 그러면 캐시에 의해 과부하가 걸릴 수 있고 관리가 쉽지 않아 보이기 때문이다. 그래서 게시판이나 블로그 등 웹 기반의 애플리케이션은 최근에 사용된 데이터가 또다시 사용되는 경향을 있는 곳에서 사용하면 좋다고 한다. 최범균님 블로그를 보면 80:20 법칙에 따라 20%의 데이터가 전체 조회 건수의 80%를 차지할 경우 캐시를 사용함으로써 성능을 대폭적으로 향상시킬 수 있을 것이라고 말씀하셨다. 이 정도의 기준인 데서 캐시를 쓰면 정말 효율적으로 성능의 폭을 대폭 향상시킬 수 있고 시간, 자원 등을 아낄 수 있을 거라고 생각한다.\n\n\n참고\n* [MKyong](https://www.mkyong.com/spring/spring-caching-and-ehcache-example/) [docs.spring.io](https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache)\n* [머루의 개발블로그](http://wonwoo.ml/index.php/post/1551)\n* [자바 ORM 표준 JPA 프로그래밍](http://book.naver.com/bookdb/book_detail.nhn?bid=9252528)\n* [최범균님 블로그](http://javacan.tistory.com/entry/133)\n","slug":"2018-03-18-Spring-Cache","published":1,"updated":"2018-06-20T16:05:18.328Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27dc002ejjpe7e9op29d","content":"<h2><span id=\"spring-cache-ehcache-구현\">Spring cache, ehcache 구현</span></h2>\n<h3><span id=\"cache\">Cache</span></h3>\n<p>일반적으로 애플리케이션에서 데이터베이스를 접근하게 되면 많은 시간과 비용을 소비하게 된다. 그래서 반복적으로 일어나면서 많은 양의 데이터를 가지고 와야 하는 작업은 부담이 된다. 그래서 많은 사람들은 이러한 문제를 해결하기 위해서 캐시를 사용한다. 캐시를 사용하면 데이터베이스 접근하는 횟수를 획기적으로 개선할 수 있기 때문이다.</p>\n<h3><span id=\"spring-cache\">Spring Cache</span></h3>\n<p>그래서 Spring에서는 이러한 Cache 기능을 지원하기 위해서 Spring caching abstraction을 지원한다. Spring caching abstraction는 다른 캐시 솔루션을 Spring CacheManager를 통해서 쉽게 사용할 수 있도록 해준다. Spring CacheManager는 다양한 캐시의 솔루션들을 코드에 최소의 영향으로 다양한 캐싱 솔루션(라이브러리)을 도입할 수 있게 해준다. Spring caching abstraction은 자바 메소드에 캐싱을 적용한다. 그래서 메소드가 실행될 떄마다 메소드의 넘어온 파라미터에 따라 캐쉬를 적용하게 된다. 예를들어 2초이상걸리는 A라는 메소드를 호출 했을 때 파라미터로 1의 값을 넘겼고, 결과값 으로 2를 받았다고 하면 그다음에 다시 한번 누군가가 A메소드를 1의 파라미터를 넘겼으면 A메소드는 2초의 시간이 걸리지 않고 캐시되어 있는 데이터 2를 바로 리턴해준다. 이것의 범위는 애플리케이션내의 범위이다.</p>\n<h3><span id=\"spring-cache-다양한-캐시-솔루션-도입방법\">Spring Cache 다양한 캐시 솔루션 도입방법</span></h3>\n<p>Spring 3.1 부터 간단하게 캐시를 도입할 수 있게 되었다. Spring에서 제공해주는 CacheManager인터페이스만 구현체에 따라 구현 해주면 된다. 다른 캐시 라이브러리들을 추가해서 구현체에 사용할 수 있다.Spring Boot에서 캐시를 사용하기위해서는 spring-boot-starter-cache를 추가하는데 기본적으로 spring-boot-starter-cache 이외에 아무 서드파트 라이브러리를 추가 하지 않는다면 기본설정인 SimpleCacheConfiguration 가 동작하며 CacheManager로는 ConcurrentMapCacheManager가 빈으로 등록이 된다. ConcurrentMapCacheManager는 가벼워서 많이들 사용하지만 Product용으로는 Ehcache 사용하는 것 같다. Ehcache를 사용하면 좀 더 확장적이고 분산시스템등 커스터마이징을 할 수 있기 때문이다.</p>\n<h3><span id=\"spring-cache-사용방법\">Spring Cache 사용방법</span></h3>\n<p>먼저 Spring Cache를 사용하기 위해서는 메이븐에 아래와같이 라이브러리를 추가해줘야한다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-cache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>위와 같이 메이븐에 내용을 추가하고 @EnableCaching 를 선언하게 되면 Spring container에 빈이 등록된다. 기본적으로는 위에서 말햇듯이 ConcurrentMapCacheManager이 등록된다. 하지만 상황에 맞게 다른 캐쉬 구현체를 등록할 수 있다. 그 다음 Cache를 적용하기를 원하는 메소드에 @Cacheable 를 붙이면 된다. 이어노테이션 이외에도 몇개의 어노테이션이 존재한다. 그리고 그 어노테이션에 맞는 몇개의 속성들이 존재한다. 아래는 그 어노테이션과 속성에대한 간단한 설명이 있다.</p>\n<p>다음은 스프링 캐시 설정 어노테이션들이다.</p>\n<table>\n<thead>\n<tr>\n<th>어노테이션</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>@Cacheable</td>\n<td>메소드에 캐시 트리거 설정</td>\n</tr>\n<tr>\n<td>@CachePut</td>\n<td>메소드 실행과 방해없이 캐시 갱신</td>\n</tr>\n<tr>\n<td>@CacheEvict</td>\n<td>캐시되있는 데이터 지우기</td>\n</tr>\n<tr>\n<td>@CacheConfig</td>\n<td>캐쉬 관려설정</td>\n</tr>\n<tr>\n<td>@EnableCaching</td>\n<td>스프링 캐시활성화</td>\n</tr>\n</tbody>\n</table>\n<p>다음은 캐시 어노테이션들의 속성이다</p>\n<table>\n<thead>\n<tr>\n<th>어노테이션</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>캐시의 이름</td>\n</tr>\n<tr>\n<td>key</td>\n<td>캐시할 키를 설정(기본설정하지 않으면 파라미터로 설정됨)</td>\n</tr>\n<tr>\n<td>condition</td>\n<td>특정 조건에 따라 캐시를 할지 않을지 결정</td>\n</tr>\n<tr>\n<td>cacheManager등</td>\n<td>해당 캐시 매니저 설정가능</td>\n</tr>\n</tbody>\n</table>\n<p>좀더 많은 설정들을 확인하기 위해서는 <a href=\"https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/cache.html\" target=\"_blank\" rel=\"noopener\">공식문서</a>를 참조하면 된다.</p>\n<h4><span id=\"spring-cache-concurrentmapcachemanager-적용\">Spring Cache ConcurrentMapCacheManager 적용</span></h4>\n<p>먼저 간단하게 ConcurrentMapCacheManager를 이용해서 캐시를 구현해보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableCaching</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CacheApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tSpringApplication.run(CacheApplication.class, args);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>일단 위와 같이 @EnableCaching를 선언함으로 Spring Cache를 사용하겠다고 선언한다. 그리고 사용하고자하는 메소드위에 @Cacheable 어노테이션을 적는다. 이렇게 되면 캐시기능이 적용된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Cacheable</span>(value = <span class=\"string\">\"members\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Member <span class=\"title\">findById</span><span class=\"params\">(<span class=\"keyword\">long</span> id)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"test\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(id == <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>  Member.builder()</span><br><span class=\"line\">                    .id(<span class=\"number\">1</span>)</span><br><span class=\"line\">                    .age(<span class=\"number\">15</span>)</span><br><span class=\"line\">                    .name(<span class=\"string\">\"김철수\"</span>)</span><br><span class=\"line\">                    .build();</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>  Member.builder()</span><br><span class=\"line\">                    .id(<span class=\"number\">2</span>)</span><br><span class=\"line\">                    .age(<span class=\"number\">17</span>)</span><br><span class=\"line\">                    .name(<span class=\"string\">\"김아무개\"</span>)</span><br><span class=\"line\">                    .build();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>이 findById 메소드에 멤버 id로 1이라는 id를 호출한 후에 다시 한번 똑같은 id로 호출하게 되면 이 findById메소드를 타지않고 캐시 되어 있는 데이터를 가지고오는것을 확인할 수 있다. 여기에서 제대로 캐시기능이 적용 되었는지 테스트하기위해서 System.out.println(“test”)로 로거를 찍었는데 2번이상 1번아이디의 유저를 호출하려고 해도 아래와 같이 한번만 test가 로그에 찍히는 것을 확인할 수 있다.<br>\n<img src=\"https://i.imgur.com/KB4IssF.png\" alt=\"\"></p>\n<p>위에 ConcurrentMapCacheManager캐시 관련 소스는 여기 <a href=\"https://github.com/minwan1/blog-example/tree/concurrent-cache-example/cache\" target=\"_blank\" rel=\"noopener\">깃허브</a>에서 확인할 수 있다.</p>\n<h4><span id=\"spring-cache-ehcache-적용\">Spring Cache Ehcache 적용</span></h4>\n<p>이번에는 Ehcache를 적용하는 예제를 구현할 것이다. Ehcache를 사용하기 위해서는 아래와 같이 메이븐을 추가해줘야 한다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>net.sf.ehcache<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>ehcache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.10.2.2.21<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>그리고 Ehcache를 사용하기 위해서는 아래와 같이 xml 설정을 해줘야 한다. Ehcache xml 설정에 대한 세부 내용은 <a href=\"http://www.ehcache.org/\" target=\"_blank\" rel=\"noopener\">공식 홈페이지</a>에서 확인할 수 있다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ehcache</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xsi:noNamespaceSchemaLocation</span>=<span class=\"string\">\"ehcache.xsd\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">updateCheck</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">monitoring</span>=<span class=\"string\">\"autodetect\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">dynamicConfig</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">diskStore</span> <span class=\"attr\">path</span>=<span class=\"string\">\"java.io.tmpdir\"</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"members\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">maxEntriesLocalHeap</span>=<span class=\"string\">\"100\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">maxEntriesLocalDisk</span>=<span class=\"string\">\"1000\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"300\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"600\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LFU\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">transactionalMode</span>=<span class=\"string\">\"off\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">persistence</span> <span class=\"attr\">strategy</span>=<span class=\"string\">\"localTempSwap\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>간단히 위의 내용을 설명하자면 'members’라는 캐시의 이름을 선언했고, 최대 100개의 member들을 heap store에 담을 수 있고, 최대 1천개의 members은 diskStore에(java.io.tmpdir) 보관될 것이다. 이 member는 5분 이상 변화가 없거나 10분 이상 살아있다면 이캐시는 만료 될 것이다.</p>\n<p>Ehcache XML 설정을 한후 Spring Cache를 등록하면 기본적으로 ConcurrentMapCacheManager가 등록되니까 Ehcache를 사용하기위해서 아래와같이 ehCacheCacheManager 빈을 등록해야한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CacheManager <span class=\"title\">cacheManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EhCacheCacheManager(ehCacheCacheManager().getObject());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> EhCacheManagerFactoryBean <span class=\"title\">ehCacheCacheManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    EhCacheManagerFactoryBean factory = <span class=\"keyword\">new</span> EhCacheManagerFactoryBean();</span><br><span class=\"line\">    factory.setConfigLocation(<span class=\"keyword\">new</span> ClassPathResource(<span class=\"string\">\"ehcache.xml\"</span>));</span><br><span class=\"line\">    factory.setShared(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> factory;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위에 ConcurrentMapCacheManager에서는 member를 조회하는 곳에서만 캐시를 사용했었는데 여기에서는 멤버를 조회하고, 저장된 캐시를 제거하는 예제를 만들 것이다.  먼저 멤버 조회하는 Service는 위의 예제와 동일하게 가지 갈 것이다. 그리고 아래와 같이 member 지웠다고 가정하는 메서드를 만들 것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@CacheEvict</span>(value = <span class=\"string\">\"members\"</span>,key =<span class=\"string\">\"#id\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteMember</span><span class=\"params\">(<span class=\"keyword\">long</span> id)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"deleteMember\"</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>CacheEvict 이어노테이션은 캐시에 저장된 데이터를 지우는 역할을 한다. 예를 들어 아까 1이라는 id의 멤버를 조회했을 경우 id 1로 조회하는 데이터는 캐시가 된것을 볼 수 있었다. 하지만 이메소드를 탄후에 다시 조회하려고 하면 캐시 된 내용이 사라지고 findById 메소드가 실행되는 모습을 볼 수 있다.<br>\n<img src=\"https://i.imgur.com/PCwOLfU.png\" alt=\"\"><br>\n위에 사진은 Member id가 1인유저를 findById 메소드를 이용해 조회했다가,다시 Member id가 1인 유저를 deleteMember 메소드를 호출한후 다시 Member id가 1인유저를 findById 메소드를 이용해 조회한 결과이다. 2번이상 findById를 탔음에도 불구하고 test라는 로그가 2번 찍힌 것을 볼 수 있다. 그 이유는 deleteMember를 탐으로써 캐시된 내용이 삭제되었기 때문이다.</p>\n<p>Ehcache에대한 소스는 여기 <a href=\"https://github.com/minwan1/blog-example/tree/ehcache-example/cache\" target=\"_blank\" rel=\"noopener\">깃허브</a>에서 확인할 수 있다.</p>\n<h3><span id=\"마무리하며\">마무리하며</span></h3>\n<p>캐시에 대해 많은 내용들이 있지만 먼저 간단하게 캐시를 알아봤다. 캐시를 적용한다면 디비에 접근하는 시간, 비용들을 많이 아낄 수 있을 거라고 생각한다. 그렇다고해서 모든 애플리케이션 내에 캐시를 적용 한다고 해서 좋은 것은 아닐것 같다. 어느 정도 기준을 두고 캐시를 사용해야 한다고 생각한다. 안 그러면 캐시에 의해 과부하가 걸릴 수 있고 관리가 쉽지 않아 보이기 때문이다. 그래서 게시판이나 블로그 등 웹 기반의 애플리케이션은 최근에 사용된 데이터가 또다시 사용되는 경향을 있는 곳에서 사용하면 좋다고 한다. 최범균님 블로그를 보면 80:20 법칙에 따라 20%의 데이터가 전체 조회 건수의 80%를 차지할 경우 캐시를 사용함으로써 성능을 대폭적으로 향상시킬 수 있을 것이라고 말씀하셨다. 이 정도의 기준인 데서 캐시를 쓰면 정말 효율적으로 성능의 폭을 대폭 향상시킬 수 있고 시간, 자원 등을 아낄 수 있을 거라고 생각한다.</p>\n<p>참고</p>\n<ul>\n<li><a href=\"https://www.mkyong.com/spring/spring-caching-and-ehcache-example/\" target=\"_blank\" rel=\"noopener\">MKyong</a> <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache\" target=\"_blank\" rel=\"noopener\">docs.spring.io</a></li>\n<li><a href=\"http://wonwoo.ml/index.php/post/1551\" target=\"_blank\" rel=\"noopener\">머루의 개발블로그</a></li>\n<li><a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=9252528\" target=\"_blank\" rel=\"noopener\">자바 ORM 표준 JPA 프로그래밍</a></li>\n<li><a href=\"http://javacan.tistory.com/entry/133\" target=\"_blank\" rel=\"noopener\">최범균님 블로그</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>Spring cache, ehcache 구현</h2>\n<h3>Cache</h3>\n<p>일반적으로 애플리케이션에서 데이터베이스를 접근하게 되면 많은 시간과 비용을 소비하게 된다. 그래서 반복적으로 일어나면서 많은 양의 데이터를 가지고 와야 하는 작업은 부담이 된다. 그래서 많은 사람들은 이러한 문제를 해결하기 위해서 캐시를 사용한다. 캐시를 사용하면 데이터베이스 접근하는 횟수를 획기적으로 개선할 수 있기 때문이다.</p>\n<h3>Spring Cache</h3>\n<p>그래서 Spring에서는 이러한 Cache 기능을 지원하기 위해서 Spring caching abstraction을 지원한다. Spring caching abstraction는 다른 캐시 솔루션을 Spring CacheManager를 통해서 쉽게 사용할 수 있도록 해준다. Spring CacheManager는 다양한 캐시의 솔루션들을 코드에 최소의 영향으로 다양한 캐싱 솔루션(라이브러리)을 도입할 수 있게 해준다. Spring caching abstraction은 자바 메소드에 캐싱을 적용한다. 그래서 메소드가 실행될 떄마다 메소드의 넘어온 파라미터에 따라 캐쉬를 적용하게 된다. 예를들어 2초이상걸리는 A라는 메소드를 호출 했을 때 파라미터로 1의 값을 넘겼고, 결과값 으로 2를 받았다고 하면 그다음에 다시 한번 누군가가 A메소드를 1의 파라미터를 넘겼으면 A메소드는 2초의 시간이 걸리지 않고 캐시되어 있는 데이터 2를 바로 리턴해준다. 이것의 범위는 애플리케이션내의 범위이다.</p>\n<h3>Spring Cache 다양한 캐시 솔루션 도입방법</h3>\n<p>Spring 3.1 부터 간단하게 캐시를 도입할 수 있게 되었다. Spring에서 제공해주는 CacheManager인터페이스만 구현체에 따라 구현 해주면 된다. 다른 캐시 라이브러리들을 추가해서 구현체에 사용할 수 있다.Spring Boot에서 캐시를 사용하기위해서는 spring-boot-starter-cache를 추가하는데 기본적으로 spring-boot-starter-cache 이외에 아무 서드파트 라이브러리를 추가 하지 않는다면 기본설정인 SimpleCacheConfiguration 가 동작하며 CacheManager로는 ConcurrentMapCacheManager가 빈으로 등록이 된다. ConcurrentMapCacheManager는 가벼워서 많이들 사용하지만 Product용으로는 Ehcache 사용하는 것 같다. Ehcache를 사용하면 좀 더 확장적이고 분산시스템등 커스터마이징을 할 수 있기 때문이다.</p>\n<h3>Spring Cache 사용방법</h3>\n<p>먼저 Spring Cache를 사용하기 위해서는 메이븐에 아래와같이 라이브러리를 추가해줘야한다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-cache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>위와 같이 메이븐에 내용을 추가하고 @EnableCaching 를 선언하게 되면 Spring container에 빈이 등록된다. 기본적으로는 위에서 말햇듯이 ConcurrentMapCacheManager이 등록된다. 하지만 상황에 맞게 다른 캐쉬 구현체를 등록할 수 있다. 그 다음 Cache를 적용하기를 원하는 메소드에 @Cacheable 를 붙이면 된다. 이어노테이션 이외에도 몇개의 어노테이션이 존재한다. 그리고 그 어노테이션에 맞는 몇개의 속성들이 존재한다. 아래는 그 어노테이션과 속성에대한 간단한 설명이 있다.</p>\n<p>다음은 스프링 캐시 설정 어노테이션들이다.</p>\n<table>\n<thead>\n<tr>\n<th>어노테이션</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>@Cacheable</td>\n<td>메소드에 캐시 트리거 설정</td>\n</tr>\n<tr>\n<td>@CachePut</td>\n<td>메소드 실행과 방해없이 캐시 갱신</td>\n</tr>\n<tr>\n<td>@CacheEvict</td>\n<td>캐시되있는 데이터 지우기</td>\n</tr>\n<tr>\n<td>@CacheConfig</td>\n<td>캐쉬 관려설정</td>\n</tr>\n<tr>\n<td>@EnableCaching</td>\n<td>스프링 캐시활성화</td>\n</tr>\n</tbody>\n</table>\n<p>다음은 캐시 어노테이션들의 속성이다</p>\n<table>\n<thead>\n<tr>\n<th>어노테이션</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>value</td>\n<td>캐시의 이름</td>\n</tr>\n<tr>\n<td>key</td>\n<td>캐시할 키를 설정(기본설정하지 않으면 파라미터로 설정됨)</td>\n</tr>\n<tr>\n<td>condition</td>\n<td>특정 조건에 따라 캐시를 할지 않을지 결정</td>\n</tr>\n<tr>\n<td>cacheManager등</td>\n<td>해당 캐시 매니저 설정가능</td>\n</tr>\n</tbody>\n</table>\n<p>좀더 많은 설정들을 확인하기 위해서는 <a href=\"https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/cache.html\" target=\"_blank\" rel=\"noopener\">공식문서</a>를 참조하면 된다.</p>\n<h4>Spring Cache ConcurrentMapCacheManager 적용</h4>\n<p>먼저 간단하게 ConcurrentMapCacheManager를 이용해서 캐시를 구현해보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableCaching</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CacheApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tSpringApplication.run(CacheApplication.class, args);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>일단 위와 같이 @EnableCaching를 선언함으로 Spring Cache를 사용하겠다고 선언한다. 그리고 사용하고자하는 메소드위에 @Cacheable 어노테이션을 적는다. 이렇게 되면 캐시기능이 적용된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Cacheable</span>(value = <span class=\"string\">\"members\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Member <span class=\"title\">findById</span><span class=\"params\">(<span class=\"keyword\">long</span> id)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"test\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(id == <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span>  Member.builder()</span><br><span class=\"line\">                    .id(<span class=\"number\">1</span>)</span><br><span class=\"line\">                    .age(<span class=\"number\">15</span>)</span><br><span class=\"line\">                    .name(<span class=\"string\">\"김철수\"</span>)</span><br><span class=\"line\">                    .build();</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span>  Member.builder()</span><br><span class=\"line\">                    .id(<span class=\"number\">2</span>)</span><br><span class=\"line\">                    .age(<span class=\"number\">17</span>)</span><br><span class=\"line\">                    .name(<span class=\"string\">\"김아무개\"</span>)</span><br><span class=\"line\">                    .build();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>이 findById 메소드에 멤버 id로 1이라는 id를 호출한 후에 다시 한번 똑같은 id로 호출하게 되면 이 findById메소드를 타지않고 캐시 되어 있는 데이터를 가지고오는것을 확인할 수 있다. 여기에서 제대로 캐시기능이 적용 되었는지 테스트하기위해서 System.out.println(“test”)로 로거를 찍었는데 2번이상 1번아이디의 유저를 호출하려고 해도 아래와 같이 한번만 test가 로그에 찍히는 것을 확인할 수 있다.<br>\n<img src=\"https://i.imgur.com/KB4IssF.png\" alt=\"\"></p>\n<p>위에 ConcurrentMapCacheManager캐시 관련 소스는 여기 <a href=\"https://github.com/minwan1/blog-example/tree/concurrent-cache-example/cache\" target=\"_blank\" rel=\"noopener\">깃허브</a>에서 확인할 수 있다.</p>\n<h4>Spring Cache Ehcache 적용</h4>\n<p>이번에는 Ehcache를 적용하는 예제를 구현할 것이다. Ehcache를 사용하기 위해서는 아래와 같이 메이븐을 추가해줘야 한다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>net.sf.ehcache<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>ehcache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.10.2.2.21<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>그리고 Ehcache를 사용하기 위해서는 아래와 같이 xml 설정을 해줘야 한다. Ehcache xml 설정에 대한 세부 내용은 <a href=\"http://www.ehcache.org/\" target=\"_blank\" rel=\"noopener\">공식 홈페이지</a>에서 확인할 수 있다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ehcache</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">\"http://www.w3.org/2001/XMLSchema-instance\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">xsi:noNamespaceSchemaLocation</span>=<span class=\"string\">\"ehcache.xsd\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">updateCheck</span>=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">monitoring</span>=<span class=\"string\">\"autodetect\"</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">dynamicConfig</span>=<span class=\"string\">\"true\"</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">diskStore</span> <span class=\"attr\">path</span>=<span class=\"string\">\"java.io.tmpdir\"</span> /&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">cache</span> <span class=\"attr\">name</span>=<span class=\"string\">\"members\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">maxEntriesLocalHeap</span>=<span class=\"string\">\"100\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">maxEntriesLocalDisk</span>=<span class=\"string\">\"1000\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">eternal</span>=<span class=\"string\">\"false\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">timeToIdleSeconds</span>=<span class=\"string\">\"300\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">timeToLiveSeconds</span>=<span class=\"string\">\"600\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">memoryStoreEvictionPolicy</span>=<span class=\"string\">\"LFU\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">transactionalMode</span>=<span class=\"string\">\"off\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">persistence</span> <span class=\"attr\">strategy</span>=<span class=\"string\">\"localTempSwap\"</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">cache</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>간단히 위의 내용을 설명하자면 'members’라는 캐시의 이름을 선언했고, 최대 100개의 member들을 heap store에 담을 수 있고, 최대 1천개의 members은 diskStore에(java.io.tmpdir) 보관될 것이다. 이 member는 5분 이상 변화가 없거나 10분 이상 살아있다면 이캐시는 만료 될 것이다.</p>\n<p>Ehcache XML 설정을 한후 Spring Cache를 등록하면 기본적으로 ConcurrentMapCacheManager가 등록되니까 Ehcache를 사용하기위해서 아래와같이 ehCacheCacheManager 빈을 등록해야한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> CacheManager <span class=\"title\">cacheManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EhCacheCacheManager(ehCacheCacheManager().getObject());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> EhCacheManagerFactoryBean <span class=\"title\">ehCacheCacheManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    EhCacheManagerFactoryBean factory = <span class=\"keyword\">new</span> EhCacheManagerFactoryBean();</span><br><span class=\"line\">    factory.setConfigLocation(<span class=\"keyword\">new</span> ClassPathResource(<span class=\"string\">\"ehcache.xml\"</span>));</span><br><span class=\"line\">    factory.setShared(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> factory;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위에 ConcurrentMapCacheManager에서는 member를 조회하는 곳에서만 캐시를 사용했었는데 여기에서는 멤버를 조회하고, 저장된 캐시를 제거하는 예제를 만들 것이다.  먼저 멤버 조회하는 Service는 위의 예제와 동일하게 가지 갈 것이다. 그리고 아래와 같이 member 지웠다고 가정하는 메서드를 만들 것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@CacheEvict</span>(value = <span class=\"string\">\"members\"</span>,key =<span class=\"string\">\"#id\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteMember</span><span class=\"params\">(<span class=\"keyword\">long</span> id)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"deleteMember\"</span>);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>CacheEvict 이어노테이션은 캐시에 저장된 데이터를 지우는 역할을 한다. 예를 들어 아까 1이라는 id의 멤버를 조회했을 경우 id 1로 조회하는 데이터는 캐시가 된것을 볼 수 있었다. 하지만 이메소드를 탄후에 다시 조회하려고 하면 캐시 된 내용이 사라지고 findById 메소드가 실행되는 모습을 볼 수 있다.<br>\n<img src=\"https://i.imgur.com/PCwOLfU.png\" alt=\"\"><br>\n위에 사진은 Member id가 1인유저를 findById 메소드를 이용해 조회했다가,다시 Member id가 1인 유저를 deleteMember 메소드를 호출한후 다시 Member id가 1인유저를 findById 메소드를 이용해 조회한 결과이다. 2번이상 findById를 탔음에도 불구하고 test라는 로그가 2번 찍힌 것을 볼 수 있다. 그 이유는 deleteMember를 탐으로써 캐시된 내용이 삭제되었기 때문이다.</p>\n<p>Ehcache에대한 소스는 여기 <a href=\"https://github.com/minwan1/blog-example/tree/ehcache-example/cache\" target=\"_blank\" rel=\"noopener\">깃허브</a>에서 확인할 수 있다.</p>\n<h3>마무리하며</h3>\n<p>캐시에 대해 많은 내용들이 있지만 먼저 간단하게 캐시를 알아봤다. 캐시를 적용한다면 디비에 접근하는 시간, 비용들을 많이 아낄 수 있을 거라고 생각한다. 그렇다고해서 모든 애플리케이션 내에 캐시를 적용 한다고 해서 좋은 것은 아닐것 같다. 어느 정도 기준을 두고 캐시를 사용해야 한다고 생각한다. 안 그러면 캐시에 의해 과부하가 걸릴 수 있고 관리가 쉽지 않아 보이기 때문이다. 그래서 게시판이나 블로그 등 웹 기반의 애플리케이션은 최근에 사용된 데이터가 또다시 사용되는 경향을 있는 곳에서 사용하면 좋다고 한다. 최범균님 블로그를 보면 80:20 법칙에 따라 20%의 데이터가 전체 조회 건수의 80%를 차지할 경우 캐시를 사용함으로써 성능을 대폭적으로 향상시킬 수 있을 것이라고 말씀하셨다. 이 정도의 기준인 데서 캐시를 쓰면 정말 효율적으로 성능의 폭을 대폭 향상시킬 수 있고 시간, 자원 등을 아낄 수 있을 거라고 생각한다.</p>\n<p>참고</p>\n<ul>\n<li><a href=\"https://www.mkyong.com/spring/spring-caching-and-ehcache-example/\" target=\"_blank\" rel=\"noopener\">MKyong</a> <a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/integration.html#cache\" target=\"_blank\" rel=\"noopener\">docs.spring.io</a></li>\n<li><a href=\"http://wonwoo.ml/index.php/post/1551\" target=\"_blank\" rel=\"noopener\">머루의 개발블로그</a></li>\n<li><a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=9252528\" target=\"_blank\" rel=\"noopener\">자바 ORM 표준 JPA 프로그래밍</a></li>\n<li><a href=\"http://javacan.tistory.com/entry/133\" target=\"_blank\" rel=\"noopener\">최범균님 블로그</a></li>\n</ul>\n"},{"title":"스프링 기능 추상화 예제","catalog":true,"date":"2018-03-31T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n## 스프링 기능 추상화 예제\n\n### 시작하며\n이글의 내용은 [토비의 스프링](http://book.naver.com/bookdb/book_detail.nhn?bid=7006516)책의 내용으로 제가 이해한 스프링 서비스 추상화에 대한 내용을 정리한 글입니다. 물론 책에 더 상세하게 설명이 되어있지만 개인적으로 간단하게 정리하고 싶었습니다. 다른 사람에게 잘 설명을 할 수 있어야 더욱 깊게 이 내용을 이해한 것이라고 생각하기 때문입니다!! 물론 또 저만을 위한 것은 아니고 이 글을 통해 서비스 추상화에 대한 이해를 하시는데 도움이 되시는 분들이 있을 거라고 생각합니다! [참고로 책에서는 mybatis 예제였으나.. 이 글에서 Spring JPA로 구현한 예제입니다.]\n\n### 추상화란\n자바에는 표준 스펙, 사용 제품, 오픈소스를 통틀어서 사용방법과 형식은 다르지만 기능과 목적이 유사한 기술이 존재한다. 환경과 상황에 따라서 기술이 바뀌고, 그에 따른 다른 API를 사용하고 다른 스타일의 접근 방법을 따라야 한다는 건 매우 피곤한 일이다. 이러한 문제를 해결하기 위해서는 규격을 정하고 그것을 이용해야 한다. 그 규격은 인터페이스로 정할 수 있다. 예를 들어 List라는 인터페이스가 있으면 우리는 구현체를 ArrayList를 선언하느냐, LinkedList를 선언하느냐에 따라 구현체가 달라진다. 이렇듯 구현체를 어떻게 구성하느냐에 쓸 수 있는 기능, 효율이 달라진다. 다음 글에서 스프링이 어떻게 성격이 비슷한 여러 종류의 기술을 추상화하고 이를 일관된 방법으로 사용할 수 있도록 지원하는지 확인할 것이다. 이 글에서는 정책에 따른 유저 레벨[티어] 업그레이드를 추상화하는 방법에 대해 설명할 것이다. 좀 더 상세한 설명은 아래에서 설명할 것이다.\n\n#### 요구사항\n먼저 책에서 Level, User, UserService, UserRepository, 의 클래스가 있다. 이 클래스들을 이용해서 우리는 유저의 레벨 관리 기능을 추가해야 한다. 유저의 레벨 관리 기능은 관리자 호출 등을 통해서 userService.upgradeLevels()라는 메서드를 호출했을 때 이 애플리케이션의 존재하는 유저들이 아래의 요구 조건에 맞게 유저의 레벨을 올려야 한다는 요구 조건이다.\n\n다음은 요구조건과 레벨이 올라가기 위한조건에 대한 내용이다.\n* 사용자의 레벨은 BASIC, SILVER, GOLD 세가지중 하나이다.\n* 사용자가 처음 가입하면 BASIC 레벨이 되며, 이후 활동에 따라서 한단계씩 업그레이드 될 수 있다.\n* 가입 후 50회 이상 로그인을 하면 BASIC에서 SIRVER레벨이 된다.\n* SILVER레벨이면서 30번 이상 추천을 받으면 GOLD레벨이 된다.\n* 사용자 레벨의 변경 작업은 일정한 주기를 가지고 일관적으로 진행된다. userService.upgradeLevels()를 호출하기 전까지는 조건을 충족하더라도 레벨의 변경이 일어나지 않는다.\n\n참고로 위의 기본 요구 조건은 정해진 조건에 따라 사용자의 레벨이 주기적으로 변경되거나 레벨을 업그레드하는 정책이 변경될 수 있다. 예를들어 연말 이벤트나, 새로운 서비스 홍보기간중에는 레벨 조건 정책이 바뀔 수 있다. 이럴때 어떻게 효율적으로 변경할 수 있을까. 그것은 바로 추상화이다. 여기에서 추상화해야 할것은 바로 UserLevelUpgradePolicy이다. 먼저 위의 요구 조건의 맞는 기능을 구현하고 이것을 어떻게 추상화하여 유연하게 바꿀지에 대해 생각해보자.\n\n#### 객체선언\n먼저 아래와 같이 요구조건에 맞는 객체와 서비스들을 선언하자.\n\n##### User 객체\n```java\n@Getter\n@Entity\n@NoArgsConstructor\npublic class User {\n\n    @Id\n    private String id;\n    private String name;\n    private Level level;\n    private int loginCount;\n    private int recommend;\n\n\n    @Builder\n    public User(String id, Level level, int loginCount, int recommend, String name) {\n        this.id = id;\n        this.level = level;\n        this.loginCount = loginCount;\n        this.recommend = recommend;\n        this.name = name;\n    }\n\n    public void updateName(String name) {\n        this.name = name;\n    }\n\n    public void setLevel(Level level){\n        this.level = level;\n    }\n\n\n    public void updateLevel(){\n        final Level nextLevel = this.level.nextLevel();\n        if(nextLevel == null){\n            throw new IllegalStateException(this.level + \"은 업그레이드가 불가능합니다.\");\n        }else{\n            this.level = nextLevel;\n        }\n    }\n}\n\n```\n\n##### 레벨 객체\n```java\npublic enum Level {\n    GOLD(3, null),\n    SILVER(2, GOLD),\n    BASIC(1, SILVER),\n    ;\n\n    private final int value;\n    private final Level next;\n\n    Level(int value, Level next){\n        this.value = value;\n        this.next = next;\n    }\n\n    public int value(){\n        return value;\n    }\n\n    public Level nextLevel(){\n        return this.next;\n    }\n}\n```\n관리자가 아래의 기능을 호출하면 애플리케이션에 모든 유저들의 레벨이 레벨정책조건에 따라 업데이트가 된다.\n##### UserService 객체\n```java\n// userService\n\n@Transactional\npublic void upgradeLevels(){\n    List<User> users = (List<User>) userRepository.findAll(); // 모든 유저 조회\n    for(User user : users){ // 유저하나하나 조회\n        if(canUpgradeLevel(user)) // 업그레이드 가능여부\n            user.updateLevel(); // 업그레이드\n    }\n}\n\nprivate boolean canUpgradeLevel(User user){// 레벨 업그레이드 가능한지 여부를 체크하는 함수이다.\n    Level currentLevel = user.getLevel();\n    switch (currentLevel){\n        case BASIC: return (user.getLoginCount() >= MIN_LOGCOUNT_FOR_SILVER); //로그인한횟수\n        case SILVER: return (user.getRecommend() >= MIN_RECCOMEND_FOR_GOLD); // 추천횟수\n        case GOLD: return false;\n        default: throw new IllegalArgumentException(\"Unknown Level\");\n    }\n}\n```\n여기까지 간단하게 기능을 구현했다. upgradeLevels메소드를 호출하면 모든 유저를 조회해서 요구조건에 맞게 레벨업을 시킨다. 지금은 업그레이드 가능여부를 로그인 카운트와 추천 카운트를 기반으로 유저의 레벨업을 시켰다. 하지만 위에서 말한대로 연말 이벤트나 새로운 서비스 홍보 기간중에 레벨업그레이드 정책이 달라질 수 가 있다. 물론 현재 canUpgradeLevel메소드를 지우고 새롭게 코드를 짜는 방법도 있다. 하지만 이벤트성 레벨업그레이드는 한번만 사용하거나 그 비슷한 이벤트가 일어나야 다시 사용할 수 있다. 그래서 이런 부분을 부품처럼 잘라 내서 관리 할수 있다.\n```java\npublic interface UserLevelUpgradePolicy {\n    boolean canUpgradeLevel(User user);\n}\n```\n\n이렇게 레벨 업그레이드 정책기능을 인터페이스로 만들어 필요한 정책에 따라 의존성 주입을해서 사용할 수 있다. 예를 들어 아래와 같이 사용할 수 있다. 아래 보면 UserLevelUpgradePolicy라는 인터페이스를 선언했다. 그리고 userService에서 그 인터페이스를 이용해 정책에 따라 구현 Component를 주입받아 레벨을 업그레이드한다.\n\n```java\n//userService\n@Autowired\nprivate UserLevelUpgradePolicy userLevelUpgradePolicy;\n\n@Transactional\npublic void upgradeLevels(){\n    List<User> users = (List<User>) userRepository.findAll(); // 모든 유저 조회\n    for(User user : users){ // 유저하나하나 조회\n        if(userLevelUpgradePolicy.canUpgradeLevel(user)) // 업그레이드 가능여부\n            user.updateLevel(); // 업그레이드\n    }\n}\n```\n\n이제 일반적인 업그레이드 정책이냐, 이벤트에 정책이냐에 따라서 아래와 같이 정책을 사용할 수 있다.\n```java\npublic class OrdinaryLevelUpgradePolicy implements UserLevelUpgradePolicy{\n\n    @Override\n    public boolean canUpgradeLevel(User user) {\n        Level currentLevel = user.getLevel();\n        switch (currentLevel){\n            case BASIC: return (user.getLoginCount() >= MIN_LOGCOUNT_FOR_SILVER);\n            case SILVER: return (user.getRecommend() >= MIN_RECCOMEND_FOR_GOLD);\n            case GOLD: return false;\n            default: throw new IllegalArgumentException(\"Unknown Level\");\n        }\n    }\n}\n\npublic class EventLevelUpgradePolicy implements UserLevelUpgradePolicy{\n    @Override\n    public boolean canUpgradeLevel(User user) {\n        //이벤트성 비즈니스로직\n    }\n}\n\n```\n레벨정책에 따라 아래와같이 의존성 주입을 해줄 수 있다. 그렇게되면 일반적인 정책과 이벤트 진행에따라 정책을 유연하게 변경할 수 있다.\n```java\n@Bean\npublic UserLevelUpgradePolicy userLevelUpgradePolicy(){\n      return new OrdinaryLevelUpgradePolicy();\n  }\n```\n### 마무리하며\n여기까지 아주간단하게 스프링에서 어떻게 추상화를 사용할지에 대해 간단히 구현해봤다. 이렇게 하면 어떤 정책클래스를 주입받았느냐에 따라서 유저 레벨을 업그레이드할 수 있다. 물론 그 구현체 클래스에 비즈니스로직에 따라서 업그레이드를 할 수 있느냐 못하느냐가 결정된다. 위에서 구현한 레벨업그레이드 정책클레스에서는 워낙 비즈니스로직이 간단해서 저렇게까지 하나 이런생각이 들 수 있다. 하지만 정책이 더 생기고, 비즈니스 로직이 아주 복잡하다고 생각하면 이렇게 추상화해서 사용하는것은 유지보수, 확장성면에 아주 큰도움이 될것이다. 또한 이렇게 구성함으로 SOLID 원칙에서 말하는 원칙중 하나인 단일책임의 원칙을 아주 잘 지킬 수 있다.\n\n위와같이 UserLevelUpgradePolicy를 인터페이스로 뺌으로써 어떤 정책이 들어와도 적절하게 책임과 관심이 다른 코드로 분리된다. 또한 애플리케이션 로직과 기술/환경을 분리하는 등의 작업을 통해 어떤 변경이 필요할 때 수정 대상이 명확해진다.\n\n추상화를 통해 인터페이스를 도입하고 이를  DI 를 통해 연결하고 그로 인해 개방 패쇄 원칙도 잘 지키고 모듈 간에 결합도가 낮아서 서로의 변경이 영향을 주지 않고, 같은 이유로 변경이 단일 책임에 집중되는 응집도가 높은 코드가 나오게 되었다.\n\n예제소스는 아래에서 참고할 수 있습니다.\n\n[git-hub-예제소스](https://github.com/minwan1/Spring-tobi/tree/service-abstraction-level-policy/5-service-abstraction)\n\n\n참고\n* [토비의 스프링](http://book.naver.com/bookdb/book_detail.nhn?bid=7006516)\n","source":"_posts/2018-04-01-spring-service.md","raw":"---\ntitle: 스프링 기능 추상화 예제\ncatalog: true\ndate: 2018-04-01\nsubtitle:\nheader-img:\ntags:\n- Spring\n- Java\n\n---\n\n## 스프링 기능 추상화 예제\n\n### 시작하며\n이글의 내용은 [토비의 스프링](http://book.naver.com/bookdb/book_detail.nhn?bid=7006516)책의 내용으로 제가 이해한 스프링 서비스 추상화에 대한 내용을 정리한 글입니다. 물론 책에 더 상세하게 설명이 되어있지만 개인적으로 간단하게 정리하고 싶었습니다. 다른 사람에게 잘 설명을 할 수 있어야 더욱 깊게 이 내용을 이해한 것이라고 생각하기 때문입니다!! 물론 또 저만을 위한 것은 아니고 이 글을 통해 서비스 추상화에 대한 이해를 하시는데 도움이 되시는 분들이 있을 거라고 생각합니다! [참고로 책에서는 mybatis 예제였으나.. 이 글에서 Spring JPA로 구현한 예제입니다.]\n\n### 추상화란\n자바에는 표준 스펙, 사용 제품, 오픈소스를 통틀어서 사용방법과 형식은 다르지만 기능과 목적이 유사한 기술이 존재한다. 환경과 상황에 따라서 기술이 바뀌고, 그에 따른 다른 API를 사용하고 다른 스타일의 접근 방법을 따라야 한다는 건 매우 피곤한 일이다. 이러한 문제를 해결하기 위해서는 규격을 정하고 그것을 이용해야 한다. 그 규격은 인터페이스로 정할 수 있다. 예를 들어 List라는 인터페이스가 있으면 우리는 구현체를 ArrayList를 선언하느냐, LinkedList를 선언하느냐에 따라 구현체가 달라진다. 이렇듯 구현체를 어떻게 구성하느냐에 쓸 수 있는 기능, 효율이 달라진다. 다음 글에서 스프링이 어떻게 성격이 비슷한 여러 종류의 기술을 추상화하고 이를 일관된 방법으로 사용할 수 있도록 지원하는지 확인할 것이다. 이 글에서는 정책에 따른 유저 레벨[티어] 업그레이드를 추상화하는 방법에 대해 설명할 것이다. 좀 더 상세한 설명은 아래에서 설명할 것이다.\n\n#### 요구사항\n먼저 책에서 Level, User, UserService, UserRepository, 의 클래스가 있다. 이 클래스들을 이용해서 우리는 유저의 레벨 관리 기능을 추가해야 한다. 유저의 레벨 관리 기능은 관리자 호출 등을 통해서 userService.upgradeLevels()라는 메서드를 호출했을 때 이 애플리케이션의 존재하는 유저들이 아래의 요구 조건에 맞게 유저의 레벨을 올려야 한다는 요구 조건이다.\n\n다음은 요구조건과 레벨이 올라가기 위한조건에 대한 내용이다.\n* 사용자의 레벨은 BASIC, SILVER, GOLD 세가지중 하나이다.\n* 사용자가 처음 가입하면 BASIC 레벨이 되며, 이후 활동에 따라서 한단계씩 업그레이드 될 수 있다.\n* 가입 후 50회 이상 로그인을 하면 BASIC에서 SIRVER레벨이 된다.\n* SILVER레벨이면서 30번 이상 추천을 받으면 GOLD레벨이 된다.\n* 사용자 레벨의 변경 작업은 일정한 주기를 가지고 일관적으로 진행된다. userService.upgradeLevels()를 호출하기 전까지는 조건을 충족하더라도 레벨의 변경이 일어나지 않는다.\n\n참고로 위의 기본 요구 조건은 정해진 조건에 따라 사용자의 레벨이 주기적으로 변경되거나 레벨을 업그레드하는 정책이 변경될 수 있다. 예를들어 연말 이벤트나, 새로운 서비스 홍보기간중에는 레벨 조건 정책이 바뀔 수 있다. 이럴때 어떻게 효율적으로 변경할 수 있을까. 그것은 바로 추상화이다. 여기에서 추상화해야 할것은 바로 UserLevelUpgradePolicy이다. 먼저 위의 요구 조건의 맞는 기능을 구현하고 이것을 어떻게 추상화하여 유연하게 바꿀지에 대해 생각해보자.\n\n#### 객체선언\n먼저 아래와 같이 요구조건에 맞는 객체와 서비스들을 선언하자.\n\n##### User 객체\n```java\n@Getter\n@Entity\n@NoArgsConstructor\npublic class User {\n\n    @Id\n    private String id;\n    private String name;\n    private Level level;\n    private int loginCount;\n    private int recommend;\n\n\n    @Builder\n    public User(String id, Level level, int loginCount, int recommend, String name) {\n        this.id = id;\n        this.level = level;\n        this.loginCount = loginCount;\n        this.recommend = recommend;\n        this.name = name;\n    }\n\n    public void updateName(String name) {\n        this.name = name;\n    }\n\n    public void setLevel(Level level){\n        this.level = level;\n    }\n\n\n    public void updateLevel(){\n        final Level nextLevel = this.level.nextLevel();\n        if(nextLevel == null){\n            throw new IllegalStateException(this.level + \"은 업그레이드가 불가능합니다.\");\n        }else{\n            this.level = nextLevel;\n        }\n    }\n}\n\n```\n\n##### 레벨 객체\n```java\npublic enum Level {\n    GOLD(3, null),\n    SILVER(2, GOLD),\n    BASIC(1, SILVER),\n    ;\n\n    private final int value;\n    private final Level next;\n\n    Level(int value, Level next){\n        this.value = value;\n        this.next = next;\n    }\n\n    public int value(){\n        return value;\n    }\n\n    public Level nextLevel(){\n        return this.next;\n    }\n}\n```\n관리자가 아래의 기능을 호출하면 애플리케이션에 모든 유저들의 레벨이 레벨정책조건에 따라 업데이트가 된다.\n##### UserService 객체\n```java\n// userService\n\n@Transactional\npublic void upgradeLevels(){\n    List<User> users = (List<User>) userRepository.findAll(); // 모든 유저 조회\n    for(User user : users){ // 유저하나하나 조회\n        if(canUpgradeLevel(user)) // 업그레이드 가능여부\n            user.updateLevel(); // 업그레이드\n    }\n}\n\nprivate boolean canUpgradeLevel(User user){// 레벨 업그레이드 가능한지 여부를 체크하는 함수이다.\n    Level currentLevel = user.getLevel();\n    switch (currentLevel){\n        case BASIC: return (user.getLoginCount() >= MIN_LOGCOUNT_FOR_SILVER); //로그인한횟수\n        case SILVER: return (user.getRecommend() >= MIN_RECCOMEND_FOR_GOLD); // 추천횟수\n        case GOLD: return false;\n        default: throw new IllegalArgumentException(\"Unknown Level\");\n    }\n}\n```\n여기까지 간단하게 기능을 구현했다. upgradeLevels메소드를 호출하면 모든 유저를 조회해서 요구조건에 맞게 레벨업을 시킨다. 지금은 업그레이드 가능여부를 로그인 카운트와 추천 카운트를 기반으로 유저의 레벨업을 시켰다. 하지만 위에서 말한대로 연말 이벤트나 새로운 서비스 홍보 기간중에 레벨업그레이드 정책이 달라질 수 가 있다. 물론 현재 canUpgradeLevel메소드를 지우고 새롭게 코드를 짜는 방법도 있다. 하지만 이벤트성 레벨업그레이드는 한번만 사용하거나 그 비슷한 이벤트가 일어나야 다시 사용할 수 있다. 그래서 이런 부분을 부품처럼 잘라 내서 관리 할수 있다.\n```java\npublic interface UserLevelUpgradePolicy {\n    boolean canUpgradeLevel(User user);\n}\n```\n\n이렇게 레벨 업그레이드 정책기능을 인터페이스로 만들어 필요한 정책에 따라 의존성 주입을해서 사용할 수 있다. 예를 들어 아래와 같이 사용할 수 있다. 아래 보면 UserLevelUpgradePolicy라는 인터페이스를 선언했다. 그리고 userService에서 그 인터페이스를 이용해 정책에 따라 구현 Component를 주입받아 레벨을 업그레이드한다.\n\n```java\n//userService\n@Autowired\nprivate UserLevelUpgradePolicy userLevelUpgradePolicy;\n\n@Transactional\npublic void upgradeLevels(){\n    List<User> users = (List<User>) userRepository.findAll(); // 모든 유저 조회\n    for(User user : users){ // 유저하나하나 조회\n        if(userLevelUpgradePolicy.canUpgradeLevel(user)) // 업그레이드 가능여부\n            user.updateLevel(); // 업그레이드\n    }\n}\n```\n\n이제 일반적인 업그레이드 정책이냐, 이벤트에 정책이냐에 따라서 아래와 같이 정책을 사용할 수 있다.\n```java\npublic class OrdinaryLevelUpgradePolicy implements UserLevelUpgradePolicy{\n\n    @Override\n    public boolean canUpgradeLevel(User user) {\n        Level currentLevel = user.getLevel();\n        switch (currentLevel){\n            case BASIC: return (user.getLoginCount() >= MIN_LOGCOUNT_FOR_SILVER);\n            case SILVER: return (user.getRecommend() >= MIN_RECCOMEND_FOR_GOLD);\n            case GOLD: return false;\n            default: throw new IllegalArgumentException(\"Unknown Level\");\n        }\n    }\n}\n\npublic class EventLevelUpgradePolicy implements UserLevelUpgradePolicy{\n    @Override\n    public boolean canUpgradeLevel(User user) {\n        //이벤트성 비즈니스로직\n    }\n}\n\n```\n레벨정책에 따라 아래와같이 의존성 주입을 해줄 수 있다. 그렇게되면 일반적인 정책과 이벤트 진행에따라 정책을 유연하게 변경할 수 있다.\n```java\n@Bean\npublic UserLevelUpgradePolicy userLevelUpgradePolicy(){\n      return new OrdinaryLevelUpgradePolicy();\n  }\n```\n### 마무리하며\n여기까지 아주간단하게 스프링에서 어떻게 추상화를 사용할지에 대해 간단히 구현해봤다. 이렇게 하면 어떤 정책클래스를 주입받았느냐에 따라서 유저 레벨을 업그레이드할 수 있다. 물론 그 구현체 클래스에 비즈니스로직에 따라서 업그레이드를 할 수 있느냐 못하느냐가 결정된다. 위에서 구현한 레벨업그레이드 정책클레스에서는 워낙 비즈니스로직이 간단해서 저렇게까지 하나 이런생각이 들 수 있다. 하지만 정책이 더 생기고, 비즈니스 로직이 아주 복잡하다고 생각하면 이렇게 추상화해서 사용하는것은 유지보수, 확장성면에 아주 큰도움이 될것이다. 또한 이렇게 구성함으로 SOLID 원칙에서 말하는 원칙중 하나인 단일책임의 원칙을 아주 잘 지킬 수 있다.\n\n위와같이 UserLevelUpgradePolicy를 인터페이스로 뺌으로써 어떤 정책이 들어와도 적절하게 책임과 관심이 다른 코드로 분리된다. 또한 애플리케이션 로직과 기술/환경을 분리하는 등의 작업을 통해 어떤 변경이 필요할 때 수정 대상이 명확해진다.\n\n추상화를 통해 인터페이스를 도입하고 이를  DI 를 통해 연결하고 그로 인해 개방 패쇄 원칙도 잘 지키고 모듈 간에 결합도가 낮아서 서로의 변경이 영향을 주지 않고, 같은 이유로 변경이 단일 책임에 집중되는 응집도가 높은 코드가 나오게 되었다.\n\n예제소스는 아래에서 참고할 수 있습니다.\n\n[git-hub-예제소스](https://github.com/minwan1/Spring-tobi/tree/service-abstraction-level-policy/5-service-abstraction)\n\n\n참고\n* [토비의 스프링](http://book.naver.com/bookdb/book_detail.nhn?bid=7006516)\n","slug":"2018-04-01-spring-service","published":1,"updated":"2018-06-20T16:05:18.375Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27dd002gjjpe7je0a9gc","content":"<h2><span id=\"스프링-기능-추상화-예제\">스프링 기능 추상화 예제</span></h2>\n<h3><span id=\"시작하며\">시작하며</span></h3>\n<p>이글의 내용은 <a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=7006516\" target=\"_blank\" rel=\"noopener\">토비의 스프링</a>책의 내용으로 제가 이해한 스프링 서비스 추상화에 대한 내용을 정리한 글입니다. 물론 책에 더 상세하게 설명이 되어있지만 개인적으로 간단하게 정리하고 싶었습니다. 다른 사람에게 잘 설명을 할 수 있어야 더욱 깊게 이 내용을 이해한 것이라고 생각하기 때문입니다!! 물론 또 저만을 위한 것은 아니고 이 글을 통해 서비스 추상화에 대한 이해를 하시는데 도움이 되시는 분들이 있을 거라고 생각합니다! [참고로 책에서는 mybatis 예제였으나… 이 글에서 Spring JPA로 구현한 예제입니다.]</p>\n<h3><span id=\"추상화란\">추상화란</span></h3>\n<p>자바에는 표준 스펙, 사용 제품, 오픈소스를 통틀어서 사용방법과 형식은 다르지만 기능과 목적이 유사한 기술이 존재한다. 환경과 상황에 따라서 기술이 바뀌고, 그에 따른 다른 API를 사용하고 다른 스타일의 접근 방법을 따라야 한다는 건 매우 피곤한 일이다. 이러한 문제를 해결하기 위해서는 규격을 정하고 그것을 이용해야 한다. 그 규격은 인터페이스로 정할 수 있다. 예를 들어 List라는 인터페이스가 있으면 우리는 구현체를 ArrayList를 선언하느냐, LinkedList를 선언하느냐에 따라 구현체가 달라진다. 이렇듯 구현체를 어떻게 구성하느냐에 쓸 수 있는 기능, 효율이 달라진다. 다음 글에서 스프링이 어떻게 성격이 비슷한 여러 종류의 기술을 추상화하고 이를 일관된 방법으로 사용할 수 있도록 지원하는지 확인할 것이다. 이 글에서는 정책에 따른 유저 레벨[티어] 업그레이드를 추상화하는 방법에 대해 설명할 것이다. 좀 더 상세한 설명은 아래에서 설명할 것이다.</p>\n<h4><span id=\"요구사항\">요구사항</span></h4>\n<p>먼저 책에서 Level, User, UserService, UserRepository, 의 클래스가 있다. 이 클래스들을 이용해서 우리는 유저의 레벨 관리 기능을 추가해야 한다. 유저의 레벨 관리 기능은 관리자 호출 등을 통해서 userService.upgradeLevels()라는 메서드를 호출했을 때 이 애플리케이션의 존재하는 유저들이 아래의 요구 조건에 맞게 유저의 레벨을 올려야 한다는 요구 조건이다.</p>\n<p>다음은 요구조건과 레벨이 올라가기 위한조건에 대한 내용이다.</p>\n<ul>\n<li>사용자의 레벨은 BASIC, SILVER, GOLD 세가지중 하나이다.</li>\n<li>사용자가 처음 가입하면 BASIC 레벨이 되며, 이후 활동에 따라서 한단계씩 업그레이드 될 수 있다.</li>\n<li>가입 후 50회 이상 로그인을 하면 BASIC에서 SIRVER레벨이 된다.</li>\n<li>SILVER레벨이면서 30번 이상 추천을 받으면 GOLD레벨이 된다.</li>\n<li>사용자 레벨의 변경 작업은 일정한 주기를 가지고 일관적으로 진행된다. userService.upgradeLevels()를 호출하기 전까지는 조건을 충족하더라도 레벨의 변경이 일어나지 않는다.</li>\n</ul>\n<p>참고로 위의 기본 요구 조건은 정해진 조건에 따라 사용자의 레벨이 주기적으로 변경되거나 레벨을 업그레드하는 정책이 변경될 수 있다. 예를들어 연말 이벤트나, 새로운 서비스 홍보기간중에는 레벨 조건 정책이 바뀔 수 있다. 이럴때 어떻게 효율적으로 변경할 수 있을까. 그것은 바로 추상화이다. 여기에서 추상화해야 할것은 바로 UserLevelUpgradePolicy이다. 먼저 위의 요구 조건의 맞는 기능을 구현하고 이것을 어떻게 추상화하여 유연하게 바꿀지에 대해 생각해보자.</p>\n<h4><span id=\"객체선언\">객체선언</span></h4>\n<p>먼저 아래와 같이 요구조건에 맞는 객체와 서비스들을 선언하자.</p>\n<h5><span id=\"user-객체\">User 객체</span></h5>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Level level;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> loginCount;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> recommend;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Builder</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">(String id, Level level, <span class=\"keyword\">int</span> loginCount, <span class=\"keyword\">int</span> recommend, String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.level = level;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.loginCount = loginCount;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.recommend = recommend;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">updateName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setLevel</span><span class=\"params\">(Level level)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.level = level;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">updateLevel</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Level nextLevel = <span class=\"keyword\">this</span>.level.nextLevel();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nextLevel == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"keyword\">this</span>.level + <span class=\"string\">\"은 업그레이드가 불가능합니다.\"</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.level = nextLevel;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5><span id=\"레벨-객체\">레벨 객체</span></h5>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Level &#123;</span><br><span class=\"line\">    GOLD(<span class=\"number\">3</span>, <span class=\"keyword\">null</span>),</span><br><span class=\"line\">    SILVER(<span class=\"number\">2</span>, GOLD),</span><br><span class=\"line\">    BASIC(<span class=\"number\">1</span>, SILVER),</span><br><span class=\"line\">    ;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Level next;</span><br><span class=\"line\"></span><br><span class=\"line\">    Level(<span class=\"keyword\">int</span> value, Level next)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">value</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Level <span class=\"title\">nextLevel</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>관리자가 아래의 기능을 호출하면 애플리케이션에 모든 유저들의 레벨이 레벨정책조건에 따라 업데이트가 된다.</p>\n<h5><span id=\"userservice-객체\">UserService 객체</span></h5>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// userService</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">upgradeLevels</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    List&lt;User&gt; users = (List&lt;User&gt;) userRepository.findAll(); <span class=\"comment\">// 모든 유저 조회</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(User user : users)&#123; <span class=\"comment\">// 유저하나하나 조회</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(canUpgradeLevel(user)) <span class=\"comment\">// 업그레이드 가능여부</span></span><br><span class=\"line\">            user.updateLevel(); <span class=\"comment\">// 업그레이드</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canUpgradeLevel</span><span class=\"params\">(User user)</span></span>&#123;<span class=\"comment\">// 레벨 업그레이드 가능한지 여부를 체크하는 함수이다.</span></span><br><span class=\"line\">    Level currentLevel = user.getLevel();</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (currentLevel)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> BASIC: <span class=\"keyword\">return</span> (user.getLoginCount() &gt;= MIN_LOGCOUNT_FOR_SILVER); <span class=\"comment\">//로그인한횟수</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> SILVER: <span class=\"keyword\">return</span> (user.getRecommend() &gt;= MIN_RECCOMEND_FOR_GOLD); <span class=\"comment\">// 추천횟수</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> GOLD: <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Unknown Level\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>여기까지 간단하게 기능을 구현했다. upgradeLevels메소드를 호출하면 모든 유저를 조회해서 요구조건에 맞게 레벨업을 시킨다. 지금은 업그레이드 가능여부를 로그인 카운트와 추천 카운트를 기반으로 유저의 레벨업을 시켰다. 하지만 위에서 말한대로 연말 이벤트나 새로운 서비스 홍보 기간중에 레벨업그레이드 정책이 달라질 수 가 있다. 물론 현재 canUpgradeLevel메소드를 지우고 새롭게 코드를 짜는 방법도 있다. 하지만 이벤트성 레벨업그레이드는 한번만 사용하거나 그 비슷한 이벤트가 일어나야 다시 사용할 수 있다. 그래서 이런 부분을 부품처럼 잘라 내서 관리 할수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserLevelUpgradePolicy</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">canUpgradeLevel</span><span class=\"params\">(User user)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이렇게 레벨 업그레이드 정책기능을 인터페이스로 만들어 필요한 정책에 따라 의존성 주입을해서 사용할 수 있다. 예를 들어 아래와 같이 사용할 수 있다. 아래 보면 UserLevelUpgradePolicy라는 인터페이스를 선언했다. 그리고 userService에서 그 인터페이스를 이용해 정책에 따라 구현 Component를 주입받아 레벨을 업그레이드한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//userService</span></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> UserLevelUpgradePolicy userLevelUpgradePolicy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">upgradeLevels</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    List&lt;User&gt; users = (List&lt;User&gt;) userRepository.findAll(); <span class=\"comment\">// 모든 유저 조회</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(User user : users)&#123; <span class=\"comment\">// 유저하나하나 조회</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(userLevelUpgradePolicy.canUpgradeLevel(user)) <span class=\"comment\">// 업그레이드 가능여부</span></span><br><span class=\"line\">            user.updateLevel(); <span class=\"comment\">// 업그레이드</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이제 일반적인 업그레이드 정책이냐, 이벤트에 정책이냐에 따라서 아래와 같이 정책을 사용할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrdinaryLevelUpgradePolicy</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserLevelUpgradePolicy</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canUpgradeLevel</span><span class=\"params\">(User user)</span> </span>&#123;</span><br><span class=\"line\">        Level currentLevel = user.getLevel();</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (currentLevel)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> BASIC: <span class=\"keyword\">return</span> (user.getLoginCount() &gt;= MIN_LOGCOUNT_FOR_SILVER);</span><br><span class=\"line\">            <span class=\"keyword\">case</span> SILVER: <span class=\"keyword\">return</span> (user.getRecommend() &gt;= MIN_RECCOMEND_FOR_GOLD);</span><br><span class=\"line\">            <span class=\"keyword\">case</span> GOLD: <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Unknown Level\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EventLevelUpgradePolicy</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserLevelUpgradePolicy</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canUpgradeLevel</span><span class=\"params\">(User user)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//이벤트성 비즈니스로직</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>레벨정책에 따라 아래와같이 의존성 주입을 해줄 수 있다. 그렇게되면 일반적인 정책과 이벤트 진행에따라 정책을 유연하게 변경할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> UserLevelUpgradePolicy <span class=\"title\">userLevelUpgradePolicy</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> OrdinaryLevelUpgradePolicy();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"마무리하며\">마무리하며</span></h3>\n<p>여기까지 아주간단하게 스프링에서 어떻게 추상화를 사용할지에 대해 간단히 구현해봤다. 이렇게 하면 어떤 정책클래스를 주입받았느냐에 따라서 유저 레벨을 업그레이드할 수 있다. 물론 그 구현체 클래스에 비즈니스로직에 따라서 업그레이드를 할 수 있느냐 못하느냐가 결정된다. 위에서 구현한 레벨업그레이드 정책클레스에서는 워낙 비즈니스로직이 간단해서 저렇게까지 하나 이런생각이 들 수 있다. 하지만 정책이 더 생기고, 비즈니스 로직이 아주 복잡하다고 생각하면 이렇게 추상화해서 사용하는것은 유지보수, 확장성면에 아주 큰도움이 될것이다. 또한 이렇게 구성함으로 SOLID 원칙에서 말하는 원칙중 하나인 단일책임의 원칙을 아주 잘 지킬 수 있다.</p>\n<p>위와같이 UserLevelUpgradePolicy를 인터페이스로 뺌으로써 어떤 정책이 들어와도 적절하게 책임과 관심이 다른 코드로 분리된다. 또한 애플리케이션 로직과 기술/환경을 분리하는 등의 작업을 통해 어떤 변경이 필요할 때 수정 대상이 명확해진다.</p>\n<p>추상화를 통해 인터페이스를 도입하고 이를  DI 를 통해 연결하고 그로 인해 개방 패쇄 원칙도 잘 지키고 모듈 간에 결합도가 낮아서 서로의 변경이 영향을 주지 않고, 같은 이유로 변경이 단일 책임에 집중되는 응집도가 높은 코드가 나오게 되었다.</p>\n<p>예제소스는 아래에서 참고할 수 있습니다.</p>\n<p><a href=\"https://github.com/minwan1/Spring-tobi/tree/service-abstraction-level-policy/5-service-abstraction\" target=\"_blank\" rel=\"noopener\">git-hub-예제소스</a></p>\n<p>참고</p>\n<ul>\n<li><a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=7006516\" target=\"_blank\" rel=\"noopener\">토비의 스프링</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>스프링 기능 추상화 예제</h2>\n<h3>시작하며</h3>\n<p>이글의 내용은 <a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=7006516\" target=\"_blank\" rel=\"noopener\">토비의 스프링</a>책의 내용으로 제가 이해한 스프링 서비스 추상화에 대한 내용을 정리한 글입니다. 물론 책에 더 상세하게 설명이 되어있지만 개인적으로 간단하게 정리하고 싶었습니다. 다른 사람에게 잘 설명을 할 수 있어야 더욱 깊게 이 내용을 이해한 것이라고 생각하기 때문입니다!! 물론 또 저만을 위한 것은 아니고 이 글을 통해 서비스 추상화에 대한 이해를 하시는데 도움이 되시는 분들이 있을 거라고 생각합니다! [참고로 책에서는 mybatis 예제였으나… 이 글에서 Spring JPA로 구현한 예제입니다.]</p>\n<h3>추상화란</h3>\n<p>자바에는 표준 스펙, 사용 제품, 오픈소스를 통틀어서 사용방법과 형식은 다르지만 기능과 목적이 유사한 기술이 존재한다. 환경과 상황에 따라서 기술이 바뀌고, 그에 따른 다른 API를 사용하고 다른 스타일의 접근 방법을 따라야 한다는 건 매우 피곤한 일이다. 이러한 문제를 해결하기 위해서는 규격을 정하고 그것을 이용해야 한다. 그 규격은 인터페이스로 정할 수 있다. 예를 들어 List라는 인터페이스가 있으면 우리는 구현체를 ArrayList를 선언하느냐, LinkedList를 선언하느냐에 따라 구현체가 달라진다. 이렇듯 구현체를 어떻게 구성하느냐에 쓸 수 있는 기능, 효율이 달라진다. 다음 글에서 스프링이 어떻게 성격이 비슷한 여러 종류의 기술을 추상화하고 이를 일관된 방법으로 사용할 수 있도록 지원하는지 확인할 것이다. 이 글에서는 정책에 따른 유저 레벨[티어] 업그레이드를 추상화하는 방법에 대해 설명할 것이다. 좀 더 상세한 설명은 아래에서 설명할 것이다.</p>\n<h4>요구사항</h4>\n<p>먼저 책에서 Level, User, UserService, UserRepository, 의 클래스가 있다. 이 클래스들을 이용해서 우리는 유저의 레벨 관리 기능을 추가해야 한다. 유저의 레벨 관리 기능은 관리자 호출 등을 통해서 userService.upgradeLevels()라는 메서드를 호출했을 때 이 애플리케이션의 존재하는 유저들이 아래의 요구 조건에 맞게 유저의 레벨을 올려야 한다는 요구 조건이다.</p>\n<p>다음은 요구조건과 레벨이 올라가기 위한조건에 대한 내용이다.</p>\n<ul>\n<li>사용자의 레벨은 BASIC, SILVER, GOLD 세가지중 하나이다.</li>\n<li>사용자가 처음 가입하면 BASIC 레벨이 되며, 이후 활동에 따라서 한단계씩 업그레이드 될 수 있다.</li>\n<li>가입 후 50회 이상 로그인을 하면 BASIC에서 SIRVER레벨이 된다.</li>\n<li>SILVER레벨이면서 30번 이상 추천을 받으면 GOLD레벨이 된다.</li>\n<li>사용자 레벨의 변경 작업은 일정한 주기를 가지고 일관적으로 진행된다. userService.upgradeLevels()를 호출하기 전까지는 조건을 충족하더라도 레벨의 변경이 일어나지 않는다.</li>\n</ul>\n<p>참고로 위의 기본 요구 조건은 정해진 조건에 따라 사용자의 레벨이 주기적으로 변경되거나 레벨을 업그레드하는 정책이 변경될 수 있다. 예를들어 연말 이벤트나, 새로운 서비스 홍보기간중에는 레벨 조건 정책이 바뀔 수 있다. 이럴때 어떻게 효율적으로 변경할 수 있을까. 그것은 바로 추상화이다. 여기에서 추상화해야 할것은 바로 UserLevelUpgradePolicy이다. 먼저 위의 요구 조건의 맞는 기능을 구현하고 이것을 어떻게 추상화하여 유연하게 바꿀지에 대해 생각해보자.</p>\n<h4>객체선언</h4>\n<p>먼저 아래와 같이 요구조건에 맞는 객체와 서비스들을 선언하자.</p>\n<h5>User 객체</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Level level;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> loginCount;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> recommend;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Builder</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">(String id, Level level, <span class=\"keyword\">int</span> loginCount, <span class=\"keyword\">int</span> recommend, String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.level = level;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.loginCount = loginCount;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.recommend = recommend;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">updateName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setLevel</span><span class=\"params\">(Level level)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.level = level;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">updateLevel</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Level nextLevel = <span class=\"keyword\">this</span>.level.nextLevel();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nextLevel == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"keyword\">this</span>.level + <span class=\"string\">\"은 업그레이드가 불가능합니다.\"</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.level = nextLevel;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5>레벨 객체</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> Level &#123;</span><br><span class=\"line\">    GOLD(<span class=\"number\">3</span>, <span class=\"keyword\">null</span>),</span><br><span class=\"line\">    SILVER(<span class=\"number\">2</span>, GOLD),</span><br><span class=\"line\">    BASIC(<span class=\"number\">1</span>, SILVER),</span><br><span class=\"line\">    ;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Level next;</span><br><span class=\"line\"></span><br><span class=\"line\">    Level(<span class=\"keyword\">int</span> value, Level next)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">value</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Level <span class=\"title\">nextLevel</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>관리자가 아래의 기능을 호출하면 애플리케이션에 모든 유저들의 레벨이 레벨정책조건에 따라 업데이트가 된다.</p>\n<h5>UserService 객체</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// userService</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">upgradeLevels</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    List&lt;User&gt; users = (List&lt;User&gt;) userRepository.findAll(); <span class=\"comment\">// 모든 유저 조회</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(User user : users)&#123; <span class=\"comment\">// 유저하나하나 조회</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(canUpgradeLevel(user)) <span class=\"comment\">// 업그레이드 가능여부</span></span><br><span class=\"line\">            user.updateLevel(); <span class=\"comment\">// 업그레이드</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canUpgradeLevel</span><span class=\"params\">(User user)</span></span>&#123;<span class=\"comment\">// 레벨 업그레이드 가능한지 여부를 체크하는 함수이다.</span></span><br><span class=\"line\">    Level currentLevel = user.getLevel();</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (currentLevel)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> BASIC: <span class=\"keyword\">return</span> (user.getLoginCount() &gt;= MIN_LOGCOUNT_FOR_SILVER); <span class=\"comment\">//로그인한횟수</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> SILVER: <span class=\"keyword\">return</span> (user.getRecommend() &gt;= MIN_RECCOMEND_FOR_GOLD); <span class=\"comment\">// 추천횟수</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> GOLD: <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Unknown Level\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>여기까지 간단하게 기능을 구현했다. upgradeLevels메소드를 호출하면 모든 유저를 조회해서 요구조건에 맞게 레벨업을 시킨다. 지금은 업그레이드 가능여부를 로그인 카운트와 추천 카운트를 기반으로 유저의 레벨업을 시켰다. 하지만 위에서 말한대로 연말 이벤트나 새로운 서비스 홍보 기간중에 레벨업그레이드 정책이 달라질 수 가 있다. 물론 현재 canUpgradeLevel메소드를 지우고 새롭게 코드를 짜는 방법도 있다. 하지만 이벤트성 레벨업그레이드는 한번만 사용하거나 그 비슷한 이벤트가 일어나야 다시 사용할 수 있다. 그래서 이런 부분을 부품처럼 잘라 내서 관리 할수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserLevelUpgradePolicy</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">canUpgradeLevel</span><span class=\"params\">(User user)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이렇게 레벨 업그레이드 정책기능을 인터페이스로 만들어 필요한 정책에 따라 의존성 주입을해서 사용할 수 있다. 예를 들어 아래와 같이 사용할 수 있다. 아래 보면 UserLevelUpgradePolicy라는 인터페이스를 선언했다. 그리고 userService에서 그 인터페이스를 이용해 정책에 따라 구현 Component를 주입받아 레벨을 업그레이드한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//userService</span></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> UserLevelUpgradePolicy userLevelUpgradePolicy;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">upgradeLevels</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    List&lt;User&gt; users = (List&lt;User&gt;) userRepository.findAll(); <span class=\"comment\">// 모든 유저 조회</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(User user : users)&#123; <span class=\"comment\">// 유저하나하나 조회</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(userLevelUpgradePolicy.canUpgradeLevel(user)) <span class=\"comment\">// 업그레이드 가능여부</span></span><br><span class=\"line\">            user.updateLevel(); <span class=\"comment\">// 업그레이드</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이제 일반적인 업그레이드 정책이냐, 이벤트에 정책이냐에 따라서 아래와 같이 정책을 사용할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrdinaryLevelUpgradePolicy</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserLevelUpgradePolicy</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canUpgradeLevel</span><span class=\"params\">(User user)</span> </span>&#123;</span><br><span class=\"line\">        Level currentLevel = user.getLevel();</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (currentLevel)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> BASIC: <span class=\"keyword\">return</span> (user.getLoginCount() &gt;= MIN_LOGCOUNT_FOR_SILVER);</span><br><span class=\"line\">            <span class=\"keyword\">case</span> SILVER: <span class=\"keyword\">return</span> (user.getRecommend() &gt;= MIN_RECCOMEND_FOR_GOLD);</span><br><span class=\"line\">            <span class=\"keyword\">case</span> GOLD: <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Unknown Level\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EventLevelUpgradePolicy</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserLevelUpgradePolicy</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canUpgradeLevel</span><span class=\"params\">(User user)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//이벤트성 비즈니스로직</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>레벨정책에 따라 아래와같이 의존성 주입을 해줄 수 있다. 그렇게되면 일반적인 정책과 이벤트 진행에따라 정책을 유연하게 변경할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> UserLevelUpgradePolicy <span class=\"title\">userLevelUpgradePolicy</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> OrdinaryLevelUpgradePolicy();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h3>마무리하며</h3>\n<p>여기까지 아주간단하게 스프링에서 어떻게 추상화를 사용할지에 대해 간단히 구현해봤다. 이렇게 하면 어떤 정책클래스를 주입받았느냐에 따라서 유저 레벨을 업그레이드할 수 있다. 물론 그 구현체 클래스에 비즈니스로직에 따라서 업그레이드를 할 수 있느냐 못하느냐가 결정된다. 위에서 구현한 레벨업그레이드 정책클레스에서는 워낙 비즈니스로직이 간단해서 저렇게까지 하나 이런생각이 들 수 있다. 하지만 정책이 더 생기고, 비즈니스 로직이 아주 복잡하다고 생각하면 이렇게 추상화해서 사용하는것은 유지보수, 확장성면에 아주 큰도움이 될것이다. 또한 이렇게 구성함으로 SOLID 원칙에서 말하는 원칙중 하나인 단일책임의 원칙을 아주 잘 지킬 수 있다.</p>\n<p>위와같이 UserLevelUpgradePolicy를 인터페이스로 뺌으로써 어떤 정책이 들어와도 적절하게 책임과 관심이 다른 코드로 분리된다. 또한 애플리케이션 로직과 기술/환경을 분리하는 등의 작업을 통해 어떤 변경이 필요할 때 수정 대상이 명확해진다.</p>\n<p>추상화를 통해 인터페이스를 도입하고 이를  DI 를 통해 연결하고 그로 인해 개방 패쇄 원칙도 잘 지키고 모듈 간에 결합도가 낮아서 서로의 변경이 영향을 주지 않고, 같은 이유로 변경이 단일 책임에 집중되는 응집도가 높은 코드가 나오게 되었다.</p>\n<p>예제소스는 아래에서 참고할 수 있습니다.</p>\n<p><a href=\"https://github.com/minwan1/Spring-tobi/tree/service-abstraction-level-policy/5-service-abstraction\" target=\"_blank\" rel=\"noopener\">git-hub-예제소스</a></p>\n<p>참고</p>\n<ul>\n<li><a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=7006516\" target=\"_blank\" rel=\"noopener\">토비의 스프링</a></li>\n</ul>\n"},{"title":"Java, JVM 이란","catalog":true,"date":"2018-06-05T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n\n## Java란\n자바는 썬 마이크로 시스템즈에서 개발하여 1996년 1월 공식적으로 발표한 객체지향언어이다.\n\n기본적으로 자바프로그램들은 JVM위에서 동작한다. JVM 위에서 동작하기 위해서는 자바 바이트코드가 필요하다. 이 자바 바이트코드는 개발자에 의해서 작성된 자바 소스코드(.java)를 자바컴파일러(javac)로 변환 된 코드(.class)를 말한다. 아래 간단하게 자바프로그램 특징을 정리해보았다.\n\n### 자바 프로그램 특징\n1. 자바프로그램은 운영체제에 독립적이다.\n2. 객체지향 언어이기 때문에 유지보수가 용이하다.\n3. 자동으로 메모리관리를 해준다.\n4. 동적 로딩을 지원한다.\n5. 오픈소스 자료가 풍부하다.\n6. 자바프로그램은 안정적이다.\n\n## JVM이란\nJVM이란 JAVA Virtual Machine, 자바 가상 머신의 약자를 따서 주려 부르는 용어이다. JVM 역할은 자바 애플리케이션을 클래스 로더를 통해 읽어 들여 자바 API와 함께 실행하는 것이다. 그리고 JVM은 JAVA와 OS사이에서 중개자 역할을 수행하여 운영체제에 독립적인 플랫폼을 갖게 해준다.\n\n또한 JVM은 프로그램의 메모리 관리를 알아서 해준다. C프로그램 같은 경우 에는 직접 메모리할당을 해주고 해지해줘야한다. 하지만 JAVA에서는 JVM이 자동으로 Memory 관리를 해주는 장점이 있다.\n\n### JVM 실행구조\n일반적인 프로그램은 Windows또는 Linux같은 운영체제 위에서 실행된다.\n![](https://i.imgur.com/zV6xu0h.png)\n<center>그림1</center>\n\n하지만 위에서 설명한대로 자바프로그램 같은경우에는 위 오른쪽 그림과 같이 운영체제위에 자바 가상 머신위에서 실행이된다. 이렇게 JVM위에서 굳이 자바 프로그램을 돌리는 이유는 자바 프로그램을 운영체제에 상관없이 실행시키기 위함이다.\n예를들어 윈도우에서 동작하도록 구현된 워드 프로그램은 Linux에서 동작하지 않는다. 이 워드 프로그램을 Mac환경에서 돌리기 위해서는 Mac기반으로 다시 구현해야 한다. 이렇게 운영체제가 다르면 같은 프로그래밍의 언어로 구현한다 할지라도 운영체제에서 일부 다른 기능이 존재하기 때문이다. 예를 들어 그래픽, 키보드 마우스 관련 기능들은 운영체제에 의해서 제공되기 때문에, 운영체제가 달라지면 동일한 프로그래밍 언어일지라도 기능의 완성법이 달라진다. 하지만 자바 프로그램 같은 경우에는 아래의 그림과 같이 운영체제에 맞는 JVM을 다운로드한다면 어떤 환경에 운영체제에서도 자바 프로그램을 실행 실킬 수 있다.\n\n\n### JVM 실행과정\n1. 프로그램이 실행되면 JVM은 OS로부터 이 프로그램이 필요로 하는 메모리를 할당 받는다. JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.\n2. 자바 컴파일러(javac)가 자바소스(.java)코드를 읽어 들여 자바 바이트코드(.class)로 변환시킨다.\n3. 이 변경된 Class 파일들을 Class Loader를 통해 JVM 메모리영역(Runtime Data Areas) 영역으로 로딩한다.\n4. 로딩된 class파일들은 Execution engine을 통해 해석된다.\n5. 해석된 바이트코드는 Runtime Data Areas에 배치되어 실질적인 수행이 이루어지게된다.\n이러한 실행과정속에서 JVM은 필요에 따라 Thread Synchronization과 GC같은 관리 작업을 수행한다.\n\n아래는 JVM 실행과정을 그림으로 표현한것이다.\n\n![](https://i.imgur.com/Vy1JC1b.png)\n<center>그림2</center>\n\n\nJVM 내에 기능들을 좀 더 세부적으로 알아보자.\n#### Java Compiler\n자바 소스(.java)코드를 Byte code(.class)로 변환하는 역할을 한다.\n\n#### Class Loader\nJVM은 컴파일 타임이 아닌 런타임시에 처음으로 클래스를 참조할때 해당 클래스를 로드하고 RuntimeDataArea에 배치한다. 이 동적 로드를 담당하는 부분이 JVM의 Class Loader이다.\n\n#### Runtime Data Areas\n런타임 데이터 영역은 JVM이라는 프로그램이 운영체제 위에서 실행되면서 할당받는 메모리 영역이다. 런타임 데이터 영역은 5개의 영역으로 나눌 수 있다. 이중 PC 레지스터(PC Register), JVM 스택(JVM Stack), 네이티브 메서드 스택(Native Method Stack)은 스레드마다 하나씩 생성되며 힙(Heap), 메서드 영역(Method Area) 은 모든 스레드가 공유해서 사용한다.\n<center>\n\n ![](https://i.imgur.com/zv717Hf.png)\n\n</center>\n<center>그림 3</center>\n\n아래그림은 실제 런타임시에 어떻게 클래스들과 객체 그리고 지역변수들이 할당되는지에 대한 것을 그림으로 표현한것이다.\n\n![](https://i.imgur.com/pAh5gIZ.png)\n<center>그림 4</center>\n\n##### PC Register\n레지스터는 각 스레드마다 하나씩 존재하며 스레드가 시작될 때 생성된다. PC레지스터는 Thread가 어떤 명령어로 실행되어야 할지에 대한 기록을 하는 부분으로 현재 수행중인 JVM명령의 주소를 갖는다.\n\n##### Stack Area\n이곳에는 지역변수, 매개변수, 메소드 정보, 연산중 발생하는 임시 데이터등 저장이 된다.JVM은 오직 JVM 스택에 스택 프레임을 추가하고(push) 제거하는(pop) 동작만 수행한다. 예외 발생 시 printStackTrace() 등의 메서드로 보여주는 Stack Trace의 각 라인은 하나의 스택 프레임을 표현한다.\n\n> Stack에 저장되는 Element의 단위는 frame 이라한다.\n\n##### Native method stack area\n자바 프로그램이 컴파일되어 생성되는 바이트코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역이다. JAVA가 아닌 다른 언어로 작성된 코드를 위한 공간이다.\nJNI(Java Native Interface)를 통해 호출하는 C/C++등의 코드를 수행하기위한 스택 공간이다.\n\n##### Heap Area\nRuntime 에 동적으로 할당되는 데이터가 저장되는 영역입니다. 예를들어 객체생, 배열등이 생성되었을 때 저장되는 공간이다. Heap에 할당된 데이터는 GC의 대상입니다. JVM 성능 등의 이슈에서 가장 많이 언급되는 공간이다.\n\n##### Method Area(Class Area, Code Area, Static Area)\n메서드 영역은 모든 스레드가 공유하는 영역으로 JVM이 시작될 때 생성된다. JVM이 읽어 들인 각각의 클래스와 인터페이스에 대한 런타임 상수 풀, 필드와 메서드 코드, Static 변수, 메서드의 바이트코드 등을 보관한다.\n\n\n\n###### Runtime constant pool\nRuntime constant pool 은 Method area 내부에 존재하는 영역으로, 각 클래스와 인터페이스의 상수뿐만 아니라, 메서드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블이다. 즉, 어떤 메서드나 필드를 참조할 때 JVM은 런타임 상수 풀을 통해 해당 메서드나 필드의 실제 메모리상 주소를 찾아서 참조하여 중복을 막는 역할을 한다.\n\n\n\n#### Execution Engine\nLoad된 Class의 ByteCode를 실행하는 Runtime Module이 바로 Execution Engine이다. Class Loader를 통해 JVM 내의 Runtime Data Areas 에 배치된 바이트 코드는 Execution Engine에 의해 실행되며, 실행 엔진은 자바 바이트 코드를 기계어로 변경한 뒤에 사용하게 된다. 해당 작업을 실행 엔진이 하게 된다.. 그리고 바이트 코드를 기계어로 변경할 때엔 두 종류의 방식을 사용한다. 각각 Interpreter와 JIT (Just-In-Time) compiler이다.\n\nInterpreter는 명령어를 그때그때 해석해서 실행하게 되어 있다. JIT (Just-In-Time) compiler는 인터프리터의 단점(성능,속도 등)을 보완하기 위해 도입되었다. 실행 엔진이 인터프리터를 이용해 명령어를 하나씩 실행하지만 JIT 컴파일러는 적정한 시간에 전체 바이트 코드를 기계어로 변경한다.\n\n\n#### Native Method Interface(JNI)\nNative Method Interface는 줄여서 JNI라고도 한다. JNI는 JVM에 의해 실행되는 코드 중 네이티브로 실행하는 것이 있다면 해당 네이티브 코드를 호출하거나 호출 될 수 있도록 만든 일종의 프레임워크입니다\n\n#### Native Method Libraries\n네이티브 메소드 실행에 필요한 라이브러리들을 뜻한다.\n\n\n## Garbage Collection\nGC는 Java Application에서 사용하지 않는 메모리를 자동으로 수거하는 기능을 말한다. 예전의 전통적인 언어 C등의 경우 malloc, free등을 이용해서 메모리를 할당하고, 일일이 그 메모리를 수거해 줘야 했다. 그러나 Java 언어에서는 GC 기술을 사용함에 따라서 개발자로 하여금 메모리 관리에서 부터 좀더 자유롭게 해주었다.\n\nGC의 실행순서이다.\n* 참조되지 않은 객체들을 탐색 후 삭제\n* 삭제된 객체의 메모리를 반환\n* Heap 메모리의 재사용\n\n\n## 마무리하며\n자바가 메모리를 효율적으로 관리하기위해 자바 가상머신을 알아야한다. 동일한 기능의 프로그램이더라도 메모리 관리에 따라 성능이 좌우된다고한다. 메모리 관리가 되지 않으면 속도저하현상등이 일어날 수 있다.\n\n\n참고\n* [훈마로의 보물창고](http://hoonmaro.tistory.com/9)\n* [Jbee](http://asfirstalways.tistory.com/158)\n* [Lazysoul](https://medium.com/@lazysoul/jvm-%EC%9D%B4%EB%9E%80-c142b01571f2)\n* [jdm](http://jdm.kr/blog/188)\n* [D2](https://d2.naver.com/helloworld/1230)\n* [이것이 자바다](http://book.naver.com/bookdb/book_detail.nhn?bid=8589375)\n","source":"_posts/2018-06-06-Java,JVM.md","raw":"---\ntitle: Java, JVM 이란\ncatalog: true\ndate: 2018-06-06\nsubtitle:\nheader-img:\ntags:\n- Java\n- JVM\n\n\n---\n\n\n## Java란\n자바는 썬 마이크로 시스템즈에서 개발하여 1996년 1월 공식적으로 발표한 객체지향언어이다.\n\n기본적으로 자바프로그램들은 JVM위에서 동작한다. JVM 위에서 동작하기 위해서는 자바 바이트코드가 필요하다. 이 자바 바이트코드는 개발자에 의해서 작성된 자바 소스코드(.java)를 자바컴파일러(javac)로 변환 된 코드(.class)를 말한다. 아래 간단하게 자바프로그램 특징을 정리해보았다.\n\n### 자바 프로그램 특징\n1. 자바프로그램은 운영체제에 독립적이다.\n2. 객체지향 언어이기 때문에 유지보수가 용이하다.\n3. 자동으로 메모리관리를 해준다.\n4. 동적 로딩을 지원한다.\n5. 오픈소스 자료가 풍부하다.\n6. 자바프로그램은 안정적이다.\n\n## JVM이란\nJVM이란 JAVA Virtual Machine, 자바 가상 머신의 약자를 따서 주려 부르는 용어이다. JVM 역할은 자바 애플리케이션을 클래스 로더를 통해 읽어 들여 자바 API와 함께 실행하는 것이다. 그리고 JVM은 JAVA와 OS사이에서 중개자 역할을 수행하여 운영체제에 독립적인 플랫폼을 갖게 해준다.\n\n또한 JVM은 프로그램의 메모리 관리를 알아서 해준다. C프로그램 같은 경우 에는 직접 메모리할당을 해주고 해지해줘야한다. 하지만 JAVA에서는 JVM이 자동으로 Memory 관리를 해주는 장점이 있다.\n\n### JVM 실행구조\n일반적인 프로그램은 Windows또는 Linux같은 운영체제 위에서 실행된다.\n![](https://i.imgur.com/zV6xu0h.png)\n<center>그림1</center>\n\n하지만 위에서 설명한대로 자바프로그램 같은경우에는 위 오른쪽 그림과 같이 운영체제위에 자바 가상 머신위에서 실행이된다. 이렇게 JVM위에서 굳이 자바 프로그램을 돌리는 이유는 자바 프로그램을 운영체제에 상관없이 실행시키기 위함이다.\n예를들어 윈도우에서 동작하도록 구현된 워드 프로그램은 Linux에서 동작하지 않는다. 이 워드 프로그램을 Mac환경에서 돌리기 위해서는 Mac기반으로 다시 구현해야 한다. 이렇게 운영체제가 다르면 같은 프로그래밍의 언어로 구현한다 할지라도 운영체제에서 일부 다른 기능이 존재하기 때문이다. 예를 들어 그래픽, 키보드 마우스 관련 기능들은 운영체제에 의해서 제공되기 때문에, 운영체제가 달라지면 동일한 프로그래밍 언어일지라도 기능의 완성법이 달라진다. 하지만 자바 프로그램 같은 경우에는 아래의 그림과 같이 운영체제에 맞는 JVM을 다운로드한다면 어떤 환경에 운영체제에서도 자바 프로그램을 실행 실킬 수 있다.\n\n\n### JVM 실행과정\n1. 프로그램이 실행되면 JVM은 OS로부터 이 프로그램이 필요로 하는 메모리를 할당 받는다. JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.\n2. 자바 컴파일러(javac)가 자바소스(.java)코드를 읽어 들여 자바 바이트코드(.class)로 변환시킨다.\n3. 이 변경된 Class 파일들을 Class Loader를 통해 JVM 메모리영역(Runtime Data Areas) 영역으로 로딩한다.\n4. 로딩된 class파일들은 Execution engine을 통해 해석된다.\n5. 해석된 바이트코드는 Runtime Data Areas에 배치되어 실질적인 수행이 이루어지게된다.\n이러한 실행과정속에서 JVM은 필요에 따라 Thread Synchronization과 GC같은 관리 작업을 수행한다.\n\n아래는 JVM 실행과정을 그림으로 표현한것이다.\n\n![](https://i.imgur.com/Vy1JC1b.png)\n<center>그림2</center>\n\n\nJVM 내에 기능들을 좀 더 세부적으로 알아보자.\n#### Java Compiler\n자바 소스(.java)코드를 Byte code(.class)로 변환하는 역할을 한다.\n\n#### Class Loader\nJVM은 컴파일 타임이 아닌 런타임시에 처음으로 클래스를 참조할때 해당 클래스를 로드하고 RuntimeDataArea에 배치한다. 이 동적 로드를 담당하는 부분이 JVM의 Class Loader이다.\n\n#### Runtime Data Areas\n런타임 데이터 영역은 JVM이라는 프로그램이 운영체제 위에서 실행되면서 할당받는 메모리 영역이다. 런타임 데이터 영역은 5개의 영역으로 나눌 수 있다. 이중 PC 레지스터(PC Register), JVM 스택(JVM Stack), 네이티브 메서드 스택(Native Method Stack)은 스레드마다 하나씩 생성되며 힙(Heap), 메서드 영역(Method Area) 은 모든 스레드가 공유해서 사용한다.\n<center>\n\n ![](https://i.imgur.com/zv717Hf.png)\n\n</center>\n<center>그림 3</center>\n\n아래그림은 실제 런타임시에 어떻게 클래스들과 객체 그리고 지역변수들이 할당되는지에 대한 것을 그림으로 표현한것이다.\n\n![](https://i.imgur.com/pAh5gIZ.png)\n<center>그림 4</center>\n\n##### PC Register\n레지스터는 각 스레드마다 하나씩 존재하며 스레드가 시작될 때 생성된다. PC레지스터는 Thread가 어떤 명령어로 실행되어야 할지에 대한 기록을 하는 부분으로 현재 수행중인 JVM명령의 주소를 갖는다.\n\n##### Stack Area\n이곳에는 지역변수, 매개변수, 메소드 정보, 연산중 발생하는 임시 데이터등 저장이 된다.JVM은 오직 JVM 스택에 스택 프레임을 추가하고(push) 제거하는(pop) 동작만 수행한다. 예외 발생 시 printStackTrace() 등의 메서드로 보여주는 Stack Trace의 각 라인은 하나의 스택 프레임을 표현한다.\n\n> Stack에 저장되는 Element의 단위는 frame 이라한다.\n\n##### Native method stack area\n자바 프로그램이 컴파일되어 생성되는 바이트코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역이다. JAVA가 아닌 다른 언어로 작성된 코드를 위한 공간이다.\nJNI(Java Native Interface)를 통해 호출하는 C/C++등의 코드를 수행하기위한 스택 공간이다.\n\n##### Heap Area\nRuntime 에 동적으로 할당되는 데이터가 저장되는 영역입니다. 예를들어 객체생, 배열등이 생성되었을 때 저장되는 공간이다. Heap에 할당된 데이터는 GC의 대상입니다. JVM 성능 등의 이슈에서 가장 많이 언급되는 공간이다.\n\n##### Method Area(Class Area, Code Area, Static Area)\n메서드 영역은 모든 스레드가 공유하는 영역으로 JVM이 시작될 때 생성된다. JVM이 읽어 들인 각각의 클래스와 인터페이스에 대한 런타임 상수 풀, 필드와 메서드 코드, Static 변수, 메서드의 바이트코드 등을 보관한다.\n\n\n\n###### Runtime constant pool\nRuntime constant pool 은 Method area 내부에 존재하는 영역으로, 각 클래스와 인터페이스의 상수뿐만 아니라, 메서드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블이다. 즉, 어떤 메서드나 필드를 참조할 때 JVM은 런타임 상수 풀을 통해 해당 메서드나 필드의 실제 메모리상 주소를 찾아서 참조하여 중복을 막는 역할을 한다.\n\n\n\n#### Execution Engine\nLoad된 Class의 ByteCode를 실행하는 Runtime Module이 바로 Execution Engine이다. Class Loader를 통해 JVM 내의 Runtime Data Areas 에 배치된 바이트 코드는 Execution Engine에 의해 실행되며, 실행 엔진은 자바 바이트 코드를 기계어로 변경한 뒤에 사용하게 된다. 해당 작업을 실행 엔진이 하게 된다.. 그리고 바이트 코드를 기계어로 변경할 때엔 두 종류의 방식을 사용한다. 각각 Interpreter와 JIT (Just-In-Time) compiler이다.\n\nInterpreter는 명령어를 그때그때 해석해서 실행하게 되어 있다. JIT (Just-In-Time) compiler는 인터프리터의 단점(성능,속도 등)을 보완하기 위해 도입되었다. 실행 엔진이 인터프리터를 이용해 명령어를 하나씩 실행하지만 JIT 컴파일러는 적정한 시간에 전체 바이트 코드를 기계어로 변경한다.\n\n\n#### Native Method Interface(JNI)\nNative Method Interface는 줄여서 JNI라고도 한다. JNI는 JVM에 의해 실행되는 코드 중 네이티브로 실행하는 것이 있다면 해당 네이티브 코드를 호출하거나 호출 될 수 있도록 만든 일종의 프레임워크입니다\n\n#### Native Method Libraries\n네이티브 메소드 실행에 필요한 라이브러리들을 뜻한다.\n\n\n## Garbage Collection\nGC는 Java Application에서 사용하지 않는 메모리를 자동으로 수거하는 기능을 말한다. 예전의 전통적인 언어 C등의 경우 malloc, free등을 이용해서 메모리를 할당하고, 일일이 그 메모리를 수거해 줘야 했다. 그러나 Java 언어에서는 GC 기술을 사용함에 따라서 개발자로 하여금 메모리 관리에서 부터 좀더 자유롭게 해주었다.\n\nGC의 실행순서이다.\n* 참조되지 않은 객체들을 탐색 후 삭제\n* 삭제된 객체의 메모리를 반환\n* Heap 메모리의 재사용\n\n\n## 마무리하며\n자바가 메모리를 효율적으로 관리하기위해 자바 가상머신을 알아야한다. 동일한 기능의 프로그램이더라도 메모리 관리에 따라 성능이 좌우된다고한다. 메모리 관리가 되지 않으면 속도저하현상등이 일어날 수 있다.\n\n\n참고\n* [훈마로의 보물창고](http://hoonmaro.tistory.com/9)\n* [Jbee](http://asfirstalways.tistory.com/158)\n* [Lazysoul](https://medium.com/@lazysoul/jvm-%EC%9D%B4%EB%9E%80-c142b01571f2)\n* [jdm](http://jdm.kr/blog/188)\n* [D2](https://d2.naver.com/helloworld/1230)\n* [이것이 자바다](http://book.naver.com/bookdb/book_detail.nhn?bid=8589375)\n","slug":"2018-06-06-Java,JVM","published":1,"updated":"2018-12-25T15:46:33.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27de002ijjpe7oa834w5","content":"<h2><span id=\"java란\">Java란</span></h2>\n<p>자바는 썬 마이크로 시스템즈에서 개발하여 1996년 1월 공식적으로 발표한 객체지향언어이다.</p>\n<p>기본적으로 자바프로그램들은 JVM위에서 동작한다. JVM 위에서 동작하기 위해서는 자바 바이트코드가 필요하다. 이 자바 바이트코드는 개발자에 의해서 작성된 자바 소스코드(.java)를 자바컴파일러(javac)로 변환 된 코드(.class)를 말한다. 아래 간단하게 자바프로그램 특징을 정리해보았다.</p>\n<h3><span id=\"자바-프로그램-특징\">자바 프로그램 특징</span></h3>\n<ol>\n<li>자바프로그램은 운영체제에 독립적이다.</li>\n<li>객체지향 언어이기 때문에 유지보수가 용이하다.</li>\n<li>자동으로 메모리관리를 해준다.</li>\n<li>동적 로딩을 지원한다.</li>\n<li>오픈소스 자료가 풍부하다.</li>\n<li>자바프로그램은 안정적이다.</li>\n</ol>\n<h2><span id=\"jvm이란\">JVM이란</span></h2>\n<p>JVM이란 JAVA Virtual Machine, 자바 가상 머신의 약자를 따서 주려 부르는 용어이다. JVM 역할은 자바 애플리케이션을 클래스 로더를 통해 읽어 들여 자바 API와 함께 실행하는 것이다. 그리고 JVM은 JAVA와 OS사이에서 중개자 역할을 수행하여 운영체제에 독립적인 플랫폼을 갖게 해준다.</p>\n<p>또한 JVM은 프로그램의 메모리 관리를 알아서 해준다. C프로그램 같은 경우 에는 직접 메모리할당을 해주고 해지해줘야한다. 하지만 JAVA에서는 JVM이 자동으로 Memory 관리를 해주는 장점이 있다.</p>\n<h3><span id=\"jvm-실행구조\">JVM 실행구조</span></h3>\n<p>일반적인 프로그램은 Windows또는 Linux같은 운영체제 위에서 실행된다.<br>\n<img src=\"https://i.imgur.com/zV6xu0h.png\" alt=\"\"></p>\n<center>그림1</center>\n<p>하지만 위에서 설명한대로 자바프로그램 같은경우에는 위 오른쪽 그림과 같이 운영체제위에 자바 가상 머신위에서 실행이된다. 이렇게 JVM위에서 굳이 자바 프로그램을 돌리는 이유는 자바 프로그램을 운영체제에 상관없이 실행시키기 위함이다.<br>\n예를들어 윈도우에서 동작하도록 구현된 워드 프로그램은 Linux에서 동작하지 않는다. 이 워드 프로그램을 Mac환경에서 돌리기 위해서는 Mac기반으로 다시 구현해야 한다. 이렇게 운영체제가 다르면 같은 프로그래밍의 언어로 구현한다 할지라도 운영체제에서 일부 다른 기능이 존재하기 때문이다. 예를 들어 그래픽, 키보드 마우스 관련 기능들은 운영체제에 의해서 제공되기 때문에, 운영체제가 달라지면 동일한 프로그래밍 언어일지라도 기능의 완성법이 달라진다. 하지만 자바 프로그램 같은 경우에는 아래의 그림과 같이 운영체제에 맞는 JVM을 다운로드한다면 어떤 환경에 운영체제에서도 자바 프로그램을 실행 실킬 수 있다.</p>\n<h3><span id=\"jvm-실행과정\">JVM 실행과정</span></h3>\n<ol>\n<li>프로그램이 실행되면 JVM은 OS로부터 이 프로그램이 필요로 하는 메모리를 할당 받는다. JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.</li>\n<li>자바 컴파일러(javac)가 자바소스(.java)코드를 읽어 들여 자바 바이트코드(.class)로 변환시킨다.</li>\n<li>이 변경된 Class 파일들을 Class Loader를 통해 JVM 메모리영역(Runtime Data Areas) 영역으로 로딩한다.</li>\n<li>로딩된 class파일들은 Execution engine을 통해 해석된다.</li>\n<li>해석된 바이트코드는 Runtime Data Areas에 배치되어 실질적인 수행이 이루어지게된다.<br>\n이러한 실행과정속에서 JVM은 필요에 따라 Thread Synchronization과 GC같은 관리 작업을 수행한다.</li>\n</ol>\n<p>아래는 JVM 실행과정을 그림으로 표현한것이다.</p>\n<p><img src=\"https://i.imgur.com/Vy1JC1b.png\" alt=\"\"></p>\n<center>그림2</center>\n<p>JVM 내에 기능들을 좀 더 세부적으로 알아보자.</p>\n<h4><span id=\"java-compiler\">Java Compiler</span></h4>\n<p>자바 소스(.java)코드를 Byte code(.class)로 변환하는 역할을 한다.</p>\n<h4><span id=\"class-loader\">Class Loader</span></h4>\n<p>JVM은 컴파일 타임이 아닌 런타임시에 처음으로 클래스를 참조할때 해당 클래스를 로드하고 RuntimeDataArea에 배치한다. 이 동적 로드를 담당하는 부분이 JVM의 Class Loader이다.</p>\n<h4><span id=\"runtime-data-areas\">Runtime Data Areas</span></h4>\n<p>런타임 데이터 영역은 JVM이라는 프로그램이 운영체제 위에서 실행되면서 할당받는 메모리 영역이다. 런타임 데이터 영역은 5개의 영역으로 나눌 수 있다. 이중 PC 레지스터(PC Register), JVM 스택(JVM Stack), 네이티브 메서드 스택(Native Method Stack)은 스레드마다 하나씩 생성되며 힙(Heap), 메서드 영역(Method Area) 은 모든 스레드가 공유해서 사용한다.</p>\n<center>\n<p><img src=\"https://i.imgur.com/zv717Hf.png\" alt=\"\"></p>\n</center>\n<center>그림 3</center>\n<p>아래그림은 실제 런타임시에 어떻게 클래스들과 객체 그리고 지역변수들이 할당되는지에 대한 것을 그림으로 표현한것이다.</p>\n<p><img src=\"https://i.imgur.com/pAh5gIZ.png\" alt=\"\"></p>\n<center>그림 4</center>\n<h5><span id=\"pc-register\">PC Register</span></h5>\n<p>레지스터는 각 스레드마다 하나씩 존재하며 스레드가 시작될 때 생성된다. PC레지스터는 Thread가 어떤 명령어로 실행되어야 할지에 대한 기록을 하는 부분으로 현재 수행중인 JVM명령의 주소를 갖는다.</p>\n<h5><span id=\"stack-area\">Stack Area</span></h5>\n<p>이곳에는 지역변수, 매개변수, 메소드 정보, 연산중 발생하는 임시 데이터등 저장이 된다.JVM은 오직 JVM 스택에 스택 프레임을 추가하고(push) 제거하는(pop) 동작만 수행한다. 예외 발생 시 printStackTrace() 등의 메서드로 보여주는 Stack Trace의 각 라인은 하나의 스택 프레임을 표현한다.</p>\n<blockquote>\n<p>Stack에 저장되는 Element의 단위는 frame 이라한다.</p>\n</blockquote>\n<h5><span id=\"native-method-stack-area\">Native method stack area</span></h5>\n<p>자바 프로그램이 컴파일되어 생성되는 바이트코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역이다. JAVA가 아닌 다른 언어로 작성된 코드를 위한 공간이다.<br>\nJNI(Java Native Interface)를 통해 호출하는 C/C++등의 코드를 수행하기위한 스택 공간이다.</p>\n<h5><span id=\"heap-area\">Heap Area</span></h5>\n<p>Runtime 에 동적으로 할당되는 데이터가 저장되는 영역입니다. 예를들어 객체생, 배열등이 생성되었을 때 저장되는 공간이다. Heap에 할당된 데이터는 GC의 대상입니다. JVM 성능 등의 이슈에서 가장 많이 언급되는 공간이다.</p>\n<h5><span id=\"method-areaclass-area-code-area-static-area\">Method Area(Class Area, Code Area, Static Area)</span></h5>\n<p>메서드 영역은 모든 스레드가 공유하는 영역으로 JVM이 시작될 때 생성된다. JVM이 읽어 들인 각각의 클래스와 인터페이스에 대한 런타임 상수 풀, 필드와 메서드 코드, Static 변수, 메서드의 바이트코드 등을 보관한다.</p>\n<h6><span id=\"runtime-constant-pool\">Runtime constant pool</span></h6>\n<p>Runtime constant pool 은 Method area 내부에 존재하는 영역으로, 각 클래스와 인터페이스의 상수뿐만 아니라, 메서드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블이다. 즉, 어떤 메서드나 필드를 참조할 때 JVM은 런타임 상수 풀을 통해 해당 메서드나 필드의 실제 메모리상 주소를 찾아서 참조하여 중복을 막는 역할을 한다.</p>\n<h4><span id=\"execution-engine\">Execution Engine</span></h4>\n<p>Load된 Class의 ByteCode를 실행하는 Runtime Module이 바로 Execution Engine이다. Class Loader를 통해 JVM 내의 Runtime Data Areas 에 배치된 바이트 코드는 Execution Engine에 의해 실행되며, 실행 엔진은 자바 바이트 코드를 기계어로 변경한 뒤에 사용하게 된다. 해당 작업을 실행 엔진이 하게 된다… 그리고 바이트 코드를 기계어로 변경할 때엔 두 종류의 방식을 사용한다. 각각 Interpreter와 JIT (Just-In-Time) compiler이다.</p>\n<p>Interpreter는 명령어를 그때그때 해석해서 실행하게 되어 있다. JIT (Just-In-Time) compiler는 인터프리터의 단점(성능,속도 등)을 보완하기 위해 도입되었다. 실행 엔진이 인터프리터를 이용해 명령어를 하나씩 실행하지만 JIT 컴파일러는 적정한 시간에 전체 바이트 코드를 기계어로 변경한다.</p>\n<h4><span id=\"native-method-interfacejni\">Native Method Interface(JNI)</span></h4>\n<p>Native Method Interface는 줄여서 JNI라고도 한다. JNI는 JVM에 의해 실행되는 코드 중 네이티브로 실행하는 것이 있다면 해당 네이티브 코드를 호출하거나 호출 될 수 있도록 만든 일종의 프레임워크입니다</p>\n<h4><span id=\"native-method-libraries\">Native Method Libraries</span></h4>\n<p>네이티브 메소드 실행에 필요한 라이브러리들을 뜻한다.</p>\n<h2><span id=\"garbage-collection\">Garbage Collection</span></h2>\n<p>GC는 Java Application에서 사용하지 않는 메모리를 자동으로 수거하는 기능을 말한다. 예전의 전통적인 언어 C등의 경우 malloc, free등을 이용해서 메모리를 할당하고, 일일이 그 메모리를 수거해 줘야 했다. 그러나 Java 언어에서는 GC 기술을 사용함에 따라서 개발자로 하여금 메모리 관리에서 부터 좀더 자유롭게 해주었다.</p>\n<p>GC의 실행순서이다.</p>\n<ul>\n<li>참조되지 않은 객체들을 탐색 후 삭제</li>\n<li>삭제된 객체의 메모리를 반환</li>\n<li>Heap 메모리의 재사용</li>\n</ul>\n<h2><span id=\"마무리하며\">마무리하며</span></h2>\n<p>자바가 메모리를 효율적으로 관리하기위해 자바 가상머신을 알아야한다. 동일한 기능의 프로그램이더라도 메모리 관리에 따라 성능이 좌우된다고한다. 메모리 관리가 되지 않으면 속도저하현상등이 일어날 수 있다.</p>\n<p>참고</p>\n<ul>\n<li><a href=\"http://hoonmaro.tistory.com/9\" target=\"_blank\" rel=\"noopener\">훈마로의 보물창고</a></li>\n<li><a href=\"http://asfirstalways.tistory.com/158\" target=\"_blank\" rel=\"noopener\">Jbee</a></li>\n<li><a href=\"https://medium.com/@lazysoul/jvm-%EC%9D%B4%EB%9E%80-c142b01571f2\" target=\"_blank\" rel=\"noopener\">Lazysoul</a></li>\n<li><a href=\"http://jdm.kr/blog/188\" target=\"_blank\" rel=\"noopener\">jdm</a></li>\n<li><a href=\"https://d2.naver.com/helloworld/1230\" target=\"_blank\" rel=\"noopener\">D2</a></li>\n<li><a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=8589375\" target=\"_blank\" rel=\"noopener\">이것이 자바다</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>Java란</h2>\n<p>자바는 썬 마이크로 시스템즈에서 개발하여 1996년 1월 공식적으로 발표한 객체지향언어이다.</p>\n<p>기본적으로 자바프로그램들은 JVM위에서 동작한다. JVM 위에서 동작하기 위해서는 자바 바이트코드가 필요하다. 이 자바 바이트코드는 개발자에 의해서 작성된 자바 소스코드(.java)를 자바컴파일러(javac)로 변환 된 코드(.class)를 말한다. 아래 간단하게 자바프로그램 특징을 정리해보았다.</p>\n<h3>자바 프로그램 특징</h3>\n<ol>\n<li>자바프로그램은 운영체제에 독립적이다.</li>\n<li>객체지향 언어이기 때문에 유지보수가 용이하다.</li>\n<li>자동으로 메모리관리를 해준다.</li>\n<li>동적 로딩을 지원한다.</li>\n<li>오픈소스 자료가 풍부하다.</li>\n<li>자바프로그램은 안정적이다.</li>\n</ol>\n<h2>JVM이란</h2>\n<p>JVM이란 JAVA Virtual Machine, 자바 가상 머신의 약자를 따서 주려 부르는 용어이다. JVM 역할은 자바 애플리케이션을 클래스 로더를 통해 읽어 들여 자바 API와 함께 실행하는 것이다. 그리고 JVM은 JAVA와 OS사이에서 중개자 역할을 수행하여 운영체제에 독립적인 플랫폼을 갖게 해준다.</p>\n<p>또한 JVM은 프로그램의 메모리 관리를 알아서 해준다. C프로그램 같은 경우 에는 직접 메모리할당을 해주고 해지해줘야한다. 하지만 JAVA에서는 JVM이 자동으로 Memory 관리를 해주는 장점이 있다.</p>\n<h3>JVM 실행구조</h3>\n<p>일반적인 프로그램은 Windows또는 Linux같은 운영체제 위에서 실행된다.<br>\n<img src=\"https://i.imgur.com/zV6xu0h.png\" alt=\"\"></p>\n<center>그림1</center>\n<p>하지만 위에서 설명한대로 자바프로그램 같은경우에는 위 오른쪽 그림과 같이 운영체제위에 자바 가상 머신위에서 실행이된다. 이렇게 JVM위에서 굳이 자바 프로그램을 돌리는 이유는 자바 프로그램을 운영체제에 상관없이 실행시키기 위함이다.<br>\n예를들어 윈도우에서 동작하도록 구현된 워드 프로그램은 Linux에서 동작하지 않는다. 이 워드 프로그램을 Mac환경에서 돌리기 위해서는 Mac기반으로 다시 구현해야 한다. 이렇게 운영체제가 다르면 같은 프로그래밍의 언어로 구현한다 할지라도 운영체제에서 일부 다른 기능이 존재하기 때문이다. 예를 들어 그래픽, 키보드 마우스 관련 기능들은 운영체제에 의해서 제공되기 때문에, 운영체제가 달라지면 동일한 프로그래밍 언어일지라도 기능의 완성법이 달라진다. 하지만 자바 프로그램 같은 경우에는 아래의 그림과 같이 운영체제에 맞는 JVM을 다운로드한다면 어떤 환경에 운영체제에서도 자바 프로그램을 실행 실킬 수 있다.</p>\n<h3>JVM 실행과정</h3>\n<ol>\n<li>프로그램이 실행되면 JVM은 OS로부터 이 프로그램이 필요로 하는 메모리를 할당 받는다. JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.</li>\n<li>자바 컴파일러(javac)가 자바소스(.java)코드를 읽어 들여 자바 바이트코드(.class)로 변환시킨다.</li>\n<li>이 변경된 Class 파일들을 Class Loader를 통해 JVM 메모리영역(Runtime Data Areas) 영역으로 로딩한다.</li>\n<li>로딩된 class파일들은 Execution engine을 통해 해석된다.</li>\n<li>해석된 바이트코드는 Runtime Data Areas에 배치되어 실질적인 수행이 이루어지게된다.<br>\n이러한 실행과정속에서 JVM은 필요에 따라 Thread Synchronization과 GC같은 관리 작업을 수행한다.</li>\n</ol>\n<p>아래는 JVM 실행과정을 그림으로 표현한것이다.</p>\n<p><img src=\"https://i.imgur.com/Vy1JC1b.png\" alt=\"\"></p>\n<center>그림2</center>\n<p>JVM 내에 기능들을 좀 더 세부적으로 알아보자.</p>\n<h4>Java Compiler</h4>\n<p>자바 소스(.java)코드를 Byte code(.class)로 변환하는 역할을 한다.</p>\n<h4>Class Loader</h4>\n<p>JVM은 컴파일 타임이 아닌 런타임시에 처음으로 클래스를 참조할때 해당 클래스를 로드하고 RuntimeDataArea에 배치한다. 이 동적 로드를 담당하는 부분이 JVM의 Class Loader이다.</p>\n<h4>Runtime Data Areas</h4>\n<p>런타임 데이터 영역은 JVM이라는 프로그램이 운영체제 위에서 실행되면서 할당받는 메모리 영역이다. 런타임 데이터 영역은 5개의 영역으로 나눌 수 있다. 이중 PC 레지스터(PC Register), JVM 스택(JVM Stack), 네이티브 메서드 스택(Native Method Stack)은 스레드마다 하나씩 생성되며 힙(Heap), 메서드 영역(Method Area) 은 모든 스레드가 공유해서 사용한다.</p>\n<center>\n<p><img src=\"https://i.imgur.com/zv717Hf.png\" alt=\"\"></p>\n</center>\n<center>그림 3</center>\n<p>아래그림은 실제 런타임시에 어떻게 클래스들과 객체 그리고 지역변수들이 할당되는지에 대한 것을 그림으로 표현한것이다.</p>\n<p><img src=\"https://i.imgur.com/pAh5gIZ.png\" alt=\"\"></p>\n<center>그림 4</center>\n<h5>PC Register</h5>\n<p>레지스터는 각 스레드마다 하나씩 존재하며 스레드가 시작될 때 생성된다. PC레지스터는 Thread가 어떤 명령어로 실행되어야 할지에 대한 기록을 하는 부분으로 현재 수행중인 JVM명령의 주소를 갖는다.</p>\n<h5>Stack Area</h5>\n<p>이곳에는 지역변수, 매개변수, 메소드 정보, 연산중 발생하는 임시 데이터등 저장이 된다.JVM은 오직 JVM 스택에 스택 프레임을 추가하고(push) 제거하는(pop) 동작만 수행한다. 예외 발생 시 printStackTrace() 등의 메서드로 보여주는 Stack Trace의 각 라인은 하나의 스택 프레임을 표현한다.</p>\n<blockquote>\n<p>Stack에 저장되는 Element의 단위는 frame 이라한다.</p>\n</blockquote>\n<h5>Native method stack area</h5>\n<p>자바 프로그램이 컴파일되어 생성되는 바이트코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역이다. JAVA가 아닌 다른 언어로 작성된 코드를 위한 공간이다.<br>\nJNI(Java Native Interface)를 통해 호출하는 C/C++등의 코드를 수행하기위한 스택 공간이다.</p>\n<h5>Heap Area</h5>\n<p>Runtime 에 동적으로 할당되는 데이터가 저장되는 영역입니다. 예를들어 객체생, 배열등이 생성되었을 때 저장되는 공간이다. Heap에 할당된 데이터는 GC의 대상입니다. JVM 성능 등의 이슈에서 가장 많이 언급되는 공간이다.</p>\n<h5>Method Area(Class Area, Code Area, Static Area)</h5>\n<p>메서드 영역은 모든 스레드가 공유하는 영역으로 JVM이 시작될 때 생성된다. JVM이 읽어 들인 각각의 클래스와 인터페이스에 대한 런타임 상수 풀, 필드와 메서드 코드, Static 변수, 메서드의 바이트코드 등을 보관한다.</p>\n<h6>Runtime constant pool</h6>\n<p>Runtime constant pool 은 Method area 내부에 존재하는 영역으로, 각 클래스와 인터페이스의 상수뿐만 아니라, 메서드와 필드에 대한 모든 레퍼런스까지 담고 있는 테이블이다. 즉, 어떤 메서드나 필드를 참조할 때 JVM은 런타임 상수 풀을 통해 해당 메서드나 필드의 실제 메모리상 주소를 찾아서 참조하여 중복을 막는 역할을 한다.</p>\n<h4>Execution Engine</h4>\n<p>Load된 Class의 ByteCode를 실행하는 Runtime Module이 바로 Execution Engine이다. Class Loader를 통해 JVM 내의 Runtime Data Areas 에 배치된 바이트 코드는 Execution Engine에 의해 실행되며, 실행 엔진은 자바 바이트 코드를 기계어로 변경한 뒤에 사용하게 된다. 해당 작업을 실행 엔진이 하게 된다… 그리고 바이트 코드를 기계어로 변경할 때엔 두 종류의 방식을 사용한다. 각각 Interpreter와 JIT (Just-In-Time) compiler이다.</p>\n<p>Interpreter는 명령어를 그때그때 해석해서 실행하게 되어 있다. JIT (Just-In-Time) compiler는 인터프리터의 단점(성능,속도 등)을 보완하기 위해 도입되었다. 실행 엔진이 인터프리터를 이용해 명령어를 하나씩 실행하지만 JIT 컴파일러는 적정한 시간에 전체 바이트 코드를 기계어로 변경한다.</p>\n<h4>Native Method Interface(JNI)</h4>\n<p>Native Method Interface는 줄여서 JNI라고도 한다. JNI는 JVM에 의해 실행되는 코드 중 네이티브로 실행하는 것이 있다면 해당 네이티브 코드를 호출하거나 호출 될 수 있도록 만든 일종의 프레임워크입니다</p>\n<h4>Native Method Libraries</h4>\n<p>네이티브 메소드 실행에 필요한 라이브러리들을 뜻한다.</p>\n<h2>Garbage Collection</h2>\n<p>GC는 Java Application에서 사용하지 않는 메모리를 자동으로 수거하는 기능을 말한다. 예전의 전통적인 언어 C등의 경우 malloc, free등을 이용해서 메모리를 할당하고, 일일이 그 메모리를 수거해 줘야 했다. 그러나 Java 언어에서는 GC 기술을 사용함에 따라서 개발자로 하여금 메모리 관리에서 부터 좀더 자유롭게 해주었다.</p>\n<p>GC의 실행순서이다.</p>\n<ul>\n<li>참조되지 않은 객체들을 탐색 후 삭제</li>\n<li>삭제된 객체의 메모리를 반환</li>\n<li>Heap 메모리의 재사용</li>\n</ul>\n<h2>마무리하며</h2>\n<p>자바가 메모리를 효율적으로 관리하기위해 자바 가상머신을 알아야한다. 동일한 기능의 프로그램이더라도 메모리 관리에 따라 성능이 좌우된다고한다. 메모리 관리가 되지 않으면 속도저하현상등이 일어날 수 있다.</p>\n<p>참고</p>\n<ul>\n<li><a href=\"http://hoonmaro.tistory.com/9\" target=\"_blank\" rel=\"noopener\">훈마로의 보물창고</a></li>\n<li><a href=\"http://asfirstalways.tistory.com/158\" target=\"_blank\" rel=\"noopener\">Jbee</a></li>\n<li><a href=\"https://medium.com/@lazysoul/jvm-%EC%9D%B4%EB%9E%80-c142b01571f2\" target=\"_blank\" rel=\"noopener\">Lazysoul</a></li>\n<li><a href=\"http://jdm.kr/blog/188\" target=\"_blank\" rel=\"noopener\">jdm</a></li>\n<li><a href=\"https://d2.naver.com/helloworld/1230\" target=\"_blank\" rel=\"noopener\">D2</a></li>\n<li><a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=8589375\" target=\"_blank\" rel=\"noopener\">이것이 자바다</a></li>\n</ul>\n"},{"title":"OS-1:운영체제란?","catalog":true,"date":"2018-06-18T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n## 1.운영체제란?\n컴퓨터 하드웨어 바로 위에 설치되어 사용 및 다른 모든 소프트웨어를 연결하는 소프트웨어 계층으로\n써 컴퓨터 메모리를 효율적으로 관리하는 역할을 한다.\n\n![](https://i.imgur.com/f72IER2.png)\n\n**커널이란**\n컴퓨터와 전원을 켜면 운영체제는 이와 동시에 수행된다. 한편 소프트웨어가 컴퓨터 시스템에서 수행되기 위해서는 메모리에 그 프로그램이 올라가 있어야한다. 마찬가지로 운영 체제 자체도 소프트웨어로서 전원이 켜짐과 동시에 메모리에 올라가야한다. 하지만, 운영체제처럼 규모가 큰 프로그램이 모두 메모리에 올라간다면 한정된 메모리 공간의 낭비가 심할것이다. 따라서 운영체제 중 항상 필요한 부분만을 전원이 켜짐과 동시에 메모리에 올려놓고 그렇지 않은 부분은 필요할 때 메모리에 올려서 사용하게 된다. 이 때 메모리에 상주하는 운영체제의 부분을 커널이라 한다. 또 이것을 좁은 의미의 운영체제라고도 한다. 즉 커널은 메모리에 상주하는 부분으로써 운영체제의 핵심적인 부분을 뜻한다.\n이에 반에 넓은 의미의 운영체제는 커널뿐 아니라 각종 시스템을 위한 유틸리티들을 광범위하게 포함하는 개념이다.(보통은 운영체제라고 하면 커널을 말하게 된다.)\n\n\n### 1.1 운영체제의 목적\n* CPU, 기억장치, 입출력장등의 컴퓨터 시스템 자원 등을 효율적으로 관리하는것\n\n### 1.2 운영 체제 목표\n* 컴퓨터 시스템을 편리하게 사용할 수 있도록  운영체제는 동시 사용자/ 프로그램들이 각각 독자적으로 컴퓨터에서 수행되는것같은 황상을 제공\n* 하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행\n* 프로세서(CPU), 기억장치, 입출력 장치등을 효율적으로 관리\n![](https://i.imgur.com/OUOWqtq.png)\n\n### 1.3 운영체제의 분류\n운영체의 분류는 크게 동시 자원을 지원하는지 여부 즉 여러 프로그램을 한번에 돌리수 있냐의 분류방식과, 작업을 처리하는 방식 여부에따른 분류등으로 나눌 수 있다.\n\n#### 동시 자원을 지원하는지 여부에 따른 분류\n동시에 작업을 지원하는지의 여부에 따라 운영체제를 단일 작업용 운영체제와 다중 작업용 운영체로 나누어 볼 수 있다.\n##### 단일작업\n* 한번에 하나의 작업만 처리\n* DOS같은 환경\n##### 다중작업 운영체제\n* 동시에 두개이상의 작업처리\n아래는 다중 작업 운영체제의 프로그램들이 시스템들이다.\n\n**시분할 시스템이란[CPU가 한개있는 컴퓨터의 성질]**\n컴퓨터 처리 능력을 짧은 시간단위로 구분하고 이를 여러 사용자에게 조금씩 분할해 서비스하는 방식을 말한다. 예를 들어 시분할 방식을 사용하는 메인 프레임 컴퓨터에서는 전국에 있는 여러 은행 지점의 많은 터미너들을 동시에 서비스하는것이 가능하다. 여기에서 '동시'라는 표현을 썻지만 정확하게는 메인 프레임 컴퓨터가 매 시점 하나의 터미널만을 서비스하므로 동시란 말이 정확한것은 아니다. 단지 메인 프레임 컴퓨터가 여러 터미널을 아주 짧은 시간 간격으로 나누어 서비스하기 때문에 각 터미널 입장에서는 동시에 서비스를 받게 되는 느낌이다.\n\n**다중 프로그래밍 시스템[CPU가 한개있는 컴퓨터의 성질]**\nCPU와 달리 메모리의 경우 여러 프로그램들이 조금씩 메모리 공간을 보유하며 동시에 메모리에 올라갈 수 있다. 이처럼 메모리 공간을 분할해 여러 프로그램들을 동시에 메모리에 올려놓고 처리하는 시스템을 다중 프로그램 시스템이라 한다.\n\n**다중처리기 시스템(multi-processor system)[CPU가 한개이상있는 컴퓨터의 성질]**\n하나의 컴퓨터안에 CPU가 여러개 설치된 경우를 뜻하므로 위의 용어들과는 의미가 다르다. CPU가 여럿 있는 컴퓨터는 서로 다른 CPU안에서 여러 프로그램이 동시에 수행될 수 있어 처리가 더욱 빨라지지만, 운영체제 입장에서는 여러 CPU를 관리하기 위해 더욱 복잡한 매커니즘을 사용해야한다.\n\n#### 작업을 처리하는 방식 여부에 따른 분류\n\n**일괄 처리(batch processing)**\n작업 요청의 일정량을 모아서 한꺼번에 처리 하는 방식이다.\n**시분할(time sharing)**\n여러 작업을 수행할 때 컴퓨터의 처리 능력을 일정한 시간 단위로 빠르게 나눠서 처리하는 방식\n\n**실시간(real time)**\n실시간 운영체제는 정해진 시간안에 일이 반드시 종료됨이 보장되어야하는 시스템에서 사용된다.\n\n### 1.4 운영체제 자원관리 기능\n운영 체제의 핵심은 자원을 어떻게 효율적으로 관리할것인가이다. 자원은 하드웨어 자원과 소프트웨어 자원으로 나뉜다. CPU는 통상적으로 컴퓨터 한대에 하나가 장착되기 때문에 여러 프로세스들이 CPU를 효율적으로 나누어 사용할 수 있도록 관리해야한다. CPU와 메모리는 전원이 꺼지면 처리중이던 정보가 모두 사라지기 때문에 전원이 나가도 기억해야하는 부분은 보조기억장치에 파일형태로 저장된다. 이러한 파일들이 저장되는 방식 및 접근 권한등에 대해서도 운영체제가 관리를 해주어야한다.\n\n![](https://i.imgur.com/CeItZzu.png)\n\n먼저 CPU 관리방법부터 알아보자.\n\n#### CPU 스케줄링\n여러개의 프로세스가 실행될 때 어떠한 프로세스에게 CPU 를 처리할지 결정이 필요하다. 이러한 결정을 처리하는것이 CPU 스케줄링이라한다.\n##### 선입선출(First Come First Served)\n먼저 CPU를 사용하기 위해 도착한 프로세스를 먼저 처리해주는 방식을 말한다. 이는 일상생활에서 줄서기하는것과 같다. 이방법을 사용하면 먼저 CPU를 요청한 프로세스가 작업이 끝날 때 까지 다른 프로세스들은 작업을 할 수 없다. 이방법은 CPU는 효율적으로 계속 작업은 할 수 있으나 전체적인 프로세스를 처리하는 면에서는 비효율적인 방법이다.\n##### 라운드 로빈(Round Robin)\n선입선출의 방법을 보안하고자 나온 방법이 라운드 로빈 스케줄링이다. 이 기법에서는 CPU를 한 번 할당받아 사용할 수 있는 시간을 일정한 고정된 시간으로 제한한다. 긴작업이 필요한 프로세스가 CPU를 할당받더라도 정해진 시간이 지나면 CPU를 내어놓고 CPU의 서비스를 기다리는 줄의 제일 뒤에서 기다려야한다. 이렇게되면 뒤의 프로세스들이 무작정 오래 기다려야하는 상황은 막을 수 있다.\n##### 우선순위(Priority)\n이기법은 수행 대기중인 프로세스들에게 프로그램에 따라 우선순위를 부여하고 우선순위가 높은 프로세스에게 CPU를 먼저 할당하게 된다. 또한 지나치게 오래 기다리는 프로세스가 발생하지 않도록, 기다린 시간이 늘어날수록 우선순위를 점차 높여주는 방안도 사용되어질 수 있다.\n\n#### 메모리 관리\n물리적 메모리를 관리하는 방식에는 고정분할방식, 가변분할방식, 가상메모리 방식이 있다.\n\n##### 고정 분할(fixed partion)\n물리적 메모리를 몇개의 영구적인 분할로 나눈다. 나뉜 각각의 분할에는 하나의 프로그램이 적재된다. 이방식은 단순해서 분할의 크키보다 큰프로그램은 적재가 불가능하다. 이렇기때문에 메모리의 효율적인 사용측면에서도 바람직하지 않다.\n##### 가변 분할(variable partion)\n매 시점 프로그램의 크기에 맞게 메모리를 분할해서 사용하는 방식이다. 따라서 분할의 큰 프로그램의 실행이제한되는 문제는 발생하지 않는다. 그러나 물리적 메모리크기보다 더 큰 프로그램의 실행은 여전히 불가능하다.\n##### 가상 메모리(virtual memory)\n최근에 거의 모든 컴퓨터 시스템에서 사용하는 메모리 관리 기법이다. 가상 메모리 기법에서는 물리적 메모리보다 더 큰프로그램이 실행되는것을 지원한다. 이때 실행될 수 있는 프로그램의 크기는 가상 메모리 크기에 의해 결정된다. 운영체제는 물리적인 주소와 가상 메모리에 주소를 매핑하여 관리한다. 실제 이렇게 가상 메모리를 할당할 수 있게하는것은 실행되지 않는 부분의 프로그램은 보조디스크에 두었다가 필요할때 메모리에 적재하는 방식이다. 이때 그리고 보조 기억장치에서 사용되느부분을 스왑 영역이라한다.\n\n#### 주변 장치 및 입출력 장치\nCPU나 메모리와 달리 인터럽트라는 메커니즘을 통해 관리한다. 주변 장치들은 CPU의 서비스가 필요한 경우에 신호를 발생시켜 서비스를 요청하게되는데 이 때 발생시키는 신호를 인터럽트라고 한다. CPU는 평소에 CPU 스케줄링에 따라 자신에게 주어진 작업을 수행하고 있다가 인터럽트가 발생하면 하던일을 잠시 멈추고 인터럽트에 의한 요청 서비스를 수행하게 된다.\n주변 장치들은 각 장치마다 그 장치에서 일어나는 업무에대한 관리를 위한 일종의 작은 CPU를 가진다. 이를 컨트롤러라고하는데 이컨트롤러를 바탕으로 무언가 입력이되면 CPU 에게 인터럽트를 발생시켜 보고하는 역할을 한다. 그러면 CPU는 하던일을 잠시 멈추고 인터럽트에 대한 처리를 하기 위해 운영체제로 할당이 넘어간다.\n\n참조\n* [운영체제와 정보기술의 원리](http://www.yes24.com/24/goods/2824944)\n","source":"_posts/2018-06-19-운영체제란[OS-1].md","raw":"---\ntitle: OS-1:운영체제란?\ncatalog: true\ndate: 2018-06-19\nsubtitle:\nheader-img:\ntags:\n- ETC\n- O/S\n\n\n\n---\n\n## 1.운영체제란?\n컴퓨터 하드웨어 바로 위에 설치되어 사용 및 다른 모든 소프트웨어를 연결하는 소프트웨어 계층으로\n써 컴퓨터 메모리를 효율적으로 관리하는 역할을 한다.\n\n![](https://i.imgur.com/f72IER2.png)\n\n**커널이란**\n컴퓨터와 전원을 켜면 운영체제는 이와 동시에 수행된다. 한편 소프트웨어가 컴퓨터 시스템에서 수행되기 위해서는 메모리에 그 프로그램이 올라가 있어야한다. 마찬가지로 운영 체제 자체도 소프트웨어로서 전원이 켜짐과 동시에 메모리에 올라가야한다. 하지만, 운영체제처럼 규모가 큰 프로그램이 모두 메모리에 올라간다면 한정된 메모리 공간의 낭비가 심할것이다. 따라서 운영체제 중 항상 필요한 부분만을 전원이 켜짐과 동시에 메모리에 올려놓고 그렇지 않은 부분은 필요할 때 메모리에 올려서 사용하게 된다. 이 때 메모리에 상주하는 운영체제의 부분을 커널이라 한다. 또 이것을 좁은 의미의 운영체제라고도 한다. 즉 커널은 메모리에 상주하는 부분으로써 운영체제의 핵심적인 부분을 뜻한다.\n이에 반에 넓은 의미의 운영체제는 커널뿐 아니라 각종 시스템을 위한 유틸리티들을 광범위하게 포함하는 개념이다.(보통은 운영체제라고 하면 커널을 말하게 된다.)\n\n\n### 1.1 운영체제의 목적\n* CPU, 기억장치, 입출력장등의 컴퓨터 시스템 자원 등을 효율적으로 관리하는것\n\n### 1.2 운영 체제 목표\n* 컴퓨터 시스템을 편리하게 사용할 수 있도록  운영체제는 동시 사용자/ 프로그램들이 각각 독자적으로 컴퓨터에서 수행되는것같은 황상을 제공\n* 하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행\n* 프로세서(CPU), 기억장치, 입출력 장치등을 효율적으로 관리\n![](https://i.imgur.com/OUOWqtq.png)\n\n### 1.3 운영체제의 분류\n운영체의 분류는 크게 동시 자원을 지원하는지 여부 즉 여러 프로그램을 한번에 돌리수 있냐의 분류방식과, 작업을 처리하는 방식 여부에따른 분류등으로 나눌 수 있다.\n\n#### 동시 자원을 지원하는지 여부에 따른 분류\n동시에 작업을 지원하는지의 여부에 따라 운영체제를 단일 작업용 운영체제와 다중 작업용 운영체로 나누어 볼 수 있다.\n##### 단일작업\n* 한번에 하나의 작업만 처리\n* DOS같은 환경\n##### 다중작업 운영체제\n* 동시에 두개이상의 작업처리\n아래는 다중 작업 운영체제의 프로그램들이 시스템들이다.\n\n**시분할 시스템이란[CPU가 한개있는 컴퓨터의 성질]**\n컴퓨터 처리 능력을 짧은 시간단위로 구분하고 이를 여러 사용자에게 조금씩 분할해 서비스하는 방식을 말한다. 예를 들어 시분할 방식을 사용하는 메인 프레임 컴퓨터에서는 전국에 있는 여러 은행 지점의 많은 터미너들을 동시에 서비스하는것이 가능하다. 여기에서 '동시'라는 표현을 썻지만 정확하게는 메인 프레임 컴퓨터가 매 시점 하나의 터미널만을 서비스하므로 동시란 말이 정확한것은 아니다. 단지 메인 프레임 컴퓨터가 여러 터미널을 아주 짧은 시간 간격으로 나누어 서비스하기 때문에 각 터미널 입장에서는 동시에 서비스를 받게 되는 느낌이다.\n\n**다중 프로그래밍 시스템[CPU가 한개있는 컴퓨터의 성질]**\nCPU와 달리 메모리의 경우 여러 프로그램들이 조금씩 메모리 공간을 보유하며 동시에 메모리에 올라갈 수 있다. 이처럼 메모리 공간을 분할해 여러 프로그램들을 동시에 메모리에 올려놓고 처리하는 시스템을 다중 프로그램 시스템이라 한다.\n\n**다중처리기 시스템(multi-processor system)[CPU가 한개이상있는 컴퓨터의 성질]**\n하나의 컴퓨터안에 CPU가 여러개 설치된 경우를 뜻하므로 위의 용어들과는 의미가 다르다. CPU가 여럿 있는 컴퓨터는 서로 다른 CPU안에서 여러 프로그램이 동시에 수행될 수 있어 처리가 더욱 빨라지지만, 운영체제 입장에서는 여러 CPU를 관리하기 위해 더욱 복잡한 매커니즘을 사용해야한다.\n\n#### 작업을 처리하는 방식 여부에 따른 분류\n\n**일괄 처리(batch processing)**\n작업 요청의 일정량을 모아서 한꺼번에 처리 하는 방식이다.\n**시분할(time sharing)**\n여러 작업을 수행할 때 컴퓨터의 처리 능력을 일정한 시간 단위로 빠르게 나눠서 처리하는 방식\n\n**실시간(real time)**\n실시간 운영체제는 정해진 시간안에 일이 반드시 종료됨이 보장되어야하는 시스템에서 사용된다.\n\n### 1.4 운영체제 자원관리 기능\n운영 체제의 핵심은 자원을 어떻게 효율적으로 관리할것인가이다. 자원은 하드웨어 자원과 소프트웨어 자원으로 나뉜다. CPU는 통상적으로 컴퓨터 한대에 하나가 장착되기 때문에 여러 프로세스들이 CPU를 효율적으로 나누어 사용할 수 있도록 관리해야한다. CPU와 메모리는 전원이 꺼지면 처리중이던 정보가 모두 사라지기 때문에 전원이 나가도 기억해야하는 부분은 보조기억장치에 파일형태로 저장된다. 이러한 파일들이 저장되는 방식 및 접근 권한등에 대해서도 운영체제가 관리를 해주어야한다.\n\n![](https://i.imgur.com/CeItZzu.png)\n\n먼저 CPU 관리방법부터 알아보자.\n\n#### CPU 스케줄링\n여러개의 프로세스가 실행될 때 어떠한 프로세스에게 CPU 를 처리할지 결정이 필요하다. 이러한 결정을 처리하는것이 CPU 스케줄링이라한다.\n##### 선입선출(First Come First Served)\n먼저 CPU를 사용하기 위해 도착한 프로세스를 먼저 처리해주는 방식을 말한다. 이는 일상생활에서 줄서기하는것과 같다. 이방법을 사용하면 먼저 CPU를 요청한 프로세스가 작업이 끝날 때 까지 다른 프로세스들은 작업을 할 수 없다. 이방법은 CPU는 효율적으로 계속 작업은 할 수 있으나 전체적인 프로세스를 처리하는 면에서는 비효율적인 방법이다.\n##### 라운드 로빈(Round Robin)\n선입선출의 방법을 보안하고자 나온 방법이 라운드 로빈 스케줄링이다. 이 기법에서는 CPU를 한 번 할당받아 사용할 수 있는 시간을 일정한 고정된 시간으로 제한한다. 긴작업이 필요한 프로세스가 CPU를 할당받더라도 정해진 시간이 지나면 CPU를 내어놓고 CPU의 서비스를 기다리는 줄의 제일 뒤에서 기다려야한다. 이렇게되면 뒤의 프로세스들이 무작정 오래 기다려야하는 상황은 막을 수 있다.\n##### 우선순위(Priority)\n이기법은 수행 대기중인 프로세스들에게 프로그램에 따라 우선순위를 부여하고 우선순위가 높은 프로세스에게 CPU를 먼저 할당하게 된다. 또한 지나치게 오래 기다리는 프로세스가 발생하지 않도록, 기다린 시간이 늘어날수록 우선순위를 점차 높여주는 방안도 사용되어질 수 있다.\n\n#### 메모리 관리\n물리적 메모리를 관리하는 방식에는 고정분할방식, 가변분할방식, 가상메모리 방식이 있다.\n\n##### 고정 분할(fixed partion)\n물리적 메모리를 몇개의 영구적인 분할로 나눈다. 나뉜 각각의 분할에는 하나의 프로그램이 적재된다. 이방식은 단순해서 분할의 크키보다 큰프로그램은 적재가 불가능하다. 이렇기때문에 메모리의 효율적인 사용측면에서도 바람직하지 않다.\n##### 가변 분할(variable partion)\n매 시점 프로그램의 크기에 맞게 메모리를 분할해서 사용하는 방식이다. 따라서 분할의 큰 프로그램의 실행이제한되는 문제는 발생하지 않는다. 그러나 물리적 메모리크기보다 더 큰 프로그램의 실행은 여전히 불가능하다.\n##### 가상 메모리(virtual memory)\n최근에 거의 모든 컴퓨터 시스템에서 사용하는 메모리 관리 기법이다. 가상 메모리 기법에서는 물리적 메모리보다 더 큰프로그램이 실행되는것을 지원한다. 이때 실행될 수 있는 프로그램의 크기는 가상 메모리 크기에 의해 결정된다. 운영체제는 물리적인 주소와 가상 메모리에 주소를 매핑하여 관리한다. 실제 이렇게 가상 메모리를 할당할 수 있게하는것은 실행되지 않는 부분의 프로그램은 보조디스크에 두었다가 필요할때 메모리에 적재하는 방식이다. 이때 그리고 보조 기억장치에서 사용되느부분을 스왑 영역이라한다.\n\n#### 주변 장치 및 입출력 장치\nCPU나 메모리와 달리 인터럽트라는 메커니즘을 통해 관리한다. 주변 장치들은 CPU의 서비스가 필요한 경우에 신호를 발생시켜 서비스를 요청하게되는데 이 때 발생시키는 신호를 인터럽트라고 한다. CPU는 평소에 CPU 스케줄링에 따라 자신에게 주어진 작업을 수행하고 있다가 인터럽트가 발생하면 하던일을 잠시 멈추고 인터럽트에 의한 요청 서비스를 수행하게 된다.\n주변 장치들은 각 장치마다 그 장치에서 일어나는 업무에대한 관리를 위한 일종의 작은 CPU를 가진다. 이를 컨트롤러라고하는데 이컨트롤러를 바탕으로 무언가 입력이되면 CPU 에게 인터럽트를 발생시켜 보고하는 역할을 한다. 그러면 CPU는 하던일을 잠시 멈추고 인터럽트에 대한 처리를 하기 위해 운영체제로 할당이 넘어간다.\n\n참조\n* [운영체제와 정보기술의 원리](http://www.yes24.com/24/goods/2824944)\n","slug":"2018-06-19-운영체제란[OS-1]","published":1,"updated":"2018-06-20T16:05:18.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27dg002kjjpeziap35p6","content":"<h2><span id=\"1운영체제란\">1.운영체제란?</span></h2>\n<p>컴퓨터 하드웨어 바로 위에 설치되어 사용 및 다른 모든 소프트웨어를 연결하는 소프트웨어 계층으로<br>\n써 컴퓨터 메모리를 효율적으로 관리하는 역할을 한다.</p>\n<p><img src=\"https://i.imgur.com/f72IER2.png\" alt=\"\"></p>\n<p><strong>커널이란</strong><br>\n컴퓨터와 전원을 켜면 운영체제는 이와 동시에 수행된다. 한편 소프트웨어가 컴퓨터 시스템에서 수행되기 위해서는 메모리에 그 프로그램이 올라가 있어야한다. 마찬가지로 운영 체제 자체도 소프트웨어로서 전원이 켜짐과 동시에 메모리에 올라가야한다. 하지만, 운영체제처럼 규모가 큰 프로그램이 모두 메모리에 올라간다면 한정된 메모리 공간의 낭비가 심할것이다. 따라서 운영체제 중 항상 필요한 부분만을 전원이 켜짐과 동시에 메모리에 올려놓고 그렇지 않은 부분은 필요할 때 메모리에 올려서 사용하게 된다. 이 때 메모리에 상주하는 운영체제의 부분을 커널이라 한다. 또 이것을 좁은 의미의 운영체제라고도 한다. 즉 커널은 메모리에 상주하는 부분으로써 운영체제의 핵심적인 부분을 뜻한다.<br>\n이에 반에 넓은 의미의 운영체제는 커널뿐 아니라 각종 시스템을 위한 유틸리티들을 광범위하게 포함하는 개념이다.(보통은 운영체제라고 하면 커널을 말하게 된다.)</p>\n<h3><span id=\"11-운영체제의-목적\">1.1 운영체제의 목적</span></h3>\n<ul>\n<li>CPU, 기억장치, 입출력장등의 컴퓨터 시스템 자원 등을 효율적으로 관리하는것</li>\n</ul>\n<h3><span id=\"12-운영-체제-목표\">1.2 운영 체제 목표</span></h3>\n<ul>\n<li>컴퓨터 시스템을 편리하게 사용할 수 있도록  운영체제는 동시 사용자/ 프로그램들이 각각 독자적으로 컴퓨터에서 수행되는것같은 황상을 제공</li>\n<li>하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행</li>\n<li>프로세서(CPU), 기억장치, 입출력 장치등을 효율적으로 관리<br>\n<img src=\"https://i.imgur.com/OUOWqtq.png\" alt=\"\"></li>\n</ul>\n<h3><span id=\"13-운영체제의-분류\">1.3 운영체제의 분류</span></h3>\n<p>운영체의 분류는 크게 동시 자원을 지원하는지 여부 즉 여러 프로그램을 한번에 돌리수 있냐의 분류방식과, 작업을 처리하는 방식 여부에따른 분류등으로 나눌 수 있다.</p>\n<h4><span id=\"동시-자원을-지원하는지-여부에-따른-분류\">동시 자원을 지원하는지 여부에 따른 분류</span></h4>\n<p>동시에 작업을 지원하는지의 여부에 따라 운영체제를 단일 작업용 운영체제와 다중 작업용 운영체로 나누어 볼 수 있다.</p>\n<h5><span id=\"단일작업\">단일작업</span></h5>\n<ul>\n<li>한번에 하나의 작업만 처리</li>\n<li>DOS같은 환경</li>\n</ul>\n<h5><span id=\"다중작업-운영체제\">다중작업 운영체제</span></h5>\n<ul>\n<li>동시에 두개이상의 작업처리<br>\n아래는 다중 작업 운영체제의 프로그램들이 시스템들이다.</li>\n</ul>\n<p><strong>시분할 시스템이란[CPU가 한개있는 컴퓨터의 성질]</strong><br>\n컴퓨터 처리 능력을 짧은 시간단위로 구분하고 이를 여러 사용자에게 조금씩 분할해 서비스하는 방식을 말한다. 예를 들어 시분할 방식을 사용하는 메인 프레임 컴퓨터에서는 전국에 있는 여러 은행 지점의 많은 터미너들을 동시에 서비스하는것이 가능하다. 여기에서 '동시’라는 표현을 썻지만 정확하게는 메인 프레임 컴퓨터가 매 시점 하나의 터미널만을 서비스하므로 동시란 말이 정확한것은 아니다. 단지 메인 프레임 컴퓨터가 여러 터미널을 아주 짧은 시간 간격으로 나누어 서비스하기 때문에 각 터미널 입장에서는 동시에 서비스를 받게 되는 느낌이다.</p>\n<p><strong>다중 프로그래밍 시스템[CPU가 한개있는 컴퓨터의 성질]</strong><br>\nCPU와 달리 메모리의 경우 여러 프로그램들이 조금씩 메모리 공간을 보유하며 동시에 메모리에 올라갈 수 있다. 이처럼 메모리 공간을 분할해 여러 프로그램들을 동시에 메모리에 올려놓고 처리하는 시스템을 다중 프로그램 시스템이라 한다.</p>\n<p><strong>다중처리기 시스템(multi-processor system)[CPU가 한개이상있는 컴퓨터의 성질]</strong><br>\n하나의 컴퓨터안에 CPU가 여러개 설치된 경우를 뜻하므로 위의 용어들과는 의미가 다르다. CPU가 여럿 있는 컴퓨터는 서로 다른 CPU안에서 여러 프로그램이 동시에 수행될 수 있어 처리가 더욱 빨라지지만, 운영체제 입장에서는 여러 CPU를 관리하기 위해 더욱 복잡한 매커니즘을 사용해야한다.</p>\n<h4><span id=\"작업을-처리하는-방식-여부에-따른-분류\">작업을 처리하는 방식 여부에 따른 분류</span></h4>\n<p><strong>일괄 처리(batch processing)</strong><br>\n작업 요청의 일정량을 모아서 한꺼번에 처리 하는 방식이다.<br>\n<strong>시분할(time sharing)</strong><br>\n여러 작업을 수행할 때 컴퓨터의 처리 능력을 일정한 시간 단위로 빠르게 나눠서 처리하는 방식</p>\n<p><strong>실시간(real time)</strong><br>\n실시간 운영체제는 정해진 시간안에 일이 반드시 종료됨이 보장되어야하는 시스템에서 사용된다.</p>\n<h3><span id=\"14-운영체제-자원관리-기능\">1.4 운영체제 자원관리 기능</span></h3>\n<p>운영 체제의 핵심은 자원을 어떻게 효율적으로 관리할것인가이다. 자원은 하드웨어 자원과 소프트웨어 자원으로 나뉜다. CPU는 통상적으로 컴퓨터 한대에 하나가 장착되기 때문에 여러 프로세스들이 CPU를 효율적으로 나누어 사용할 수 있도록 관리해야한다. CPU와 메모리는 전원이 꺼지면 처리중이던 정보가 모두 사라지기 때문에 전원이 나가도 기억해야하는 부분은 보조기억장치에 파일형태로 저장된다. 이러한 파일들이 저장되는 방식 및 접근 권한등에 대해서도 운영체제가 관리를 해주어야한다.</p>\n<p><img src=\"https://i.imgur.com/CeItZzu.png\" alt=\"\"></p>\n<p>먼저 CPU 관리방법부터 알아보자.</p>\n<h4><span id=\"cpu-스케줄링\">CPU 스케줄링</span></h4>\n<p>여러개의 프로세스가 실행될 때 어떠한 프로세스에게 CPU 를 처리할지 결정이 필요하다. 이러한 결정을 처리하는것이 CPU 스케줄링이라한다.</p>\n<h5><span id=\"선입선출first-come-first-served\">선입선출(First Come First Served)</span></h5>\n<p>먼저 CPU를 사용하기 위해 도착한 프로세스를 먼저 처리해주는 방식을 말한다. 이는 일상생활에서 줄서기하는것과 같다. 이방법을 사용하면 먼저 CPU를 요청한 프로세스가 작업이 끝날 때 까지 다른 프로세스들은 작업을 할 수 없다. 이방법은 CPU는 효율적으로 계속 작업은 할 수 있으나 전체적인 프로세스를 처리하는 면에서는 비효율적인 방법이다.</p>\n<h5><span id=\"라운드-로빈round-robin\">라운드 로빈(Round Robin)</span></h5>\n<p>선입선출의 방법을 보안하고자 나온 방법이 라운드 로빈 스케줄링이다. 이 기법에서는 CPU를 한 번 할당받아 사용할 수 있는 시간을 일정한 고정된 시간으로 제한한다. 긴작업이 필요한 프로세스가 CPU를 할당받더라도 정해진 시간이 지나면 CPU를 내어놓고 CPU의 서비스를 기다리는 줄의 제일 뒤에서 기다려야한다. 이렇게되면 뒤의 프로세스들이 무작정 오래 기다려야하는 상황은 막을 수 있다.</p>\n<h5><span id=\"우선순위priority\">우선순위(Priority)</span></h5>\n<p>이기법은 수행 대기중인 프로세스들에게 프로그램에 따라 우선순위를 부여하고 우선순위가 높은 프로세스에게 CPU를 먼저 할당하게 된다. 또한 지나치게 오래 기다리는 프로세스가 발생하지 않도록, 기다린 시간이 늘어날수록 우선순위를 점차 높여주는 방안도 사용되어질 수 있다.</p>\n<h4><span id=\"메모리-관리\">메모리 관리</span></h4>\n<p>물리적 메모리를 관리하는 방식에는 고정분할방식, 가변분할방식, 가상메모리 방식이 있다.</p>\n<h5><span id=\"고정-분할fixed-partion\">고정 분할(fixed partion)</span></h5>\n<p>물리적 메모리를 몇개의 영구적인 분할로 나눈다. 나뉜 각각의 분할에는 하나의 프로그램이 적재된다. 이방식은 단순해서 분할의 크키보다 큰프로그램은 적재가 불가능하다. 이렇기때문에 메모리의 효율적인 사용측면에서도 바람직하지 않다.</p>\n<h5><span id=\"가변-분할variable-partion\">가변 분할(variable partion)</span></h5>\n<p>매 시점 프로그램의 크기에 맞게 메모리를 분할해서 사용하는 방식이다. 따라서 분할의 큰 프로그램의 실행이제한되는 문제는 발생하지 않는다. 그러나 물리적 메모리크기보다 더 큰 프로그램의 실행은 여전히 불가능하다.</p>\n<h5><span id=\"가상-메모리virtual-memory\">가상 메모리(virtual memory)</span></h5>\n<p>최근에 거의 모든 컴퓨터 시스템에서 사용하는 메모리 관리 기법이다. 가상 메모리 기법에서는 물리적 메모리보다 더 큰프로그램이 실행되는것을 지원한다. 이때 실행될 수 있는 프로그램의 크기는 가상 메모리 크기에 의해 결정된다. 운영체제는 물리적인 주소와 가상 메모리에 주소를 매핑하여 관리한다. 실제 이렇게 가상 메모리를 할당할 수 있게하는것은 실행되지 않는 부분의 프로그램은 보조디스크에 두었다가 필요할때 메모리에 적재하는 방식이다. 이때 그리고 보조 기억장치에서 사용되느부분을 스왑 영역이라한다.</p>\n<h4><span id=\"주변-장치-및-입출력-장치\">주변 장치 및 입출력 장치</span></h4>\n<p>CPU나 메모리와 달리 인터럽트라는 메커니즘을 통해 관리한다. 주변 장치들은 CPU의 서비스가 필요한 경우에 신호를 발생시켜 서비스를 요청하게되는데 이 때 발생시키는 신호를 인터럽트라고 한다. CPU는 평소에 CPU 스케줄링에 따라 자신에게 주어진 작업을 수행하고 있다가 인터럽트가 발생하면 하던일을 잠시 멈추고 인터럽트에 의한 요청 서비스를 수행하게 된다.<br>\n주변 장치들은 각 장치마다 그 장치에서 일어나는 업무에대한 관리를 위한 일종의 작은 CPU를 가진다. 이를 컨트롤러라고하는데 이컨트롤러를 바탕으로 무언가 입력이되면 CPU 에게 인터럽트를 발생시켜 보고하는 역할을 한다. 그러면 CPU는 하던일을 잠시 멈추고 인터럽트에 대한 처리를 하기 위해 운영체제로 할당이 넘어간다.</p>\n<p>참조</p>\n<ul>\n<li><a href=\"http://www.yes24.com/24/goods/2824944\" target=\"_blank\" rel=\"noopener\">운영체제와 정보기술의 원리</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>1.운영체제란?</h2>\n<p>컴퓨터 하드웨어 바로 위에 설치되어 사용 및 다른 모든 소프트웨어를 연결하는 소프트웨어 계층으로<br>\n써 컴퓨터 메모리를 효율적으로 관리하는 역할을 한다.</p>\n<p><img src=\"https://i.imgur.com/f72IER2.png\" alt=\"\"></p>\n<p><strong>커널이란</strong><br>\n컴퓨터와 전원을 켜면 운영체제는 이와 동시에 수행된다. 한편 소프트웨어가 컴퓨터 시스템에서 수행되기 위해서는 메모리에 그 프로그램이 올라가 있어야한다. 마찬가지로 운영 체제 자체도 소프트웨어로서 전원이 켜짐과 동시에 메모리에 올라가야한다. 하지만, 운영체제처럼 규모가 큰 프로그램이 모두 메모리에 올라간다면 한정된 메모리 공간의 낭비가 심할것이다. 따라서 운영체제 중 항상 필요한 부분만을 전원이 켜짐과 동시에 메모리에 올려놓고 그렇지 않은 부분은 필요할 때 메모리에 올려서 사용하게 된다. 이 때 메모리에 상주하는 운영체제의 부분을 커널이라 한다. 또 이것을 좁은 의미의 운영체제라고도 한다. 즉 커널은 메모리에 상주하는 부분으로써 운영체제의 핵심적인 부분을 뜻한다.<br>\n이에 반에 넓은 의미의 운영체제는 커널뿐 아니라 각종 시스템을 위한 유틸리티들을 광범위하게 포함하는 개념이다.(보통은 운영체제라고 하면 커널을 말하게 된다.)</p>\n<h3>1.1 운영체제의 목적</h3>\n<ul>\n<li>CPU, 기억장치, 입출력장등의 컴퓨터 시스템 자원 등을 효율적으로 관리하는것</li>\n</ul>\n<h3>1.2 운영 체제 목표</h3>\n<ul>\n<li>컴퓨터 시스템을 편리하게 사용할 수 있도록  운영체제는 동시 사용자/ 프로그램들이 각각 독자적으로 컴퓨터에서 수행되는것같은 황상을 제공</li>\n<li>하드웨어를 직접 다루는 복잡한 부분을 운영체제가 대행</li>\n<li>프로세서(CPU), 기억장치, 입출력 장치등을 효율적으로 관리<br>\n<img src=\"https://i.imgur.com/OUOWqtq.png\" alt=\"\"></li>\n</ul>\n<h3>1.3 운영체제의 분류</h3>\n<p>운영체의 분류는 크게 동시 자원을 지원하는지 여부 즉 여러 프로그램을 한번에 돌리수 있냐의 분류방식과, 작업을 처리하는 방식 여부에따른 분류등으로 나눌 수 있다.</p>\n<h4>동시 자원을 지원하는지 여부에 따른 분류</h4>\n<p>동시에 작업을 지원하는지의 여부에 따라 운영체제를 단일 작업용 운영체제와 다중 작업용 운영체로 나누어 볼 수 있다.</p>\n<h5>단일작업</h5>\n<ul>\n<li>한번에 하나의 작업만 처리</li>\n<li>DOS같은 환경</li>\n</ul>\n<h5>다중작업 운영체제</h5>\n<ul>\n<li>동시에 두개이상의 작업처리<br>\n아래는 다중 작업 운영체제의 프로그램들이 시스템들이다.</li>\n</ul>\n<p><strong>시분할 시스템이란[CPU가 한개있는 컴퓨터의 성질]</strong><br>\n컴퓨터 처리 능력을 짧은 시간단위로 구분하고 이를 여러 사용자에게 조금씩 분할해 서비스하는 방식을 말한다. 예를 들어 시분할 방식을 사용하는 메인 프레임 컴퓨터에서는 전국에 있는 여러 은행 지점의 많은 터미너들을 동시에 서비스하는것이 가능하다. 여기에서 '동시’라는 표현을 썻지만 정확하게는 메인 프레임 컴퓨터가 매 시점 하나의 터미널만을 서비스하므로 동시란 말이 정확한것은 아니다. 단지 메인 프레임 컴퓨터가 여러 터미널을 아주 짧은 시간 간격으로 나누어 서비스하기 때문에 각 터미널 입장에서는 동시에 서비스를 받게 되는 느낌이다.</p>\n<p><strong>다중 프로그래밍 시스템[CPU가 한개있는 컴퓨터의 성질]</strong><br>\nCPU와 달리 메모리의 경우 여러 프로그램들이 조금씩 메모리 공간을 보유하며 동시에 메모리에 올라갈 수 있다. 이처럼 메모리 공간을 분할해 여러 프로그램들을 동시에 메모리에 올려놓고 처리하는 시스템을 다중 프로그램 시스템이라 한다.</p>\n<p><strong>다중처리기 시스템(multi-processor system)[CPU가 한개이상있는 컴퓨터의 성질]</strong><br>\n하나의 컴퓨터안에 CPU가 여러개 설치된 경우를 뜻하므로 위의 용어들과는 의미가 다르다. CPU가 여럿 있는 컴퓨터는 서로 다른 CPU안에서 여러 프로그램이 동시에 수행될 수 있어 처리가 더욱 빨라지지만, 운영체제 입장에서는 여러 CPU를 관리하기 위해 더욱 복잡한 매커니즘을 사용해야한다.</p>\n<h4>작업을 처리하는 방식 여부에 따른 분류</h4>\n<p><strong>일괄 처리(batch processing)</strong><br>\n작업 요청의 일정량을 모아서 한꺼번에 처리 하는 방식이다.<br>\n<strong>시분할(time sharing)</strong><br>\n여러 작업을 수행할 때 컴퓨터의 처리 능력을 일정한 시간 단위로 빠르게 나눠서 처리하는 방식</p>\n<p><strong>실시간(real time)</strong><br>\n실시간 운영체제는 정해진 시간안에 일이 반드시 종료됨이 보장되어야하는 시스템에서 사용된다.</p>\n<h3>1.4 운영체제 자원관리 기능</h3>\n<p>운영 체제의 핵심은 자원을 어떻게 효율적으로 관리할것인가이다. 자원은 하드웨어 자원과 소프트웨어 자원으로 나뉜다. CPU는 통상적으로 컴퓨터 한대에 하나가 장착되기 때문에 여러 프로세스들이 CPU를 효율적으로 나누어 사용할 수 있도록 관리해야한다. CPU와 메모리는 전원이 꺼지면 처리중이던 정보가 모두 사라지기 때문에 전원이 나가도 기억해야하는 부분은 보조기억장치에 파일형태로 저장된다. 이러한 파일들이 저장되는 방식 및 접근 권한등에 대해서도 운영체제가 관리를 해주어야한다.</p>\n<p><img src=\"https://i.imgur.com/CeItZzu.png\" alt=\"\"></p>\n<p>먼저 CPU 관리방법부터 알아보자.</p>\n<h4>CPU 스케줄링</h4>\n<p>여러개의 프로세스가 실행될 때 어떠한 프로세스에게 CPU 를 처리할지 결정이 필요하다. 이러한 결정을 처리하는것이 CPU 스케줄링이라한다.</p>\n<h5>선입선출(First Come First Served)</h5>\n<p>먼저 CPU를 사용하기 위해 도착한 프로세스를 먼저 처리해주는 방식을 말한다. 이는 일상생활에서 줄서기하는것과 같다. 이방법을 사용하면 먼저 CPU를 요청한 프로세스가 작업이 끝날 때 까지 다른 프로세스들은 작업을 할 수 없다. 이방법은 CPU는 효율적으로 계속 작업은 할 수 있으나 전체적인 프로세스를 처리하는 면에서는 비효율적인 방법이다.</p>\n<h5>라운드 로빈(Round Robin)</h5>\n<p>선입선출의 방법을 보안하고자 나온 방법이 라운드 로빈 스케줄링이다. 이 기법에서는 CPU를 한 번 할당받아 사용할 수 있는 시간을 일정한 고정된 시간으로 제한한다. 긴작업이 필요한 프로세스가 CPU를 할당받더라도 정해진 시간이 지나면 CPU를 내어놓고 CPU의 서비스를 기다리는 줄의 제일 뒤에서 기다려야한다. 이렇게되면 뒤의 프로세스들이 무작정 오래 기다려야하는 상황은 막을 수 있다.</p>\n<h5>우선순위(Priority)</h5>\n<p>이기법은 수행 대기중인 프로세스들에게 프로그램에 따라 우선순위를 부여하고 우선순위가 높은 프로세스에게 CPU를 먼저 할당하게 된다. 또한 지나치게 오래 기다리는 프로세스가 발생하지 않도록, 기다린 시간이 늘어날수록 우선순위를 점차 높여주는 방안도 사용되어질 수 있다.</p>\n<h4>메모리 관리</h4>\n<p>물리적 메모리를 관리하는 방식에는 고정분할방식, 가변분할방식, 가상메모리 방식이 있다.</p>\n<h5>고정 분할(fixed partion)</h5>\n<p>물리적 메모리를 몇개의 영구적인 분할로 나눈다. 나뉜 각각의 분할에는 하나의 프로그램이 적재된다. 이방식은 단순해서 분할의 크키보다 큰프로그램은 적재가 불가능하다. 이렇기때문에 메모리의 효율적인 사용측면에서도 바람직하지 않다.</p>\n<h5>가변 분할(variable partion)</h5>\n<p>매 시점 프로그램의 크기에 맞게 메모리를 분할해서 사용하는 방식이다. 따라서 분할의 큰 프로그램의 실행이제한되는 문제는 발생하지 않는다. 그러나 물리적 메모리크기보다 더 큰 프로그램의 실행은 여전히 불가능하다.</p>\n<h5>가상 메모리(virtual memory)</h5>\n<p>최근에 거의 모든 컴퓨터 시스템에서 사용하는 메모리 관리 기법이다. 가상 메모리 기법에서는 물리적 메모리보다 더 큰프로그램이 실행되는것을 지원한다. 이때 실행될 수 있는 프로그램의 크기는 가상 메모리 크기에 의해 결정된다. 운영체제는 물리적인 주소와 가상 메모리에 주소를 매핑하여 관리한다. 실제 이렇게 가상 메모리를 할당할 수 있게하는것은 실행되지 않는 부분의 프로그램은 보조디스크에 두었다가 필요할때 메모리에 적재하는 방식이다. 이때 그리고 보조 기억장치에서 사용되느부분을 스왑 영역이라한다.</p>\n<h4>주변 장치 및 입출력 장치</h4>\n<p>CPU나 메모리와 달리 인터럽트라는 메커니즘을 통해 관리한다. 주변 장치들은 CPU의 서비스가 필요한 경우에 신호를 발생시켜 서비스를 요청하게되는데 이 때 발생시키는 신호를 인터럽트라고 한다. CPU는 평소에 CPU 스케줄링에 따라 자신에게 주어진 작업을 수행하고 있다가 인터럽트가 발생하면 하던일을 잠시 멈추고 인터럽트에 의한 요청 서비스를 수행하게 된다.<br>\n주변 장치들은 각 장치마다 그 장치에서 일어나는 업무에대한 관리를 위한 일종의 작은 CPU를 가진다. 이를 컨트롤러라고하는데 이컨트롤러를 바탕으로 무언가 입력이되면 CPU 에게 인터럽트를 발생시켜 보고하는 역할을 한다. 그러면 CPU는 하던일을 잠시 멈추고 인터럽트에 대한 처리를 하기 위해 운영체제로 할당이 넘어간다.</p>\n<p>참조</p>\n<ul>\n<li><a href=\"http://www.yes24.com/24/goods/2824944\" target=\"_blank\" rel=\"noopener\">운영체제와 정보기술의 원리</a></li>\n</ul>\n"},{"title":"Toby-2 테스트","catalog":true,"date":"2018-06-22T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n# 토비의 스프링\n이글은 [토비님의 스프링책](http://book.naver.com/bookdb/book_detail.nhn?bid=7006516)을 보고 요약한 내용입니다\n\n## 테스트\n스프링이 개발자에게 제공하는 가장 중요한 가치가 무엇이냐고 질문한다면 그것은 객체지향과 테스트라고 한다. 엔터프라이즈 앱은 변화가 계속해서 일어난다. 이런 변환에 대응하는 첫 번째 전략이 확장과 변화를 고려한 객체지향적 설계와 그것을 효과적으로 담아낼 수 있는 IoC/DI같은기술이다. 두번째 전략은 만들어진 코드를 확실할 수 있게 해주고, 변화에 유연하게 대처할 수 있는 자신감을 주는 테스트 기술이다.\n\n### 2.1 UserDaoTest 다시 보기\n\n#### 테스트의 유용성\n테스트 코드를 작성하게 되면 자신이 작성한 코드가 제대로 작동하는지 확인할 수 있다. 이를 통해 코드의 결함(의존성)을 제거해가는 작업, 디버깅을 거치게 되고 최종적으로 테스트가 성공하면 모든 결함이 제거됐다는 확인을 얻을 수 있다.\n\n#### UserDaoTest특징\n다시 1장에서 작성한 UserDao 테스트의 장점을 간단하게 봐보자.\n\n```java\npublic class UserDaoTest {\n\n    public static void main(String[] args) throws ClassNotFoundException, SQLException {\n\n        final ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);\n        final UserDao userDao = context.getBean(\"userDao\",UserDao.class);\n\n        User user = new User();\n        user.setId(\"whiteship\");\n        user.setName(\"백기선\");\n        user.setPassword(\"married\");\n        userDao.add(user);\n        System.out.println(user.getId() + \" 등록 성공\");\n\n        User user2 = userDao.get(user.getId());\n        System.out.println(user2.getName());\n        System.out.println(user2.getPassword());\n        System.out.println(user2.getId() + \" 조회 성공\");\n    }\n\n}\n```\n위의 UserDaoTest를 이용해 작성한 테스트 코드의 장점은 아래와 같을 수 있을것이다.\n* 자바에서 가장 손쉽게 실행가능한 main()함수를 사용해 테스트할 수 있다.\n* 테스트의 결과를 콘솔로 확인할 수 있다.\n* 테스트에 사용할 객체들의 의존성을 쉽게 주입해줄 수 있다.\n\n만약 테스트코드 작성이 아닌 구현을 통한 테스트는 아래와같은 문제점을 가질 수 있다.\n\n**웹을 통한 DAO 테스트 방법의 문제점**\n웹화면을 통해 DAO를 테스트하게되면 프리젠테이션계층, 서비스계층을 포함한 모든 입출력기능을 대충이라도 테스트해야만한다. 좀 더 자세히말하면 서비스클래스, 컨트롤러, 뷰단 모든 레이어의 기능을 다만들어야만 테스트를 할 수 있다는 단점이 있다.\n\n**작은 단위의 테스트 필요성**\n한꺼번에 너무많은것을 몰아서 테스트하면 테스트 수행과정도 복잡해지고 오류가 발생했을 때 정확한 원인을 찾기도 힘들어진다. 따라서 테스틑 가능하면 작은 단위로 쪼개서 집중해서 할수 있어야 한다.\n\n때로는 긴 시나리오에 테스트를 하는경우도 있을것이다. 예를들어 회원가입 - 로그인 - 로그아웃 - 회원삭제, 하지만 이흐름을 한번에 시키다가 에러가 발생하면 어느부분에서 에러가 낫는지 확인하기위해 많은 디버깅 시간이 필요할 것 이다. 하지만 미리 단위 테스트하고 그다음 긴 시나리오를 진행하게되면 예외가 발생하거나 테스트가 실패할 수 있지만, 좀더 에러의 원인을 빨리 잡을 가망성이 커진다. 이렇기 때문에 각각의 기능을 쪼개서 테스트할필요가 있다.\n\n#### UserDaoTest의 문제점\n위에 작성한 UserDaoTest가 직접 테스트하는 방법보다는 훨씬 효율적인 방법이다. 좋은 방법임에도 불구하고 몇가지 만족스럽지 못한것은 사실이다. 예를들어 테스트 코드를 개발자가 직접 실행시켜야한다거나 그결과를 직접 확인해야한다는것이다. 그래서 이러한문제를 체계적으로 해결할 수 있는 프레임워크를 스프링에서 제공해준다. 그것이 바로 Junit 테스트 프레임워크이다.\n\n### 2.2 JUnit 테스트로 전환\n#### Junit테스트로 전환\nJUnit프레임워크는 두가지 조건을 따라야 한다. 첫번째는 public 으로 선언 돼야하고, 다른하나는 메소드에 @test라는 애노테이션을 붙여야한다.\n\n#### 검증 코드 전환\nJunit code에서 assertThat()메소드는 첫 번째 파라미터의 값을 뒤에나오는 matcher라고 불리는 조건으로 비교해서 일치하면 다음으로 넘어가고, 아니면 테스트가 실패하도록 만들어준다. is()는 matcher의 일종으로 equals()로 비교해주는 기능을 가졌다.\n\n```java\nassertThat(user2.getPassword(), is(user.getPassword())); // 같지않으면 다음단계로 못넘어감\nif(!user.getName.equals(user2.getName())){\n  //마찬가지\n}\n```\n\n### 2.3 개발자를 위한 테스팅 프레임워크 JUnit\n#### 테스트 결과의 일관성\n테스트를 하다 보면 외부 상태에 따라 성공하기도 실패하기도한다. 당연히 성공해야하는 상황도 실패하는경우가있다. 예를들어 데이터베이스가 이전에 테스트했던 데이터가 들어가있어 중복 문제로 인하여 테스트가 실팽하는 경우 등이 있을 수 있다. 가장 좋은 해결책은 addAndGet()같은 메소드가 테스트를 마치고 나면 테스트가 등록한 사용자 정보를 삭제해서, 테스트를 수행하기 이전 상태로 만들어주는 것이다. 그러면 아무리 많은 테스트를 해도 항상 동일한 테스트 결과를 얻을 것 이다.\n\n##### deleteAll()의 getCount() 추가\n\n```java\npublic void deleteAll() throws SQLException{\n  System.out.println(\"delete from users\"); //실제로는 해당기능 실제 수행\n}\n\npublic void getCount() throws SQLException{\n  System.out.println(\"select count(*) from users\"); //실제로는 해당기능 실제 수행\n}\n\n```\n##\n\n테스트의 결과가 테스트(메소드) 실행 순서에 영향을 받는다면 테스트를 잘못 만든 것이다. 모든 테스트는 실행순서에 상관없이 독립적으로 항상 동일한 결과를 낼수 있도록 해야한다.\n\nJUnit은 예외조건 테스트를 위한 특별한 방법을 제공해준다. Junit의 예외 테스트 기능을 이용하면 아래와 같이 테스트를 만들 수 있다.\n\n```java\n@Test(expected = EmptyResultDataAccessException.class)\npublic void getUserFailure(){\n  //비지니스로직하다가 예상되어지는 exception발생시 성공\n}\n\n```\n\n테스트 코드를 작성할때는 조건, 행위, 결과에대한 내용이 잘 표현되어 있어야 한다. 이렇게 구현하다보면 마치 잘작성된 하나의 기능정의서처럼 보인다. 그래서 보통 기능설계, 구현, 테스트라는 일반적인 개발 흐름의 기능설계에 해당하는 부분을 테스트 코드가 일부분 담당하고 있다고 볼 수 있다. 마치 코드로 된 설계 문서 처럼 만들어놓 것이라고 생각해보자.\n\n##### 테스트 주도 개발(TDD)\n만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법을 테스트 주도 개발이라고한다. 또는 테스트우선개발 Test First Development라고도 한다.\n\n#####Before\n미리 JUnit테스트가 시작되기전에 before이라는 어노테이션을 이용해 아래와 같이 필요한 변수를 셋팅하고 시작할 수 있다.\n```java\n\npublic class UserDaoTest {\n  private UserDao dao;\n\n  @Before\n  public void setUp(){\n    ApplicationContext context = new GenericXmlApplicationContext(\"ApplicationContext.xml\");\n    this.dao = contenxt.getBean(\"userDao\",UserDao.class)\n  }\n}\n```\nJunit 프레임워크는 스스로 제어권을 가지고 주도적으로 동작하고, 개발자가 만든 코드는 프레임워크에 의해 수동적으로 실행된다. 그래서 프레임워크에 사용되는 코드만으로는 실행 흐름이 잘보이지 않기 때문에 프레임워크가 어떻게 사용할지를 잘 이해를 하고 있어야 한다.\nJUnit이 하나의 테스트 클래스를 가져와 테스트를 수행하는 방식은 다음과 같다.\n\n1. 테스트 클래스에서 @Test가 붙은 public이고 void형이며 파라미터가 없는 테스트 메소드를 모두 찾는다.\n2. 테스트 클래스의 오브젝트를 하나 만든다.\n3. @before가 붙은 메소드가 있으면 실행한다.\n4. @test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.\n5. @after가 붙은 메소드가 있으면 실행한다.\n6. 나머지 테스트 메소드에 대해 2~5번을 반복한다.\n7. 모든 테스트의 결과를 종합해서 돌려준다.\n크게 이렇게 7단계를 거쳐서 진행된다고 볼 수 있다.\n\n한가지 기억해야할점은 실행되는 각테스트 클래스는 실행때마다 새롭게 만들어진다. 한번 만들어진 테스트 클래스는 하나의 오브젝트는 테스트 메소드가 사용하고나면 버려진다. 만약 해당 클래스가 @test 메소드를 2개가지고있다면 2개의 오브젝트를 만들고 각각 테스트 될것이다.\n\n![](https://i.imgur.com/eq09toD.png)        \n\n### 2.4 스프링 테스트 적용\n@Before메소드가 테스트 메소드 개수만큼 반복되기 떄문에 어플리케이션 컨텍스트도 3번 만들어진다. 지금은 이 빈을 생성하는데 얼마 걸리지 않지만 나중에 빈이 많이 등록되고 그러면 이 빈 컨텍스트를 만드는데 많은 시간이 걸린다. 그래서 ApplicationContext같은경우에는 스태틱필드에 저장해두고 공통 변수로 사용하면 효율적으로 사용할 수 있게 된다. JUnit은 테스트 클래스 전체에 걸쳐 딱 한번만 실행되는 @BeforeClass 스태틱 메소드를 지원한다. 하지만 이보다는 스프링이 직접제공해주는 어플리케이션 컨텍스트 테스트 지원기능을 사용하는것이다.\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class) // Spring 테스트 컨텍스트 프레임워크의 JUnit확장 기능 지정\n@ContextConfiguration(classes={DaoFactory.class}) // 테스트 컨텍스트가 자동으로 만들어줄 어플리케이션 컨텍스트의 위치\npublic class UserDaoTest{\n  @Autowired\n  private ApplicationContext context; //위에서 제공해주는 컨텍스트로 의존성주입됨\n\n  @Before\n  public void setUp(){\n    this.dao = this.context.getBean(\"UserDao\",UserDao.class);\n    ...\n  }\n}\n```\n\n@RunWith는 Junit프레임워크의 테스트 실행방법을 확장할 때 사용하는 애노테이션이다. SpringJUnit4ClassRunner는 Junit용 테스트 컨텍스트 프레임워크 확장 클래스를 지정해주면 JUnit이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행해준다.\n\n@ContextConfiguration은 자동으로 만들어줄 애플리케이션 컨텍스트 설정위치를 지정한것이다.\n\n#### 테스트 메소드의 컨텍스트 공유\n@Before은 매 테스트코드가 실행될때 마다 실행되게 메소드를 설정해주 어노테이션이다. 만약 2개의 테스트 메소드를 실행한다면 this.context 같은 오브젝트일것이다. 위에서 @RunWith 어노테이션때문에 한번만 context를 load할것이기 때문이다. 반면 this는 테스트메소드마다 새롭게 생성된 오브젝트 일것이다\n```java\n@Before\npublic void setUp(){\n  System.out.println(this.context);\n  System.out.println(this);\n}\n```\n\n#### 테스트 클래스의 컨텍스트 공유\n만약 여러개의 테스트 클래스가 있는데 모두 같은 설정파일을 가진 애플리케이션 컨텍스트를 사용한다면, 스프링은 테스트클래스 사이에서도 애플리케이션 컨텍스트를 공유하여 사용한다.\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(classes={DaoFactory.class})\npublic class UserDaoTest{..}\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(classes={DaoFactory.class})\npublic class GroupDaoTest{..}\n```\n만약 위와같이 두개의 다른 테스트클래스가 있더라도, DaoFactory에 관한 Context는 한번만 올라가지게 된다. 따라서 수백 개의 테스트 클래스를 만들어도 모두 같은 설정파일을 사용하게 된다. 당연히 테스트파일을 실행시켜도 한번만 Context가 load될것이다.\n\n#### @Autowired를 통한 의존성주입\n아래는 dataSource를 의존성을 주입하는 방법이다.\n```java\n@Autowired\nprivate SimpleDriverDataSource datasource;\n\n@Autowired\nprivate DataSource datasource;\n```\n위 방법중에 어느방식을 사용해서 의존성주입을 해도 상관은없다. 하지만 인터페이스를 선언한것이 좀더 확장성 있게 개발할 수 있다. 인터페이스를 사용하면 총 몇가지의 장점을 가진다.\n첫째, 인터페이스를 사용하여 의존성주입을 하게되면 해당 의존성주입의 클래스부분만 bean을 등록해주면 되기때문이다.\n둘째, 1장에서 만들었던 DB커넥션의 개수를 카운팅하는 부가기능이 대표적인예이다. 추가 기능을 확장하는데 아주 좋다.\n\n\n#### 테스트를 위한 별도의 DI설정\n\n```java\n@ContextConfiguration(classes={DaoFactory.class})\n```\n\n테스트를 위해 설정 클래스파일을 하나 더만들어 구성하면 쉽게 개발용 테스트 클래스를 실행할 수 있다. 이렇게 하면 테스트환경에서 적합한 구성을 가진 설정파일을 이용해서 테스트를 진행할 수 있다.\n\n[예제소스](https://github.com/minwan1/Spring-toby)\n\n## 정리\n* Test 주도 개발로 개발을 하게 되면 너무나도 많은 장점을 가지는 것 같다. 일단 변화를 두려워 하지않는다. 소스 리팩토링, 기능변경 이 있더라도 개발을한 후 간단하게 테스트를 할 수 있기 때문이다.\n\n* 또 개발 시간이 단축된다. 단순 개발시간만 놓고보면 당연히 개발시간이 단축된다고 말할 수 는 없다.하지만 예를들어 User 정보 변경 기능을 개발한다고 치면 개발을 하고 매번 테스트 하기위해서는 프론트엔드와 연결을하고 테스트 해야한다. 단순 유저 정보 변경 기능 개발인데 프론트엔드가 없으면 개발 테스트를 못하게 된다. 물론 Postman, Curl등을 호출해 API 테스트를 할 수 있겠지만 문제는 API하나 테스트를 위해 몇분의 서버 로딩을 기다려야한다. 하지만 Unit 테스트등으로는 몇개의 빈만 올리고 테스트할 수 있기때문에 개발 및 테스트 시간을 아낄 수 있게 된다.\n\n* 그리고 테스트 주도 개발을 하게 되면 자연스럽게 단일 책임 원칙, 개방 폐쇄 원칙을 준수하게 되는 것 같다. 왜냐 테스트 코드를 작성하다 보면 왠지 모르게 테스트 코드가 작성하기가 어려울 때 가 있는데 이때 단일 책임 원칙, 개방 폐쇄 원칙을 지키지 않고 있을가망성이 크기때문이다. 이럴 때 보면 보통 하나의 클래스에 너무 많은 책임을 줬기 때문에 테스트 코드를 작성하기가 어려워지는 경우가 많다. 일단 테스트 코드가 작성하기 어렵다는 것은 지금 만들고자 하는 기능이 뭔가 SOLID 원칙을 위반하고 있다는 것을 의심해봐야 한다.\n","source":"_posts/2018-06-23-Toby-2.md","raw":"---\ntitle: Toby-2 테스트\ncatalog: true\ndate: 2018-06-23\nsubtitle:\nheader-img:\ntags:\n- Java\n- Spring\n- Toby\n\n\n---\n\n# 토비의 스프링\n이글은 [토비님의 스프링책](http://book.naver.com/bookdb/book_detail.nhn?bid=7006516)을 보고 요약한 내용입니다\n\n## 테스트\n스프링이 개발자에게 제공하는 가장 중요한 가치가 무엇이냐고 질문한다면 그것은 객체지향과 테스트라고 한다. 엔터프라이즈 앱은 변화가 계속해서 일어난다. 이런 변환에 대응하는 첫 번째 전략이 확장과 변화를 고려한 객체지향적 설계와 그것을 효과적으로 담아낼 수 있는 IoC/DI같은기술이다. 두번째 전략은 만들어진 코드를 확실할 수 있게 해주고, 변화에 유연하게 대처할 수 있는 자신감을 주는 테스트 기술이다.\n\n### 2.1 UserDaoTest 다시 보기\n\n#### 테스트의 유용성\n테스트 코드를 작성하게 되면 자신이 작성한 코드가 제대로 작동하는지 확인할 수 있다. 이를 통해 코드의 결함(의존성)을 제거해가는 작업, 디버깅을 거치게 되고 최종적으로 테스트가 성공하면 모든 결함이 제거됐다는 확인을 얻을 수 있다.\n\n#### UserDaoTest특징\n다시 1장에서 작성한 UserDao 테스트의 장점을 간단하게 봐보자.\n\n```java\npublic class UserDaoTest {\n\n    public static void main(String[] args) throws ClassNotFoundException, SQLException {\n\n        final ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);\n        final UserDao userDao = context.getBean(\"userDao\",UserDao.class);\n\n        User user = new User();\n        user.setId(\"whiteship\");\n        user.setName(\"백기선\");\n        user.setPassword(\"married\");\n        userDao.add(user);\n        System.out.println(user.getId() + \" 등록 성공\");\n\n        User user2 = userDao.get(user.getId());\n        System.out.println(user2.getName());\n        System.out.println(user2.getPassword());\n        System.out.println(user2.getId() + \" 조회 성공\");\n    }\n\n}\n```\n위의 UserDaoTest를 이용해 작성한 테스트 코드의 장점은 아래와 같을 수 있을것이다.\n* 자바에서 가장 손쉽게 실행가능한 main()함수를 사용해 테스트할 수 있다.\n* 테스트의 결과를 콘솔로 확인할 수 있다.\n* 테스트에 사용할 객체들의 의존성을 쉽게 주입해줄 수 있다.\n\n만약 테스트코드 작성이 아닌 구현을 통한 테스트는 아래와같은 문제점을 가질 수 있다.\n\n**웹을 통한 DAO 테스트 방법의 문제점**\n웹화면을 통해 DAO를 테스트하게되면 프리젠테이션계층, 서비스계층을 포함한 모든 입출력기능을 대충이라도 테스트해야만한다. 좀 더 자세히말하면 서비스클래스, 컨트롤러, 뷰단 모든 레이어의 기능을 다만들어야만 테스트를 할 수 있다는 단점이 있다.\n\n**작은 단위의 테스트 필요성**\n한꺼번에 너무많은것을 몰아서 테스트하면 테스트 수행과정도 복잡해지고 오류가 발생했을 때 정확한 원인을 찾기도 힘들어진다. 따라서 테스틑 가능하면 작은 단위로 쪼개서 집중해서 할수 있어야 한다.\n\n때로는 긴 시나리오에 테스트를 하는경우도 있을것이다. 예를들어 회원가입 - 로그인 - 로그아웃 - 회원삭제, 하지만 이흐름을 한번에 시키다가 에러가 발생하면 어느부분에서 에러가 낫는지 확인하기위해 많은 디버깅 시간이 필요할 것 이다. 하지만 미리 단위 테스트하고 그다음 긴 시나리오를 진행하게되면 예외가 발생하거나 테스트가 실패할 수 있지만, 좀더 에러의 원인을 빨리 잡을 가망성이 커진다. 이렇기 때문에 각각의 기능을 쪼개서 테스트할필요가 있다.\n\n#### UserDaoTest의 문제점\n위에 작성한 UserDaoTest가 직접 테스트하는 방법보다는 훨씬 효율적인 방법이다. 좋은 방법임에도 불구하고 몇가지 만족스럽지 못한것은 사실이다. 예를들어 테스트 코드를 개발자가 직접 실행시켜야한다거나 그결과를 직접 확인해야한다는것이다. 그래서 이러한문제를 체계적으로 해결할 수 있는 프레임워크를 스프링에서 제공해준다. 그것이 바로 Junit 테스트 프레임워크이다.\n\n### 2.2 JUnit 테스트로 전환\n#### Junit테스트로 전환\nJUnit프레임워크는 두가지 조건을 따라야 한다. 첫번째는 public 으로 선언 돼야하고, 다른하나는 메소드에 @test라는 애노테이션을 붙여야한다.\n\n#### 검증 코드 전환\nJunit code에서 assertThat()메소드는 첫 번째 파라미터의 값을 뒤에나오는 matcher라고 불리는 조건으로 비교해서 일치하면 다음으로 넘어가고, 아니면 테스트가 실패하도록 만들어준다. is()는 matcher의 일종으로 equals()로 비교해주는 기능을 가졌다.\n\n```java\nassertThat(user2.getPassword(), is(user.getPassword())); // 같지않으면 다음단계로 못넘어감\nif(!user.getName.equals(user2.getName())){\n  //마찬가지\n}\n```\n\n### 2.3 개발자를 위한 테스팅 프레임워크 JUnit\n#### 테스트 결과의 일관성\n테스트를 하다 보면 외부 상태에 따라 성공하기도 실패하기도한다. 당연히 성공해야하는 상황도 실패하는경우가있다. 예를들어 데이터베이스가 이전에 테스트했던 데이터가 들어가있어 중복 문제로 인하여 테스트가 실팽하는 경우 등이 있을 수 있다. 가장 좋은 해결책은 addAndGet()같은 메소드가 테스트를 마치고 나면 테스트가 등록한 사용자 정보를 삭제해서, 테스트를 수행하기 이전 상태로 만들어주는 것이다. 그러면 아무리 많은 테스트를 해도 항상 동일한 테스트 결과를 얻을 것 이다.\n\n##### deleteAll()의 getCount() 추가\n\n```java\npublic void deleteAll() throws SQLException{\n  System.out.println(\"delete from users\"); //실제로는 해당기능 실제 수행\n}\n\npublic void getCount() throws SQLException{\n  System.out.println(\"select count(*) from users\"); //실제로는 해당기능 실제 수행\n}\n\n```\n##\n\n테스트의 결과가 테스트(메소드) 실행 순서에 영향을 받는다면 테스트를 잘못 만든 것이다. 모든 테스트는 실행순서에 상관없이 독립적으로 항상 동일한 결과를 낼수 있도록 해야한다.\n\nJUnit은 예외조건 테스트를 위한 특별한 방법을 제공해준다. Junit의 예외 테스트 기능을 이용하면 아래와 같이 테스트를 만들 수 있다.\n\n```java\n@Test(expected = EmptyResultDataAccessException.class)\npublic void getUserFailure(){\n  //비지니스로직하다가 예상되어지는 exception발생시 성공\n}\n\n```\n\n테스트 코드를 작성할때는 조건, 행위, 결과에대한 내용이 잘 표현되어 있어야 한다. 이렇게 구현하다보면 마치 잘작성된 하나의 기능정의서처럼 보인다. 그래서 보통 기능설계, 구현, 테스트라는 일반적인 개발 흐름의 기능설계에 해당하는 부분을 테스트 코드가 일부분 담당하고 있다고 볼 수 있다. 마치 코드로 된 설계 문서 처럼 만들어놓 것이라고 생각해보자.\n\n##### 테스트 주도 개발(TDD)\n만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법을 테스트 주도 개발이라고한다. 또는 테스트우선개발 Test First Development라고도 한다.\n\n#####Before\n미리 JUnit테스트가 시작되기전에 before이라는 어노테이션을 이용해 아래와 같이 필요한 변수를 셋팅하고 시작할 수 있다.\n```java\n\npublic class UserDaoTest {\n  private UserDao dao;\n\n  @Before\n  public void setUp(){\n    ApplicationContext context = new GenericXmlApplicationContext(\"ApplicationContext.xml\");\n    this.dao = contenxt.getBean(\"userDao\",UserDao.class)\n  }\n}\n```\nJunit 프레임워크는 스스로 제어권을 가지고 주도적으로 동작하고, 개발자가 만든 코드는 프레임워크에 의해 수동적으로 실행된다. 그래서 프레임워크에 사용되는 코드만으로는 실행 흐름이 잘보이지 않기 때문에 프레임워크가 어떻게 사용할지를 잘 이해를 하고 있어야 한다.\nJUnit이 하나의 테스트 클래스를 가져와 테스트를 수행하는 방식은 다음과 같다.\n\n1. 테스트 클래스에서 @Test가 붙은 public이고 void형이며 파라미터가 없는 테스트 메소드를 모두 찾는다.\n2. 테스트 클래스의 오브젝트를 하나 만든다.\n3. @before가 붙은 메소드가 있으면 실행한다.\n4. @test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.\n5. @after가 붙은 메소드가 있으면 실행한다.\n6. 나머지 테스트 메소드에 대해 2~5번을 반복한다.\n7. 모든 테스트의 결과를 종합해서 돌려준다.\n크게 이렇게 7단계를 거쳐서 진행된다고 볼 수 있다.\n\n한가지 기억해야할점은 실행되는 각테스트 클래스는 실행때마다 새롭게 만들어진다. 한번 만들어진 테스트 클래스는 하나의 오브젝트는 테스트 메소드가 사용하고나면 버려진다. 만약 해당 클래스가 @test 메소드를 2개가지고있다면 2개의 오브젝트를 만들고 각각 테스트 될것이다.\n\n![](https://i.imgur.com/eq09toD.png)        \n\n### 2.4 스프링 테스트 적용\n@Before메소드가 테스트 메소드 개수만큼 반복되기 떄문에 어플리케이션 컨텍스트도 3번 만들어진다. 지금은 이 빈을 생성하는데 얼마 걸리지 않지만 나중에 빈이 많이 등록되고 그러면 이 빈 컨텍스트를 만드는데 많은 시간이 걸린다. 그래서 ApplicationContext같은경우에는 스태틱필드에 저장해두고 공통 변수로 사용하면 효율적으로 사용할 수 있게 된다. JUnit은 테스트 클래스 전체에 걸쳐 딱 한번만 실행되는 @BeforeClass 스태틱 메소드를 지원한다. 하지만 이보다는 스프링이 직접제공해주는 어플리케이션 컨텍스트 테스트 지원기능을 사용하는것이다.\n\n```java\n@RunWith(SpringJUnit4ClassRunner.class) // Spring 테스트 컨텍스트 프레임워크의 JUnit확장 기능 지정\n@ContextConfiguration(classes={DaoFactory.class}) // 테스트 컨텍스트가 자동으로 만들어줄 어플리케이션 컨텍스트의 위치\npublic class UserDaoTest{\n  @Autowired\n  private ApplicationContext context; //위에서 제공해주는 컨텍스트로 의존성주입됨\n\n  @Before\n  public void setUp(){\n    this.dao = this.context.getBean(\"UserDao\",UserDao.class);\n    ...\n  }\n}\n```\n\n@RunWith는 Junit프레임워크의 테스트 실행방법을 확장할 때 사용하는 애노테이션이다. SpringJUnit4ClassRunner는 Junit용 테스트 컨텍스트 프레임워크 확장 클래스를 지정해주면 JUnit이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행해준다.\n\n@ContextConfiguration은 자동으로 만들어줄 애플리케이션 컨텍스트 설정위치를 지정한것이다.\n\n#### 테스트 메소드의 컨텍스트 공유\n@Before은 매 테스트코드가 실행될때 마다 실행되게 메소드를 설정해주 어노테이션이다. 만약 2개의 테스트 메소드를 실행한다면 this.context 같은 오브젝트일것이다. 위에서 @RunWith 어노테이션때문에 한번만 context를 load할것이기 때문이다. 반면 this는 테스트메소드마다 새롭게 생성된 오브젝트 일것이다\n```java\n@Before\npublic void setUp(){\n  System.out.println(this.context);\n  System.out.println(this);\n}\n```\n\n#### 테스트 클래스의 컨텍스트 공유\n만약 여러개의 테스트 클래스가 있는데 모두 같은 설정파일을 가진 애플리케이션 컨텍스트를 사용한다면, 스프링은 테스트클래스 사이에서도 애플리케이션 컨텍스트를 공유하여 사용한다.\n```java\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(classes={DaoFactory.class})\npublic class UserDaoTest{..}\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(classes={DaoFactory.class})\npublic class GroupDaoTest{..}\n```\n만약 위와같이 두개의 다른 테스트클래스가 있더라도, DaoFactory에 관한 Context는 한번만 올라가지게 된다. 따라서 수백 개의 테스트 클래스를 만들어도 모두 같은 설정파일을 사용하게 된다. 당연히 테스트파일을 실행시켜도 한번만 Context가 load될것이다.\n\n#### @Autowired를 통한 의존성주입\n아래는 dataSource를 의존성을 주입하는 방법이다.\n```java\n@Autowired\nprivate SimpleDriverDataSource datasource;\n\n@Autowired\nprivate DataSource datasource;\n```\n위 방법중에 어느방식을 사용해서 의존성주입을 해도 상관은없다. 하지만 인터페이스를 선언한것이 좀더 확장성 있게 개발할 수 있다. 인터페이스를 사용하면 총 몇가지의 장점을 가진다.\n첫째, 인터페이스를 사용하여 의존성주입을 하게되면 해당 의존성주입의 클래스부분만 bean을 등록해주면 되기때문이다.\n둘째, 1장에서 만들었던 DB커넥션의 개수를 카운팅하는 부가기능이 대표적인예이다. 추가 기능을 확장하는데 아주 좋다.\n\n\n#### 테스트를 위한 별도의 DI설정\n\n```java\n@ContextConfiguration(classes={DaoFactory.class})\n```\n\n테스트를 위해 설정 클래스파일을 하나 더만들어 구성하면 쉽게 개발용 테스트 클래스를 실행할 수 있다. 이렇게 하면 테스트환경에서 적합한 구성을 가진 설정파일을 이용해서 테스트를 진행할 수 있다.\n\n[예제소스](https://github.com/minwan1/Spring-toby)\n\n## 정리\n* Test 주도 개발로 개발을 하게 되면 너무나도 많은 장점을 가지는 것 같다. 일단 변화를 두려워 하지않는다. 소스 리팩토링, 기능변경 이 있더라도 개발을한 후 간단하게 테스트를 할 수 있기 때문이다.\n\n* 또 개발 시간이 단축된다. 단순 개발시간만 놓고보면 당연히 개발시간이 단축된다고 말할 수 는 없다.하지만 예를들어 User 정보 변경 기능을 개발한다고 치면 개발을 하고 매번 테스트 하기위해서는 프론트엔드와 연결을하고 테스트 해야한다. 단순 유저 정보 변경 기능 개발인데 프론트엔드가 없으면 개발 테스트를 못하게 된다. 물론 Postman, Curl등을 호출해 API 테스트를 할 수 있겠지만 문제는 API하나 테스트를 위해 몇분의 서버 로딩을 기다려야한다. 하지만 Unit 테스트등으로는 몇개의 빈만 올리고 테스트할 수 있기때문에 개발 및 테스트 시간을 아낄 수 있게 된다.\n\n* 그리고 테스트 주도 개발을 하게 되면 자연스럽게 단일 책임 원칙, 개방 폐쇄 원칙을 준수하게 되는 것 같다. 왜냐 테스트 코드를 작성하다 보면 왠지 모르게 테스트 코드가 작성하기가 어려울 때 가 있는데 이때 단일 책임 원칙, 개방 폐쇄 원칙을 지키지 않고 있을가망성이 크기때문이다. 이럴 때 보면 보통 하나의 클래스에 너무 많은 책임을 줬기 때문에 테스트 코드를 작성하기가 어려워지는 경우가 많다. 일단 테스트 코드가 작성하기 어렵다는 것은 지금 만들고자 하는 기능이 뭔가 SOLID 원칙을 위반하고 있다는 것을 의심해봐야 한다.\n","slug":"2018-06-23-Toby-2","published":1,"updated":"2018-06-23T14:26:46.457Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27do002njjpee5fi9kma","content":"<h1><span id=\"토비의-스프링\">토비의 스프링</span></h1>\n<p>이글은 <a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=7006516\" target=\"_blank\" rel=\"noopener\">토비님의 스프링책</a>을 보고 요약한 내용입니다</p>\n<h2><span id=\"테스트\">테스트</span></h2>\n<p>스프링이 개발자에게 제공하는 가장 중요한 가치가 무엇이냐고 질문한다면 그것은 객체지향과 테스트라고 한다. 엔터프라이즈 앱은 변화가 계속해서 일어난다. 이런 변환에 대응하는 첫 번째 전략이 확장과 변화를 고려한 객체지향적 설계와 그것을 효과적으로 담아낼 수 있는 IoC/DI같은기술이다. 두번째 전략은 만들어진 코드를 확실할 수 있게 해주고, 변화에 유연하게 대처할 수 있는 자신감을 주는 테스트 기술이다.</p>\n<h3><span id=\"21-userdaotest-다시-보기\">2.1 UserDaoTest 다시 보기</span></h3>\n<h4><span id=\"테스트의-유용성\">테스트의 유용성</span></h4>\n<p>테스트 코드를 작성하게 되면 자신이 작성한 코드가 제대로 작동하는지 확인할 수 있다. 이를 통해 코드의 결함(의존성)을 제거해가는 작업, 디버깅을 거치게 되고 최종적으로 테스트가 성공하면 모든 결함이 제거됐다는 확인을 얻을 수 있다.</p>\n<h4><span id=\"userdaotest특징\">UserDaoTest특징</span></h4>\n<p>다시 1장에서 작성한 UserDao 테스트의 장점을 간단하게 봐보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDaoTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> ApplicationContext context = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(DaoFactory.class);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> UserDao userDao = context.getBean(<span class=\"string\">\"userDao\"</span>,UserDao.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">        user.setId(<span class=\"string\">\"whiteship\"</span>);</span><br><span class=\"line\">        user.setName(<span class=\"string\">\"백기선\"</span>);</span><br><span class=\"line\">        user.setPassword(<span class=\"string\">\"married\"</span>);</span><br><span class=\"line\">        userDao.add(user);</span><br><span class=\"line\">        System.out.println(user.getId() + <span class=\"string\">\" 등록 성공\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        User user2 = userDao.get(user.getId());</span><br><span class=\"line\">        System.out.println(user2.getName());</span><br><span class=\"line\">        System.out.println(user2.getPassword());</span><br><span class=\"line\">        System.out.println(user2.getId() + <span class=\"string\">\" 조회 성공\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위의 UserDaoTest를 이용해 작성한 테스트 코드의 장점은 아래와 같을 수 있을것이다.</p>\n<ul>\n<li>자바에서 가장 손쉽게 실행가능한 main()함수를 사용해 테스트할 수 있다.</li>\n<li>테스트의 결과를 콘솔로 확인할 수 있다.</li>\n<li>테스트에 사용할 객체들의 의존성을 쉽게 주입해줄 수 있다.</li>\n</ul>\n<p>만약 테스트코드 작성이 아닌 구현을 통한 테스트는 아래와같은 문제점을 가질 수 있다.</p>\n<p><strong>웹을 통한 DAO 테스트 방법의 문제점</strong><br>\n웹화면을 통해 DAO를 테스트하게되면 프리젠테이션계층, 서비스계층을 포함한 모든 입출력기능을 대충이라도 테스트해야만한다. 좀 더 자세히말하면 서비스클래스, 컨트롤러, 뷰단 모든 레이어의 기능을 다만들어야만 테스트를 할 수 있다는 단점이 있다.</p>\n<p><strong>작은 단위의 테스트 필요성</strong><br>\n한꺼번에 너무많은것을 몰아서 테스트하면 테스트 수행과정도 복잡해지고 오류가 발생했을 때 정확한 원인을 찾기도 힘들어진다. 따라서 테스틑 가능하면 작은 단위로 쪼개서 집중해서 할수 있어야 한다.</p>\n<p>때로는 긴 시나리오에 테스트를 하는경우도 있을것이다. 예를들어 회원가입 - 로그인 - 로그아웃 - 회원삭제, 하지만 이흐름을 한번에 시키다가 에러가 발생하면 어느부분에서 에러가 낫는지 확인하기위해 많은 디버깅 시간이 필요할 것 이다. 하지만 미리 단위 테스트하고 그다음 긴 시나리오를 진행하게되면 예외가 발생하거나 테스트가 실패할 수 있지만, 좀더 에러의 원인을 빨리 잡을 가망성이 커진다. 이렇기 때문에 각각의 기능을 쪼개서 테스트할필요가 있다.</p>\n<h4><span id=\"userdaotest의-문제점\">UserDaoTest의 문제점</span></h4>\n<p>위에 작성한 UserDaoTest가 직접 테스트하는 방법보다는 훨씬 효율적인 방법이다. 좋은 방법임에도 불구하고 몇가지 만족스럽지 못한것은 사실이다. 예를들어 테스트 코드를 개발자가 직접 실행시켜야한다거나 그결과를 직접 확인해야한다는것이다. 그래서 이러한문제를 체계적으로 해결할 수 있는 프레임워크를 스프링에서 제공해준다. 그것이 바로 Junit 테스트 프레임워크이다.</p>\n<h3><span id=\"22-junit-테스트로-전환\">2.2 JUnit 테스트로 전환</span></h3>\n<h4><span id=\"junit테스트로-전환\">Junit테스트로 전환</span></h4>\n<p>JUnit프레임워크는 두가지 조건을 따라야 한다. 첫번째는 public 으로 선언 돼야하고, 다른하나는 메소드에 @test라는 애노테이션을 붙여야한다.</p>\n<h4><span id=\"검증-코드-전환\">검증 코드 전환</span></h4>\n<p>Junit code에서 assertThat()메소드는 첫 번째 파라미터의 값을 뒤에나오는 matcher라고 불리는 조건으로 비교해서 일치하면 다음으로 넘어가고, 아니면 테스트가 실패하도록 만들어준다. is()는 matcher의 일종으로 equals()로 비교해주는 기능을 가졌다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">assertThat(user2.getPassword(), is(user.getPassword())); <span class=\"comment\">// 같지않으면 다음단계로 못넘어감</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(!user.getName.equals(user2.getName()))&#123;</span><br><span class=\"line\">  <span class=\"comment\">//마찬가지</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"23-개발자를-위한-테스팅-프레임워크-junit\">2.3 개발자를 위한 테스팅 프레임워크 JUnit</span></h3>\n<h4><span id=\"테스트-결과의-일관성\">테스트 결과의 일관성</span></h4>\n<p>테스트를 하다 보면 외부 상태에 따라 성공하기도 실패하기도한다. 당연히 성공해야하는 상황도 실패하는경우가있다. 예를들어 데이터베이스가 이전에 테스트했던 데이터가 들어가있어 중복 문제로 인하여 테스트가 실팽하는 경우 등이 있을 수 있다. 가장 좋은 해결책은 addAndGet()같은 메소드가 테스트를 마치고 나면 테스트가 등록한 사용자 정보를 삭제해서, 테스트를 수행하기 이전 상태로 만들어주는 것이다. 그러면 아무리 많은 테스트를 해도 항상 동일한 테스트 결과를 얻을 것 이다.</p>\n<h5><span id=\"deleteall의-getcount-추가\">deleteAll()의 getCount() 추가</span></h5>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteAll</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException</span>&#123;</span><br><span class=\"line\">  System.out.println(<span class=\"string\">\"delete from users\"</span>); <span class=\"comment\">//실제로는 해당기능 실제 수행</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getCount</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException</span>&#123;</span><br><span class=\"line\">  System.out.println(<span class=\"string\">\"select count(*) from users\"</span>); <span class=\"comment\">//실제로는 해당기능 실제 수행</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"\"></span></h2>\n<p>테스트의 결과가 테스트(메소드) 실행 순서에 영향을 받는다면 테스트를 잘못 만든 것이다. 모든 테스트는 실행순서에 상관없이 독립적으로 항상 동일한 결과를 낼수 있도록 해야한다.</p>\n<p>JUnit은 예외조건 테스트를 위한 특별한 방법을 제공해준다. Junit의 예외 테스트 기능을 이용하면 아래와 같이 테스트를 만들 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span>(expected = EmptyResultDataAccessException.class)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getUserFailure</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//비지니스로직하다가 예상되어지는 exception발생시 성공</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>테스트 코드를 작성할때는 조건, 행위, 결과에대한 내용이 잘 표현되어 있어야 한다. 이렇게 구현하다보면 마치 잘작성된 하나의 기능정의서처럼 보인다. 그래서 보통 기능설계, 구현, 테스트라는 일반적인 개발 흐름의 기능설계에 해당하는 부분을 테스트 코드가 일부분 담당하고 있다고 볼 수 있다. 마치 코드로 된 설계 문서 처럼 만들어놓 것이라고 생각해보자.</p>\n<h5><span id=\"테스트-주도-개발tdd\">테스트 주도 개발(TDD)</span></h5>\n<p>만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법을 테스트 주도 개발이라고한다. 또는 테스트우선개발 Test First Development라고도 한다.</p>\n<p>#####Before<br>\n미리 JUnit테스트가 시작되기전에 before이라는 어노테이션을 이용해 아래와 같이 필요한 변수를 셋팅하고 시작할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDaoTest</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> UserDao dao;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Before</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUp</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ApplicationContext context = <span class=\"keyword\">new</span> GenericXmlApplicationContext(<span class=\"string\">\"ApplicationContext.xml\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.dao = contenxt.getBean(<span class=\"string\">\"userDao\"</span>,UserDao.class)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Junit 프레임워크는 스스로 제어권을 가지고 주도적으로 동작하고, 개발자가 만든 코드는 프레임워크에 의해 수동적으로 실행된다. 그래서 프레임워크에 사용되는 코드만으로는 실행 흐름이 잘보이지 않기 때문에 프레임워크가 어떻게 사용할지를 잘 이해를 하고 있어야 한다.<br>\nJUnit이 하나의 테스트 클래스를 가져와 테스트를 수행하는 방식은 다음과 같다.</p>\n<ol>\n<li>테스트 클래스에서 @Test가 붙은 public이고 void형이며 파라미터가 없는 테스트 메소드를 모두 찾는다.</li>\n<li>테스트 클래스의 오브젝트를 하나 만든다.</li>\n<li>@before가 붙은 메소드가 있으면 실행한다.</li>\n<li>@test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.</li>\n<li>@after가 붙은 메소드가 있으면 실행한다.</li>\n<li>나머지 테스트 메소드에 대해 2~5번을 반복한다.</li>\n<li>모든 테스트의 결과를 종합해서 돌려준다.<br>\n크게 이렇게 7단계를 거쳐서 진행된다고 볼 수 있다.</li>\n</ol>\n<p>한가지 기억해야할점은 실행되는 각테스트 클래스는 실행때마다 새롭게 만들어진다. 한번 만들어진 테스트 클래스는 하나의 오브젝트는 테스트 메소드가 사용하고나면 버려진다. 만약 해당 클래스가 @test 메소드를 2개가지고있다면 2개의 오브젝트를 만들고 각각 테스트 될것이다.</p>\n<p><img src=\"https://i.imgur.com/eq09toD.png\" alt=\"\"></p>\n<h3><span id=\"24-스프링-테스트-적용\">2.4 스프링 테스트 적용</span></h3>\n<p>@Before메소드가 테스트 메소드 개수만큼 반복되기 떄문에 어플리케이션 컨텍스트도 3번 만들어진다. 지금은 이 빈을 생성하는데 얼마 걸리지 않지만 나중에 빈이 많이 등록되고 그러면 이 빈 컨텍스트를 만드는데 많은 시간이 걸린다. 그래서 ApplicationContext같은경우에는 스태틱필드에 저장해두고 공통 변수로 사용하면 효율적으로 사용할 수 있게 된다. JUnit은 테스트 클래스 전체에 걸쳐 딱 한번만 실행되는 @BeforeClass 스태틱 메소드를 지원한다. 하지만 이보다는 스프링이 직접제공해주는 어플리케이션 컨텍스트 테스트 지원기능을 사용하는것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith</span>(SpringJUnit4ClassRunner.class) <span class=\"comment\">// Spring 테스트 컨텍스트 프레임워크의 JUnit확장 기능 지정</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration</span>(classes=&#123;DaoFactory.class&#125;) <span class=\"comment\">// 테스트 컨텍스트가 자동으로 만들어줄 어플리케이션 컨텍스트의 위치</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDaoTest</span></span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> ApplicationContext context; <span class=\"comment\">//위에서 제공해주는 컨텍스트로 의존성주입됨</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Before</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUp</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.dao = <span class=\"keyword\">this</span>.context.getBean(<span class=\"string\">\"UserDao\"</span>,UserDao.class);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>@RunWith는 Junit프레임워크의 테스트 실행방법을 확장할 때 사용하는 애노테이션이다. SpringJUnit4ClassRunner는 Junit용 테스트 컨텍스트 프레임워크 확장 클래스를 지정해주면 JUnit이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행해준다.</p>\n<p>@ContextConfiguration은 자동으로 만들어줄 애플리케이션 컨텍스트 설정위치를 지정한것이다.</p>\n<h4><span id=\"테스트-메소드의-컨텍스트-공유\">테스트 메소드의 컨텍스트 공유</span></h4>\n<p>@Before은 매 테스트코드가 실행될때 마다 실행되게 메소드를 설정해주 어노테이션이다. 만약 2개의 테스트 메소드를 실행한다면 this.context 같은 오브젝트일것이다. 위에서 @RunWith 어노테이션때문에 한번만 context를 load할것이기 때문이다. 반면 this는 테스트메소드마다 새롭게 생성된 오브젝트 일것이다</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Before</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUp</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  System.out.println(<span class=\"keyword\">this</span>.context);</span><br><span class=\"line\">  System.out.println(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4><span id=\"테스트-클래스의-컨텍스트-공유\">테스트 클래스의 컨텍스트 공유</span></h4>\n<p>만약 여러개의 테스트 클래스가 있는데 모두 같은 설정파일을 가진 애플리케이션 컨텍스트를 사용한다면, 스프링은 테스트클래스 사이에서도 애플리케이션 컨텍스트를 공유하여 사용한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration</span>(classes=&#123;DaoFactory.class&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDaoTest</span></span>&#123;..&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration</span>(classes=&#123;DaoFactory.class&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GroupDaoTest</span></span>&#123;..&#125;</span><br></pre></td></tr></table></figure>\n<p>만약 위와같이 두개의 다른 테스트클래스가 있더라도, DaoFactory에 관한 Context는 한번만 올라가지게 된다. 따라서 수백 개의 테스트 클래스를 만들어도 모두 같은 설정파일을 사용하게 된다. 당연히 테스트파일을 실행시켜도 한번만 Context가 load될것이다.</p>\n<h4><span id=\"autowired를-통한-의존성주입\">@Autowired를 통한 의존성주입</span></h4>\n<p>아래는 dataSource를 의존성을 주입하는 방법이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> SimpleDriverDataSource datasource;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> DataSource datasource;</span><br></pre></td></tr></table></figure>\n<p>위 방법중에 어느방식을 사용해서 의존성주입을 해도 상관은없다. 하지만 인터페이스를 선언한것이 좀더 확장성 있게 개발할 수 있다. 인터페이스를 사용하면 총 몇가지의 장점을 가진다.<br>\n첫째, 인터페이스를 사용하여 의존성주입을 하게되면 해당 의존성주입의 클래스부분만 bean을 등록해주면 되기때문이다.<br>\n둘째, 1장에서 만들었던 DB커넥션의 개수를 카운팅하는 부가기능이 대표적인예이다. 추가 기능을 확장하는데 아주 좋다.</p>\n<h4><span id=\"테스트를-위한-별도의-di설정\">테스트를 위한 별도의 DI설정</span></h4>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ContextConfiguration</span>(classes=&#123;DaoFactory.class&#125;)</span><br></pre></td></tr></table></figure>\n<p>테스트를 위해 설정 클래스파일을 하나 더만들어 구성하면 쉽게 개발용 테스트 클래스를 실행할 수 있다. 이렇게 하면 테스트환경에서 적합한 구성을 가진 설정파일을 이용해서 테스트를 진행할 수 있다.</p>\n<p><a href=\"https://github.com/minwan1/Spring-toby\" target=\"_blank\" rel=\"noopener\">예제소스</a></p>\n<h2><span id=\"정리\">정리</span></h2>\n<ul>\n<li>\n<p>Test 주도 개발로 개발을 하게 되면 너무나도 많은 장점을 가지는 것 같다. 일단 변화를 두려워 하지않는다. 소스 리팩토링, 기능변경 이 있더라도 개발을한 후 간단하게 테스트를 할 수 있기 때문이다.</p>\n</li>\n<li>\n<p>또 개발 시간이 단축된다. 단순 개발시간만 놓고보면 당연히 개발시간이 단축된다고 말할 수 는 없다.하지만 예를들어 User 정보 변경 기능을 개발한다고 치면 개발을 하고 매번 테스트 하기위해서는 프론트엔드와 연결을하고 테스트 해야한다. 단순 유저 정보 변경 기능 개발인데 프론트엔드가 없으면 개발 테스트를 못하게 된다. 물론 Postman, Curl등을 호출해 API 테스트를 할 수 있겠지만 문제는 API하나 테스트를 위해 몇분의 서버 로딩을 기다려야한다. 하지만 Unit 테스트등으로는 몇개의 빈만 올리고 테스트할 수 있기때문에 개발 및 테스트 시간을 아낄 수 있게 된다.</p>\n</li>\n<li>\n<p>그리고 테스트 주도 개발을 하게 되면 자연스럽게 단일 책임 원칙, 개방 폐쇄 원칙을 준수하게 되는 것 같다. 왜냐 테스트 코드를 작성하다 보면 왠지 모르게 테스트 코드가 작성하기가 어려울 때 가 있는데 이때 단일 책임 원칙, 개방 폐쇄 원칙을 지키지 않고 있을가망성이 크기때문이다. 이럴 때 보면 보통 하나의 클래스에 너무 많은 책임을 줬기 때문에 테스트 코드를 작성하기가 어려워지는 경우가 많다. 일단 테스트 코드가 작성하기 어렵다는 것은 지금 만들고자 하는 기능이 뭔가 SOLID 원칙을 위반하고 있다는 것을 의심해봐야 한다.</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>토비의 스프링</h1>\n<p>이글은 <a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=7006516\" target=\"_blank\" rel=\"noopener\">토비님의 스프링책</a>을 보고 요약한 내용입니다</p>\n<h2>테스트</h2>\n<p>스프링이 개발자에게 제공하는 가장 중요한 가치가 무엇이냐고 질문한다면 그것은 객체지향과 테스트라고 한다. 엔터프라이즈 앱은 변화가 계속해서 일어난다. 이런 변환에 대응하는 첫 번째 전략이 확장과 변화를 고려한 객체지향적 설계와 그것을 효과적으로 담아낼 수 있는 IoC/DI같은기술이다. 두번째 전략은 만들어진 코드를 확실할 수 있게 해주고, 변화에 유연하게 대처할 수 있는 자신감을 주는 테스트 기술이다.</p>\n<h3>2.1 UserDaoTest 다시 보기</h3>\n<h4>테스트의 유용성</h4>\n<p>테스트 코드를 작성하게 되면 자신이 작성한 코드가 제대로 작동하는지 확인할 수 있다. 이를 통해 코드의 결함(의존성)을 제거해가는 작업, 디버깅을 거치게 되고 최종적으로 테스트가 성공하면 모든 결함이 제거됐다는 확인을 얻을 수 있다.</p>\n<h4>UserDaoTest특징</h4>\n<p>다시 1장에서 작성한 UserDao 테스트의 장점을 간단하게 봐보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDaoTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> ApplicationContext context = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(DaoFactory.class);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> UserDao userDao = context.getBean(<span class=\"string\">\"userDao\"</span>,UserDao.class);</span><br><span class=\"line\"></span><br><span class=\"line\">        User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">        user.setId(<span class=\"string\">\"whiteship\"</span>);</span><br><span class=\"line\">        user.setName(<span class=\"string\">\"백기선\"</span>);</span><br><span class=\"line\">        user.setPassword(<span class=\"string\">\"married\"</span>);</span><br><span class=\"line\">        userDao.add(user);</span><br><span class=\"line\">        System.out.println(user.getId() + <span class=\"string\">\" 등록 성공\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        User user2 = userDao.get(user.getId());</span><br><span class=\"line\">        System.out.println(user2.getName());</span><br><span class=\"line\">        System.out.println(user2.getPassword());</span><br><span class=\"line\">        System.out.println(user2.getId() + <span class=\"string\">\" 조회 성공\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위의 UserDaoTest를 이용해 작성한 테스트 코드의 장점은 아래와 같을 수 있을것이다.</p>\n<ul>\n<li>자바에서 가장 손쉽게 실행가능한 main()함수를 사용해 테스트할 수 있다.</li>\n<li>테스트의 결과를 콘솔로 확인할 수 있다.</li>\n<li>테스트에 사용할 객체들의 의존성을 쉽게 주입해줄 수 있다.</li>\n</ul>\n<p>만약 테스트코드 작성이 아닌 구현을 통한 테스트는 아래와같은 문제점을 가질 수 있다.</p>\n<p><strong>웹을 통한 DAO 테스트 방법의 문제점</strong><br>\n웹화면을 통해 DAO를 테스트하게되면 프리젠테이션계층, 서비스계층을 포함한 모든 입출력기능을 대충이라도 테스트해야만한다. 좀 더 자세히말하면 서비스클래스, 컨트롤러, 뷰단 모든 레이어의 기능을 다만들어야만 테스트를 할 수 있다는 단점이 있다.</p>\n<p><strong>작은 단위의 테스트 필요성</strong><br>\n한꺼번에 너무많은것을 몰아서 테스트하면 테스트 수행과정도 복잡해지고 오류가 발생했을 때 정확한 원인을 찾기도 힘들어진다. 따라서 테스틑 가능하면 작은 단위로 쪼개서 집중해서 할수 있어야 한다.</p>\n<p>때로는 긴 시나리오에 테스트를 하는경우도 있을것이다. 예를들어 회원가입 - 로그인 - 로그아웃 - 회원삭제, 하지만 이흐름을 한번에 시키다가 에러가 발생하면 어느부분에서 에러가 낫는지 확인하기위해 많은 디버깅 시간이 필요할 것 이다. 하지만 미리 단위 테스트하고 그다음 긴 시나리오를 진행하게되면 예외가 발생하거나 테스트가 실패할 수 있지만, 좀더 에러의 원인을 빨리 잡을 가망성이 커진다. 이렇기 때문에 각각의 기능을 쪼개서 테스트할필요가 있다.</p>\n<h4>UserDaoTest의 문제점</h4>\n<p>위에 작성한 UserDaoTest가 직접 테스트하는 방법보다는 훨씬 효율적인 방법이다. 좋은 방법임에도 불구하고 몇가지 만족스럽지 못한것은 사실이다. 예를들어 테스트 코드를 개발자가 직접 실행시켜야한다거나 그결과를 직접 확인해야한다는것이다. 그래서 이러한문제를 체계적으로 해결할 수 있는 프레임워크를 스프링에서 제공해준다. 그것이 바로 Junit 테스트 프레임워크이다.</p>\n<h3>2.2 JUnit 테스트로 전환</h3>\n<h4>Junit테스트로 전환</h4>\n<p>JUnit프레임워크는 두가지 조건을 따라야 한다. 첫번째는 public 으로 선언 돼야하고, 다른하나는 메소드에 @test라는 애노테이션을 붙여야한다.</p>\n<h4>검증 코드 전환</h4>\n<p>Junit code에서 assertThat()메소드는 첫 번째 파라미터의 값을 뒤에나오는 matcher라고 불리는 조건으로 비교해서 일치하면 다음으로 넘어가고, 아니면 테스트가 실패하도록 만들어준다. is()는 matcher의 일종으로 equals()로 비교해주는 기능을 가졌다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">assertThat(user2.getPassword(), is(user.getPassword())); <span class=\"comment\">// 같지않으면 다음단계로 못넘어감</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(!user.getName.equals(user2.getName()))&#123;</span><br><span class=\"line\">  <span class=\"comment\">//마찬가지</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>2.3 개발자를 위한 테스팅 프레임워크 JUnit</h3>\n<h4>테스트 결과의 일관성</h4>\n<p>테스트를 하다 보면 외부 상태에 따라 성공하기도 실패하기도한다. 당연히 성공해야하는 상황도 실패하는경우가있다. 예를들어 데이터베이스가 이전에 테스트했던 데이터가 들어가있어 중복 문제로 인하여 테스트가 실팽하는 경우 등이 있을 수 있다. 가장 좋은 해결책은 addAndGet()같은 메소드가 테스트를 마치고 나면 테스트가 등록한 사용자 정보를 삭제해서, 테스트를 수행하기 이전 상태로 만들어주는 것이다. 그러면 아무리 많은 테스트를 해도 항상 동일한 테스트 결과를 얻을 것 이다.</p>\n<h5>deleteAll()의 getCount() 추가</h5>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">deleteAll</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException</span>&#123;</span><br><span class=\"line\">  System.out.println(<span class=\"string\">\"delete from users\"</span>); <span class=\"comment\">//실제로는 해당기능 실제 수행</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getCount</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> SQLException</span>&#123;</span><br><span class=\"line\">  System.out.println(<span class=\"string\">\"select count(*) from users\"</span>); <span class=\"comment\">//실제로는 해당기능 실제 수행</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2></h2>\n<p>테스트의 결과가 테스트(메소드) 실행 순서에 영향을 받는다면 테스트를 잘못 만든 것이다. 모든 테스트는 실행순서에 상관없이 독립적으로 항상 동일한 결과를 낼수 있도록 해야한다.</p>\n<p>JUnit은 예외조건 테스트를 위한 특별한 방법을 제공해준다. Junit의 예외 테스트 기능을 이용하면 아래와 같이 테스트를 만들 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span>(expected = EmptyResultDataAccessException.class)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">getUserFailure</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//비지니스로직하다가 예상되어지는 exception발생시 성공</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>테스트 코드를 작성할때는 조건, 행위, 결과에대한 내용이 잘 표현되어 있어야 한다. 이렇게 구현하다보면 마치 잘작성된 하나의 기능정의서처럼 보인다. 그래서 보통 기능설계, 구현, 테스트라는 일반적인 개발 흐름의 기능설계에 해당하는 부분을 테스트 코드가 일부분 담당하고 있다고 볼 수 있다. 마치 코드로 된 설계 문서 처럼 만들어놓 것이라고 생각해보자.</p>\n<h5>테스트 주도 개발(TDD)</h5>\n<p>만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법을 테스트 주도 개발이라고한다. 또는 테스트우선개발 Test First Development라고도 한다.</p>\n<p>#####Before<br>\n미리 JUnit테스트가 시작되기전에 before이라는 어노테이션을 이용해 아래와 같이 필요한 변수를 셋팅하고 시작할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDaoTest</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> UserDao dao;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Before</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUp</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    ApplicationContext context = <span class=\"keyword\">new</span> GenericXmlApplicationContext(<span class=\"string\">\"ApplicationContext.xml\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.dao = contenxt.getBean(<span class=\"string\">\"userDao\"</span>,UserDao.class)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Junit 프레임워크는 스스로 제어권을 가지고 주도적으로 동작하고, 개발자가 만든 코드는 프레임워크에 의해 수동적으로 실행된다. 그래서 프레임워크에 사용되는 코드만으로는 실행 흐름이 잘보이지 않기 때문에 프레임워크가 어떻게 사용할지를 잘 이해를 하고 있어야 한다.<br>\nJUnit이 하나의 테스트 클래스를 가져와 테스트를 수행하는 방식은 다음과 같다.</p>\n<ol>\n<li>테스트 클래스에서 @Test가 붙은 public이고 void형이며 파라미터가 없는 테스트 메소드를 모두 찾는다.</li>\n<li>테스트 클래스의 오브젝트를 하나 만든다.</li>\n<li>@before가 붙은 메소드가 있으면 실행한다.</li>\n<li>@test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.</li>\n<li>@after가 붙은 메소드가 있으면 실행한다.</li>\n<li>나머지 테스트 메소드에 대해 2~5번을 반복한다.</li>\n<li>모든 테스트의 결과를 종합해서 돌려준다.<br>\n크게 이렇게 7단계를 거쳐서 진행된다고 볼 수 있다.</li>\n</ol>\n<p>한가지 기억해야할점은 실행되는 각테스트 클래스는 실행때마다 새롭게 만들어진다. 한번 만들어진 테스트 클래스는 하나의 오브젝트는 테스트 메소드가 사용하고나면 버려진다. 만약 해당 클래스가 @test 메소드를 2개가지고있다면 2개의 오브젝트를 만들고 각각 테스트 될것이다.</p>\n<p><img src=\"https://i.imgur.com/eq09toD.png\" alt=\"\"></p>\n<h3>2.4 스프링 테스트 적용</h3>\n<p>@Before메소드가 테스트 메소드 개수만큼 반복되기 떄문에 어플리케이션 컨텍스트도 3번 만들어진다. 지금은 이 빈을 생성하는데 얼마 걸리지 않지만 나중에 빈이 많이 등록되고 그러면 이 빈 컨텍스트를 만드는데 많은 시간이 걸린다. 그래서 ApplicationContext같은경우에는 스태틱필드에 저장해두고 공통 변수로 사용하면 효율적으로 사용할 수 있게 된다. JUnit은 테스트 클래스 전체에 걸쳐 딱 한번만 실행되는 @BeforeClass 스태틱 메소드를 지원한다. 하지만 이보다는 스프링이 직접제공해주는 어플리케이션 컨텍스트 테스트 지원기능을 사용하는것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith</span>(SpringJUnit4ClassRunner.class) <span class=\"comment\">// Spring 테스트 컨텍스트 프레임워크의 JUnit확장 기능 지정</span></span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration</span>(classes=&#123;DaoFactory.class&#125;) <span class=\"comment\">// 테스트 컨텍스트가 자동으로 만들어줄 어플리케이션 컨텍스트의 위치</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDaoTest</span></span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> ApplicationContext context; <span class=\"comment\">//위에서 제공해주는 컨텍스트로 의존성주입됨</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Before</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUp</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.dao = <span class=\"keyword\">this</span>.context.getBean(<span class=\"string\">\"UserDao\"</span>,UserDao.class);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>@RunWith는 Junit프레임워크의 테스트 실행방법을 확장할 때 사용하는 애노테이션이다. SpringJUnit4ClassRunner는 Junit용 테스트 컨텍스트 프레임워크 확장 클래스를 지정해주면 JUnit이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행해준다.</p>\n<p>@ContextConfiguration은 자동으로 만들어줄 애플리케이션 컨텍스트 설정위치를 지정한것이다.</p>\n<h4>테스트 메소드의 컨텍스트 공유</h4>\n<p>@Before은 매 테스트코드가 실행될때 마다 실행되게 메소드를 설정해주 어노테이션이다. 만약 2개의 테스트 메소드를 실행한다면 this.context 같은 오브젝트일것이다. 위에서 @RunWith 어노테이션때문에 한번만 context를 load할것이기 때문이다. 반면 this는 테스트메소드마다 새롭게 생성된 오브젝트 일것이다</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Before</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUp</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  System.out.println(<span class=\"keyword\">this</span>.context);</span><br><span class=\"line\">  System.out.println(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4>테스트 클래스의 컨텍스트 공유</h4>\n<p>만약 여러개의 테스트 클래스가 있는데 모두 같은 설정파일을 가진 애플리케이션 컨텍스트를 사용한다면, 스프링은 테스트클래스 사이에서도 애플리케이션 컨텍스트를 공유하여 사용한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration</span>(classes=&#123;DaoFactory.class&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDaoTest</span></span>&#123;..&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class=\"line\"><span class=\"meta\">@ContextConfiguration</span>(classes=&#123;DaoFactory.class&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GroupDaoTest</span></span>&#123;..&#125;</span><br></pre></td></tr></table></figure>\n<p>만약 위와같이 두개의 다른 테스트클래스가 있더라도, DaoFactory에 관한 Context는 한번만 올라가지게 된다. 따라서 수백 개의 테스트 클래스를 만들어도 모두 같은 설정파일을 사용하게 된다. 당연히 테스트파일을 실행시켜도 한번만 Context가 load될것이다.</p>\n<h4>@Autowired를 통한 의존성주입</h4>\n<p>아래는 dataSource를 의존성을 주입하는 방법이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> SimpleDriverDataSource datasource;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> DataSource datasource;</span><br></pre></td></tr></table></figure>\n<p>위 방법중에 어느방식을 사용해서 의존성주입을 해도 상관은없다. 하지만 인터페이스를 선언한것이 좀더 확장성 있게 개발할 수 있다. 인터페이스를 사용하면 총 몇가지의 장점을 가진다.<br>\n첫째, 인터페이스를 사용하여 의존성주입을 하게되면 해당 의존성주입의 클래스부분만 bean을 등록해주면 되기때문이다.<br>\n둘째, 1장에서 만들었던 DB커넥션의 개수를 카운팅하는 부가기능이 대표적인예이다. 추가 기능을 확장하는데 아주 좋다.</p>\n<h4>테스트를 위한 별도의 DI설정</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@ContextConfiguration</span>(classes=&#123;DaoFactory.class&#125;)</span><br></pre></td></tr></table></figure>\n<p>테스트를 위해 설정 클래스파일을 하나 더만들어 구성하면 쉽게 개발용 테스트 클래스를 실행할 수 있다. 이렇게 하면 테스트환경에서 적합한 구성을 가진 설정파일을 이용해서 테스트를 진행할 수 있다.</p>\n<p><a href=\"https://github.com/minwan1/Spring-toby\" target=\"_blank\" rel=\"noopener\">예제소스</a></p>\n<h2>정리</h2>\n<ul>\n<li>\n<p>Test 주도 개발로 개발을 하게 되면 너무나도 많은 장점을 가지는 것 같다. 일단 변화를 두려워 하지않는다. 소스 리팩토링, 기능변경 이 있더라도 개발을한 후 간단하게 테스트를 할 수 있기 때문이다.</p>\n</li>\n<li>\n<p>또 개발 시간이 단축된다. 단순 개발시간만 놓고보면 당연히 개발시간이 단축된다고 말할 수 는 없다.하지만 예를들어 User 정보 변경 기능을 개발한다고 치면 개발을 하고 매번 테스트 하기위해서는 프론트엔드와 연결을하고 테스트 해야한다. 단순 유저 정보 변경 기능 개발인데 프론트엔드가 없으면 개발 테스트를 못하게 된다. 물론 Postman, Curl등을 호출해 API 테스트를 할 수 있겠지만 문제는 API하나 테스트를 위해 몇분의 서버 로딩을 기다려야한다. 하지만 Unit 테스트등으로는 몇개의 빈만 올리고 테스트할 수 있기때문에 개발 및 테스트 시간을 아낄 수 있게 된다.</p>\n</li>\n<li>\n<p>그리고 테스트 주도 개발을 하게 되면 자연스럽게 단일 책임 원칙, 개방 폐쇄 원칙을 준수하게 되는 것 같다. 왜냐 테스트 코드를 작성하다 보면 왠지 모르게 테스트 코드가 작성하기가 어려울 때 가 있는데 이때 단일 책임 원칙, 개방 폐쇄 원칙을 지키지 않고 있을가망성이 크기때문이다. 이럴 때 보면 보통 하나의 클래스에 너무 많은 책임을 줬기 때문에 테스트 코드를 작성하기가 어려워지는 경우가 많다. 일단 테스트 코드가 작성하기 어렵다는 것은 지금 만들고자 하는 기능이 뭔가 SOLID 원칙을 위반하고 있다는 것을 의심해봐야 한다.</p>\n</li>\n</ul>\n"},{"title":"Euqals, Hashcode 메소드에 대해 알아보자.","catalog":true,"date":"2018-07-02T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n\n## Euqals, Hashcode 메소드에 대해 알아보자.\n\n먼저 equals 메서드와 hash code가 왜 필요한지를 간단하게 알아보자. 만약 아래처럼 member1객체와 member2객체를 선언하고 객체를 비교했을 때 true 값을 받을 수 있을까 ?? 그렇다.. 너무 쉬운 질문이었다. 답은 당연히 false 일 것이다. 그 이유는 둘은 동일 객체가 아니기 때문이다.\n\n```java\npublic class Test {\n\n    public static void main(String[] args){\n\n        final Member member1 = new Member(\"1\");\n        final Member member2 = new Member(\"1\");\n\n        System.out.println(member1 == member2); // false\n        System.out.println(member1.equals(member2)); // false\n    }\n\n    public static class Member{\n\n        private String id;\n\n        public Member(final String id) {\n            this.id = id;\n        }\n    }\n\n}\n```\n\n동일 객체란 서로 같은 참조를 바라보는 것을 말한다. 예를 들어 아래와 같을 수 있다.\n\n```java\npublic class Test {\n\n    public static void main(String[] args){\n\n        final Member member1 = new Member(\"1\");\n        final Member member2 = member1;\n\n        System.out.println(member1 == member2);//true\n        System.out.println( member1.equals(member2));//true\n    }\n\n    public static class Member{\n\n        private String id;\n\n        public Member(String id) {\n            this.id = id;\n        }\n    }\n\n}\n\n```\n위에 예제는 둘 다 true 값이 나온다. 이것을 동일 객체라고 한다. 하지만 이렇게 생각할 수 있다. 유저의 id는 동일한데 왜 다른 유저가 되는지에 대해서... 보통 자바에서 이것을 동등 객체라고 한다. 동등 객체를 비교하기 위해서는 equals 함수를 사용해야 한다. 하지만 처음 예제에서 equals 함수도 false 값이 나왔다. 이러한 이유는 equals 함수를 재정의하지 않았기 때문이다. 아래에 예제에서 좀 더 자세하게 equals 메소드를 알아보자.\n\n## 객체 비교(equals())\n\n다음은 Object의 equals() 메소드이다.\n```java\npublic boolean equals(Object obj){...}\n```\n\nObject 클래스의 equals()는 아래와같은 기능으로써 이 메소드는 비교 연사자인 == 과 동일한 결과를 리턴한다. 오로지 참조값이 같은지, 다시말하면 동일 객체인지를 확인하는 기능이다.\n```java\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n```\n\n자바에서는 두 객체를 동등 비교할 때 equals() 메소드를 흔히 사용한다. equals() 메소드는 두 객체를 비교해서 논리적으로 동등하면 true를 리턴하고 그렇지 않으면 false를 리턴한다. 논리적으로 동등하다는것은 둘의 참조값이 다르더라도 객체 내부 value는 같다는것을 의미한다. 이 equals함수를 재정의한 대표적인예가 String class이다. String class는 equals() 메소드를 재정의해서 번지비교가 아닌 문자열리 비교한다. 아래는 String class의 euqals 메소드의 내용 소스이다.\n\n```java\n//String class\npublic boolean equals(Object anObject) {\n    if (this == anObject) {\n        return true;\n    }\n    if (anObject instanceof String) {\n        String anotherString = (String)anObject;\n        int n = value.length;\n        if (n == anotherString.value.length) {\n            char v1[] = value;\n            char v2[] = anotherString.value;\n            int i = 0;\n            while (n-- != 0) {\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n위 소스를 보면 Object로 객체를 받아 하나하나 문자열을 비교하는것을 볼 수 있다. char은 참조값이 아닌 기본값이기 때문에 == 만으로도 값비교가 된다.\n>팁 <br> String 을 이용해 문자열 리터럴 방식으로 문자열을정의하면 동일 객체를 생성하게 되어있다.\n\n예를 들어 Member라는 클래스가 있는데 여기에 Id값이 같은면 동등객체로 취급하고싶다면 equals()메소드를 재정의해서 id 필드값이 같음을 비교하면 된다. 아래는 그의 해당하는 예제이다.\n\n```java\npublic class Member {\n  public String id;\n  public Member(String id){\n    this.id = id;\n  }\n\n  @Override\n  public boolean equals(Object obj){\n    if(obj instanceof Member){\n      Member member = (Member) obj;\n      if(id.equals(member.id)){\n        return true;\n      }\n    }\n  }\n  return false;\n}\n```\n위와같이 equals메소드를 재정의하게 되면 Member 객체를 통해 객체를 비교할 때 Id가 같다면 두 객체는 동등 객체가 될 것이다\n\n* 동일성 비교는 == 비교다. 객체 인스턴스의 주소 값을 비교한다.\n* 동등성 비교는 equals() 메소드를 사용해서 객체 내부의 값을 비교한다.\n\n## Java hash code란\n객체 해시코드란 객체를 실별할 하나의 정수값을 말한다. Object의 hashCode() 메소드는 객체의 메모리 번지를 이용해서 해시코드를 만들어 리턴하기 때문에 객체 마다 다른 값을 가지고 있다. 객체의 값을 동등성 비교시 hashCode()를 오버라이딩할 필요성이 있는데, 컬렉션 프레임워크에서 HashSet, HashMap, HashTable은 다음과 같은 방법으로 두 객체가 동등한지 비교한다.\n\n우선 hashCode() 메소드를 실행해서 리턴된 해시코드 값이 같은지를 본다. 해시 코드값이 다르면 다른 객체로 판단하고, 해시 코드값이 같으면 equals()메소드로 다시 비교한다. 이두개가 모두 맞아야 동등 객체로 판단한다.\n\n![](https://i.imgur.com/dShPCEh.png)\n\n다음 예제를 보면 Key클래스 equals 메소드를 재정의해서 number필드값이 같으면 true를 리턴하도록했다. 그러나 hashCode메소드는 재정의 하지 않았기 때문에 Object의 hashCode() 메소드가 사용된다.\n\n```java\npublic class Key{\n  public int number;\n\n  public Key(int number){\n    this.number = number;\n  }\n\n  @override\n  public boolean equals(Object obj){\n    if(obj instanceof Key){\n      Key compareKey = (Key) obj;\n      if(this.number == compareKey.number){\n        return true;\n      }\n    }\n    return false;\n  }\n}\n```\n\n이런 경우 두개의 동등한 객체를 HashMap의 식별키로 Key 객체를 사용하면 저장된 값을 찾아 오지 못한다. 왜냐하면 number 필드값이 같더라도 hashCode() 메소드에서 리턴하는 해시코드가 다르기 때문에 다른 식별키로 익식하기 때문이다. 실제 예제를 실행해보고 확인해보자.\n\n```java\npublic class KeyExample{\n  public static void main(String[] args){\n\n    //Key 객체를 식별키로 사용해서 String 값을 저장하는 HashMap 객체생성.\n    HashMap<Key, String> hashMap = new HashMap<Key, String>();\n\n    //식별키 \"new key(1)\"로 \"홍길동\"을 저장함\n    hashMap.put(new Key(1), \"홍길동\");\n\n    //식별키 \"new key(1)\"로 \"홍길동\"을 읽어옴\n    String value = hashMap.get(new Key(1));\n    System.out.println(value);\n  }\n}\n```\n위에 내용에서 Hash Code를 정의하지 않았기 때문에 값은 null이 조회될 것이다. 만약 의도한 대로 홍길동을 읽으려면 아래와 같이 hashCode를 재정의 해야 한다.\n\n```java\npublic class Key{\n...\n  @override\n  public int hashCode(Object obj){\n    return number;\n  }\n\n}\n```\n저장할 때의 new Key(1)과 읽을때의 new Key(1)은 다른 참조값의 다른 객체지이지만 HashMap은 hashCode()의 리턴값이 같고, equals() 리턴값이 true가 나오기 때문에 두 객체는 동등 객체로 평가하여 하나의 키처럼키 사용하게 된다. 즉, 같은 식별키로 인식한다는 뜻이다. **이러한 이유로 객체의 동등 비교를 위해서는 Object의 equals() 메소드만 재정의하지 말고 hashCode()메소드도 재정의해서 논리적 동등 객체일경우 동일한 해시코드가 리턴되도록 해야한다.**\n\n여기에서 다시 한번 말하면 키를 기반으로 찾는 것이지 객체의 참조 값으로 찾는 것은 아니다. 고로 hash 코드값이 같다고 해서 객체의 참조 값이 같은 것은 아니다.\n\n### 해시코드 생성(hash(), hashCode())\nObject중에 해쉬코드를 생성해주는 역할이 있다. 이 Object.hash(Object... values) 메소드는 매개값으로 주어진 값들을 이용해서 해시 코드를 생성하는 역할을하는데, 주어진 매개값들로 배열을 생성하고 Arrays.hashCode(Object[])를 호출해서 해시코드를 얻고 이값을 리턴한다. Object.hash(Object... values) 메소드는 hashCode()를 재정의할 때 리턴값을 생성하기 위해 사용하면 좋다. 클래스 하나가 여러가지 필드를 가지고 있을 때 이 필드들로부터 해시코드를 생성하게 되면 동일한 필드값을 가지는 객체는 동일한 해시코드를 가질 수 있다. 좀 더 정밀한 동등 객체를 이용한다면 이방법을 사용할 수 있다.\n\nIDE 또는 lombock등을 이용해 좀더 쉽게 equals, hashCode를 재정의할 수 도있다.\n\n```java\n@Override\npublic int hashCode() {\n  return Objects.hash(field1, field2, filed3);\n}\n```\n\n\n참고 \n* [이것이 자바다](https://book.naver.com/bookdb/book_detail.nhn?bid=8589375)","source":"_posts/2018-07-03-equals,hashcode.md","raw":"---\ntitle: Euqals, Hashcode 메소드에 대해 알아보자.\ncatalog: true\ndate: 2018-07-03\nsubtitle:\nheader-img:\ntags:\n- Java\n\n\n---\n\n\n## Euqals, Hashcode 메소드에 대해 알아보자.\n\n먼저 equals 메서드와 hash code가 왜 필요한지를 간단하게 알아보자. 만약 아래처럼 member1객체와 member2객체를 선언하고 객체를 비교했을 때 true 값을 받을 수 있을까 ?? 그렇다.. 너무 쉬운 질문이었다. 답은 당연히 false 일 것이다. 그 이유는 둘은 동일 객체가 아니기 때문이다.\n\n```java\npublic class Test {\n\n    public static void main(String[] args){\n\n        final Member member1 = new Member(\"1\");\n        final Member member2 = new Member(\"1\");\n\n        System.out.println(member1 == member2); // false\n        System.out.println(member1.equals(member2)); // false\n    }\n\n    public static class Member{\n\n        private String id;\n\n        public Member(final String id) {\n            this.id = id;\n        }\n    }\n\n}\n```\n\n동일 객체란 서로 같은 참조를 바라보는 것을 말한다. 예를 들어 아래와 같을 수 있다.\n\n```java\npublic class Test {\n\n    public static void main(String[] args){\n\n        final Member member1 = new Member(\"1\");\n        final Member member2 = member1;\n\n        System.out.println(member1 == member2);//true\n        System.out.println( member1.equals(member2));//true\n    }\n\n    public static class Member{\n\n        private String id;\n\n        public Member(String id) {\n            this.id = id;\n        }\n    }\n\n}\n\n```\n위에 예제는 둘 다 true 값이 나온다. 이것을 동일 객체라고 한다. 하지만 이렇게 생각할 수 있다. 유저의 id는 동일한데 왜 다른 유저가 되는지에 대해서... 보통 자바에서 이것을 동등 객체라고 한다. 동등 객체를 비교하기 위해서는 equals 함수를 사용해야 한다. 하지만 처음 예제에서 equals 함수도 false 값이 나왔다. 이러한 이유는 equals 함수를 재정의하지 않았기 때문이다. 아래에 예제에서 좀 더 자세하게 equals 메소드를 알아보자.\n\n## 객체 비교(equals())\n\n다음은 Object의 equals() 메소드이다.\n```java\npublic boolean equals(Object obj){...}\n```\n\nObject 클래스의 equals()는 아래와같은 기능으로써 이 메소드는 비교 연사자인 == 과 동일한 결과를 리턴한다. 오로지 참조값이 같은지, 다시말하면 동일 객체인지를 확인하는 기능이다.\n```java\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n```\n\n자바에서는 두 객체를 동등 비교할 때 equals() 메소드를 흔히 사용한다. equals() 메소드는 두 객체를 비교해서 논리적으로 동등하면 true를 리턴하고 그렇지 않으면 false를 리턴한다. 논리적으로 동등하다는것은 둘의 참조값이 다르더라도 객체 내부 value는 같다는것을 의미한다. 이 equals함수를 재정의한 대표적인예가 String class이다. String class는 equals() 메소드를 재정의해서 번지비교가 아닌 문자열리 비교한다. 아래는 String class의 euqals 메소드의 내용 소스이다.\n\n```java\n//String class\npublic boolean equals(Object anObject) {\n    if (this == anObject) {\n        return true;\n    }\n    if (anObject instanceof String) {\n        String anotherString = (String)anObject;\n        int n = value.length;\n        if (n == anotherString.value.length) {\n            char v1[] = value;\n            char v2[] = anotherString.value;\n            int i = 0;\n            while (n-- != 0) {\n                if (v1[i] != v2[i])\n                    return false;\n                i++;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n위 소스를 보면 Object로 객체를 받아 하나하나 문자열을 비교하는것을 볼 수 있다. char은 참조값이 아닌 기본값이기 때문에 == 만으로도 값비교가 된다.\n>팁 <br> String 을 이용해 문자열 리터럴 방식으로 문자열을정의하면 동일 객체를 생성하게 되어있다.\n\n예를 들어 Member라는 클래스가 있는데 여기에 Id값이 같은면 동등객체로 취급하고싶다면 equals()메소드를 재정의해서 id 필드값이 같음을 비교하면 된다. 아래는 그의 해당하는 예제이다.\n\n```java\npublic class Member {\n  public String id;\n  public Member(String id){\n    this.id = id;\n  }\n\n  @Override\n  public boolean equals(Object obj){\n    if(obj instanceof Member){\n      Member member = (Member) obj;\n      if(id.equals(member.id)){\n        return true;\n      }\n    }\n  }\n  return false;\n}\n```\n위와같이 equals메소드를 재정의하게 되면 Member 객체를 통해 객체를 비교할 때 Id가 같다면 두 객체는 동등 객체가 될 것이다\n\n* 동일성 비교는 == 비교다. 객체 인스턴스의 주소 값을 비교한다.\n* 동등성 비교는 equals() 메소드를 사용해서 객체 내부의 값을 비교한다.\n\n## Java hash code란\n객체 해시코드란 객체를 실별할 하나의 정수값을 말한다. Object의 hashCode() 메소드는 객체의 메모리 번지를 이용해서 해시코드를 만들어 리턴하기 때문에 객체 마다 다른 값을 가지고 있다. 객체의 값을 동등성 비교시 hashCode()를 오버라이딩할 필요성이 있는데, 컬렉션 프레임워크에서 HashSet, HashMap, HashTable은 다음과 같은 방법으로 두 객체가 동등한지 비교한다.\n\n우선 hashCode() 메소드를 실행해서 리턴된 해시코드 값이 같은지를 본다. 해시 코드값이 다르면 다른 객체로 판단하고, 해시 코드값이 같으면 equals()메소드로 다시 비교한다. 이두개가 모두 맞아야 동등 객체로 판단한다.\n\n![](https://i.imgur.com/dShPCEh.png)\n\n다음 예제를 보면 Key클래스 equals 메소드를 재정의해서 number필드값이 같으면 true를 리턴하도록했다. 그러나 hashCode메소드는 재정의 하지 않았기 때문에 Object의 hashCode() 메소드가 사용된다.\n\n```java\npublic class Key{\n  public int number;\n\n  public Key(int number){\n    this.number = number;\n  }\n\n  @override\n  public boolean equals(Object obj){\n    if(obj instanceof Key){\n      Key compareKey = (Key) obj;\n      if(this.number == compareKey.number){\n        return true;\n      }\n    }\n    return false;\n  }\n}\n```\n\n이런 경우 두개의 동등한 객체를 HashMap의 식별키로 Key 객체를 사용하면 저장된 값을 찾아 오지 못한다. 왜냐하면 number 필드값이 같더라도 hashCode() 메소드에서 리턴하는 해시코드가 다르기 때문에 다른 식별키로 익식하기 때문이다. 실제 예제를 실행해보고 확인해보자.\n\n```java\npublic class KeyExample{\n  public static void main(String[] args){\n\n    //Key 객체를 식별키로 사용해서 String 값을 저장하는 HashMap 객체생성.\n    HashMap<Key, String> hashMap = new HashMap<Key, String>();\n\n    //식별키 \"new key(1)\"로 \"홍길동\"을 저장함\n    hashMap.put(new Key(1), \"홍길동\");\n\n    //식별키 \"new key(1)\"로 \"홍길동\"을 읽어옴\n    String value = hashMap.get(new Key(1));\n    System.out.println(value);\n  }\n}\n```\n위에 내용에서 Hash Code를 정의하지 않았기 때문에 값은 null이 조회될 것이다. 만약 의도한 대로 홍길동을 읽으려면 아래와 같이 hashCode를 재정의 해야 한다.\n\n```java\npublic class Key{\n...\n  @override\n  public int hashCode(Object obj){\n    return number;\n  }\n\n}\n```\n저장할 때의 new Key(1)과 읽을때의 new Key(1)은 다른 참조값의 다른 객체지이지만 HashMap은 hashCode()의 리턴값이 같고, equals() 리턴값이 true가 나오기 때문에 두 객체는 동등 객체로 평가하여 하나의 키처럼키 사용하게 된다. 즉, 같은 식별키로 인식한다는 뜻이다. **이러한 이유로 객체의 동등 비교를 위해서는 Object의 equals() 메소드만 재정의하지 말고 hashCode()메소드도 재정의해서 논리적 동등 객체일경우 동일한 해시코드가 리턴되도록 해야한다.**\n\n여기에서 다시 한번 말하면 키를 기반으로 찾는 것이지 객체의 참조 값으로 찾는 것은 아니다. 고로 hash 코드값이 같다고 해서 객체의 참조 값이 같은 것은 아니다.\n\n### 해시코드 생성(hash(), hashCode())\nObject중에 해쉬코드를 생성해주는 역할이 있다. 이 Object.hash(Object... values) 메소드는 매개값으로 주어진 값들을 이용해서 해시 코드를 생성하는 역할을하는데, 주어진 매개값들로 배열을 생성하고 Arrays.hashCode(Object[])를 호출해서 해시코드를 얻고 이값을 리턴한다. Object.hash(Object... values) 메소드는 hashCode()를 재정의할 때 리턴값을 생성하기 위해 사용하면 좋다. 클래스 하나가 여러가지 필드를 가지고 있을 때 이 필드들로부터 해시코드를 생성하게 되면 동일한 필드값을 가지는 객체는 동일한 해시코드를 가질 수 있다. 좀 더 정밀한 동등 객체를 이용한다면 이방법을 사용할 수 있다.\n\nIDE 또는 lombock등을 이용해 좀더 쉽게 equals, hashCode를 재정의할 수 도있다.\n\n```java\n@Override\npublic int hashCode() {\n  return Objects.hash(field1, field2, filed3);\n}\n```\n\n\n참고 \n* [이것이 자바다](https://book.naver.com/bookdb/book_detail.nhn?bid=8589375)","slug":"2018-07-03-equals,hashcode","published":1,"updated":"2018-10-12T16:30:47.666Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27dx002pjjpe86nfrnci","content":"<h2><span id=\"euqals-hashcode-메소드에-대해-알아보자\">Euqals, Hashcode 메소드에 대해 알아보자.</span></h2>\n<p>먼저 equals 메서드와 hash code가 왜 필요한지를 간단하게 알아보자. 만약 아래처럼 member1객체와 member2객체를 선언하고 객체를 비교했을 때 true 값을 받을 수 있을까 ?? 그렇다… 너무 쉬운 질문이었다. 답은 당연히 false 일 것이다. 그 이유는 둘은 동일 객체가 아니기 때문이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Member member1 = <span class=\"keyword\">new</span> Member(<span class=\"string\">\"1\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Member member2 = <span class=\"keyword\">new</span> Member(<span class=\"string\">\"1\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(member1 == member2); <span class=\"comment\">// false</span></span><br><span class=\"line\">        System.out.println(member1.equals(member2)); <span class=\"comment\">// false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> String id;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Member</span><span class=\"params\">(<span class=\"keyword\">final</span> String id)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>동일 객체란 서로 같은 참조를 바라보는 것을 말한다. 예를 들어 아래와 같을 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Member member1 = <span class=\"keyword\">new</span> Member(<span class=\"string\">\"1\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Member member2 = member1;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(member1 == member2);<span class=\"comment\">//true</span></span><br><span class=\"line\">        System.out.println( member1.equals(member2));<span class=\"comment\">//true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> String id;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Member</span><span class=\"params\">(String id)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위에 예제는 둘 다 true 값이 나온다. 이것을 동일 객체라고 한다. 하지만 이렇게 생각할 수 있다. 유저의 id는 동일한데 왜 다른 유저가 되는지에 대해서… 보통 자바에서 이것을 동등 객체라고 한다. 동등 객체를 비교하기 위해서는 equals 함수를 사용해야 한다. 하지만 처음 예제에서 equals 함수도 false 값이 나왔다. 이러한 이유는 equals 함수를 재정의하지 않았기 때문이다. 아래에 예제에서 좀 더 자세하게 equals 메소드를 알아보자.</p>\n<h2><span id=\"객체-비교equals\">객체 비교(equals())</span></h2>\n<p>다음은 Object의 equals() 메소드이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>Object 클래스의 equals()는 아래와같은 기능으로써 이 메소드는 비교 연사자인 == 과 동일한 결과를 리턴한다. 오로지 참조값이 같은지, 다시말하면 동일 객체인지를 확인하는 기능이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> == obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>자바에서는 두 객체를 동등 비교할 때 equals() 메소드를 흔히 사용한다. equals() 메소드는 두 객체를 비교해서 논리적으로 동등하면 true를 리턴하고 그렇지 않으면 false를 리턴한다. 논리적으로 동등하다는것은 둘의 참조값이 다르더라도 객체 내부 value는 같다는것을 의미한다. 이 equals함수를 재정의한 대표적인예가 String class이다. String class는 equals() 메소드를 재정의해서 번지비교가 아닌 문자열리 비교한다. 아래는 String class의 euqals 메소드의 내용 소스이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//String class</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;</span><br><span class=\"line\">        String anotherString = (String)anObject;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = value.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == anotherString.value.length) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> v1[] = value;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> v2[] = anotherString.value;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (v1[i] != v2[i])</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위 소스를 보면 Object로 객체를 받아 하나하나 문자열을 비교하는것을 볼 수 있다. char은 참조값이 아닌 기본값이기 때문에 == 만으로도 값비교가 된다.</p>\n<blockquote>\n<p>팁 <br> String 을 이용해 문자열 리터럴 방식으로 문자열을정의하면 동일 객체를 생성하게 되어있다.</p>\n</blockquote>\n<p>예를 들어 Member라는 클래스가 있는데 여기에 Id값이 같은면 동등객체로 취급하고싶다면 equals()메소드를 재정의해서 id 필드값이 같음을 비교하면 된다. 아래는 그의 해당하는 예제이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> String id;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Member</span><span class=\"params\">(String id)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(obj <span class=\"keyword\">instanceof</span> Member)&#123;</span><br><span class=\"line\">      Member member = (Member) obj;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(id.equals(member.id))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위와같이 equals메소드를 재정의하게 되면 Member 객체를 통해 객체를 비교할 때 Id가 같다면 두 객체는 동등 객체가 될 것이다</p>\n<ul>\n<li>동일성 비교는 == 비교다. 객체 인스턴스의 주소 값을 비교한다.</li>\n<li>동등성 비교는 equals() 메소드를 사용해서 객체 내부의 값을 비교한다.</li>\n</ul>\n<h2><span id=\"java-hash-code란\">Java hash code란</span></h2>\n<p>객체 해시코드란 객체를 실별할 하나의 정수값을 말한다. Object의 hashCode() 메소드는 객체의 메모리 번지를 이용해서 해시코드를 만들어 리턴하기 때문에 객체 마다 다른 값을 가지고 있다. 객체의 값을 동등성 비교시 hashCode()를 오버라이딩할 필요성이 있는데, 컬렉션 프레임워크에서 HashSet, HashMap, HashTable은 다음과 같은 방법으로 두 객체가 동등한지 비교한다.</p>\n<p>우선 hashCode() 메소드를 실행해서 리턴된 해시코드 값이 같은지를 본다. 해시 코드값이 다르면 다른 객체로 판단하고, 해시 코드값이 같으면 equals()메소드로 다시 비교한다. 이두개가 모두 맞아야 동등 객체로 판단한다.</p>\n<p><img src=\"https://i.imgur.com/dShPCEh.png\" alt=\"\"></p>\n<p>다음 예제를 보면 Key클래스 equals 메소드를 재정의해서 number필드값이 같으면 true를 리턴하도록했다. 그러나 hashCode메소드는 재정의 하지 않았기 때문에 Object의 hashCode() 메소드가 사용된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Key</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> number;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Key</span><span class=\"params\">(<span class=\"keyword\">int</span> number)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.number = number;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(obj <span class=\"keyword\">instanceof</span> Key)&#123;</span><br><span class=\"line\">      Key compareKey = (Key) obj;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.number == compareKey.number)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이런 경우 두개의 동등한 객체를 HashMap의 식별키로 Key 객체를 사용하면 저장된 값을 찾아 오지 못한다. 왜냐하면 number 필드값이 같더라도 hashCode() 메소드에서 리턴하는 해시코드가 다르기 때문에 다른 식별키로 익식하기 때문이다. 실제 예제를 실행해보고 확인해보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KeyExample</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Key 객체를 식별키로 사용해서 String 값을 저장하는 HashMap 객체생성.</span></span><br><span class=\"line\">    HashMap&lt;Key, String&gt; hashMap = <span class=\"keyword\">new</span> HashMap&lt;Key, String&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//식별키 \"new key(1)\"로 \"홍길동\"을 저장함</span></span><br><span class=\"line\">    hashMap.put(<span class=\"keyword\">new</span> Key(<span class=\"number\">1</span>), <span class=\"string\">\"홍길동\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//식별키 \"new key(1)\"로 \"홍길동\"을 읽어옴</span></span><br><span class=\"line\">    String value = hashMap.get(<span class=\"keyword\">new</span> Key(<span class=\"number\">1</span>));</span><br><span class=\"line\">    System.out.println(value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위에 내용에서 Hash Code를 정의하지 않았기 때문에 값은 null이 조회될 것이다. 만약 의도한 대로 홍길동을 읽으려면 아래와 같이 hashCode를 재정의 해야 한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Key</span></span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">(Object obj)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> number;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>저장할 때의 new Key(1)과 읽을때의 new Key(1)은 다른 참조값의 다른 객체지이지만 HashMap은 hashCode()의 리턴값이 같고, equals() 리턴값이 true가 나오기 때문에 두 객체는 동등 객체로 평가하여 하나의 키처럼키 사용하게 된다. 즉, 같은 식별키로 인식한다는 뜻이다. <strong>이러한 이유로 객체의 동등 비교를 위해서는 Object의 equals() 메소드만 재정의하지 말고 hashCode()메소드도 재정의해서 논리적 동등 객체일경우 동일한 해시코드가 리턴되도록 해야한다.</strong></p>\n<p>여기에서 다시 한번 말하면 키를 기반으로 찾는 것이지 객체의 참조 값으로 찾는 것은 아니다. 고로 hash 코드값이 같다고 해서 객체의 참조 값이 같은 것은 아니다.</p>\n<h3><span id=\"해시코드-생성hash-hashcode\">해시코드 생성(hash(), hashCode())</span></h3>\n<p>Object중에 해쉬코드를 생성해주는 역할이 있다. 이 Object.hash(Object… values) 메소드는 매개값으로 주어진 값들을 이용해서 해시 코드를 생성하는 역할을하는데, 주어진 매개값들로 배열을 생성하고 Arrays.hashCode(Object[])를 호출해서 해시코드를 얻고 이값을 리턴한다. Object.hash(Object… values) 메소드는 hashCode()를 재정의할 때 리턴값을 생성하기 위해 사용하면 좋다. 클래스 하나가 여러가지 필드를 가지고 있을 때 이 필드들로부터 해시코드를 생성하게 되면 동일한 필드값을 가지는 객체는 동일한 해시코드를 가질 수 있다. 좀 더 정밀한 동등 객체를 이용한다면 이방법을 사용할 수 있다.</p>\n<p>IDE 또는 lombock등을 이용해 좀더 쉽게 equals, hashCode를 재정의할 수 도있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Objects.hash(field1, field2, filed3);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>참고</p>\n<ul>\n<li><a href=\"https://book.naver.com/bookdb/book_detail.nhn?bid=8589375\" target=\"_blank\" rel=\"noopener\">이것이 자바다</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>Euqals, Hashcode 메소드에 대해 알아보자.</h2>\n<p>먼저 equals 메서드와 hash code가 왜 필요한지를 간단하게 알아보자. 만약 아래처럼 member1객체와 member2객체를 선언하고 객체를 비교했을 때 true 값을 받을 수 있을까 ?? 그렇다… 너무 쉬운 질문이었다. 답은 당연히 false 일 것이다. 그 이유는 둘은 동일 객체가 아니기 때문이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Member member1 = <span class=\"keyword\">new</span> Member(<span class=\"string\">\"1\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Member member2 = <span class=\"keyword\">new</span> Member(<span class=\"string\">\"1\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(member1 == member2); <span class=\"comment\">// false</span></span><br><span class=\"line\">        System.out.println(member1.equals(member2)); <span class=\"comment\">// false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> String id;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Member</span><span class=\"params\">(<span class=\"keyword\">final</span> String id)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>동일 객체란 서로 같은 참조를 바라보는 것을 말한다. 예를 들어 아래와 같을 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Member member1 = <span class=\"keyword\">new</span> Member(<span class=\"string\">\"1\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Member member2 = member1;</span><br><span class=\"line\"></span><br><span class=\"line\">        System.out.println(member1 == member2);<span class=\"comment\">//true</span></span><br><span class=\"line\">        System.out.println( member1.equals(member2));<span class=\"comment\">//true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> String id;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Member</span><span class=\"params\">(String id)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위에 예제는 둘 다 true 값이 나온다. 이것을 동일 객체라고 한다. 하지만 이렇게 생각할 수 있다. 유저의 id는 동일한데 왜 다른 유저가 되는지에 대해서… 보통 자바에서 이것을 동등 객체라고 한다. 동등 객체를 비교하기 위해서는 equals 함수를 사용해야 한다. 하지만 처음 예제에서 equals 함수도 false 값이 나왔다. 이러한 이유는 equals 함수를 재정의하지 않았기 때문이다. 아래에 예제에서 좀 더 자세하게 equals 메소드를 알아보자.</p>\n<h2>객체 비교(equals())</h2>\n<p>다음은 Object의 equals() 메소드이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n<p>Object 클래스의 equals()는 아래와같은 기능으로써 이 메소드는 비교 연사자인 == 과 동일한 결과를 리턴한다. 오로지 참조값이 같은지, 다시말하면 동일 객체인지를 확인하는 기능이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> == obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>자바에서는 두 객체를 동등 비교할 때 equals() 메소드를 흔히 사용한다. equals() 메소드는 두 객체를 비교해서 논리적으로 동등하면 true를 리턴하고 그렇지 않으면 false를 리턴한다. 논리적으로 동등하다는것은 둘의 참조값이 다르더라도 객체 내부 value는 같다는것을 의미한다. 이 equals함수를 재정의한 대표적인예가 String class이다. String class는 equals() 메소드를 재정의해서 번지비교가 아닌 문자열리 비교한다. 아래는 String class의 euqals 메소드의 내용 소스이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//String class</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object anObject)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> == anObject) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (anObject <span class=\"keyword\">instanceof</span> String) &#123;</span><br><span class=\"line\">        String anotherString = (String)anObject;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = value.length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == anotherString.value.length) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> v1[] = value;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> v2[] = anotherString.value;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (n-- != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (v1[i] != v2[i])</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위 소스를 보면 Object로 객체를 받아 하나하나 문자열을 비교하는것을 볼 수 있다. char은 참조값이 아닌 기본값이기 때문에 == 만으로도 값비교가 된다.</p>\n<blockquote>\n<p>팁 <br> String 을 이용해 문자열 리터럴 방식으로 문자열을정의하면 동일 객체를 생성하게 되어있다.</p>\n</blockquote>\n<p>예를 들어 Member라는 클래스가 있는데 여기에 Id값이 같은면 동등객체로 취급하고싶다면 equals()메소드를 재정의해서 id 필드값이 같음을 비교하면 된다. 아래는 그의 해당하는 예제이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> String id;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Member</span><span class=\"params\">(String id)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(obj <span class=\"keyword\">instanceof</span> Member)&#123;</span><br><span class=\"line\">      Member member = (Member) obj;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(id.equals(member.id))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위와같이 equals메소드를 재정의하게 되면 Member 객체를 통해 객체를 비교할 때 Id가 같다면 두 객체는 동등 객체가 될 것이다</p>\n<ul>\n<li>동일성 비교는 == 비교다. 객체 인스턴스의 주소 값을 비교한다.</li>\n<li>동등성 비교는 equals() 메소드를 사용해서 객체 내부의 값을 비교한다.</li>\n</ul>\n<h2>Java hash code란</h2>\n<p>객체 해시코드란 객체를 실별할 하나의 정수값을 말한다. Object의 hashCode() 메소드는 객체의 메모리 번지를 이용해서 해시코드를 만들어 리턴하기 때문에 객체 마다 다른 값을 가지고 있다. 객체의 값을 동등성 비교시 hashCode()를 오버라이딩할 필요성이 있는데, 컬렉션 프레임워크에서 HashSet, HashMap, HashTable은 다음과 같은 방법으로 두 객체가 동등한지 비교한다.</p>\n<p>우선 hashCode() 메소드를 실행해서 리턴된 해시코드 값이 같은지를 본다. 해시 코드값이 다르면 다른 객체로 판단하고, 해시 코드값이 같으면 equals()메소드로 다시 비교한다. 이두개가 모두 맞아야 동등 객체로 판단한다.</p>\n<p><img src=\"https://i.imgur.com/dShPCEh.png\" alt=\"\"></p>\n<p>다음 예제를 보면 Key클래스 equals 메소드를 재정의해서 number필드값이 같으면 true를 리턴하도록했다. 그러나 hashCode메소드는 재정의 하지 않았기 때문에 Object의 hashCode() 메소드가 사용된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Key</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> number;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Key</span><span class=\"params\">(<span class=\"keyword\">int</span> number)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.number = number;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(obj <span class=\"keyword\">instanceof</span> Key)&#123;</span><br><span class=\"line\">      Key compareKey = (Key) obj;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.number == compareKey.number)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이런 경우 두개의 동등한 객체를 HashMap의 식별키로 Key 객체를 사용하면 저장된 값을 찾아 오지 못한다. 왜냐하면 number 필드값이 같더라도 hashCode() 메소드에서 리턴하는 해시코드가 다르기 때문에 다른 식별키로 익식하기 때문이다. 실제 예제를 실행해보고 확인해보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KeyExample</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//Key 객체를 식별키로 사용해서 String 값을 저장하는 HashMap 객체생성.</span></span><br><span class=\"line\">    HashMap&lt;Key, String&gt; hashMap = <span class=\"keyword\">new</span> HashMap&lt;Key, String&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//식별키 \"new key(1)\"로 \"홍길동\"을 저장함</span></span><br><span class=\"line\">    hashMap.put(<span class=\"keyword\">new</span> Key(<span class=\"number\">1</span>), <span class=\"string\">\"홍길동\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//식별키 \"new key(1)\"로 \"홍길동\"을 읽어옴</span></span><br><span class=\"line\">    String value = hashMap.get(<span class=\"keyword\">new</span> Key(<span class=\"number\">1</span>));</span><br><span class=\"line\">    System.out.println(value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위에 내용에서 Hash Code를 정의하지 않았기 때문에 값은 null이 조회될 것이다. 만약 의도한 대로 홍길동을 읽으려면 아래와 같이 hashCode를 재정의 해야 한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Key</span></span>&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">  <span class=\"meta\">@override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">(Object obj)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> number;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>저장할 때의 new Key(1)과 읽을때의 new Key(1)은 다른 참조값의 다른 객체지이지만 HashMap은 hashCode()의 리턴값이 같고, equals() 리턴값이 true가 나오기 때문에 두 객체는 동등 객체로 평가하여 하나의 키처럼키 사용하게 된다. 즉, 같은 식별키로 인식한다는 뜻이다. <strong>이러한 이유로 객체의 동등 비교를 위해서는 Object의 equals() 메소드만 재정의하지 말고 hashCode()메소드도 재정의해서 논리적 동등 객체일경우 동일한 해시코드가 리턴되도록 해야한다.</strong></p>\n<p>여기에서 다시 한번 말하면 키를 기반으로 찾는 것이지 객체의 참조 값으로 찾는 것은 아니다. 고로 hash 코드값이 같다고 해서 객체의 참조 값이 같은 것은 아니다.</p>\n<h3>해시코드 생성(hash(), hashCode())</h3>\n<p>Object중에 해쉬코드를 생성해주는 역할이 있다. 이 Object.hash(Object… values) 메소드는 매개값으로 주어진 값들을 이용해서 해시 코드를 생성하는 역할을하는데, 주어진 매개값들로 배열을 생성하고 Arrays.hashCode(Object[])를 호출해서 해시코드를 얻고 이값을 리턴한다. Object.hash(Object… values) 메소드는 hashCode()를 재정의할 때 리턴값을 생성하기 위해 사용하면 좋다. 클래스 하나가 여러가지 필드를 가지고 있을 때 이 필드들로부터 해시코드를 생성하게 되면 동일한 필드값을 가지는 객체는 동일한 해시코드를 가질 수 있다. 좀 더 정밀한 동등 객체를 이용한다면 이방법을 사용할 수 있다.</p>\n<p>IDE 또는 lombock등을 이용해 좀더 쉽게 equals, hashCode를 재정의할 수 도있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> Objects.hash(field1, field2, filed3);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>참고</p>\n<ul>\n<li><a href=\"https://book.naver.com/bookdb/book_detail.nhn?bid=8589375\" target=\"_blank\" rel=\"noopener\">이것이 자바다</a></li>\n</ul>\n"},{"title":"온라인 서점 API 만들기로 살펴보는 Spring Boot OOP 2","catalog":true,"date":"2018-07-25T15:00:00.000Z","subtitle":"회원 엔터티 정의","header-img":null,"_content":"\n# Step02 -  회원 엔터티 정의\n\n# 1. 회원 엔터티 정의  \n먼저 앞에서 설계 테이블을 간단히 보겠습니다. 다음과 같은 member 테이블이 있었습니다.\n\n![](https://i.imgur.com/Aa1gDEY.png)\n\n회원을 가입시키기 위해서는 member 엔터티를 정의해야할 필요가 있습니다. 위 그림 테이블을 기반으로 Member 엔터티를 정의해볼것입니다.\n\n```java\n@Entity\n@Table(name = \"member\")\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\n@Getter\npublic class Member  {\n\n    @Id\n    @Column(name = \"id\")\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private long id;\n\n    @Embedded\n    private Email email;\n    @Embedded\n    private Password password;\n    @Embedded\n    private Name name;\n\n    @CreationTimestamp\n    @Column(name = \"created_dt\", nullable = false, updatable = false)\n    private Timestamp createdAt;\n\n    @UpdateTimestamp\n    @Column(name = \"updated_dt\", nullable = false )\n    private Timestamp updatedAt;\n\n    public Member(final Email email, final Password password, final Name name) {\n        this.email = email;\n        this.password = password;\n        this.name = name;\n    }\n}\n```\n위에 정의되어있는 Member클래스에 어노테이션들이 어떻게 정의되었는지, 어떤 용도인지 알아보겠습니다.\n\n# @Entity\nJPA를 통해 관리할 클래스들을 명시적으로 @Entity라고 선언하는 것입니다. 도메인을 Entity로 사용하기 위해서는 필수로 입력하셔야 합니다.\n\n# @Table\n테이블어노테이션은 엔터티와 매핑할 실제 디비 테이블을 지정합니다. 위에서 정의한 도메인은 member를 지정함으로써 테이블 member와 Entity Member와 매핑이됩니다. JPA에서 테이블을 새로 만들어주는 기능이 있는데 이것을 이용해 테이블을 생성하면 name에 value를 기반으로 테이블을 만들어줍니다.\n\n## @NoArgsConstructor(access = AccessLevel.PROTECTED)\n다음은 파라미터가없는 기본생성자를 만들어주는 어노테이션입니다. Spring JPA를 사용하기위해서는 반드시 기본생성자가 필요합니다. Spring JPA는 DB에서 데이터를 읽어와 도메인에 매핑할 때 기본생성자를 사용해서 객체를 생성해 데이터를 매핑합니다. 그렇기 때문에 반드시 기본생성자가 필요합니다. 롬복을 사용하지않고 java로 표현하면 다음과 같이 기본생성자를 protected로 선언하는것과 같습니다.\n\n```java\nprotected Member(){\n\n}\n```\n\n여기에서 굳이 접근 레벨을 Protected로 한 이유는 애플리케이션 내에서 이유없이 도메인을 생성 하는것을 막으려했기 때문입니다. Member가 만들어지기 위해서는 필수적인 정보가 있을 텐데 기본 생성자를 이용해서 객체를 만들면 불안전한 객체가 생성되기 때문입니다.\n\n그리고 Protected로 생성자를 지정하면 같이 개발하는 개발자들이 적어도 이객체는 기본생성자로 생성해서는 안되는 객체구나라고 생각할 수 있습니다.\n\n# @Id\nJPA에서 해당 필드에 기본키를 지정하기위해서 @Id 어노테이션을 지정해야합니다.\n\n## @GeneratedValue(strategy = GenerationType.IDENTITY)\n@GeneratedValue(strategy = GenerationType.IDENTITY) 지정하면 mysql의 AUTO_INCREAMENT와 같은기능으로 데이터베이스가 기본키를 생성해줍니다. 예를 들어 회원을 2명 생성해주면 자동으로 2번째 회원을 생성할 때는 id를 2값으로 회원을 생성해줍니다.\n\n\n# @Embedded\n\n## 데이터의 응집력, 데이터타입 규합\nSpring Data JPA Embedded어노테이션이 있음으로써 Spring Data JPA는 좀더 객체지향적으로 프로그래밍하게 해줍니다. 데이터타입을 규합시켜주거나 객체의 응집력을 높여주기 때문입니다. 어떻게 `데이터타입을 규합`시키고, `객체의 응집력`을 높이는지 예제를통해 알려드리겠습니다.\n\n## Eamil class\n아래와 같이 Email 클래스가 있습니다. 이것은 Member 클래스에 Embedded 되어 있는 Email 클래스입니다. 이렇게 클래스형으로 가지고있다고해도 JPA는 쉽게 데이터베이스에 데이터를 CRUD를 할 수 있습니다. 그리고 단순히 String이 아닌 Email을 클래스로하는 것에 대해 너무 과하지 않냐고 생각하실 수 도 있습니다.\n\n>Email 클래스에서 @org.hibernate.validator.constraints.Email 어노테이션과 @NotEmpty 어노테이션이 있습니다. 이 어노이션은 클라이언트로부터 넘어온 데이터가 email 형식이 맞는지 value의 값이 들어있는지 validation을 체크해주고 유효하지 않으면 Exception을 발생시켜 클라이언트한테 이메일 형식이 유효하지 않다고 알려주는 역할을 합니다.\n\n예를 들어 만약 Email을 String 타입으로 선언했고, Member 클래스가 아닌 Recipient 클래스 등이 Email을 멤버 필드로 필요로 한다고 가정해보겠습니다. 그러면 Member 클래스, Recipient 클래스에도 똑같이 이메일 validation 체크 어노테이션등을 해줘야하고 이메일에 필요한 host 정보를 가져온다거나 id 정보만 가져와야 하는 똑같은 기능들의 메소드를 두 클래스에 구현해줘야 할 것입니다. 이렇듯 Email을 클래스로 가져가지 않게 되면 데이터의 응집성이 떨어지면서 반복 코드가 발생하게 됩니다.\n\n```java\n@Embeddable\n@Getter\n@NoArgsConstructor(access = AccessLevel.PUBLIC)\n@JsonIgnoreProperties({\"host\", \"id\"})\npublic class Email {\n\n    //모든데에서 email인지 validation 다체크해야하는 이슈발생.\n    @NotEmpty\n    @org.hibernate.validator.constraints.Email\n    @Column(name = \"email\", nullable = false, unique = true)\n    private String value;\n\n    public Email(final String value) {\n        this.value = value;\n    }\n\n    public String getHost() {\n        int index = value.indexOf(\"@\");\n        return value.substring(index);\n    }\n\n    public String getId() {\n        int index = value.indexOf(\"@\");\n        return value.substring(0, index);\n    }\n}\n```\n\n## Name class\n하나 더 예를들어 아래의 Name클래스를 봐보겠습니다. Name 클래스는 다음과 같이 있습니다.\n```java\n@Embeddable\n@Getter\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\npublic class Name {\n\n    @NotEmpty\n    @Column(name = \"first_name\", nullable = false)\n    private String firstname;\n\n    @NotEmpty\n    @Column(name = \"last_name\", nullable = false)\n    private String lastname;\n\n    public String getFullName(){\n        return this.firstname +\" \"+this.lastname;\n    }\n\n\n}\n\n```\n\n회사 제품이 갑자기 글로벌 시장 진출로 인해 기존 firstname, lastname만 받는 게 아닌 middle_name을 받아야 한다고 가정해보겠습니다. 만약 프로젝트에서 DTO를 쓴다면 모든 곳에서 middleName을 넣어줘야 하는 문제가 생길 것입니다. 하지만 name을 클래스로 가져갔다면 유연하게 변경할 수 있습니다. 그 이유는 Name을 쓰는 곳은 하나의 클래스이기 때문입니다.\n\n\n이렇게 2가지정도 예를들어 Embedded class를 사용하는 이유에대해 간단히 설명을 들였는데요. 처음에 말한것처럼 Embedded class는 좀 더 개발을 객체지향스럽게 해주는 아주 좋은 어노테이션이라고 생각합니다. 객체의 응집력을 높임으로써 변경에 유연하고, 객체 기능의 확장을 쉽게 해주기 때문입니다.\n\n그렇다고 해서 모든 것을 Embedded 타입으로 가져가자는 의미는 아닙니다!! 의미있는 데이터끼리 또는 위와같이 기능의 확장성이 필요로하는 데이터를 잘 선별하여 Embedded 타입으로 뺄 수 있다고 생각합니다. \n\n그리고 여기에서 나온 validate 어노테이션은 다른 장에서 좀 더 자세히 알아보겠습니다.\n\n\n# @CreationTimestamp, @UpdateTimestamp\n어노테이션은 만들어진 시간과 데이터 변경시간을 자동으로 처리해주는 어노테이션입니다.\n\n# @Column(name = \"email\", nullable = false, unique = true)\n다음은 Spring JPA에서 제공해주는 DDL 생성 기능입니다. Spring JPA에서는 애플리케이션을 다시 시작할 때 도메인을 기반으로 이러한 DDL 문을 통해 테이블을 새롭게 만들 수 있습니다. 물론 이런 DDL 설정을 auto-create로 하지 않는다면 필요 없는 기능일 수 있습니다. 하지만 데이터베이스와 Entity에 DDL 설정을 동기화하는 것을 추천드립니다.\n\n그래야 크리티컬한 버그 줄일 수 있다고 생각하기 때문입니다. 예를 들어 NULL이 들어가면 안 되는 칼럼인데 개발자도 모르게 칼럼에 NULL이 들어가고 있다고 가정해보겠습니다. 위와 같은 제약조건들이 없으면 이것을 인식하는데 오래 걸려 치명적인 버그로 이어질 수 있습니다. 차라리 DBMS 제약조건 Exception 나서 빠르게 버그를 수정하는 것이 낫습니다.\n\n>DDL설정 정보는 [JPA - 4장 - 엔티티 매핑](https://jacojang.github.io/jpa/java/hibernate/2016/12/01/jpa-chapter4-%EC%97%94%ED%8B%B0%ED%8B%B0_%EB%A7%A4%ED%95%91.html) 블로그에 잘나와있습니다. 여기에서 데이터스키마 자동생성 부분을 보시면 될것같습니다.\n\n\n\n\n# 마치며\n이장에서 엔터티 및 도메인을 정의하는 방법에 대해 설명했습니다. 사실 이장에서 객체지향도 중요하지만 좀 더 강조하고 싶은 것은 `프로그래밍을 하는 부분에서 실수를 만들지 않기 위해 노력을 하자`입니다. 물론 누구나 `실수`를 하게 되고 버그를 만들 수 있습니다. 하지만 이 `실수`나 버그가 다시 발생하지 않기 위해 어떤 식으로 노력할 것이냐 입니다.\n\n1. 데이터의 응집력을 생각하지 않은 코딩으로 인한 `사이드이펙트 남발`\n2. public 기본 생성자로 Entity 객체 생성 남발로 인한 `불안전한 엔터티 생성`\n3. 무심한 DDL 설정으로 인한 `더 큰 버그 발생`\n\n사실 위에 `실수`들은 제약조건을 코드로 강제하지 않는다면 개발하면서 계속 다시 발생할 수 있는 `실수`들입니다. 위와 같은 `실수`들을 다시 발생하는 것을 막기 위해 위 예제에서는 코드로 제약조건을 강제함으로써 같은 `실수`를 반복하지 못하도록 막았습니다. 이렇듯 다시 나올 수 있는 `실수`에 대해서는 어떻게 재발하는 것을 막을지에 대해 항상 생각한다면 좀 더 안정적인 프로그래밍을 만들 수 있다고 생각합니다.\n\n","source":"_posts/2018-07-26-spring-book-2.md","raw":"---\ntitle: 온라인 서점 API 만들기로 살펴보는 Spring Boot OOP 2\ncatalog: true\ndate: 2018-07-26\nsubtitle: 회원 엔터티 정의\nheader-img:\ntags:\n- Java\n- Spring\n- 온라인 서점 API 만들기로 살펴보는 Spring Boot OOP\n\n\n---\n\n# Step02 -  회원 엔터티 정의\n\n# 1. 회원 엔터티 정의  \n먼저 앞에서 설계 테이블을 간단히 보겠습니다. 다음과 같은 member 테이블이 있었습니다.\n\n![](https://i.imgur.com/Aa1gDEY.png)\n\n회원을 가입시키기 위해서는 member 엔터티를 정의해야할 필요가 있습니다. 위 그림 테이블을 기반으로 Member 엔터티를 정의해볼것입니다.\n\n```java\n@Entity\n@Table(name = \"member\")\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\n@Getter\npublic class Member  {\n\n    @Id\n    @Column(name = \"id\")\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private long id;\n\n    @Embedded\n    private Email email;\n    @Embedded\n    private Password password;\n    @Embedded\n    private Name name;\n\n    @CreationTimestamp\n    @Column(name = \"created_dt\", nullable = false, updatable = false)\n    private Timestamp createdAt;\n\n    @UpdateTimestamp\n    @Column(name = \"updated_dt\", nullable = false )\n    private Timestamp updatedAt;\n\n    public Member(final Email email, final Password password, final Name name) {\n        this.email = email;\n        this.password = password;\n        this.name = name;\n    }\n}\n```\n위에 정의되어있는 Member클래스에 어노테이션들이 어떻게 정의되었는지, 어떤 용도인지 알아보겠습니다.\n\n# @Entity\nJPA를 통해 관리할 클래스들을 명시적으로 @Entity라고 선언하는 것입니다. 도메인을 Entity로 사용하기 위해서는 필수로 입력하셔야 합니다.\n\n# @Table\n테이블어노테이션은 엔터티와 매핑할 실제 디비 테이블을 지정합니다. 위에서 정의한 도메인은 member를 지정함으로써 테이블 member와 Entity Member와 매핑이됩니다. JPA에서 테이블을 새로 만들어주는 기능이 있는데 이것을 이용해 테이블을 생성하면 name에 value를 기반으로 테이블을 만들어줍니다.\n\n## @NoArgsConstructor(access = AccessLevel.PROTECTED)\n다음은 파라미터가없는 기본생성자를 만들어주는 어노테이션입니다. Spring JPA를 사용하기위해서는 반드시 기본생성자가 필요합니다. Spring JPA는 DB에서 데이터를 읽어와 도메인에 매핑할 때 기본생성자를 사용해서 객체를 생성해 데이터를 매핑합니다. 그렇기 때문에 반드시 기본생성자가 필요합니다. 롬복을 사용하지않고 java로 표현하면 다음과 같이 기본생성자를 protected로 선언하는것과 같습니다.\n\n```java\nprotected Member(){\n\n}\n```\n\n여기에서 굳이 접근 레벨을 Protected로 한 이유는 애플리케이션 내에서 이유없이 도메인을 생성 하는것을 막으려했기 때문입니다. Member가 만들어지기 위해서는 필수적인 정보가 있을 텐데 기본 생성자를 이용해서 객체를 만들면 불안전한 객체가 생성되기 때문입니다.\n\n그리고 Protected로 생성자를 지정하면 같이 개발하는 개발자들이 적어도 이객체는 기본생성자로 생성해서는 안되는 객체구나라고 생각할 수 있습니다.\n\n# @Id\nJPA에서 해당 필드에 기본키를 지정하기위해서 @Id 어노테이션을 지정해야합니다.\n\n## @GeneratedValue(strategy = GenerationType.IDENTITY)\n@GeneratedValue(strategy = GenerationType.IDENTITY) 지정하면 mysql의 AUTO_INCREAMENT와 같은기능으로 데이터베이스가 기본키를 생성해줍니다. 예를 들어 회원을 2명 생성해주면 자동으로 2번째 회원을 생성할 때는 id를 2값으로 회원을 생성해줍니다.\n\n\n# @Embedded\n\n## 데이터의 응집력, 데이터타입 규합\nSpring Data JPA Embedded어노테이션이 있음으로써 Spring Data JPA는 좀더 객체지향적으로 프로그래밍하게 해줍니다. 데이터타입을 규합시켜주거나 객체의 응집력을 높여주기 때문입니다. 어떻게 `데이터타입을 규합`시키고, `객체의 응집력`을 높이는지 예제를통해 알려드리겠습니다.\n\n## Eamil class\n아래와 같이 Email 클래스가 있습니다. 이것은 Member 클래스에 Embedded 되어 있는 Email 클래스입니다. 이렇게 클래스형으로 가지고있다고해도 JPA는 쉽게 데이터베이스에 데이터를 CRUD를 할 수 있습니다. 그리고 단순히 String이 아닌 Email을 클래스로하는 것에 대해 너무 과하지 않냐고 생각하실 수 도 있습니다.\n\n>Email 클래스에서 @org.hibernate.validator.constraints.Email 어노테이션과 @NotEmpty 어노테이션이 있습니다. 이 어노이션은 클라이언트로부터 넘어온 데이터가 email 형식이 맞는지 value의 값이 들어있는지 validation을 체크해주고 유효하지 않으면 Exception을 발생시켜 클라이언트한테 이메일 형식이 유효하지 않다고 알려주는 역할을 합니다.\n\n예를 들어 만약 Email을 String 타입으로 선언했고, Member 클래스가 아닌 Recipient 클래스 등이 Email을 멤버 필드로 필요로 한다고 가정해보겠습니다. 그러면 Member 클래스, Recipient 클래스에도 똑같이 이메일 validation 체크 어노테이션등을 해줘야하고 이메일에 필요한 host 정보를 가져온다거나 id 정보만 가져와야 하는 똑같은 기능들의 메소드를 두 클래스에 구현해줘야 할 것입니다. 이렇듯 Email을 클래스로 가져가지 않게 되면 데이터의 응집성이 떨어지면서 반복 코드가 발생하게 됩니다.\n\n```java\n@Embeddable\n@Getter\n@NoArgsConstructor(access = AccessLevel.PUBLIC)\n@JsonIgnoreProperties({\"host\", \"id\"})\npublic class Email {\n\n    //모든데에서 email인지 validation 다체크해야하는 이슈발생.\n    @NotEmpty\n    @org.hibernate.validator.constraints.Email\n    @Column(name = \"email\", nullable = false, unique = true)\n    private String value;\n\n    public Email(final String value) {\n        this.value = value;\n    }\n\n    public String getHost() {\n        int index = value.indexOf(\"@\");\n        return value.substring(index);\n    }\n\n    public String getId() {\n        int index = value.indexOf(\"@\");\n        return value.substring(0, index);\n    }\n}\n```\n\n## Name class\n하나 더 예를들어 아래의 Name클래스를 봐보겠습니다. Name 클래스는 다음과 같이 있습니다.\n```java\n@Embeddable\n@Getter\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\npublic class Name {\n\n    @NotEmpty\n    @Column(name = \"first_name\", nullable = false)\n    private String firstname;\n\n    @NotEmpty\n    @Column(name = \"last_name\", nullable = false)\n    private String lastname;\n\n    public String getFullName(){\n        return this.firstname +\" \"+this.lastname;\n    }\n\n\n}\n\n```\n\n회사 제품이 갑자기 글로벌 시장 진출로 인해 기존 firstname, lastname만 받는 게 아닌 middle_name을 받아야 한다고 가정해보겠습니다. 만약 프로젝트에서 DTO를 쓴다면 모든 곳에서 middleName을 넣어줘야 하는 문제가 생길 것입니다. 하지만 name을 클래스로 가져갔다면 유연하게 변경할 수 있습니다. 그 이유는 Name을 쓰는 곳은 하나의 클래스이기 때문입니다.\n\n\n이렇게 2가지정도 예를들어 Embedded class를 사용하는 이유에대해 간단히 설명을 들였는데요. 처음에 말한것처럼 Embedded class는 좀 더 개발을 객체지향스럽게 해주는 아주 좋은 어노테이션이라고 생각합니다. 객체의 응집력을 높임으로써 변경에 유연하고, 객체 기능의 확장을 쉽게 해주기 때문입니다.\n\n그렇다고 해서 모든 것을 Embedded 타입으로 가져가자는 의미는 아닙니다!! 의미있는 데이터끼리 또는 위와같이 기능의 확장성이 필요로하는 데이터를 잘 선별하여 Embedded 타입으로 뺄 수 있다고 생각합니다. \n\n그리고 여기에서 나온 validate 어노테이션은 다른 장에서 좀 더 자세히 알아보겠습니다.\n\n\n# @CreationTimestamp, @UpdateTimestamp\n어노테이션은 만들어진 시간과 데이터 변경시간을 자동으로 처리해주는 어노테이션입니다.\n\n# @Column(name = \"email\", nullable = false, unique = true)\n다음은 Spring JPA에서 제공해주는 DDL 생성 기능입니다. Spring JPA에서는 애플리케이션을 다시 시작할 때 도메인을 기반으로 이러한 DDL 문을 통해 테이블을 새롭게 만들 수 있습니다. 물론 이런 DDL 설정을 auto-create로 하지 않는다면 필요 없는 기능일 수 있습니다. 하지만 데이터베이스와 Entity에 DDL 설정을 동기화하는 것을 추천드립니다.\n\n그래야 크리티컬한 버그 줄일 수 있다고 생각하기 때문입니다. 예를 들어 NULL이 들어가면 안 되는 칼럼인데 개발자도 모르게 칼럼에 NULL이 들어가고 있다고 가정해보겠습니다. 위와 같은 제약조건들이 없으면 이것을 인식하는데 오래 걸려 치명적인 버그로 이어질 수 있습니다. 차라리 DBMS 제약조건 Exception 나서 빠르게 버그를 수정하는 것이 낫습니다.\n\n>DDL설정 정보는 [JPA - 4장 - 엔티티 매핑](https://jacojang.github.io/jpa/java/hibernate/2016/12/01/jpa-chapter4-%EC%97%94%ED%8B%B0%ED%8B%B0_%EB%A7%A4%ED%95%91.html) 블로그에 잘나와있습니다. 여기에서 데이터스키마 자동생성 부분을 보시면 될것같습니다.\n\n\n\n\n# 마치며\n이장에서 엔터티 및 도메인을 정의하는 방법에 대해 설명했습니다. 사실 이장에서 객체지향도 중요하지만 좀 더 강조하고 싶은 것은 `프로그래밍을 하는 부분에서 실수를 만들지 않기 위해 노력을 하자`입니다. 물론 누구나 `실수`를 하게 되고 버그를 만들 수 있습니다. 하지만 이 `실수`나 버그가 다시 발생하지 않기 위해 어떤 식으로 노력할 것이냐 입니다.\n\n1. 데이터의 응집력을 생각하지 않은 코딩으로 인한 `사이드이펙트 남발`\n2. public 기본 생성자로 Entity 객체 생성 남발로 인한 `불안전한 엔터티 생성`\n3. 무심한 DDL 설정으로 인한 `더 큰 버그 발생`\n\n사실 위에 `실수`들은 제약조건을 코드로 강제하지 않는다면 개발하면서 계속 다시 발생할 수 있는 `실수`들입니다. 위와 같은 `실수`들을 다시 발생하는 것을 막기 위해 위 예제에서는 코드로 제약조건을 강제함으로써 같은 `실수`를 반복하지 못하도록 막았습니다. 이렇듯 다시 나올 수 있는 `실수`에 대해서는 어떻게 재발하는 것을 막을지에 대해 항상 생각한다면 좀 더 안정적인 프로그래밍을 만들 수 있다고 생각합니다.\n\n","slug":"2018-07-26-spring-book-2","published":1,"updated":"2018-08-01T14:18:22.974Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27dy002rjjpefhfdeo29","content":"<h1><span id=\"step02-회원-엔터티-정의\">Step02 -  회원 엔터티 정의</span></h1>\n<h1><span id=\"1-회원-엔터티-정의\">1. 회원 엔터티 정의</span></h1>\n<p>먼저 앞에서 설계 테이블을 간단히 보겠습니다. 다음과 같은 member 테이블이 있었습니다.</p>\n<p><img src=\"https://i.imgur.com/Aa1gDEY.png\" alt=\"\"></p>\n<p>회원을 가입시키기 위해서는 member 엔터티를 정의해야할 필요가 있습니다. 위 그림 테이블을 기반으로 Member 엔터티를 정의해볼것입니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Table</span>(name = <span class=\"string\">\"member\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PROTECTED)</span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span>  </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"id\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Embedded</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Email email;</span><br><span class=\"line\">    <span class=\"meta\">@Embedded</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Password password;</span><br><span class=\"line\">    <span class=\"meta\">@Embedded</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Name name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@CreationTimestamp</span></span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"created_dt\"</span>, nullable = <span class=\"keyword\">false</span>, updatable = <span class=\"keyword\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Timestamp createdAt;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@UpdateTimestamp</span></span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"updated_dt\"</span>, nullable = <span class=\"keyword\">false</span> )</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Timestamp updatedAt;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Member</span><span class=\"params\">(<span class=\"keyword\">final</span> Email email, <span class=\"keyword\">final</span> Password password, <span class=\"keyword\">final</span> Name name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.email = email;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.password = password;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위에 정의되어있는 Member클래스에 어노테이션들이 어떻게 정의되었는지, 어떤 용도인지 알아보겠습니다.</p>\n<h1><span id=\"entity\">@Entity</span></h1>\n<p>JPA를 통해 관리할 클래스들을 명시적으로 @Entity라고 선언하는 것입니다. 도메인을 Entity로 사용하기 위해서는 필수로 입력하셔야 합니다.</p>\n<h1><span id=\"table\">@Table</span></h1>\n<p>테이블어노테이션은 엔터티와 매핑할 실제 디비 테이블을 지정합니다. 위에서 정의한 도메인은 member를 지정함으로써 테이블 member와 Entity Member와 매핑이됩니다. JPA에서 테이블을 새로 만들어주는 기능이 있는데 이것을 이용해 테이블을 생성하면 name에 value를 기반으로 테이블을 만들어줍니다.</p>\n<h2><span id=\"noargsconstructoraccess-accesslevelprotected\">@NoArgsConstructor(access = AccessLevel.PROTECTED)</span></h2>\n<p>다음은 파라미터가없는 기본생성자를 만들어주는 어노테이션입니다. Spring JPA를 사용하기위해서는 반드시 기본생성자가 필요합니다. Spring JPA는 DB에서 데이터를 읽어와 도메인에 매핑할 때 기본생성자를 사용해서 객체를 생성해 데이터를 매핑합니다. 그렇기 때문에 반드시 기본생성자가 필요합니다. 롬복을 사용하지않고 java로 표현하면 다음과 같이 기본생성자를 protected로 선언하는것과 같습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">Member</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>여기에서 굳이 접근 레벨을 Protected로 한 이유는 애플리케이션 내에서 이유없이 도메인을 생성 하는것을 막으려했기 때문입니다. Member가 만들어지기 위해서는 필수적인 정보가 있을 텐데 기본 생성자를 이용해서 객체를 만들면 불안전한 객체가 생성되기 때문입니다.</p>\n<p>그리고 Protected로 생성자를 지정하면 같이 개발하는 개발자들이 적어도 이객체는 기본생성자로 생성해서는 안되는 객체구나라고 생각할 수 있습니다.</p>\n<h1><span id=\"id\">@Id</span></h1>\n<p>JPA에서 해당 필드에 기본키를 지정하기위해서 @Id 어노테이션을 지정해야합니다.</p>\n<h2><span id=\"generatedvaluestrategy-generationtypeidentity\">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></h2>\n<p>@GeneratedValue(strategy = GenerationType.IDENTITY) 지정하면 mysql의 AUTO_INCREAMENT와 같은기능으로 데이터베이스가 기본키를 생성해줍니다. 예를 들어 회원을 2명 생성해주면 자동으로 2번째 회원을 생성할 때는 id를 2값으로 회원을 생성해줍니다.</p>\n<h1><span id=\"embedded\">@Embedded</span></h1>\n<h2><span id=\"데이터의-응집력-데이터타입-규합\">데이터의 응집력, 데이터타입 규합</span></h2>\n<p>Spring Data JPA Embedded어노테이션이 있음으로써 Spring Data JPA는 좀더 객체지향적으로 프로그래밍하게 해줍니다. 데이터타입을 규합시켜주거나 객체의 응집력을 높여주기 때문입니다. 어떻게 <code>데이터타입을 규합</code>시키고, <code>객체의 응집력</code>을 높이는지 예제를통해 알려드리겠습니다.</p>\n<h2><span id=\"eamil-class\">Eamil class</span></h2>\n<p>아래와 같이 Email 클래스가 있습니다. 이것은 Member 클래스에 Embedded 되어 있는 Email 클래스입니다. 이렇게 클래스형으로 가지고있다고해도 JPA는 쉽게 데이터베이스에 데이터를 CRUD를 할 수 있습니다. 그리고 단순히 String이 아닌 Email을 클래스로하는 것에 대해 너무 과하지 않냐고 생각하실 수 도 있습니다.</p>\n<blockquote>\n<p>Email 클래스에서 @org.hibernate.validator.constraints.Email 어노테이션과 @NotEmpty 어노테이션이 있습니다. 이 어노이션은 클라이언트로부터 넘어온 데이터가 email 형식이 맞는지 value의 값이 들어있는지 validation을 체크해주고 유효하지 않으면 Exception을 발생시켜 클라이언트한테 이메일 형식이 유효하지 않다고 알려주는 역할을 합니다.</p>\n</blockquote>\n<p>예를 들어 만약 Email을 String 타입으로 선언했고, Member 클래스가 아닌 Recipient 클래스 등이 Email을 멤버 필드로 필요로 한다고 가정해보겠습니다. 그러면 Member 클래스, Recipient 클래스에도 똑같이 이메일 validation 체크 어노테이션등을 해줘야하고 이메일에 필요한 host 정보를 가져온다거나 id 정보만 가져와야 하는 똑같은 기능들의 메소드를 두 클래스에 구현해줘야 할 것입니다. 이렇듯 Email을 클래스로 가져가지 않게 되면 데이터의 응집성이 떨어지면서 반복 코드가 발생하게 됩니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Embeddable</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PUBLIC)</span><br><span class=\"line\"><span class=\"meta\">@JsonIgnoreProperties</span>(&#123;<span class=\"string\">\"host\"</span>, <span class=\"string\">\"id\"</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Email</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//모든데에서 email인지 validation 다체크해야하는 이슈발생.</span></span><br><span class=\"line\">    <span class=\"meta\">@NotEmpty</span></span><br><span class=\"line\">    <span class=\"meta\">@org</span>.hibernate.validator.constraints.Email</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"email\"</span>, nullable = <span class=\"keyword\">false</span>, unique = <span class=\"keyword\">true</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Email</span><span class=\"params\">(<span class=\"keyword\">final</span> String value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getHost</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = value.indexOf(<span class=\"string\">\"@\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value.substring(index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = value.indexOf(<span class=\"string\">\"@\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value.substring(<span class=\"number\">0</span>, index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"name-class\">Name class</span></h2>\n<p>하나 더 예를들어 아래의 Name클래스를 봐보겠습니다. Name 클래스는 다음과 같이 있습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Embeddable</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PROTECTED)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Name</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@NotEmpty</span></span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"first_name\"</span>, nullable = <span class=\"keyword\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String firstname;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@NotEmpty</span></span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"last_name\"</span>, nullable = <span class=\"keyword\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String lastname;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getFullName</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstname +<span class=\"string\">\" \"</span>+<span class=\"keyword\">this</span>.lastname;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>회사 제품이 갑자기 글로벌 시장 진출로 인해 기존 firstname, lastname만 받는 게 아닌 middle_name을 받아야 한다고 가정해보겠습니다. 만약 프로젝트에서 DTO를 쓴다면 모든 곳에서 middleName을 넣어줘야 하는 문제가 생길 것입니다. 하지만 name을 클래스로 가져갔다면 유연하게 변경할 수 있습니다. 그 이유는 Name을 쓰는 곳은 하나의 클래스이기 때문입니다.</p>\n<p>이렇게 2가지정도 예를들어 Embedded class를 사용하는 이유에대해 간단히 설명을 들였는데요. 처음에 말한것처럼 Embedded class는 좀 더 개발을 객체지향스럽게 해주는 아주 좋은 어노테이션이라고 생각합니다. 객체의 응집력을 높임으로써 변경에 유연하고, 객체 기능의 확장을 쉽게 해주기 때문입니다.</p>\n<p>그렇다고 해서 모든 것을 Embedded 타입으로 가져가자는 의미는 아닙니다!! 의미있는 데이터끼리 또는 위와같이 기능의 확장성이 필요로하는 데이터를 잘 선별하여 Embedded 타입으로 뺄 수 있다고 생각합니다.</p>\n<p>그리고 여기에서 나온 validate 어노테이션은 다른 장에서 좀 더 자세히 알아보겠습니다.</p>\n<h1><span id=\"creationtimestamp-updatetimestamp\">@CreationTimestamp, @UpdateTimestamp</span></h1>\n<p>어노테이션은 만들어진 시간과 데이터 변경시간을 자동으로 처리해주는 어노테이션입니다.</p>\n<h1><span id=\"columnname-email-nullable-false-unique-true\">@Column(name = “email”, nullable = false, unique = true)</span></h1>\n<p>다음은 Spring JPA에서 제공해주는 DDL 생성 기능입니다. Spring JPA에서는 애플리케이션을 다시 시작할 때 도메인을 기반으로 이러한 DDL 문을 통해 테이블을 새롭게 만들 수 있습니다. 물론 이런 DDL 설정을 auto-create로 하지 않는다면 필요 없는 기능일 수 있습니다. 하지만 데이터베이스와 Entity에 DDL 설정을 동기화하는 것을 추천드립니다.</p>\n<p>그래야 크리티컬한 버그 줄일 수 있다고 생각하기 때문입니다. 예를 들어 NULL이 들어가면 안 되는 칼럼인데 개발자도 모르게 칼럼에 NULL이 들어가고 있다고 가정해보겠습니다. 위와 같은 제약조건들이 없으면 이것을 인식하는데 오래 걸려 치명적인 버그로 이어질 수 있습니다. 차라리 DBMS 제약조건 Exception 나서 빠르게 버그를 수정하는 것이 낫습니다.</p>\n<blockquote>\n<p>DDL설정 정보는 <a href=\"https://jacojang.github.io/jpa/java/hibernate/2016/12/01/jpa-chapter4-%EC%97%94%ED%8B%B0%ED%8B%B0_%EB%A7%A4%ED%95%91.html\" target=\"_blank\" rel=\"noopener\">JPA - 4장 - 엔티티 매핑</a> 블로그에 잘나와있습니다. 여기에서 데이터스키마 자동생성 부분을 보시면 될것같습니다.</p>\n</blockquote>\n<h1><span id=\"마치며\">마치며</span></h1>\n<p>이장에서 엔터티 및 도메인을 정의하는 방법에 대해 설명했습니다. 사실 이장에서 객체지향도 중요하지만 좀 더 강조하고 싶은 것은 <code>프로그래밍을 하는 부분에서 실수를 만들지 않기 위해 노력을 하자</code>입니다. 물론 누구나 <code>실수</code>를 하게 되고 버그를 만들 수 있습니다. 하지만 이 <code>실수</code>나 버그가 다시 발생하지 않기 위해 어떤 식으로 노력할 것이냐 입니다.</p>\n<ol>\n<li>데이터의 응집력을 생각하지 않은 코딩으로 인한 <code>사이드이펙트 남발</code></li>\n<li>public 기본 생성자로 Entity 객체 생성 남발로 인한 <code>불안전한 엔터티 생성</code></li>\n<li>무심한 DDL 설정으로 인한 <code>더 큰 버그 발생</code></li>\n</ol>\n<p>사실 위에 <code>실수</code>들은 제약조건을 코드로 강제하지 않는다면 개발하면서 계속 다시 발생할 수 있는 <code>실수</code>들입니다. 위와 같은 <code>실수</code>들을 다시 발생하는 것을 막기 위해 위 예제에서는 코드로 제약조건을 강제함으로써 같은 <code>실수</code>를 반복하지 못하도록 막았습니다. 이렇듯 다시 나올 수 있는 <code>실수</code>에 대해서는 어떻게 재발하는 것을 막을지에 대해 항상 생각한다면 좀 더 안정적인 프로그래밍을 만들 수 있다고 생각합니다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>Step02 -  회원 엔터티 정의</h1>\n<h1>1. 회원 엔터티 정의</h1>\n<p>먼저 앞에서 설계 테이블을 간단히 보겠습니다. 다음과 같은 member 테이블이 있었습니다.</p>\n<p><img src=\"https://i.imgur.com/Aa1gDEY.png\" alt=\"\"></p>\n<p>회원을 가입시키기 위해서는 member 엔터티를 정의해야할 필요가 있습니다. 위 그림 테이블을 기반으로 Member 엔터티를 정의해볼것입니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Table</span>(name = <span class=\"string\">\"member\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PROTECTED)</span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span>  </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"id\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Embedded</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Email email;</span><br><span class=\"line\">    <span class=\"meta\">@Embedded</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Password password;</span><br><span class=\"line\">    <span class=\"meta\">@Embedded</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Name name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@CreationTimestamp</span></span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"created_dt\"</span>, nullable = <span class=\"keyword\">false</span>, updatable = <span class=\"keyword\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Timestamp createdAt;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@UpdateTimestamp</span></span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"updated_dt\"</span>, nullable = <span class=\"keyword\">false</span> )</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Timestamp updatedAt;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Member</span><span class=\"params\">(<span class=\"keyword\">final</span> Email email, <span class=\"keyword\">final</span> Password password, <span class=\"keyword\">final</span> Name name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.email = email;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.password = password;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위에 정의되어있는 Member클래스에 어노테이션들이 어떻게 정의되었는지, 어떤 용도인지 알아보겠습니다.</p>\n<h1>@Entity</h1>\n<p>JPA를 통해 관리할 클래스들을 명시적으로 @Entity라고 선언하는 것입니다. 도메인을 Entity로 사용하기 위해서는 필수로 입력하셔야 합니다.</p>\n<h1>@Table</h1>\n<p>테이블어노테이션은 엔터티와 매핑할 실제 디비 테이블을 지정합니다. 위에서 정의한 도메인은 member를 지정함으로써 테이블 member와 Entity Member와 매핑이됩니다. JPA에서 테이블을 새로 만들어주는 기능이 있는데 이것을 이용해 테이블을 생성하면 name에 value를 기반으로 테이블을 만들어줍니다.</p>\n<h2>@NoArgsConstructor(access = AccessLevel.PROTECTED)</h2>\n<p>다음은 파라미터가없는 기본생성자를 만들어주는 어노테이션입니다. Spring JPA를 사용하기위해서는 반드시 기본생성자가 필요합니다. Spring JPA는 DB에서 데이터를 읽어와 도메인에 매핑할 때 기본생성자를 사용해서 객체를 생성해 데이터를 매핑합니다. 그렇기 때문에 반드시 기본생성자가 필요합니다. 롬복을 사용하지않고 java로 표현하면 다음과 같이 기본생성자를 protected로 선언하는것과 같습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">Member</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>여기에서 굳이 접근 레벨을 Protected로 한 이유는 애플리케이션 내에서 이유없이 도메인을 생성 하는것을 막으려했기 때문입니다. Member가 만들어지기 위해서는 필수적인 정보가 있을 텐데 기본 생성자를 이용해서 객체를 만들면 불안전한 객체가 생성되기 때문입니다.</p>\n<p>그리고 Protected로 생성자를 지정하면 같이 개발하는 개발자들이 적어도 이객체는 기본생성자로 생성해서는 안되는 객체구나라고 생각할 수 있습니다.</p>\n<h1>@Id</h1>\n<p>JPA에서 해당 필드에 기본키를 지정하기위해서 @Id 어노테이션을 지정해야합니다.</p>\n<h2>@GeneratedValue(strategy = GenerationType.IDENTITY)</h2>\n<p>@GeneratedValue(strategy = GenerationType.IDENTITY) 지정하면 mysql의 AUTO_INCREAMENT와 같은기능으로 데이터베이스가 기본키를 생성해줍니다. 예를 들어 회원을 2명 생성해주면 자동으로 2번째 회원을 생성할 때는 id를 2값으로 회원을 생성해줍니다.</p>\n<h1>@Embedded</h1>\n<h2>데이터의 응집력, 데이터타입 규합</h2>\n<p>Spring Data JPA Embedded어노테이션이 있음으로써 Spring Data JPA는 좀더 객체지향적으로 프로그래밍하게 해줍니다. 데이터타입을 규합시켜주거나 객체의 응집력을 높여주기 때문입니다. 어떻게 <code>데이터타입을 규합</code>시키고, <code>객체의 응집력</code>을 높이는지 예제를통해 알려드리겠습니다.</p>\n<h2>Eamil class</h2>\n<p>아래와 같이 Email 클래스가 있습니다. 이것은 Member 클래스에 Embedded 되어 있는 Email 클래스입니다. 이렇게 클래스형으로 가지고있다고해도 JPA는 쉽게 데이터베이스에 데이터를 CRUD를 할 수 있습니다. 그리고 단순히 String이 아닌 Email을 클래스로하는 것에 대해 너무 과하지 않냐고 생각하실 수 도 있습니다.</p>\n<blockquote>\n<p>Email 클래스에서 @org.hibernate.validator.constraints.Email 어노테이션과 @NotEmpty 어노테이션이 있습니다. 이 어노이션은 클라이언트로부터 넘어온 데이터가 email 형식이 맞는지 value의 값이 들어있는지 validation을 체크해주고 유효하지 않으면 Exception을 발생시켜 클라이언트한테 이메일 형식이 유효하지 않다고 알려주는 역할을 합니다.</p>\n</blockquote>\n<p>예를 들어 만약 Email을 String 타입으로 선언했고, Member 클래스가 아닌 Recipient 클래스 등이 Email을 멤버 필드로 필요로 한다고 가정해보겠습니다. 그러면 Member 클래스, Recipient 클래스에도 똑같이 이메일 validation 체크 어노테이션등을 해줘야하고 이메일에 필요한 host 정보를 가져온다거나 id 정보만 가져와야 하는 똑같은 기능들의 메소드를 두 클래스에 구현해줘야 할 것입니다. 이렇듯 Email을 클래스로 가져가지 않게 되면 데이터의 응집성이 떨어지면서 반복 코드가 발생하게 됩니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Embeddable</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PUBLIC)</span><br><span class=\"line\"><span class=\"meta\">@JsonIgnoreProperties</span>(&#123;<span class=\"string\">\"host\"</span>, <span class=\"string\">\"id\"</span>&#125;)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Email</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//모든데에서 email인지 validation 다체크해야하는 이슈발생.</span></span><br><span class=\"line\">    <span class=\"meta\">@NotEmpty</span></span><br><span class=\"line\">    <span class=\"meta\">@org</span>.hibernate.validator.constraints.Email</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"email\"</span>, nullable = <span class=\"keyword\">false</span>, unique = <span class=\"keyword\">true</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Email</span><span class=\"params\">(<span class=\"keyword\">final</span> String value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getHost</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = value.indexOf(<span class=\"string\">\"@\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value.substring(index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = value.indexOf(<span class=\"string\">\"@\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value.substring(<span class=\"number\">0</span>, index);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>Name class</h2>\n<p>하나 더 예를들어 아래의 Name클래스를 봐보겠습니다. Name 클래스는 다음과 같이 있습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Embeddable</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PROTECTED)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Name</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@NotEmpty</span></span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"first_name\"</span>, nullable = <span class=\"keyword\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String firstname;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@NotEmpty</span></span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"last_name\"</span>, nullable = <span class=\"keyword\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String lastname;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getFullName</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.firstname +<span class=\"string\">\" \"</span>+<span class=\"keyword\">this</span>.lastname;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>회사 제품이 갑자기 글로벌 시장 진출로 인해 기존 firstname, lastname만 받는 게 아닌 middle_name을 받아야 한다고 가정해보겠습니다. 만약 프로젝트에서 DTO를 쓴다면 모든 곳에서 middleName을 넣어줘야 하는 문제가 생길 것입니다. 하지만 name을 클래스로 가져갔다면 유연하게 변경할 수 있습니다. 그 이유는 Name을 쓰는 곳은 하나의 클래스이기 때문입니다.</p>\n<p>이렇게 2가지정도 예를들어 Embedded class를 사용하는 이유에대해 간단히 설명을 들였는데요. 처음에 말한것처럼 Embedded class는 좀 더 개발을 객체지향스럽게 해주는 아주 좋은 어노테이션이라고 생각합니다. 객체의 응집력을 높임으로써 변경에 유연하고, 객체 기능의 확장을 쉽게 해주기 때문입니다.</p>\n<p>그렇다고 해서 모든 것을 Embedded 타입으로 가져가자는 의미는 아닙니다!! 의미있는 데이터끼리 또는 위와같이 기능의 확장성이 필요로하는 데이터를 잘 선별하여 Embedded 타입으로 뺄 수 있다고 생각합니다.</p>\n<p>그리고 여기에서 나온 validate 어노테이션은 다른 장에서 좀 더 자세히 알아보겠습니다.</p>\n<h1>@CreationTimestamp, @UpdateTimestamp</h1>\n<p>어노테이션은 만들어진 시간과 데이터 변경시간을 자동으로 처리해주는 어노테이션입니다.</p>\n<h1>@Column(name = “email”, nullable = false, unique = true)</h1>\n<p>다음은 Spring JPA에서 제공해주는 DDL 생성 기능입니다. Spring JPA에서는 애플리케이션을 다시 시작할 때 도메인을 기반으로 이러한 DDL 문을 통해 테이블을 새롭게 만들 수 있습니다. 물론 이런 DDL 설정을 auto-create로 하지 않는다면 필요 없는 기능일 수 있습니다. 하지만 데이터베이스와 Entity에 DDL 설정을 동기화하는 것을 추천드립니다.</p>\n<p>그래야 크리티컬한 버그 줄일 수 있다고 생각하기 때문입니다. 예를 들어 NULL이 들어가면 안 되는 칼럼인데 개발자도 모르게 칼럼에 NULL이 들어가고 있다고 가정해보겠습니다. 위와 같은 제약조건들이 없으면 이것을 인식하는데 오래 걸려 치명적인 버그로 이어질 수 있습니다. 차라리 DBMS 제약조건 Exception 나서 빠르게 버그를 수정하는 것이 낫습니다.</p>\n<blockquote>\n<p>DDL설정 정보는 <a href=\"https://jacojang.github.io/jpa/java/hibernate/2016/12/01/jpa-chapter4-%EC%97%94%ED%8B%B0%ED%8B%B0_%EB%A7%A4%ED%95%91.html\" target=\"_blank\" rel=\"noopener\">JPA - 4장 - 엔티티 매핑</a> 블로그에 잘나와있습니다. 여기에서 데이터스키마 자동생성 부분을 보시면 될것같습니다.</p>\n</blockquote>\n<h1>마치며</h1>\n<p>이장에서 엔터티 및 도메인을 정의하는 방법에 대해 설명했습니다. 사실 이장에서 객체지향도 중요하지만 좀 더 강조하고 싶은 것은 <code>프로그래밍을 하는 부분에서 실수를 만들지 않기 위해 노력을 하자</code>입니다. 물론 누구나 <code>실수</code>를 하게 되고 버그를 만들 수 있습니다. 하지만 이 <code>실수</code>나 버그가 다시 발생하지 않기 위해 어떤 식으로 노력할 것이냐 입니다.</p>\n<ol>\n<li>데이터의 응집력을 생각하지 않은 코딩으로 인한 <code>사이드이펙트 남발</code></li>\n<li>public 기본 생성자로 Entity 객체 생성 남발로 인한 <code>불안전한 엔터티 생성</code></li>\n<li>무심한 DDL 설정으로 인한 <code>더 큰 버그 발생</code></li>\n</ol>\n<p>사실 위에 <code>실수</code>들은 제약조건을 코드로 강제하지 않는다면 개발하면서 계속 다시 발생할 수 있는 <code>실수</code>들입니다. 위와 같은 <code>실수</code>들을 다시 발생하는 것을 막기 위해 위 예제에서는 코드로 제약조건을 강제함으로써 같은 <code>실수</code>를 반복하지 못하도록 막았습니다. 이렇듯 다시 나올 수 있는 <code>실수</code>에 대해서는 어떻게 재발하는 것을 막을지에 대해 항상 생각한다면 좀 더 안정적인 프로그래밍을 만들 수 있다고 생각합니다.</p>\n"},{"title":"온라인 서점 API 만들기로 살펴보는 Spring Boot OOP 3","catalog":true,"date":"2018-07-25T15:00:00.000Z","subtitle":"회원가입 Controller 만들기 - 표현영역 효율적으로 관리하기","header-img":null,"_content":"\n# Step03 - 회원가입 Controller 만들기 : 표현영역 효율적으로 관리하기\n\n# 표현 영역\n\n먼저 컨트롤러를 작성하기 전에 표현 영역에 대해 간단히 얘기해보겠습니다. 앞장에서 말한 표현 -> 응용(서비스) -> 도메인 -> 인프라스트럭처 영역에 시작입니다. 표현 영역은 클라이언트에 요청을 받아 알맞는 응용서비스를 호출한 후 결과값을 클라이언트에게 보여주는 역할을 합니다. 표현 영역은 애플리케이션 시작인 만큼 아주 중요한 역할에 영역이라고 생각합니다. 단순 컨트롤러로써 Request Data 값을 받아서 대충 서비스로 던지는 역할이라고 생각할 수도 있습니다. \n\n하지만 표현 영역에서 Request Data 값을 받을 때 아주 잘 받아야 합니다. 대충 받는 순간 그 뒤쪽 서비스 영역, 도메인 영역, 인프라스트럭처 영역이 힘들어지기 때문입니다. 특히 서비스 영역이 힘들어집니다. 뒤쪽 영역이 왜 힘들어지는지와 뒤쪽 이 안 힘들어지기 위한 노력들을 살펴볼 것입니다. 먼저 이장에서 어떤 얘기들을 할지 나열해봤습니다.\n\n* Request값 DTO로 명시적으로 받아서 응용 영역으로 넘기기(명시적이지 않는 예(Map))\n* 클라이언트로 부터 넘어오는 데이터 validate 확실하게 하기\n* 표현영역에서 사용되는 객체들을 Service에 넘기지않기(ex : HttpServletRquest)\n* Domain 객체 바로 프론트엔드로 넘기지 않기 \n\n이장은 위의 내용을 기반으로 어떻게하면 효율적으로 표현영역을 다룰지 얘기해볼것입니다.\n\n# 1. Request Data값 DTO로 명시적으로 받아서 응용 영역으로 넘기기\n먼저 Request Data값을 명시적으로 받자입니다. 이 문제는 같이 협업하는 사람과 서비스 영역이 힘들어지기 때문입니다. 컨트롤러단에서 HttpServletRequest 값을 통해서 Request 바디 값을 받거나, Map을 이용하거나, RequestParam으로 모든 데이터를 받아서 처리하게 되면 그 당시 소스를 코딩할 할 때는 기억하지만 금방 그 데이터들이 어떤 용도에 데이터들인지 잊어버리기 때문입니다. (물론 RequestParam 같은 경우에는 필요에 따라 사용하면 매우 유용합니다.)\n\n```java\n//Map으로 받는예제\n public Map<String, Object> signUpMember(@RequestBody Map<String, Object> params){\n     \n     //something\n }\n```\n\n 조금이라도 다행인것은 Map을 표현 영역단에서 Value 값을 꺼내서 서비스단으로 넘겨주는것입니다. 만약 컨트롤러에서 받은 Map을 그대로 그냥 서비스단으로 넘기고 그것이 비지니스로직으로 이어진다면 아마 끔찍할 것입니다. 그 이유는 유지 보수와 가독성, 테스트 등이 매우 힘들어지기 때문입니다.\n\n예를 들어 다른 개발자가 그것을 유지 보수한다고 가정해보겠습니다. 유지 보수하는 사람은 그 Map이 어떻게 사용되는지 모르기 때문에 하나하나의 키값 등을 추적해야 이 Map의 Request 데이터들을 명세할 수 있습니다.\n\n심지어 다음과 같은 상황이 발생할 수도 있습니다. 클라이언트로부터 넘겨받은 값을 Map을 이용하여 아래 소스와 같이 키값이 state인 value 꺼낸다고 해보겠습니다. 클라이언트에 요구 사항으로 인해 이 키값이 status로 바뀌었습니다. 그렇게 되면 서비스 단과 컨트롤러에서 2군 대 이상 쓰인다고 하면 이것을 하나하나 다 찾아서 고쳐줘야 합니다. 이것은 type형이 아닌 String 값이기 때문에 추적하기도 힘듭니다. 뭐 물론 전체 검색해서 찾을 수도 있지만 프로젝트 내에 같은 단어가 있으면 이 또한 매우 까다롭게 됩니다.\n\n ```java\n params.get(\"state\");\n ```\n\n그렇기 때문에 아래와 과같이 명시적으로 dto를 만들고 데이터를 받는 게 좋습니다. 이렇게 명시적으로 정의하게 되면 유지 보수하는 사람 입장에서도 아 회원가입을 하기 위해서는 이러한 값들은 필수고 이러한 값은 선택인 것을 알 수 있습니다. 또한 요구 사항 등 변경에 의해 데이터가 추가되거나 하더라도 유연하게 변경할 수 있습니다. 위에서 말한 Request body key 값이 변경된다고 해도 해당 키값에 변수이기 때문에 IDE를 이용해 전체 변경을 하면 되기 때문에 아주 쉽게 변경할 수 있습니다.\n\n다음은 회원가입을 하기위해 RequestDto를 정의한것입니다.\n```java\n@Getter\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\npublic class MemberSignupRequest {\n\n    @Valid\n    private Email email;\n    @Valid\n    private Name name;\n    @Valid\n    private Password password;\n\n    public Member toMember(){\n        return new Member(email, password, name);\n    }\n}\n```\n\n\n# 2. 클라이언트로 부터 넘어오는 데이터 validate 확실하게 하기\n다음은 클라언트로부터 넘어오는 값에 대해 필수 값과 값의 형태를 표현 영역에서 확실하게 validate를 진행해야 표현 영역 이후에 영역들이 안 힘들어진다는 것입니다. 만약 표현 영역에서 필수 값, 값의 형식에 대한 validate 검사들이 제대로 되지 않는다면 서비스 영역과 도메인 영역은 계속해서 비즈니스로 직을 짜는 도중에 NULL 체크를 하는 소스를 작성해야 합니다. 이렇게 되면 비즈니스 로직을 집중할 수 없게 되고 코드의 가독성이 떨어지면서 버그로 이어질 가망성이 큽니다.\n\n예를 들어 다음과 같은 소스가 서비스 영역 전방, 심지어는 비지니스 로직 중간중간에 이어질 수 있습니다. 이렇게 되면 가독성 뿐만 아니라 유지 보수하기 매우 난해해 집니다. \n\n```java\npublic void signUpUser(final String email,final String password, final String  firstname, final String lastname){\n    if(email == null) throw new NullPointerException(\"email is null!\");\n    if(password == null) throw new NullPointerException(\"password is null!\");\n    if(firstname == null) throw new NullPointerException(\"firstname is null!\");\n    if(lastname == null) throw new NullPointerException(\"lastname is null!\");\n}\n```\n\n물론 응용서비스를 실행하는 주체가 같은 응용서비스이거나, 파라미터로 전달받은 값이 불안정하다면 응용 영역에서 validate 처리를 해야 할 수도 있습니다. 하지만 이 문제도 처음 표현 영역에서부터 무결한 데이터를 받거나, 응용서비스 자체에서도 NULL을 지양하는 코드를 작성해나간다면 응용서비스 내에 validate 코드 자체를 많이 줄여 나가실 수 있습니다.\n\n이러한 무결한 데이터를 보장하기 위해 표현 영역에서부터 NULL이 들어오는 것을 방어해야 합니다. NULL을 방어하기 위해서는 다음과 같이 ReuqestData에 대한 Validate 어노테이션을 사용하는 방법이 있습니다. @NotEmpty라는 어노테이션을 사용하게 되면 NULL이나 \"\"값들이 서비스단으로 들어오게 하는 것을 막을 수 있습니다. 또 이외에 어노테이션을 커스터마이징해서 값의 크기 또는 형태가 안 맞는 것을 응용 으로 들어가는 것을 막을 수 있습니다.\n\n```java\n\n@Embeddable\n@Getter\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\npublic class Email {\n\n    //모든곳에서 다체크해야하는 이슈발생.\n    @NotEmpty\n    @org.hibernate.validator.constraints.Email\n    @Column(name = \"email\", nullable = false, unique = true)\n    private String value;\n    \n}\n\n```\n위 NotEmpty, Email어노테이션을 사용하게 되면 어노테이션에 대한 invalid 한값이 넘어오면 프론트엔드로 BadRequest(400) 처리를 하게 됩니다. \n\n>앞장에서도 말했지만 Email을 클래스로 선언해놨기 때문에 Email을 사용하는 RequestDto들은 이 클래스를 재활용해서 사용할 수 있게 됩니다. 깨알이지만 이렇듯 클래스를 잘 빼놓으면 응집력 있는 코드를 작성할 수 있습니다. \n\n위에 validate 어노테이션을 적용하기 위해서 회원가입 컨트롤러 코드를 다음과 같이 작성하시면 되겠습니다.\n\n```java\n    @RequestMapping(value = \"/members\", method = RequestMethod.POST)\n    @ResponseStatus(value = HttpStatus.CREATED)\n    public ResponseEntity signUpMember(@RequestBody @Valid final MemberSignupRequest request, final BindingResult errors){\n        if(errors.hasErrors()) {\n            return new ResponseEntity(HttpStatus.BAD_REQUEST);\n        }\n\n        final MemberResponse member = new MemberResponse(memberSignUpService.signUp(request));\n        return new ResponseEntity<>(member, HttpStatus.CREATED);\n    }\n```\n위에 매개변수로 받는 BindingResult에 request dto를 validate 하는 과정 중에 에러를 가지고 있다면 프론트엔드에게 BadRequest(400) 상태를 보낼것입니다. 여기에서 BindingResult를 매개변수로 받지 않는다면 자동으로 프론트엔드한테 BadRequest(400) 상태를 보낼것입니다. 물론 프론트엔드에서 좀 더 세부적으로 처리하기 위해서는 에러 내용 및 Error code를 함께 보내는 게 좋습니다.\n\n\n# 3. 표현영역에서 사용되는 객체들을 응용 영역에 넘기지않기(ex : HttpServletRequest, HttpServletResponse, HttpSession)\n\n다음으로 얘기할 것은 HttpServletRequest, HttpServletResponse 와같이 표현 영역의 오브젝트 등을 Service 단으로 넘기지 말자입니다. 이렇게되면 응용 영역이 표현 영역에 의존하게 되기 때문입니다. 표현 영역의 데이터들을 받은 서비스는 서비스에서 필요로 하는 데이터를 가공해서 로직을 수행할 것입니다. 예를 들어 IP 정보, Locale 정보 등이 있을 수 있습니다. 이러한 값들을 표현 영역에서 데이터나 객체로 뽑아서 주는 게 아닌 응용 영역에 바로 HttpServletRequest를 넘기게 되면 응용 영역은 재사용하기가 매우 까다로 질 것입니다. \n\n예를 들어 주문서비스에서 유저의 HttpSession 값을 기반으로 id를 꺼내서 주문을 만들었다고 가정해보겠습니다. 그런데 이번 요구 사항 추가로 인해 유저의 HTTP 요청이 아닌 배치잡으로 주문을 만들어야 합니다. 아마 주문서비스 영역은 재사용을 하기 매우 까다로울 것입니다. 처음부터 표현 영역으로부터 HttpSession 객체가 아닌 id 값을 받아서 주문을 생성했다면 아마 쉽게 주문 서비스를 재사용할 수 있었을 것입니다.\n\n또한 테스트 코드 작성하기가 매우 까다로 진다는 것입니다. 테스트를 작성하기 위해서 매번 Mock 데이터로 HttpServletRequest, HttpServletResponse을 만들어줘야 하기 때문입니다. 이러한 이유로 위와 같은 객체들은 최대한 표현 영역에서 가공한 뒤 넘겨주는 것이 좋습니다.\n\n# 4. Domain 객체 바로 프론트엔드로 넘기지 않고 DTO 사용하기\n도메인을 바로 클라이언트로 넘기게 되면 다음과 같은 문제점들을 가집니다. \n\n* 도메인의 중요한 데이터가 외부에 노출되어 질 수 있습니다\n\n도메인 객체 자체를 리턴하게 되면 회원의 개인 정보, 패스워드 등이 로그, 클라이언트에 노출이 되어집니다. 물론 어노테이션을 통해서 중요한 필드가 노출되는것을 막을 수 있습니다. 하지만 어노테이션은 실수할 확률이 크다고 생각합니다. 실수로 어노테이션을 을 안 하거나 어노테이션을 삭제하게 되면 이 문제에 대해 쉽게 인지할 수 없기 때문입니다.\n\n반면 DTO를 사용하게 되면 현저히 실수할 확률이 줄어들게 됩니다. 그 이유는 어노테이션의 방법은 DTO 방법과는 반대로 클라이언트에 표시되지 않기 위한 데이터에 대해 어노테이션을 표시하는 반면 DTO는 필요로 하는 데이터를 필드에 추가해야 하기 때문에 실수를 할 확률이 줄어들게 됩니다. 예를 들어 화면에 보여야 할 데이터가 안 보이는 것은 DTO에 추가를 안 한 것이기 때문에 쉽게 잡을 수 있습니다. 또 한 화면에 보여야 할 데이터가 안 보인다는 것은 대부분 Test code 등으로 잡히는 문제입니다.\n\n* 회원 정보를 리턴시 무한순환참조 Exception 발생하게 됩니다.\n\n예를 들어 Rest API를 통해 클라이언트가(웹브라우저)가 Member를 조회하는 기능이 있다고 해보겠습니다. 이 Member를 클라이언트로 넘겨주기 위해서는 직렬화가 되어야 합니다. 문제는 멤버와 주문 관계상 서로를 참조하는 관계가 될 수 있다는 것입니다. 그렇게 되면 직렬화하는 과정에서 Member와 주문이 서로 계속 참조하게 되어 무한 순환 참조 Exception이 발생하게 됩니다. 뮬론 이러한 문제를 어노테이션등을 통해 방지할 수 도 있습니다. 하지만 위와 아래와 같은 이슈들 때문에 개인적으로는 DTO를 사용하는것을 추천해드립니다.\n\n* 같은 도메인이라도 return 값이 다를 수 있다.\n\n예를 들어 유저와 어드민이 유저 정보를 조회해야 할 경우가 있을 것입니다. 여기에서 유저는 단순히 자기 유저 정보에 대해서만 조회가 되어야 하고, 반면 어드민이 조회하게 될 경우에 아이디가 현재 정지 상태인지 활성화 상태인지 여부도 조회되어야 합니다. 만약 여기에서 도메인에 어노테이션을 통해 무한 순환 참조 방지하거나, @JsonIgnore같은 어노테이션으로 도메인에 중요한 정보를 노출시키는 문제를 해결하려고 했다면 아마 문제가 생길것 입니다. 이유는 도메인은 하나인데 그 도메인하나로 필드를 제어하려고 했기 때문입니다. 그렇기 때문에 별도의 DTO를 가져가는 게 효율적일 것입니다.\n\n다음 회원가입후 Member 객체를 리턴하기 위해 사용되는 DTO입니다.\n\n```java\n@Getter\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\npublic class MemberResponse {\n\n    private Email email;\n    private Name name;\n\n    public MemberResponse(Member member) {\n        this.email = member.getEmail();\n        this.name = member.getName();\n    }\n}\n\n```\n\n# 마치며\n표현 영역에 대해 간단하게 알아보고 어떻게 하면 효율적으로 표현 영역을 관리할지 알아보았습니다. 위에서 말했듯이 표현 영역에서는 필수 값, 값의 형식 등을 검증을 확실히 해야만 응용서비스에서 반복된 로직이 나오지 않습니다. 그리고 응용 영역은 NULL에 대한 걱정, 데이터 format에 대한 걱정을 하지 않게 됨으로써 소스의 비지니스로직에 집중할 수 있고, 가독성이 높아집니다.\n\n물론 응용서비스를 실행하는 주체가 같은 응용서비스이거나, 파라미터로 전달받은 값이 불안정하다면 응용 영역에서 validate 처리를 해야 할 수도 있습니다. 하지만 처음부터 무결한 데이터를 받거나, 응용서비스 자체에서도 최소한 NULL을 지양하는 코드를 작성해나간다면 NULL에 대한 검사 코드는 거의 없어질것입니다. 다른장에서 어떤식으로 NULL을 지양해나가는지 알아보겠습니다.\n","source":"_posts/2018-07-26-spring-book-3.md","raw":"---\ntitle: 온라인 서점 API 만들기로 살펴보는 Spring Boot OOP 3\ncatalog: true\ndate: 2018-07-26\nsubtitle: 회원가입 Controller 만들기 - 표현영역 효율적으로 관리하기\nheader-img:\ntags:\n- Java\n- Spring\n- 온라인 서점 API 만들기로 살펴보는 Spring Boot OOP\n\n\n---\n\n# Step03 - 회원가입 Controller 만들기 : 표현영역 효율적으로 관리하기\n\n# 표현 영역\n\n먼저 컨트롤러를 작성하기 전에 표현 영역에 대해 간단히 얘기해보겠습니다. 앞장에서 말한 표현 -> 응용(서비스) -> 도메인 -> 인프라스트럭처 영역에 시작입니다. 표현 영역은 클라이언트에 요청을 받아 알맞는 응용서비스를 호출한 후 결과값을 클라이언트에게 보여주는 역할을 합니다. 표현 영역은 애플리케이션 시작인 만큼 아주 중요한 역할에 영역이라고 생각합니다. 단순 컨트롤러로써 Request Data 값을 받아서 대충 서비스로 던지는 역할이라고 생각할 수도 있습니다. \n\n하지만 표현 영역에서 Request Data 값을 받을 때 아주 잘 받아야 합니다. 대충 받는 순간 그 뒤쪽 서비스 영역, 도메인 영역, 인프라스트럭처 영역이 힘들어지기 때문입니다. 특히 서비스 영역이 힘들어집니다. 뒤쪽 영역이 왜 힘들어지는지와 뒤쪽 이 안 힘들어지기 위한 노력들을 살펴볼 것입니다. 먼저 이장에서 어떤 얘기들을 할지 나열해봤습니다.\n\n* Request값 DTO로 명시적으로 받아서 응용 영역으로 넘기기(명시적이지 않는 예(Map))\n* 클라이언트로 부터 넘어오는 데이터 validate 확실하게 하기\n* 표현영역에서 사용되는 객체들을 Service에 넘기지않기(ex : HttpServletRquest)\n* Domain 객체 바로 프론트엔드로 넘기지 않기 \n\n이장은 위의 내용을 기반으로 어떻게하면 효율적으로 표현영역을 다룰지 얘기해볼것입니다.\n\n# 1. Request Data값 DTO로 명시적으로 받아서 응용 영역으로 넘기기\n먼저 Request Data값을 명시적으로 받자입니다. 이 문제는 같이 협업하는 사람과 서비스 영역이 힘들어지기 때문입니다. 컨트롤러단에서 HttpServletRequest 값을 통해서 Request 바디 값을 받거나, Map을 이용하거나, RequestParam으로 모든 데이터를 받아서 처리하게 되면 그 당시 소스를 코딩할 할 때는 기억하지만 금방 그 데이터들이 어떤 용도에 데이터들인지 잊어버리기 때문입니다. (물론 RequestParam 같은 경우에는 필요에 따라 사용하면 매우 유용합니다.)\n\n```java\n//Map으로 받는예제\n public Map<String, Object> signUpMember(@RequestBody Map<String, Object> params){\n     \n     //something\n }\n```\n\n 조금이라도 다행인것은 Map을 표현 영역단에서 Value 값을 꺼내서 서비스단으로 넘겨주는것입니다. 만약 컨트롤러에서 받은 Map을 그대로 그냥 서비스단으로 넘기고 그것이 비지니스로직으로 이어진다면 아마 끔찍할 것입니다. 그 이유는 유지 보수와 가독성, 테스트 등이 매우 힘들어지기 때문입니다.\n\n예를 들어 다른 개발자가 그것을 유지 보수한다고 가정해보겠습니다. 유지 보수하는 사람은 그 Map이 어떻게 사용되는지 모르기 때문에 하나하나의 키값 등을 추적해야 이 Map의 Request 데이터들을 명세할 수 있습니다.\n\n심지어 다음과 같은 상황이 발생할 수도 있습니다. 클라이언트로부터 넘겨받은 값을 Map을 이용하여 아래 소스와 같이 키값이 state인 value 꺼낸다고 해보겠습니다. 클라이언트에 요구 사항으로 인해 이 키값이 status로 바뀌었습니다. 그렇게 되면 서비스 단과 컨트롤러에서 2군 대 이상 쓰인다고 하면 이것을 하나하나 다 찾아서 고쳐줘야 합니다. 이것은 type형이 아닌 String 값이기 때문에 추적하기도 힘듭니다. 뭐 물론 전체 검색해서 찾을 수도 있지만 프로젝트 내에 같은 단어가 있으면 이 또한 매우 까다롭게 됩니다.\n\n ```java\n params.get(\"state\");\n ```\n\n그렇기 때문에 아래와 과같이 명시적으로 dto를 만들고 데이터를 받는 게 좋습니다. 이렇게 명시적으로 정의하게 되면 유지 보수하는 사람 입장에서도 아 회원가입을 하기 위해서는 이러한 값들은 필수고 이러한 값은 선택인 것을 알 수 있습니다. 또한 요구 사항 등 변경에 의해 데이터가 추가되거나 하더라도 유연하게 변경할 수 있습니다. 위에서 말한 Request body key 값이 변경된다고 해도 해당 키값에 변수이기 때문에 IDE를 이용해 전체 변경을 하면 되기 때문에 아주 쉽게 변경할 수 있습니다.\n\n다음은 회원가입을 하기위해 RequestDto를 정의한것입니다.\n```java\n@Getter\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\npublic class MemberSignupRequest {\n\n    @Valid\n    private Email email;\n    @Valid\n    private Name name;\n    @Valid\n    private Password password;\n\n    public Member toMember(){\n        return new Member(email, password, name);\n    }\n}\n```\n\n\n# 2. 클라이언트로 부터 넘어오는 데이터 validate 확실하게 하기\n다음은 클라언트로부터 넘어오는 값에 대해 필수 값과 값의 형태를 표현 영역에서 확실하게 validate를 진행해야 표현 영역 이후에 영역들이 안 힘들어진다는 것입니다. 만약 표현 영역에서 필수 값, 값의 형식에 대한 validate 검사들이 제대로 되지 않는다면 서비스 영역과 도메인 영역은 계속해서 비즈니스로 직을 짜는 도중에 NULL 체크를 하는 소스를 작성해야 합니다. 이렇게 되면 비즈니스 로직을 집중할 수 없게 되고 코드의 가독성이 떨어지면서 버그로 이어질 가망성이 큽니다.\n\n예를 들어 다음과 같은 소스가 서비스 영역 전방, 심지어는 비지니스 로직 중간중간에 이어질 수 있습니다. 이렇게 되면 가독성 뿐만 아니라 유지 보수하기 매우 난해해 집니다. \n\n```java\npublic void signUpUser(final String email,final String password, final String  firstname, final String lastname){\n    if(email == null) throw new NullPointerException(\"email is null!\");\n    if(password == null) throw new NullPointerException(\"password is null!\");\n    if(firstname == null) throw new NullPointerException(\"firstname is null!\");\n    if(lastname == null) throw new NullPointerException(\"lastname is null!\");\n}\n```\n\n물론 응용서비스를 실행하는 주체가 같은 응용서비스이거나, 파라미터로 전달받은 값이 불안정하다면 응용 영역에서 validate 처리를 해야 할 수도 있습니다. 하지만 이 문제도 처음 표현 영역에서부터 무결한 데이터를 받거나, 응용서비스 자체에서도 NULL을 지양하는 코드를 작성해나간다면 응용서비스 내에 validate 코드 자체를 많이 줄여 나가실 수 있습니다.\n\n이러한 무결한 데이터를 보장하기 위해 표현 영역에서부터 NULL이 들어오는 것을 방어해야 합니다. NULL을 방어하기 위해서는 다음과 같이 ReuqestData에 대한 Validate 어노테이션을 사용하는 방법이 있습니다. @NotEmpty라는 어노테이션을 사용하게 되면 NULL이나 \"\"값들이 서비스단으로 들어오게 하는 것을 막을 수 있습니다. 또 이외에 어노테이션을 커스터마이징해서 값의 크기 또는 형태가 안 맞는 것을 응용 으로 들어가는 것을 막을 수 있습니다.\n\n```java\n\n@Embeddable\n@Getter\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\npublic class Email {\n\n    //모든곳에서 다체크해야하는 이슈발생.\n    @NotEmpty\n    @org.hibernate.validator.constraints.Email\n    @Column(name = \"email\", nullable = false, unique = true)\n    private String value;\n    \n}\n\n```\n위 NotEmpty, Email어노테이션을 사용하게 되면 어노테이션에 대한 invalid 한값이 넘어오면 프론트엔드로 BadRequest(400) 처리를 하게 됩니다. \n\n>앞장에서도 말했지만 Email을 클래스로 선언해놨기 때문에 Email을 사용하는 RequestDto들은 이 클래스를 재활용해서 사용할 수 있게 됩니다. 깨알이지만 이렇듯 클래스를 잘 빼놓으면 응집력 있는 코드를 작성할 수 있습니다. \n\n위에 validate 어노테이션을 적용하기 위해서 회원가입 컨트롤러 코드를 다음과 같이 작성하시면 되겠습니다.\n\n```java\n    @RequestMapping(value = \"/members\", method = RequestMethod.POST)\n    @ResponseStatus(value = HttpStatus.CREATED)\n    public ResponseEntity signUpMember(@RequestBody @Valid final MemberSignupRequest request, final BindingResult errors){\n        if(errors.hasErrors()) {\n            return new ResponseEntity(HttpStatus.BAD_REQUEST);\n        }\n\n        final MemberResponse member = new MemberResponse(memberSignUpService.signUp(request));\n        return new ResponseEntity<>(member, HttpStatus.CREATED);\n    }\n```\n위에 매개변수로 받는 BindingResult에 request dto를 validate 하는 과정 중에 에러를 가지고 있다면 프론트엔드에게 BadRequest(400) 상태를 보낼것입니다. 여기에서 BindingResult를 매개변수로 받지 않는다면 자동으로 프론트엔드한테 BadRequest(400) 상태를 보낼것입니다. 물론 프론트엔드에서 좀 더 세부적으로 처리하기 위해서는 에러 내용 및 Error code를 함께 보내는 게 좋습니다.\n\n\n# 3. 표현영역에서 사용되는 객체들을 응용 영역에 넘기지않기(ex : HttpServletRequest, HttpServletResponse, HttpSession)\n\n다음으로 얘기할 것은 HttpServletRequest, HttpServletResponse 와같이 표현 영역의 오브젝트 등을 Service 단으로 넘기지 말자입니다. 이렇게되면 응용 영역이 표현 영역에 의존하게 되기 때문입니다. 표현 영역의 데이터들을 받은 서비스는 서비스에서 필요로 하는 데이터를 가공해서 로직을 수행할 것입니다. 예를 들어 IP 정보, Locale 정보 등이 있을 수 있습니다. 이러한 값들을 표현 영역에서 데이터나 객체로 뽑아서 주는 게 아닌 응용 영역에 바로 HttpServletRequest를 넘기게 되면 응용 영역은 재사용하기가 매우 까다로 질 것입니다. \n\n예를 들어 주문서비스에서 유저의 HttpSession 값을 기반으로 id를 꺼내서 주문을 만들었다고 가정해보겠습니다. 그런데 이번 요구 사항 추가로 인해 유저의 HTTP 요청이 아닌 배치잡으로 주문을 만들어야 합니다. 아마 주문서비스 영역은 재사용을 하기 매우 까다로울 것입니다. 처음부터 표현 영역으로부터 HttpSession 객체가 아닌 id 값을 받아서 주문을 생성했다면 아마 쉽게 주문 서비스를 재사용할 수 있었을 것입니다.\n\n또한 테스트 코드 작성하기가 매우 까다로 진다는 것입니다. 테스트를 작성하기 위해서 매번 Mock 데이터로 HttpServletRequest, HttpServletResponse을 만들어줘야 하기 때문입니다. 이러한 이유로 위와 같은 객체들은 최대한 표현 영역에서 가공한 뒤 넘겨주는 것이 좋습니다.\n\n# 4. Domain 객체 바로 프론트엔드로 넘기지 않고 DTO 사용하기\n도메인을 바로 클라이언트로 넘기게 되면 다음과 같은 문제점들을 가집니다. \n\n* 도메인의 중요한 데이터가 외부에 노출되어 질 수 있습니다\n\n도메인 객체 자체를 리턴하게 되면 회원의 개인 정보, 패스워드 등이 로그, 클라이언트에 노출이 되어집니다. 물론 어노테이션을 통해서 중요한 필드가 노출되는것을 막을 수 있습니다. 하지만 어노테이션은 실수할 확률이 크다고 생각합니다. 실수로 어노테이션을 을 안 하거나 어노테이션을 삭제하게 되면 이 문제에 대해 쉽게 인지할 수 없기 때문입니다.\n\n반면 DTO를 사용하게 되면 현저히 실수할 확률이 줄어들게 됩니다. 그 이유는 어노테이션의 방법은 DTO 방법과는 반대로 클라이언트에 표시되지 않기 위한 데이터에 대해 어노테이션을 표시하는 반면 DTO는 필요로 하는 데이터를 필드에 추가해야 하기 때문에 실수를 할 확률이 줄어들게 됩니다. 예를 들어 화면에 보여야 할 데이터가 안 보이는 것은 DTO에 추가를 안 한 것이기 때문에 쉽게 잡을 수 있습니다. 또 한 화면에 보여야 할 데이터가 안 보인다는 것은 대부분 Test code 등으로 잡히는 문제입니다.\n\n* 회원 정보를 리턴시 무한순환참조 Exception 발생하게 됩니다.\n\n예를 들어 Rest API를 통해 클라이언트가(웹브라우저)가 Member를 조회하는 기능이 있다고 해보겠습니다. 이 Member를 클라이언트로 넘겨주기 위해서는 직렬화가 되어야 합니다. 문제는 멤버와 주문 관계상 서로를 참조하는 관계가 될 수 있다는 것입니다. 그렇게 되면 직렬화하는 과정에서 Member와 주문이 서로 계속 참조하게 되어 무한 순환 참조 Exception이 발생하게 됩니다. 뮬론 이러한 문제를 어노테이션등을 통해 방지할 수 도 있습니다. 하지만 위와 아래와 같은 이슈들 때문에 개인적으로는 DTO를 사용하는것을 추천해드립니다.\n\n* 같은 도메인이라도 return 값이 다를 수 있다.\n\n예를 들어 유저와 어드민이 유저 정보를 조회해야 할 경우가 있을 것입니다. 여기에서 유저는 단순히 자기 유저 정보에 대해서만 조회가 되어야 하고, 반면 어드민이 조회하게 될 경우에 아이디가 현재 정지 상태인지 활성화 상태인지 여부도 조회되어야 합니다. 만약 여기에서 도메인에 어노테이션을 통해 무한 순환 참조 방지하거나, @JsonIgnore같은 어노테이션으로 도메인에 중요한 정보를 노출시키는 문제를 해결하려고 했다면 아마 문제가 생길것 입니다. 이유는 도메인은 하나인데 그 도메인하나로 필드를 제어하려고 했기 때문입니다. 그렇기 때문에 별도의 DTO를 가져가는 게 효율적일 것입니다.\n\n다음 회원가입후 Member 객체를 리턴하기 위해 사용되는 DTO입니다.\n\n```java\n@Getter\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\npublic class MemberResponse {\n\n    private Email email;\n    private Name name;\n\n    public MemberResponse(Member member) {\n        this.email = member.getEmail();\n        this.name = member.getName();\n    }\n}\n\n```\n\n# 마치며\n표현 영역에 대해 간단하게 알아보고 어떻게 하면 효율적으로 표현 영역을 관리할지 알아보았습니다. 위에서 말했듯이 표현 영역에서는 필수 값, 값의 형식 등을 검증을 확실히 해야만 응용서비스에서 반복된 로직이 나오지 않습니다. 그리고 응용 영역은 NULL에 대한 걱정, 데이터 format에 대한 걱정을 하지 않게 됨으로써 소스의 비지니스로직에 집중할 수 있고, 가독성이 높아집니다.\n\n물론 응용서비스를 실행하는 주체가 같은 응용서비스이거나, 파라미터로 전달받은 값이 불안정하다면 응용 영역에서 validate 처리를 해야 할 수도 있습니다. 하지만 처음부터 무결한 데이터를 받거나, 응용서비스 자체에서도 최소한 NULL을 지양하는 코드를 작성해나간다면 NULL에 대한 검사 코드는 거의 없어질것입니다. 다른장에서 어떤식으로 NULL을 지양해나가는지 알아보겠습니다.\n","slug":"2018-07-26-spring-book-3","published":1,"updated":"2018-08-01T14:18:41.395Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27e0002ujjpea3krqpho","content":"<h1><span id=\"step03-회원가입-controller-만들기-표현영역-효율적으로-관리하기\">Step03 - 회원가입 Controller 만들기 : 표현영역 효율적으로 관리하기</span></h1>\n<h1><span id=\"표현-영역\">표현 영역</span></h1>\n<p>먼저 컨트롤러를 작성하기 전에 표현 영역에 대해 간단히 얘기해보겠습니다. 앞장에서 말한 표현 -&gt; 응용(서비스) -&gt; 도메인 -&gt; 인프라스트럭처 영역에 시작입니다. 표현 영역은 클라이언트에 요청을 받아 알맞는 응용서비스를 호출한 후 결과값을 클라이언트에게 보여주는 역할을 합니다. 표현 영역은 애플리케이션 시작인 만큼 아주 중요한 역할에 영역이라고 생각합니다. 단순 컨트롤러로써 Request Data 값을 받아서 대충 서비스로 던지는 역할이라고 생각할 수도 있습니다.</p>\n<p>하지만 표현 영역에서 Request Data 값을 받을 때 아주 잘 받아야 합니다. 대충 받는 순간 그 뒤쪽 서비스 영역, 도메인 영역, 인프라스트럭처 영역이 힘들어지기 때문입니다. 특히 서비스 영역이 힘들어집니다. 뒤쪽 영역이 왜 힘들어지는지와 뒤쪽 이 안 힘들어지기 위한 노력들을 살펴볼 것입니다. 먼저 이장에서 어떤 얘기들을 할지 나열해봤습니다.</p>\n<ul>\n<li>Request값 DTO로 명시적으로 받아서 응용 영역으로 넘기기(명시적이지 않는 예(Map))</li>\n<li>클라이언트로 부터 넘어오는 데이터 validate 확실하게 하기</li>\n<li>표현영역에서 사용되는 객체들을 Service에 넘기지않기(ex : HttpServletRquest)</li>\n<li>Domain 객체 바로 프론트엔드로 넘기지 않기</li>\n</ul>\n<p>이장은 위의 내용을 기반으로 어떻게하면 효율적으로 표현영역을 다룰지 얘기해볼것입니다.</p>\n<h1><span id=\"1-request-data값-dto로-명시적으로-받아서-응용-영역으로-넘기기\">1. Request Data값 DTO로 명시적으로 받아서 응용 영역으로 넘기기</span></h1>\n<p>먼저 Request Data값을 명시적으로 받자입니다. 이 문제는 같이 협업하는 사람과 서비스 영역이 힘들어지기 때문입니다. 컨트롤러단에서 HttpServletRequest 값을 통해서 Request 바디 값을 받거나, Map을 이용하거나, RequestParam으로 모든 데이터를 받아서 처리하게 되면 그 당시 소스를 코딩할 할 때는 기억하지만 금방 그 데이터들이 어떤 용도에 데이터들인지 잊어버리기 때문입니다. (물론 RequestParam 같은 경우에는 필요에 따라 사용하면 매우 유용합니다.)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Map으로 받는예제</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> Map&lt;String, Object&gt; <span class=\"title\">signUpMember</span><span class=\"params\">(@RequestBody Map&lt;String, Object&gt; params)</span></span>&#123;</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"comment\">//something</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>조금이라도 다행인것은 Map을 표현 영역단에서 Value 값을 꺼내서 서비스단으로 넘겨주는것입니다. 만약 컨트롤러에서 받은 Map을 그대로 그냥 서비스단으로 넘기고 그것이 비지니스로직으로 이어진다면 아마 끔찍할 것입니다. 그 이유는 유지 보수와 가독성, 테스트 등이 매우 힘들어지기 때문입니다.</p>\n<p>예를 들어 다른 개발자가 그것을 유지 보수한다고 가정해보겠습니다. 유지 보수하는 사람은 그 Map이 어떻게 사용되는지 모르기 때문에 하나하나의 키값 등을 추적해야 이 Map의 Request 데이터들을 명세할 수 있습니다.</p>\n<p>심지어 다음과 같은 상황이 발생할 수도 있습니다. 클라이언트로부터 넘겨받은 값을 Map을 이용하여 아래 소스와 같이 키값이 state인 value 꺼낸다고 해보겠습니다. 클라이언트에 요구 사항으로 인해 이 키값이 status로 바뀌었습니다. 그렇게 되면 서비스 단과 컨트롤러에서 2군 대 이상 쓰인다고 하면 이것을 하나하나 다 찾아서 고쳐줘야 합니다. 이것은 type형이 아닌 String 값이기 때문에 추적하기도 힘듭니다. 뭐 물론 전체 검색해서 찾을 수도 있지만 프로젝트 내에 같은 단어가 있으면 이 또한 매우 까다롭게 됩니다.</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">params.get(<span class=\"string\">\"state\"</span>);</span><br></pre></td></tr></table></figure>\n<p>그렇기 때문에 아래와 과같이 명시적으로 dto를 만들고 데이터를 받는 게 좋습니다. 이렇게 명시적으로 정의하게 되면 유지 보수하는 사람 입장에서도 아 회원가입을 하기 위해서는 이러한 값들은 필수고 이러한 값은 선택인 것을 알 수 있습니다. 또한 요구 사항 등 변경에 의해 데이터가 추가되거나 하더라도 유연하게 변경할 수 있습니다. 위에서 말한 Request body key 값이 변경된다고 해도 해당 키값에 변수이기 때문에 IDE를 이용해 전체 변경을 하면 되기 때문에 아주 쉽게 변경할 수 있습니다.</p>\n<p>다음은 회원가입을 하기위해 RequestDto를 정의한것입니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PROTECTED)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MemberSignupRequest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Valid</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Email email;</span><br><span class=\"line\">    <span class=\"meta\">@Valid</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Name name;</span><br><span class=\"line\">    <span class=\"meta\">@Valid</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Password password;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Member <span class=\"title\">toMember</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Member(email, password, name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"2-클라이언트로-부터-넘어오는-데이터-validate-확실하게-하기\">2. 클라이언트로 부터 넘어오는 데이터 validate 확실하게 하기</span></h1>\n<p>다음은 클라언트로부터 넘어오는 값에 대해 필수 값과 값의 형태를 표현 영역에서 확실하게 validate를 진행해야 표현 영역 이후에 영역들이 안 힘들어진다는 것입니다. 만약 표현 영역에서 필수 값, 값의 형식에 대한 validate 검사들이 제대로 되지 않는다면 서비스 영역과 도메인 영역은 계속해서 비즈니스로 직을 짜는 도중에 NULL 체크를 하는 소스를 작성해야 합니다. 이렇게 되면 비즈니스 로직을 집중할 수 없게 되고 코드의 가독성이 떨어지면서 버그로 이어질 가망성이 큽니다.</p>\n<p>예를 들어 다음과 같은 소스가 서비스 영역 전방, 심지어는 비지니스 로직 중간중간에 이어질 수 있습니다. 이렇게 되면 가독성 뿐만 아니라 유지 보수하기 매우 난해해 집니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">signUpUser</span><span class=\"params\">(<span class=\"keyword\">final</span> String email,<span class=\"keyword\">final</span> String password, <span class=\"keyword\">final</span> String  firstname, <span class=\"keyword\">final</span> String lastname)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(email == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"email is null!\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(password == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"password is null!\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(firstname == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"firstname is null!\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(lastname == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"lastname is null!\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>물론 응용서비스를 실행하는 주체가 같은 응용서비스이거나, 파라미터로 전달받은 값이 불안정하다면 응용 영역에서 validate 처리를 해야 할 수도 있습니다. 하지만 이 문제도 처음 표현 영역에서부터 무결한 데이터를 받거나, 응용서비스 자체에서도 NULL을 지양하는 코드를 작성해나간다면 응용서비스 내에 validate 코드 자체를 많이 줄여 나가실 수 있습니다.</p>\n<p>이러한 무결한 데이터를 보장하기 위해 표현 영역에서부터 NULL이 들어오는 것을 방어해야 합니다. NULL을 방어하기 위해서는 다음과 같이 ReuqestData에 대한 Validate 어노테이션을 사용하는 방법이 있습니다. @NotEmpty라는 어노테이션을 사용하게 되면 NULL이나 &quot;&quot;값들이 서비스단으로 들어오게 하는 것을 막을 수 있습니다. 또 이외에 어노테이션을 커스터마이징해서 값의 크기 또는 형태가 안 맞는 것을 응용 으로 들어가는 것을 막을 수 있습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Embeddable</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PROTECTED)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Email</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//모든곳에서 다체크해야하는 이슈발생.</span></span><br><span class=\"line\">    <span class=\"meta\">@NotEmpty</span></span><br><span class=\"line\">    <span class=\"meta\">@org</span>.hibernate.validator.constraints.Email</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"email\"</span>, nullable = <span class=\"keyword\">false</span>, unique = <span class=\"keyword\">true</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String value;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위 NotEmpty, Email어노테이션을 사용하게 되면 어노테이션에 대한 invalid 한값이 넘어오면 프론트엔드로 BadRequest(400) 처리를 하게 됩니다.</p>\n<blockquote>\n<p>앞장에서도 말했지만 Email을 클래스로 선언해놨기 때문에 Email을 사용하는 RequestDto들은 이 클래스를 재활용해서 사용할 수 있게 됩니다. 깨알이지만 이렇듯 클래스를 잘 빼놓으면 응집력 있는 코드를 작성할 수 있습니다.</p>\n</blockquote>\n<p>위에 validate 어노테이션을 적용하기 위해서 회원가입 컨트롤러 코드를 다음과 같이 작성하시면 되겠습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/members\"</span>, method = RequestMethod.POST)</span><br><span class=\"line\"><span class=\"meta\">@ResponseStatus</span>(value = HttpStatus.CREATED)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ResponseEntity <span class=\"title\">signUpMember</span><span class=\"params\">(@RequestBody @Valid <span class=\"keyword\">final</span> MemberSignupRequest request, <span class=\"keyword\">final</span> BindingResult errors)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(errors.hasErrors()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResponseEntity(HttpStatus.BAD_REQUEST);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> MemberResponse member = <span class=\"keyword\">new</span> MemberResponse(memberSignUpService.signUp(request));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResponseEntity&lt;&gt;(member, HttpStatus.CREATED);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위에 매개변수로 받는 BindingResult에 request dto를 validate 하는 과정 중에 에러를 가지고 있다면 프론트엔드에게 BadRequest(400) 상태를 보낼것입니다. 여기에서 BindingResult를 매개변수로 받지 않는다면 자동으로 프론트엔드한테 BadRequest(400) 상태를 보낼것입니다. 물론 프론트엔드에서 좀 더 세부적으로 처리하기 위해서는 에러 내용 및 Error code를 함께 보내는 게 좋습니다.</p>\n<h1><span id=\"3-표현영역에서-사용되는-객체들을-응용-영역에-넘기지않기ex-httpservletrequest-httpservletresponse-httpsession\">3. 표현영역에서 사용되는 객체들을 응용 영역에 넘기지않기(ex : HttpServletRequest, HttpServletResponse, HttpSession)</span></h1>\n<p>다음으로 얘기할 것은 HttpServletRequest, HttpServletResponse 와같이 표현 영역의 오브젝트 등을 Service 단으로 넘기지 말자입니다. 이렇게되면 응용 영역이 표현 영역에 의존하게 되기 때문입니다. 표현 영역의 데이터들을 받은 서비스는 서비스에서 필요로 하는 데이터를 가공해서 로직을 수행할 것입니다. 예를 들어 IP 정보, Locale 정보 등이 있을 수 있습니다. 이러한 값들을 표현 영역에서 데이터나 객체로 뽑아서 주는 게 아닌 응용 영역에 바로 HttpServletRequest를 넘기게 되면 응용 영역은 재사용하기가 매우 까다로 질 것입니다.</p>\n<p>예를 들어 주문서비스에서 유저의 HttpSession 값을 기반으로 id를 꺼내서 주문을 만들었다고 가정해보겠습니다. 그런데 이번 요구 사항 추가로 인해 유저의 HTTP 요청이 아닌 배치잡으로 주문을 만들어야 합니다. 아마 주문서비스 영역은 재사용을 하기 매우 까다로울 것입니다. 처음부터 표현 영역으로부터 HttpSession 객체가 아닌 id 값을 받아서 주문을 생성했다면 아마 쉽게 주문 서비스를 재사용할 수 있었을 것입니다.</p>\n<p>또한 테스트 코드 작성하기가 매우 까다로 진다는 것입니다. 테스트를 작성하기 위해서 매번 Mock 데이터로 HttpServletRequest, HttpServletResponse을 만들어줘야 하기 때문입니다. 이러한 이유로 위와 같은 객체들은 최대한 표현 영역에서 가공한 뒤 넘겨주는 것이 좋습니다.</p>\n<h1><span id=\"4-domain-객체-바로-프론트엔드로-넘기지-않고-dto-사용하기\">4. Domain 객체 바로 프론트엔드로 넘기지 않고 DTO 사용하기</span></h1>\n<p>도메인을 바로 클라이언트로 넘기게 되면 다음과 같은 문제점들을 가집니다.</p>\n<ul>\n<li>도메인의 중요한 데이터가 외부에 노출되어 질 수 있습니다</li>\n</ul>\n<p>도메인 객체 자체를 리턴하게 되면 회원의 개인 정보, 패스워드 등이 로그, 클라이언트에 노출이 되어집니다. 물론 어노테이션을 통해서 중요한 필드가 노출되는것을 막을 수 있습니다. 하지만 어노테이션은 실수할 확률이 크다고 생각합니다. 실수로 어노테이션을 을 안 하거나 어노테이션을 삭제하게 되면 이 문제에 대해 쉽게 인지할 수 없기 때문입니다.</p>\n<p>반면 DTO를 사용하게 되면 현저히 실수할 확률이 줄어들게 됩니다. 그 이유는 어노테이션의 방법은 DTO 방법과는 반대로 클라이언트에 표시되지 않기 위한 데이터에 대해 어노테이션을 표시하는 반면 DTO는 필요로 하는 데이터를 필드에 추가해야 하기 때문에 실수를 할 확률이 줄어들게 됩니다. 예를 들어 화면에 보여야 할 데이터가 안 보이는 것은 DTO에 추가를 안 한 것이기 때문에 쉽게 잡을 수 있습니다. 또 한 화면에 보여야 할 데이터가 안 보인다는 것은 대부분 Test code 등으로 잡히는 문제입니다.</p>\n<ul>\n<li>회원 정보를 리턴시 무한순환참조 Exception 발생하게 됩니다.</li>\n</ul>\n<p>예를 들어 Rest API를 통해 클라이언트가(웹브라우저)가 Member를 조회하는 기능이 있다고 해보겠습니다. 이 Member를 클라이언트로 넘겨주기 위해서는 직렬화가 되어야 합니다. 문제는 멤버와 주문 관계상 서로를 참조하는 관계가 될 수 있다는 것입니다. 그렇게 되면 직렬화하는 과정에서 Member와 주문이 서로 계속 참조하게 되어 무한 순환 참조 Exception이 발생하게 됩니다. 뮬론 이러한 문제를 어노테이션등을 통해 방지할 수 도 있습니다. 하지만 위와 아래와 같은 이슈들 때문에 개인적으로는 DTO를 사용하는것을 추천해드립니다.</p>\n<ul>\n<li>같은 도메인이라도 return 값이 다를 수 있다.</li>\n</ul>\n<p>예를 들어 유저와 어드민이 유저 정보를 조회해야 할 경우가 있을 것입니다. 여기에서 유저는 단순히 자기 유저 정보에 대해서만 조회가 되어야 하고, 반면 어드민이 조회하게 될 경우에 아이디가 현재 정지 상태인지 활성화 상태인지 여부도 조회되어야 합니다. 만약 여기에서 도메인에 어노테이션을 통해 무한 순환 참조 방지하거나, @JsonIgnore같은 어노테이션으로 도메인에 중요한 정보를 노출시키는 문제를 해결하려고 했다면 아마 문제가 생길것 입니다. 이유는 도메인은 하나인데 그 도메인하나로 필드를 제어하려고 했기 때문입니다. 그렇기 때문에 별도의 DTO를 가져가는 게 효율적일 것입니다.</p>\n<p>다음 회원가입후 Member 객체를 리턴하기 위해 사용되는 DTO입니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PROTECTED)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MemberResponse</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Email email;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Name name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MemberResponse</span><span class=\"params\">(Member member)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.email = member.getEmail();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = member.getName();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"마치며\">마치며</span></h1>\n<p>표현 영역에 대해 간단하게 알아보고 어떻게 하면 효율적으로 표현 영역을 관리할지 알아보았습니다. 위에서 말했듯이 표현 영역에서는 필수 값, 값의 형식 등을 검증을 확실히 해야만 응용서비스에서 반복된 로직이 나오지 않습니다. 그리고 응용 영역은 NULL에 대한 걱정, 데이터 format에 대한 걱정을 하지 않게 됨으로써 소스의 비지니스로직에 집중할 수 있고, 가독성이 높아집니다.</p>\n<p>물론 응용서비스를 실행하는 주체가 같은 응용서비스이거나, 파라미터로 전달받은 값이 불안정하다면 응용 영역에서 validate 처리를 해야 할 수도 있습니다. 하지만 처음부터 무결한 데이터를 받거나, 응용서비스 자체에서도 최소한 NULL을 지양하는 코드를 작성해나간다면 NULL에 대한 검사 코드는 거의 없어질것입니다. 다른장에서 어떤식으로 NULL을 지양해나가는지 알아보겠습니다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>Step03 - 회원가입 Controller 만들기 : 표현영역 효율적으로 관리하기</h1>\n<h1>표현 영역</h1>\n<p>먼저 컨트롤러를 작성하기 전에 표현 영역에 대해 간단히 얘기해보겠습니다. 앞장에서 말한 표현 -&gt; 응용(서비스) -&gt; 도메인 -&gt; 인프라스트럭처 영역에 시작입니다. 표현 영역은 클라이언트에 요청을 받아 알맞는 응용서비스를 호출한 후 결과값을 클라이언트에게 보여주는 역할을 합니다. 표현 영역은 애플리케이션 시작인 만큼 아주 중요한 역할에 영역이라고 생각합니다. 단순 컨트롤러로써 Request Data 값을 받아서 대충 서비스로 던지는 역할이라고 생각할 수도 있습니다.</p>\n<p>하지만 표현 영역에서 Request Data 값을 받을 때 아주 잘 받아야 합니다. 대충 받는 순간 그 뒤쪽 서비스 영역, 도메인 영역, 인프라스트럭처 영역이 힘들어지기 때문입니다. 특히 서비스 영역이 힘들어집니다. 뒤쪽 영역이 왜 힘들어지는지와 뒤쪽 이 안 힘들어지기 위한 노력들을 살펴볼 것입니다. 먼저 이장에서 어떤 얘기들을 할지 나열해봤습니다.</p>\n<ul>\n<li>Request값 DTO로 명시적으로 받아서 응용 영역으로 넘기기(명시적이지 않는 예(Map))</li>\n<li>클라이언트로 부터 넘어오는 데이터 validate 확실하게 하기</li>\n<li>표현영역에서 사용되는 객체들을 Service에 넘기지않기(ex : HttpServletRquest)</li>\n<li>Domain 객체 바로 프론트엔드로 넘기지 않기</li>\n</ul>\n<p>이장은 위의 내용을 기반으로 어떻게하면 효율적으로 표현영역을 다룰지 얘기해볼것입니다.</p>\n<h1>1. Request Data값 DTO로 명시적으로 받아서 응용 영역으로 넘기기</h1>\n<p>먼저 Request Data값을 명시적으로 받자입니다. 이 문제는 같이 협업하는 사람과 서비스 영역이 힘들어지기 때문입니다. 컨트롤러단에서 HttpServletRequest 값을 통해서 Request 바디 값을 받거나, Map을 이용하거나, RequestParam으로 모든 데이터를 받아서 처리하게 되면 그 당시 소스를 코딩할 할 때는 기억하지만 금방 그 데이터들이 어떤 용도에 데이터들인지 잊어버리기 때문입니다. (물론 RequestParam 같은 경우에는 필요에 따라 사용하면 매우 유용합니다.)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Map으로 받는예제</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> Map&lt;String, Object&gt; <span class=\"title\">signUpMember</span><span class=\"params\">(@RequestBody Map&lt;String, Object&gt; params)</span></span>&#123;</span><br><span class=\"line\">     </span><br><span class=\"line\">     <span class=\"comment\">//something</span></span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>조금이라도 다행인것은 Map을 표현 영역단에서 Value 값을 꺼내서 서비스단으로 넘겨주는것입니다. 만약 컨트롤러에서 받은 Map을 그대로 그냥 서비스단으로 넘기고 그것이 비지니스로직으로 이어진다면 아마 끔찍할 것입니다. 그 이유는 유지 보수와 가독성, 테스트 등이 매우 힘들어지기 때문입니다.</p>\n<p>예를 들어 다른 개발자가 그것을 유지 보수한다고 가정해보겠습니다. 유지 보수하는 사람은 그 Map이 어떻게 사용되는지 모르기 때문에 하나하나의 키값 등을 추적해야 이 Map의 Request 데이터들을 명세할 수 있습니다.</p>\n<p>심지어 다음과 같은 상황이 발생할 수도 있습니다. 클라이언트로부터 넘겨받은 값을 Map을 이용하여 아래 소스와 같이 키값이 state인 value 꺼낸다고 해보겠습니다. 클라이언트에 요구 사항으로 인해 이 키값이 status로 바뀌었습니다. 그렇게 되면 서비스 단과 컨트롤러에서 2군 대 이상 쓰인다고 하면 이것을 하나하나 다 찾아서 고쳐줘야 합니다. 이것은 type형이 아닌 String 값이기 때문에 추적하기도 힘듭니다. 뭐 물론 전체 검색해서 찾을 수도 있지만 프로젝트 내에 같은 단어가 있으면 이 또한 매우 까다롭게 됩니다.</p>\n <figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">params.get(<span class=\"string\">\"state\"</span>);</span><br></pre></td></tr></table></figure>\n<p>그렇기 때문에 아래와 과같이 명시적으로 dto를 만들고 데이터를 받는 게 좋습니다. 이렇게 명시적으로 정의하게 되면 유지 보수하는 사람 입장에서도 아 회원가입을 하기 위해서는 이러한 값들은 필수고 이러한 값은 선택인 것을 알 수 있습니다. 또한 요구 사항 등 변경에 의해 데이터가 추가되거나 하더라도 유연하게 변경할 수 있습니다. 위에서 말한 Request body key 값이 변경된다고 해도 해당 키값에 변수이기 때문에 IDE를 이용해 전체 변경을 하면 되기 때문에 아주 쉽게 변경할 수 있습니다.</p>\n<p>다음은 회원가입을 하기위해 RequestDto를 정의한것입니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PROTECTED)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MemberSignupRequest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Valid</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Email email;</span><br><span class=\"line\">    <span class=\"meta\">@Valid</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Name name;</span><br><span class=\"line\">    <span class=\"meta\">@Valid</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Password password;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Member <span class=\"title\">toMember</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Member(email, password, name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>2. 클라이언트로 부터 넘어오는 데이터 validate 확실하게 하기</h1>\n<p>다음은 클라언트로부터 넘어오는 값에 대해 필수 값과 값의 형태를 표현 영역에서 확실하게 validate를 진행해야 표현 영역 이후에 영역들이 안 힘들어진다는 것입니다. 만약 표현 영역에서 필수 값, 값의 형식에 대한 validate 검사들이 제대로 되지 않는다면 서비스 영역과 도메인 영역은 계속해서 비즈니스로 직을 짜는 도중에 NULL 체크를 하는 소스를 작성해야 합니다. 이렇게 되면 비즈니스 로직을 집중할 수 없게 되고 코드의 가독성이 떨어지면서 버그로 이어질 가망성이 큽니다.</p>\n<p>예를 들어 다음과 같은 소스가 서비스 영역 전방, 심지어는 비지니스 로직 중간중간에 이어질 수 있습니다. 이렇게 되면 가독성 뿐만 아니라 유지 보수하기 매우 난해해 집니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">signUpUser</span><span class=\"params\">(<span class=\"keyword\">final</span> String email,<span class=\"keyword\">final</span> String password, <span class=\"keyword\">final</span> String  firstname, <span class=\"keyword\">final</span> String lastname)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(email == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"email is null!\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(password == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"password is null!\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(firstname == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"firstname is null!\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(lastname == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException(<span class=\"string\">\"lastname is null!\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>물론 응용서비스를 실행하는 주체가 같은 응용서비스이거나, 파라미터로 전달받은 값이 불안정하다면 응용 영역에서 validate 처리를 해야 할 수도 있습니다. 하지만 이 문제도 처음 표현 영역에서부터 무결한 데이터를 받거나, 응용서비스 자체에서도 NULL을 지양하는 코드를 작성해나간다면 응용서비스 내에 validate 코드 자체를 많이 줄여 나가실 수 있습니다.</p>\n<p>이러한 무결한 데이터를 보장하기 위해 표현 영역에서부터 NULL이 들어오는 것을 방어해야 합니다. NULL을 방어하기 위해서는 다음과 같이 ReuqestData에 대한 Validate 어노테이션을 사용하는 방법이 있습니다. @NotEmpty라는 어노테이션을 사용하게 되면 NULL이나 &quot;&quot;값들이 서비스단으로 들어오게 하는 것을 막을 수 있습니다. 또 이외에 어노테이션을 커스터마이징해서 값의 크기 또는 형태가 안 맞는 것을 응용 으로 들어가는 것을 막을 수 있습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Embeddable</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PROTECTED)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Email</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//모든곳에서 다체크해야하는 이슈발생.</span></span><br><span class=\"line\">    <span class=\"meta\">@NotEmpty</span></span><br><span class=\"line\">    <span class=\"meta\">@org</span>.hibernate.validator.constraints.Email</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"email\"</span>, nullable = <span class=\"keyword\">false</span>, unique = <span class=\"keyword\">true</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String value;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위 NotEmpty, Email어노테이션을 사용하게 되면 어노테이션에 대한 invalid 한값이 넘어오면 프론트엔드로 BadRequest(400) 처리를 하게 됩니다.</p>\n<blockquote>\n<p>앞장에서도 말했지만 Email을 클래스로 선언해놨기 때문에 Email을 사용하는 RequestDto들은 이 클래스를 재활용해서 사용할 수 있게 됩니다. 깨알이지만 이렇듯 클래스를 잘 빼놓으면 응집력 있는 코드를 작성할 수 있습니다.</p>\n</blockquote>\n<p>위에 validate 어노테이션을 적용하기 위해서 회원가입 컨트롤러 코드를 다음과 같이 작성하시면 되겠습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(value = <span class=\"string\">\"/members\"</span>, method = RequestMethod.POST)</span><br><span class=\"line\"><span class=\"meta\">@ResponseStatus</span>(value = HttpStatus.CREATED)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ResponseEntity <span class=\"title\">signUpMember</span><span class=\"params\">(@RequestBody @Valid <span class=\"keyword\">final</span> MemberSignupRequest request, <span class=\"keyword\">final</span> BindingResult errors)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(errors.hasErrors()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResponseEntity(HttpStatus.BAD_REQUEST);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> MemberResponse member = <span class=\"keyword\">new</span> MemberResponse(memberSignUpService.signUp(request));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ResponseEntity&lt;&gt;(member, HttpStatus.CREATED);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위에 매개변수로 받는 BindingResult에 request dto를 validate 하는 과정 중에 에러를 가지고 있다면 프론트엔드에게 BadRequest(400) 상태를 보낼것입니다. 여기에서 BindingResult를 매개변수로 받지 않는다면 자동으로 프론트엔드한테 BadRequest(400) 상태를 보낼것입니다. 물론 프론트엔드에서 좀 더 세부적으로 처리하기 위해서는 에러 내용 및 Error code를 함께 보내는 게 좋습니다.</p>\n<h1>3. 표현영역에서 사용되는 객체들을 응용 영역에 넘기지않기(ex : HttpServletRequest, HttpServletResponse, HttpSession)</h1>\n<p>다음으로 얘기할 것은 HttpServletRequest, HttpServletResponse 와같이 표현 영역의 오브젝트 등을 Service 단으로 넘기지 말자입니다. 이렇게되면 응용 영역이 표현 영역에 의존하게 되기 때문입니다. 표현 영역의 데이터들을 받은 서비스는 서비스에서 필요로 하는 데이터를 가공해서 로직을 수행할 것입니다. 예를 들어 IP 정보, Locale 정보 등이 있을 수 있습니다. 이러한 값들을 표현 영역에서 데이터나 객체로 뽑아서 주는 게 아닌 응용 영역에 바로 HttpServletRequest를 넘기게 되면 응용 영역은 재사용하기가 매우 까다로 질 것입니다.</p>\n<p>예를 들어 주문서비스에서 유저의 HttpSession 값을 기반으로 id를 꺼내서 주문을 만들었다고 가정해보겠습니다. 그런데 이번 요구 사항 추가로 인해 유저의 HTTP 요청이 아닌 배치잡으로 주문을 만들어야 합니다. 아마 주문서비스 영역은 재사용을 하기 매우 까다로울 것입니다. 처음부터 표현 영역으로부터 HttpSession 객체가 아닌 id 값을 받아서 주문을 생성했다면 아마 쉽게 주문 서비스를 재사용할 수 있었을 것입니다.</p>\n<p>또한 테스트 코드 작성하기가 매우 까다로 진다는 것입니다. 테스트를 작성하기 위해서 매번 Mock 데이터로 HttpServletRequest, HttpServletResponse을 만들어줘야 하기 때문입니다. 이러한 이유로 위와 같은 객체들은 최대한 표현 영역에서 가공한 뒤 넘겨주는 것이 좋습니다.</p>\n<h1>4. Domain 객체 바로 프론트엔드로 넘기지 않고 DTO 사용하기</h1>\n<p>도메인을 바로 클라이언트로 넘기게 되면 다음과 같은 문제점들을 가집니다.</p>\n<ul>\n<li>도메인의 중요한 데이터가 외부에 노출되어 질 수 있습니다</li>\n</ul>\n<p>도메인 객체 자체를 리턴하게 되면 회원의 개인 정보, 패스워드 등이 로그, 클라이언트에 노출이 되어집니다. 물론 어노테이션을 통해서 중요한 필드가 노출되는것을 막을 수 있습니다. 하지만 어노테이션은 실수할 확률이 크다고 생각합니다. 실수로 어노테이션을 을 안 하거나 어노테이션을 삭제하게 되면 이 문제에 대해 쉽게 인지할 수 없기 때문입니다.</p>\n<p>반면 DTO를 사용하게 되면 현저히 실수할 확률이 줄어들게 됩니다. 그 이유는 어노테이션의 방법은 DTO 방법과는 반대로 클라이언트에 표시되지 않기 위한 데이터에 대해 어노테이션을 표시하는 반면 DTO는 필요로 하는 데이터를 필드에 추가해야 하기 때문에 실수를 할 확률이 줄어들게 됩니다. 예를 들어 화면에 보여야 할 데이터가 안 보이는 것은 DTO에 추가를 안 한 것이기 때문에 쉽게 잡을 수 있습니다. 또 한 화면에 보여야 할 데이터가 안 보인다는 것은 대부분 Test code 등으로 잡히는 문제입니다.</p>\n<ul>\n<li>회원 정보를 리턴시 무한순환참조 Exception 발생하게 됩니다.</li>\n</ul>\n<p>예를 들어 Rest API를 통해 클라이언트가(웹브라우저)가 Member를 조회하는 기능이 있다고 해보겠습니다. 이 Member를 클라이언트로 넘겨주기 위해서는 직렬화가 되어야 합니다. 문제는 멤버와 주문 관계상 서로를 참조하는 관계가 될 수 있다는 것입니다. 그렇게 되면 직렬화하는 과정에서 Member와 주문이 서로 계속 참조하게 되어 무한 순환 참조 Exception이 발생하게 됩니다. 뮬론 이러한 문제를 어노테이션등을 통해 방지할 수 도 있습니다. 하지만 위와 아래와 같은 이슈들 때문에 개인적으로는 DTO를 사용하는것을 추천해드립니다.</p>\n<ul>\n<li>같은 도메인이라도 return 값이 다를 수 있다.</li>\n</ul>\n<p>예를 들어 유저와 어드민이 유저 정보를 조회해야 할 경우가 있을 것입니다. 여기에서 유저는 단순히 자기 유저 정보에 대해서만 조회가 되어야 하고, 반면 어드민이 조회하게 될 경우에 아이디가 현재 정지 상태인지 활성화 상태인지 여부도 조회되어야 합니다. 만약 여기에서 도메인에 어노테이션을 통해 무한 순환 참조 방지하거나, @JsonIgnore같은 어노테이션으로 도메인에 중요한 정보를 노출시키는 문제를 해결하려고 했다면 아마 문제가 생길것 입니다. 이유는 도메인은 하나인데 그 도메인하나로 필드를 제어하려고 했기 때문입니다. 그렇기 때문에 별도의 DTO를 가져가는 게 효율적일 것입니다.</p>\n<p>다음 회원가입후 Member 객체를 리턴하기 위해 사용되는 DTO입니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PROTECTED)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MemberResponse</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Email email;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Name name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MemberResponse</span><span class=\"params\">(Member member)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.email = member.getEmail();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = member.getName();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>마치며</h1>\n<p>표현 영역에 대해 간단하게 알아보고 어떻게 하면 효율적으로 표현 영역을 관리할지 알아보았습니다. 위에서 말했듯이 표현 영역에서는 필수 값, 값의 형식 등을 검증을 확실히 해야만 응용서비스에서 반복된 로직이 나오지 않습니다. 그리고 응용 영역은 NULL에 대한 걱정, 데이터 format에 대한 걱정을 하지 않게 됨으로써 소스의 비지니스로직에 집중할 수 있고, 가독성이 높아집니다.</p>\n<p>물론 응용서비스를 실행하는 주체가 같은 응용서비스이거나, 파라미터로 전달받은 값이 불안정하다면 응용 영역에서 validate 처리를 해야 할 수도 있습니다. 하지만 처음부터 무결한 데이터를 받거나, 응용서비스 자체에서도 최소한 NULL을 지양하는 코드를 작성해나간다면 NULL에 대한 검사 코드는 거의 없어질것입니다. 다른장에서 어떤식으로 NULL을 지양해나가는지 알아보겠습니다.</p>\n"},{"title":"온라인 서점 API 만들기로 살펴보는 Spring Boot OOP 5","catalog":true,"date":"2018-07-31T15:00:00.000Z","subtitle":"회원가입 Service 만들기 - 응용영역 효율적으로 관리하기 (Part2)","header-img":null,"_content":"\n# Step-04 회원가입 Service 만들기 : 응용영역 효율적으로 관리하기 - Part2\n\n# 응용 영역(서비스)\n이번 단계는 `응용영역` 효율적으로 관리하기 - Part2 편으로 어떻게 하면 `응용영역`을 응집력 있고, 변경에 유연하고, 가독성 좋은 코드를 작성할지에 대해 알아볼 것입니다. 이장에서는 크게 아래와 같은 주제로 `응용영역`을 효율적으로 관리하는 방법에 대해 알아보겠습니다.\n\n\n* 책임\n* 도메인 HelperService 만들기\n* DTO 사용하기\n* 최종적인 회원가입 코드\n* Swagger를 통한 회원 가입 API CALL\n\n# 4. 책임(단일책임원칙)\n객체지향 설계를 하는 데 있어 기준을 잡아주는 원칙들이 있는데 이것을 SOLID 원칙이라고 합니다. 이중 먼저 단일 책임 원칙에 대한 내용을 얘기하려고 합니다. 단일 책임 원칙은 클래스는 하나의 책임을 가져야 한다는 내용입니다. 왜 클래스는 하나의 책임을 가져야 하는지에 대해 알아보겠습니다.\n\n>좀 더 책임의 의미를 잘 전달하기 위해 처음 작성한 초난감 회원가입 코드를 기반으로 이 단락을 설명하겠습니다.\n\n**초난감 회원가입 서비스 코드**\n```java\n\n@Service\n@AllArgsConstructor// 옆에 어노테이션을 통해 아래에 멤버필드들이 자동으로 스프링 빈으로 등록됨.\npublic class MemberSignUpService {\n\n    private final MemberRepository memberRepository;\n    private final CodeVerificationService codeVerificationService;\n\n    public Member signUp(final MemberSignupRequest request){\n\n        final Member duplicator = memberRepository.findByEmail(request.getEmail());\n        if(duplicator != null) throw new MemberDuplicationException();\n\n        final CodeVerification CodeVerification = codeVerificationService.findByMobile(request.getMobile()); // 유저가 있는지 여부를 확인할 수 있는데 인증코드 정보 객체\n\n        if(codeVerification.getAuthCode().equals(request.getAuthCode())){\n            Member member = request.toMember();//성공\n            memberRepository.save(member);\n            return member;\n        }else{\n            throw new MobileAuthenticationCodeFaildException();\n        }\n    }\n}\n\n```\n\n## 책임의 중요성\n먼저 책임이 뭔지 간단하게 알아보겠습니다. 클래스에서 책임의 기준은 요구 사항을 기반으로 누구에 의해 이 기능이 변경될 수 있는가를 생각하는 것입니다. 이 변경은 곧 `책임`을 의미하기 때문입니다. 각각의 책임들은 하나의 서비스 또는 클래스로 분리되어야 합니다. 그래야 변경에 유연하고 응집력 있는 코드를 가질 수 있기 때문입니다. 변경에 유연함은 버그가 없고 안정적인 코드가 되는것을 의미합니다.\n\n사실 처음 회원가입 요구 사항 분석 단계에서 구현할 기능들을 나열하면서 각각의 책임들을 분리하는 게 좋습니다. 또 개인적으로는 이러한 이유 때문에 기능 구현에 앞서 구현할 기능들을 나열해 책임들을 정리하는편입니다.\n\n> -  처음에는 요구 사항에 나열된 기능들로 바로 책임을 분리하는 게 어려울 수 있습니다. 이럴 경우 Test 코드를 작성하면서 책임을 찾아내는 게 좋은 방법일 수 있습니다. (이과정은 다음 장에서 알아보도록 하겠습니다.)\n\n다음은 왜 변경사항을 책임이라고 하고 또 분리되어야 하는지 예제를 통해 알아보겠습니다.\n\n## 책임 찾기\n먼저 회원가입 서비스에 어떤 `책임`들이 있는지 생각해보겠습니다. 위의 책임을 나누는 기준인 코드의 변경을 기반으로 책임을 찾아 보면 `회원가입`, `모바일 인증` 2가지 책임이 있을 수 있습니다.\n\n초난감 회원가입 코드를 기반으로 보면 회원가입에 대한 로직이 변경이 일어난다면 모바일 인증이라는 코드와 결합되어 있어 변경하는 로직이 쉽지 않습니다. 반대로 인증 코드 부분을보면 인증코드 이외에도 만료시간 등을 체크해야 한다고 하면 전반적인 회원가입 소스 로직을 이해한 후에야 비로소 인증 코드에 대한 로직을 수정할 수 있습니다. 단지 회원가입이 아닌 인증코드 정책에 대한 소스 수정인데도 불구하고 회원가입 로직을 이해해야 하는 상황이 발생하게 됩니다.\n\n>Email 중복 여부 체크 같은 경우에는 이메일 중복체크라는 기능이 변경이 일어날 수 없다고 생각하기 때문에 책임의 부분에서 뺏습니다. 하지만 이곳저곳 클래스에서 Email을 디비에서 검색 시 NULL 인지 검사하는 중복 소스가 발생할 수 있습니다. 이 부분은 밑에 단락에서 다루도록 하겠습니다.\n\n## 책임 분리\n만약 다른 클래스에서도 모바일 인증코드 기능을 구현해서 쓰고 있다면 사용하는 곳을 모두 변경해줘야 할 것입니다. 이렇듯 클래스 또는 서비스가 하나의 책임만을 다루지 않게 되면 변경에 엄청나게 취약하다는것을 알게되었습니다.\n\n그렇기 때문에 회원가입과 인증 코드를 확인하는 소스는 다음과 같이 별도의 서비스로 분리해야 할 것입니다.\n\n```java\n\n// MemberSignUpService.class\npublic Member signUp(final MemberSignupRequest request){\n\n    final Member duplicator = memberRepository.findByEmail(email);\n    if(duplicator != null) throw new MemberDuplicationException();\n\n    codeVerificationService.verify(request.getMobile(),request.getAuthCode());\n    Member member = request.toMember();//성공\n    memberRepository.save(member);\n    return member;\n\n}\n```\n```java\n//CodeVerificationService.class\npublic void verify(final String mobile, final String authCode) {\n    final CodeVerification codeVerification = codeVerificationRepository.findByMobile(mobile);\n    if(!codeVerification.getAuthCode().equals(request.getAuthCod))) throw new MobileAuthenticationCodeFaildException();\n}\n```\n\nMemberSignUpService에서 인증 기능의 책임을 분리한 구조입니다. 이렇게 되면 회원가입 로직이 변경되거나 모바일 인증 로직이 변경된다고 해도 서로에 영향을 주지 않게 됩니다. 이제 인증 정책이 변경된다거나 회원가입 로직이 변경된다고 해도 서로의 책임만 다해준다면 둘한테 영향을 주지 않습니다.\n\n사실 이것만으로도 기능면만 놓고 보면 코드의 응집력 + 코드 변경에 대한 유연성이 높아졌다고 할 수 있습니다. 물론 여기에 앞에 part1에서 다루었던 CodeVerification의 캡슐화된 verify() 함수를 사용한다면 더욱더 변경에 유연한 코드가 될 것입니다.\n\n## 모바일 인증과 책임을 분리한 회원가입 메소드\n\n아래는 리팩토링되어진 회원가입이 기능입니다. 이제 회원가입을 하기위해 아까와 같이 복잡합 인증코드의 로직을 이해할필요가없어졌습니다. 회원가입에 어떤 변화가 생긴다고 해도 회원가입에 대한 로직에만 집중하면 되니까 좀 더 과감하게 개발할 수 있게 되었습니다.\n\n```java\n\npublic Member signUp(final MemberSignupRequest request){\n    final Member duplicator = memberRepository.findByEmail(email);\n    if(duplicator != null) throw new MemberDuplicationException();\n    codeVerificationService.verify(request.getMobile(), request.getAuthCode());\n    Member member = request.toMember();\n    memberRepository.save(member);\n    return member;\n}\n```\n\n# 5.도메인 HelperService 만들기\n위에서 설명하지 않은 부분이 있습니다. 바로 Email 중복 체크를 하는 로직입니다. 여기에서 이메일 중복체크 여부는 사실 변경이 되거나 확장될 일이 거의 없습니다. 단순히 디비에서 해당 Email이 있는지 확인하는 로직이기 때문입니다.(물론 캐시 등을 적용할 수 도 있을 것입니다.) 사실 위에서 사용한 것처럼 아래와 같이 사용해도 크게 무방합니다.\n\n```java\nfinal Member duplicator = memberRepository.findByEmail(email);\nif(duplicator != null) throw new MemberDuplicationException();\n```\n하지만 아무래도 Email 중복체크를 하기 위해서는 전방위적으로 유저를 조회하고 NULL 인지 검사하는 로직이 중복되어야 하는 문제가 있습니다\n\n그래서 이렇게 변경이 없고 단순 조회이거나, 조회 후 NULL 체크하는 코드들은 해당 도메인에 helperService를 통해 관리하는 방법이 있습니다. 코드로 보면 아래와 같을 수 있습니다.\n\n```java\n\n//MemberHelperService\n\npublic Member findById(final long id){\n    final Member member = memberRepository.findOne(id);\n    if(member == null) throw new MemberNotFoundException();\n    return member;\n}\n\npublic void verifyEmailIsDuplicated(final Email email){\n    if(isEmailDuplicated(email)) throw new MemberDuplicationException();\n}\n```\n\n\n위와 같이 HelperService를 사용하게 되면 아이디 중복체크 외에도 특정 필드로 객체를 조회한 후 NULL을 검사하는 반복 로직들을 해당 클래스를 통해 제거할 수 있습니다.\n\n## NULL을 지양하기\n위 클래스가 바로 3장에서 말했던 부분인 NULL을 지양하게 도와주는 역할을 하는 클래스입니다. 위 소스에서 findById 후 NULL이면 그냥 MemberNotFoundException()을 던지는 부분이 있습니다. 사실 디비로부터 NULL을 받은 후 NULL을 리턴해봤자 그 후에 어디에선가 NullPointerException이 발생합니다. 그렇게 되면 오히려 더 디버깅하기 힘들어집니다. 그렇기 때문에 차라리 조회하자마자 NULL 인지 검사를 하고 해당 조회 id를 조회 하고 바로 NullPointerException를 던지는 게 더 디버깅하기 효율적입니다. NULL은 최대한 주지도 말고 받지도 말아야합니다.\n\n\n# 6. DTO 사용하기\n메서드에 전달할 파라미터가 많다면 dto를 사용하는 것을 추천드립니다. 그 이유는 표현 계층에서 말했던 이유와 비슷합니다.\n1. 해당 메서드의 파라미터가 명세화가 됩니다.\n2. 추가적인 파라미터가 있다면 유연하게 대응할 수 있습니다.\n\n\n# 7. 최종적인 회원가입 코드\n\n```java\n@Service\n@AllArgsConstructor // 옆에 어노테이션을 통해 아래에 멤버필드들이 자동으로 스프링 빈으로 등록됨.\npublic class MemberSignUpService {\n\n    private final MemberRepository memberRepository;\n    private final MemberHelperService memberHelperService;\n\n    public Member signUp(final MemberSignupRequest request){\n        memberHelperService.verifyEmailIsDuplicated(request.getEmail());\n        Member member = request.toMember();\n        memberRepository.save(member);\n        return member;\n    }\n\n}\n```\n* 모바일 인증부분은 예제 설명을 위해 추가한 부분이라 코드에서 제거했습니다.\n\n**드디어 회원가입 API가 완성되었습니다. 위에 소스를 보시면 아시겠지만 응용서비스는 직접 로직을 수행하기보다는 도메인 모델에 로직 수행시키거나 각각의 모듈들을 연결하는 역할을 합니다. 그래야 서비스 영역은 단순한 구조를 가지게 되고, 가독성이 좋아지고, 그럼으로써 품질좋은 코드를 유지할 수 있게 해줍니다.**\n\n\n\n## Swagger 를 통한 회원 가입 API CALL\n다음과 같이 Swagger 홈페이지를 통해 회원가입 API를 테스트 해보실 수 있습니다.\n\n![](https://github.com/minwan1/online-book-store/blob/master/img/swagger-test.gif)\n\n다음은 Swagger Test URL입니다. - http://localhost:8080/swagger-ui.html\n\n**회원가입 Request Body**\n```json\n{\n  \"email\": {\n    \"value\": \"test@naver.com\"\n  },\n  \"name\": {\n    \"firstname\": \"test\",\n    \"lastname\": \"test\"\n  },\n  \"password\": {\n    \"value\": \"12345\"\n  }\n}\n```\n**회원가입 Response Body**\n\n```\n{\n  \"email\": {\n    \"value\": \"test@naver.com\"\n  },\n  \"name\": {\n    \"firstname\": \"test\",\n    \"lastname\": \"test\",\n    \"fullName\": \"test test\"\n  }\n}\n\n```\n\n# 마치며\n\n회원가입 API가 드디어 만들어졌습니다. 사실 위에 초난강 회원가입 서비스처럼 생각 없이 의식의 흐름대로 코드를 작성한다면 30분 안에도 회원가입 기능을 구현할 수 있습니다. 하지만 그렇게 코드를 작성하게 되면 지금 당장은 돌아가겠지만 아마 후에 그 코드를 유지 보수하기 위해 300분 이상에 시간을 쓰고 있을 것입니다. 아주 간단한 기능 변경인데도 엄청난 리소스가 들어가게 되고, 간단한 확장인데도 코드를 손댈 수 가없어 꼼짝할 수 없는 상태가 됩니다.\n\n이러한 일이 발생하지 않도록 코드 하나를 작성하더라도 변경, 확장을 생각하면서 코드를 만들어야 합니다. 그래야 기능이 변경되더라도 유연하게 변경하고, 확장해나갈 수 있기 때문입니다. 이러한 기준을 잡게 도와주는 원칙이 위에서 말한 SOLID 원칙이라는게 있습니다.\n\n위에 예제 코드에서도 좀 부족한 부분이 있습니다. 확장 부분이나, codeVerificationService 클래스에 너무 의존하고 있는 모습들이 대표적인 예입니다. 이러한 문제들을 어떻게 풀어갈지에 대한 방법들은 주문 API를 만들면서 알아보도록 하겠습니다.\n\n아마 다음 장에서는 주문 API를 만들기 전에 테스트 코드에 대한 내용을 다룰 것 같습니다. 긴 내용 읽어주셔서 감사합니다.(__)\n","source":"_posts/2018-07-26-spring-book-5.md","raw":"---\ntitle: 온라인 서점 API 만들기로 살펴보는 Spring Boot OOP 5\ncatalog: true\ndate: 2018-08-01\nsubtitle: 회원가입 Service 만들기 - 응용영역 효율적으로 관리하기 (Part2)\nheader-img:\ntags:\n- Java\n- Spring\n- 온라인 서점 API 만들기로 살펴보는 Spring Boot OOP\n\n\n---\n\n# Step-04 회원가입 Service 만들기 : 응용영역 효율적으로 관리하기 - Part2\n\n# 응용 영역(서비스)\n이번 단계는 `응용영역` 효율적으로 관리하기 - Part2 편으로 어떻게 하면 `응용영역`을 응집력 있고, 변경에 유연하고, 가독성 좋은 코드를 작성할지에 대해 알아볼 것입니다. 이장에서는 크게 아래와 같은 주제로 `응용영역`을 효율적으로 관리하는 방법에 대해 알아보겠습니다.\n\n\n* 책임\n* 도메인 HelperService 만들기\n* DTO 사용하기\n* 최종적인 회원가입 코드\n* Swagger를 통한 회원 가입 API CALL\n\n# 4. 책임(단일책임원칙)\n객체지향 설계를 하는 데 있어 기준을 잡아주는 원칙들이 있는데 이것을 SOLID 원칙이라고 합니다. 이중 먼저 단일 책임 원칙에 대한 내용을 얘기하려고 합니다. 단일 책임 원칙은 클래스는 하나의 책임을 가져야 한다는 내용입니다. 왜 클래스는 하나의 책임을 가져야 하는지에 대해 알아보겠습니다.\n\n>좀 더 책임의 의미를 잘 전달하기 위해 처음 작성한 초난감 회원가입 코드를 기반으로 이 단락을 설명하겠습니다.\n\n**초난감 회원가입 서비스 코드**\n```java\n\n@Service\n@AllArgsConstructor// 옆에 어노테이션을 통해 아래에 멤버필드들이 자동으로 스프링 빈으로 등록됨.\npublic class MemberSignUpService {\n\n    private final MemberRepository memberRepository;\n    private final CodeVerificationService codeVerificationService;\n\n    public Member signUp(final MemberSignupRequest request){\n\n        final Member duplicator = memberRepository.findByEmail(request.getEmail());\n        if(duplicator != null) throw new MemberDuplicationException();\n\n        final CodeVerification CodeVerification = codeVerificationService.findByMobile(request.getMobile()); // 유저가 있는지 여부를 확인할 수 있는데 인증코드 정보 객체\n\n        if(codeVerification.getAuthCode().equals(request.getAuthCode())){\n            Member member = request.toMember();//성공\n            memberRepository.save(member);\n            return member;\n        }else{\n            throw new MobileAuthenticationCodeFaildException();\n        }\n    }\n}\n\n```\n\n## 책임의 중요성\n먼저 책임이 뭔지 간단하게 알아보겠습니다. 클래스에서 책임의 기준은 요구 사항을 기반으로 누구에 의해 이 기능이 변경될 수 있는가를 생각하는 것입니다. 이 변경은 곧 `책임`을 의미하기 때문입니다. 각각의 책임들은 하나의 서비스 또는 클래스로 분리되어야 합니다. 그래야 변경에 유연하고 응집력 있는 코드를 가질 수 있기 때문입니다. 변경에 유연함은 버그가 없고 안정적인 코드가 되는것을 의미합니다.\n\n사실 처음 회원가입 요구 사항 분석 단계에서 구현할 기능들을 나열하면서 각각의 책임들을 분리하는 게 좋습니다. 또 개인적으로는 이러한 이유 때문에 기능 구현에 앞서 구현할 기능들을 나열해 책임들을 정리하는편입니다.\n\n> -  처음에는 요구 사항에 나열된 기능들로 바로 책임을 분리하는 게 어려울 수 있습니다. 이럴 경우 Test 코드를 작성하면서 책임을 찾아내는 게 좋은 방법일 수 있습니다. (이과정은 다음 장에서 알아보도록 하겠습니다.)\n\n다음은 왜 변경사항을 책임이라고 하고 또 분리되어야 하는지 예제를 통해 알아보겠습니다.\n\n## 책임 찾기\n먼저 회원가입 서비스에 어떤 `책임`들이 있는지 생각해보겠습니다. 위의 책임을 나누는 기준인 코드의 변경을 기반으로 책임을 찾아 보면 `회원가입`, `모바일 인증` 2가지 책임이 있을 수 있습니다.\n\n초난감 회원가입 코드를 기반으로 보면 회원가입에 대한 로직이 변경이 일어난다면 모바일 인증이라는 코드와 결합되어 있어 변경하는 로직이 쉽지 않습니다. 반대로 인증 코드 부분을보면 인증코드 이외에도 만료시간 등을 체크해야 한다고 하면 전반적인 회원가입 소스 로직을 이해한 후에야 비로소 인증 코드에 대한 로직을 수정할 수 있습니다. 단지 회원가입이 아닌 인증코드 정책에 대한 소스 수정인데도 불구하고 회원가입 로직을 이해해야 하는 상황이 발생하게 됩니다.\n\n>Email 중복 여부 체크 같은 경우에는 이메일 중복체크라는 기능이 변경이 일어날 수 없다고 생각하기 때문에 책임의 부분에서 뺏습니다. 하지만 이곳저곳 클래스에서 Email을 디비에서 검색 시 NULL 인지 검사하는 중복 소스가 발생할 수 있습니다. 이 부분은 밑에 단락에서 다루도록 하겠습니다.\n\n## 책임 분리\n만약 다른 클래스에서도 모바일 인증코드 기능을 구현해서 쓰고 있다면 사용하는 곳을 모두 변경해줘야 할 것입니다. 이렇듯 클래스 또는 서비스가 하나의 책임만을 다루지 않게 되면 변경에 엄청나게 취약하다는것을 알게되었습니다.\n\n그렇기 때문에 회원가입과 인증 코드를 확인하는 소스는 다음과 같이 별도의 서비스로 분리해야 할 것입니다.\n\n```java\n\n// MemberSignUpService.class\npublic Member signUp(final MemberSignupRequest request){\n\n    final Member duplicator = memberRepository.findByEmail(email);\n    if(duplicator != null) throw new MemberDuplicationException();\n\n    codeVerificationService.verify(request.getMobile(),request.getAuthCode());\n    Member member = request.toMember();//성공\n    memberRepository.save(member);\n    return member;\n\n}\n```\n```java\n//CodeVerificationService.class\npublic void verify(final String mobile, final String authCode) {\n    final CodeVerification codeVerification = codeVerificationRepository.findByMobile(mobile);\n    if(!codeVerification.getAuthCode().equals(request.getAuthCod))) throw new MobileAuthenticationCodeFaildException();\n}\n```\n\nMemberSignUpService에서 인증 기능의 책임을 분리한 구조입니다. 이렇게 되면 회원가입 로직이 변경되거나 모바일 인증 로직이 변경된다고 해도 서로에 영향을 주지 않게 됩니다. 이제 인증 정책이 변경된다거나 회원가입 로직이 변경된다고 해도 서로의 책임만 다해준다면 둘한테 영향을 주지 않습니다.\n\n사실 이것만으로도 기능면만 놓고 보면 코드의 응집력 + 코드 변경에 대한 유연성이 높아졌다고 할 수 있습니다. 물론 여기에 앞에 part1에서 다루었던 CodeVerification의 캡슐화된 verify() 함수를 사용한다면 더욱더 변경에 유연한 코드가 될 것입니다.\n\n## 모바일 인증과 책임을 분리한 회원가입 메소드\n\n아래는 리팩토링되어진 회원가입이 기능입니다. 이제 회원가입을 하기위해 아까와 같이 복잡합 인증코드의 로직을 이해할필요가없어졌습니다. 회원가입에 어떤 변화가 생긴다고 해도 회원가입에 대한 로직에만 집중하면 되니까 좀 더 과감하게 개발할 수 있게 되었습니다.\n\n```java\n\npublic Member signUp(final MemberSignupRequest request){\n    final Member duplicator = memberRepository.findByEmail(email);\n    if(duplicator != null) throw new MemberDuplicationException();\n    codeVerificationService.verify(request.getMobile(), request.getAuthCode());\n    Member member = request.toMember();\n    memberRepository.save(member);\n    return member;\n}\n```\n\n# 5.도메인 HelperService 만들기\n위에서 설명하지 않은 부분이 있습니다. 바로 Email 중복 체크를 하는 로직입니다. 여기에서 이메일 중복체크 여부는 사실 변경이 되거나 확장될 일이 거의 없습니다. 단순히 디비에서 해당 Email이 있는지 확인하는 로직이기 때문입니다.(물론 캐시 등을 적용할 수 도 있을 것입니다.) 사실 위에서 사용한 것처럼 아래와 같이 사용해도 크게 무방합니다.\n\n```java\nfinal Member duplicator = memberRepository.findByEmail(email);\nif(duplicator != null) throw new MemberDuplicationException();\n```\n하지만 아무래도 Email 중복체크를 하기 위해서는 전방위적으로 유저를 조회하고 NULL 인지 검사하는 로직이 중복되어야 하는 문제가 있습니다\n\n그래서 이렇게 변경이 없고 단순 조회이거나, 조회 후 NULL 체크하는 코드들은 해당 도메인에 helperService를 통해 관리하는 방법이 있습니다. 코드로 보면 아래와 같을 수 있습니다.\n\n```java\n\n//MemberHelperService\n\npublic Member findById(final long id){\n    final Member member = memberRepository.findOne(id);\n    if(member == null) throw new MemberNotFoundException();\n    return member;\n}\n\npublic void verifyEmailIsDuplicated(final Email email){\n    if(isEmailDuplicated(email)) throw new MemberDuplicationException();\n}\n```\n\n\n위와 같이 HelperService를 사용하게 되면 아이디 중복체크 외에도 특정 필드로 객체를 조회한 후 NULL을 검사하는 반복 로직들을 해당 클래스를 통해 제거할 수 있습니다.\n\n## NULL을 지양하기\n위 클래스가 바로 3장에서 말했던 부분인 NULL을 지양하게 도와주는 역할을 하는 클래스입니다. 위 소스에서 findById 후 NULL이면 그냥 MemberNotFoundException()을 던지는 부분이 있습니다. 사실 디비로부터 NULL을 받은 후 NULL을 리턴해봤자 그 후에 어디에선가 NullPointerException이 발생합니다. 그렇게 되면 오히려 더 디버깅하기 힘들어집니다. 그렇기 때문에 차라리 조회하자마자 NULL 인지 검사를 하고 해당 조회 id를 조회 하고 바로 NullPointerException를 던지는 게 더 디버깅하기 효율적입니다. NULL은 최대한 주지도 말고 받지도 말아야합니다.\n\n\n# 6. DTO 사용하기\n메서드에 전달할 파라미터가 많다면 dto를 사용하는 것을 추천드립니다. 그 이유는 표현 계층에서 말했던 이유와 비슷합니다.\n1. 해당 메서드의 파라미터가 명세화가 됩니다.\n2. 추가적인 파라미터가 있다면 유연하게 대응할 수 있습니다.\n\n\n# 7. 최종적인 회원가입 코드\n\n```java\n@Service\n@AllArgsConstructor // 옆에 어노테이션을 통해 아래에 멤버필드들이 자동으로 스프링 빈으로 등록됨.\npublic class MemberSignUpService {\n\n    private final MemberRepository memberRepository;\n    private final MemberHelperService memberHelperService;\n\n    public Member signUp(final MemberSignupRequest request){\n        memberHelperService.verifyEmailIsDuplicated(request.getEmail());\n        Member member = request.toMember();\n        memberRepository.save(member);\n        return member;\n    }\n\n}\n```\n* 모바일 인증부분은 예제 설명을 위해 추가한 부분이라 코드에서 제거했습니다.\n\n**드디어 회원가입 API가 완성되었습니다. 위에 소스를 보시면 아시겠지만 응용서비스는 직접 로직을 수행하기보다는 도메인 모델에 로직 수행시키거나 각각의 모듈들을 연결하는 역할을 합니다. 그래야 서비스 영역은 단순한 구조를 가지게 되고, 가독성이 좋아지고, 그럼으로써 품질좋은 코드를 유지할 수 있게 해줍니다.**\n\n\n\n## Swagger 를 통한 회원 가입 API CALL\n다음과 같이 Swagger 홈페이지를 통해 회원가입 API를 테스트 해보실 수 있습니다.\n\n![](https://github.com/minwan1/online-book-store/blob/master/img/swagger-test.gif)\n\n다음은 Swagger Test URL입니다. - http://localhost:8080/swagger-ui.html\n\n**회원가입 Request Body**\n```json\n{\n  \"email\": {\n    \"value\": \"test@naver.com\"\n  },\n  \"name\": {\n    \"firstname\": \"test\",\n    \"lastname\": \"test\"\n  },\n  \"password\": {\n    \"value\": \"12345\"\n  }\n}\n```\n**회원가입 Response Body**\n\n```\n{\n  \"email\": {\n    \"value\": \"test@naver.com\"\n  },\n  \"name\": {\n    \"firstname\": \"test\",\n    \"lastname\": \"test\",\n    \"fullName\": \"test test\"\n  }\n}\n\n```\n\n# 마치며\n\n회원가입 API가 드디어 만들어졌습니다. 사실 위에 초난강 회원가입 서비스처럼 생각 없이 의식의 흐름대로 코드를 작성한다면 30분 안에도 회원가입 기능을 구현할 수 있습니다. 하지만 그렇게 코드를 작성하게 되면 지금 당장은 돌아가겠지만 아마 후에 그 코드를 유지 보수하기 위해 300분 이상에 시간을 쓰고 있을 것입니다. 아주 간단한 기능 변경인데도 엄청난 리소스가 들어가게 되고, 간단한 확장인데도 코드를 손댈 수 가없어 꼼짝할 수 없는 상태가 됩니다.\n\n이러한 일이 발생하지 않도록 코드 하나를 작성하더라도 변경, 확장을 생각하면서 코드를 만들어야 합니다. 그래야 기능이 변경되더라도 유연하게 변경하고, 확장해나갈 수 있기 때문입니다. 이러한 기준을 잡게 도와주는 원칙이 위에서 말한 SOLID 원칙이라는게 있습니다.\n\n위에 예제 코드에서도 좀 부족한 부분이 있습니다. 확장 부분이나, codeVerificationService 클래스에 너무 의존하고 있는 모습들이 대표적인 예입니다. 이러한 문제들을 어떻게 풀어갈지에 대한 방법들은 주문 API를 만들면서 알아보도록 하겠습니다.\n\n아마 다음 장에서는 주문 API를 만들기 전에 테스트 코드에 대한 내용을 다룰 것 같습니다. 긴 내용 읽어주셔서 감사합니다.(__)\n","slug":"2018-07-26-spring-book-5","published":1,"updated":"2018-08-01T14:23:02.117Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27e1002wjjpefwiovgk3","content":"<h1><span id=\"step-04-회원가입-service-만들기-응용영역-효율적으로-관리하기-part2\">Step-04 회원가입 Service 만들기 : 응용영역 효율적으로 관리하기 - Part2</span></h1>\n<h1><span id=\"응용-영역서비스\">응용 영역(서비스)</span></h1>\n<p>이번 단계는 <code>응용영역</code> 효율적으로 관리하기 - Part2 편으로 어떻게 하면 <code>응용영역</code>을 응집력 있고, 변경에 유연하고, 가독성 좋은 코드를 작성할지에 대해 알아볼 것입니다. 이장에서는 크게 아래와 같은 주제로 <code>응용영역</code>을 효율적으로 관리하는 방법에 대해 알아보겠습니다.</p>\n<ul>\n<li>책임</li>\n<li>도메인 HelperService 만들기</li>\n<li>DTO 사용하기</li>\n<li>최종적인 회원가입 코드</li>\n<li>Swagger를 통한 회원 가입 API CALL</li>\n</ul>\n<h1><span id=\"4-책임단일책임원칙\">4. 책임(단일책임원칙)</span></h1>\n<p>객체지향 설계를 하는 데 있어 기준을 잡아주는 원칙들이 있는데 이것을 SOLID 원칙이라고 합니다. 이중 먼저 단일 책임 원칙에 대한 내용을 얘기하려고 합니다. 단일 책임 원칙은 클래스는 하나의 책임을 가져야 한다는 내용입니다. 왜 클래스는 하나의 책임을 가져야 하는지에 대해 알아보겠습니다.</p>\n<blockquote>\n<p>좀 더 책임의 의미를 잘 전달하기 위해 처음 작성한 초난감 회원가입 코드를 기반으로 이 단락을 설명하겠습니다.</p>\n</blockquote>\n<p><strong>초난감 회원가입 서비스 코드</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span><span class=\"comment\">// 옆에 어노테이션을 통해 아래에 멤버필드들이 자동으로 스프링 빈으로 등록됨.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MemberSignUpService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MemberRepository memberRepository;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CodeVerificationService codeVerificationService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Member <span class=\"title\">signUp</span><span class=\"params\">(<span class=\"keyword\">final</span> MemberSignupRequest request)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Member duplicator = memberRepository.findByEmail(request.getEmail());</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(duplicator != <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MemberDuplicationException();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> CodeVerification CodeVerification = codeVerificationService.findByMobile(request.getMobile()); <span class=\"comment\">// 유저가 있는지 여부를 확인할 수 있는데 인증코드 정보 객체</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(codeVerification.getAuthCode().equals(request.getAuthCode()))&#123;</span><br><span class=\"line\">            Member member = request.toMember();<span class=\"comment\">//성공</span></span><br><span class=\"line\">            memberRepository.save(member);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> member;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MobileAuthenticationCodeFaildException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"책임의-중요성\">책임의 중요성</span></h2>\n<p>먼저 책임이 뭔지 간단하게 알아보겠습니다. 클래스에서 책임의 기준은 요구 사항을 기반으로 누구에 의해 이 기능이 변경될 수 있는가를 생각하는 것입니다. 이 변경은 곧 <code>책임</code>을 의미하기 때문입니다. 각각의 책임들은 하나의 서비스 또는 클래스로 분리되어야 합니다. 그래야 변경에 유연하고 응집력 있는 코드를 가질 수 있기 때문입니다. 변경에 유연함은 버그가 없고 안정적인 코드가 되는것을 의미합니다.</p>\n<p>사실 처음 회원가입 요구 사항 분석 단계에서 구현할 기능들을 나열하면서 각각의 책임들을 분리하는 게 좋습니다. 또 개인적으로는 이러한 이유 때문에 기능 구현에 앞서 구현할 기능들을 나열해 책임들을 정리하는편입니다.</p>\n<blockquote>\n<ul>\n<li>처음에는 요구 사항에 나열된 기능들로 바로 책임을 분리하는 게 어려울 수 있습니다. 이럴 경우 Test 코드를 작성하면서 책임을 찾아내는 게 좋은 방법일 수 있습니다. (이과정은 다음 장에서 알아보도록 하겠습니다.)</li>\n</ul>\n</blockquote>\n<p>다음은 왜 변경사항을 책임이라고 하고 또 분리되어야 하는지 예제를 통해 알아보겠습니다.</p>\n<h2><span id=\"책임-찾기\">책임 찾기</span></h2>\n<p>먼저 회원가입 서비스에 어떤 <code>책임</code>들이 있는지 생각해보겠습니다. 위의 책임을 나누는 기준인 코드의 변경을 기반으로 책임을 찾아 보면 <code>회원가입</code>, <code>모바일 인증</code> 2가지 책임이 있을 수 있습니다.</p>\n<p>초난감 회원가입 코드를 기반으로 보면 회원가입에 대한 로직이 변경이 일어난다면 모바일 인증이라는 코드와 결합되어 있어 변경하는 로직이 쉽지 않습니다. 반대로 인증 코드 부분을보면 인증코드 이외에도 만료시간 등을 체크해야 한다고 하면 전반적인 회원가입 소스 로직을 이해한 후에야 비로소 인증 코드에 대한 로직을 수정할 수 있습니다. 단지 회원가입이 아닌 인증코드 정책에 대한 소스 수정인데도 불구하고 회원가입 로직을 이해해야 하는 상황이 발생하게 됩니다.</p>\n<blockquote>\n<p>Email 중복 여부 체크 같은 경우에는 이메일 중복체크라는 기능이 변경이 일어날 수 없다고 생각하기 때문에 책임의 부분에서 뺏습니다. 하지만 이곳저곳 클래스에서 Email을 디비에서 검색 시 NULL 인지 검사하는 중복 소스가 발생할 수 있습니다. 이 부분은 밑에 단락에서 다루도록 하겠습니다.</p>\n</blockquote>\n<h2><span id=\"책임-분리\">책임 분리</span></h2>\n<p>만약 다른 클래스에서도 모바일 인증코드 기능을 구현해서 쓰고 있다면 사용하는 곳을 모두 변경해줘야 할 것입니다. 이렇듯 클래스 또는 서비스가 하나의 책임만을 다루지 않게 되면 변경에 엄청나게 취약하다는것을 알게되었습니다.</p>\n<p>그렇기 때문에 회원가입과 인증 코드를 확인하는 소스는 다음과 같이 별도의 서비스로 분리해야 할 것입니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MemberSignUpService.class</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Member <span class=\"title\">signUp</span><span class=\"params\">(<span class=\"keyword\">final</span> MemberSignupRequest request)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Member duplicator = memberRepository.findByEmail(email);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(duplicator != <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MemberDuplicationException();</span><br><span class=\"line\"></span><br><span class=\"line\">    codeVerificationService.verify(request.getMobile(),request.getAuthCode());</span><br><span class=\"line\">    Member member = request.toMember();<span class=\"comment\">//성공</span></span><br><span class=\"line\">    memberRepository.save(member);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> member;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//CodeVerificationService.class</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">verify</span><span class=\"params\">(<span class=\"keyword\">final</span> String mobile, <span class=\"keyword\">final</span> String authCode)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> CodeVerification codeVerification = codeVerificationRepository.findByMobile(mobile);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!codeVerification.getAuthCode().equals(request.getAuthCod))) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MobileAuthenticationCodeFaildException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MemberSignUpService에서 인증 기능의 책임을 분리한 구조입니다. 이렇게 되면 회원가입 로직이 변경되거나 모바일 인증 로직이 변경된다고 해도 서로에 영향을 주지 않게 됩니다. 이제 인증 정책이 변경된다거나 회원가입 로직이 변경된다고 해도 서로의 책임만 다해준다면 둘한테 영향을 주지 않습니다.</p>\n<p>사실 이것만으로도 기능면만 놓고 보면 코드의 응집력 + 코드 변경에 대한 유연성이 높아졌다고 할 수 있습니다. 물론 여기에 앞에 part1에서 다루었던 CodeVerification의 캡슐화된 verify() 함수를 사용한다면 더욱더 변경에 유연한 코드가 될 것입니다.</p>\n<h2><span id=\"모바일-인증과-책임을-분리한-회원가입-메소드\">모바일 인증과 책임을 분리한 회원가입 메소드</span></h2>\n<p>아래는 리팩토링되어진 회원가입이 기능입니다. 이제 회원가입을 하기위해 아까와 같이 복잡합 인증코드의 로직을 이해할필요가없어졌습니다. 회원가입에 어떤 변화가 생긴다고 해도 회원가입에 대한 로직에만 집중하면 되니까 좀 더 과감하게 개발할 수 있게 되었습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Member <span class=\"title\">signUp</span><span class=\"params\">(<span class=\"keyword\">final</span> MemberSignupRequest request)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Member duplicator = memberRepository.findByEmail(email);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(duplicator != <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MemberDuplicationException();</span><br><span class=\"line\">    codeVerificationService.verify(request.getMobile(), request.getAuthCode());</span><br><span class=\"line\">    Member member = request.toMember();</span><br><span class=\"line\">    memberRepository.save(member);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> member;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"5도메인-helperservice-만들기\">5.도메인 HelperService 만들기</span></h1>\n<p>위에서 설명하지 않은 부분이 있습니다. 바로 Email 중복 체크를 하는 로직입니다. 여기에서 이메일 중복체크 여부는 사실 변경이 되거나 확장될 일이 거의 없습니다. 단순히 디비에서 해당 Email이 있는지 확인하는 로직이기 때문입니다.(물론 캐시 등을 적용할 수 도 있을 것입니다.) 사실 위에서 사용한 것처럼 아래와 같이 사용해도 크게 무방합니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Member duplicator = memberRepository.findByEmail(email);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(duplicator != <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MemberDuplicationException();</span><br></pre></td></tr></table></figure>\n<p>하지만 아무래도 Email 중복체크를 하기 위해서는 전방위적으로 유저를 조회하고 NULL 인지 검사하는 로직이 중복되어야 하는 문제가 있습니다</p>\n<p>그래서 이렇게 변경이 없고 단순 조회이거나, 조회 후 NULL 체크하는 코드들은 해당 도메인에 helperService를 통해 관리하는 방법이 있습니다. 코드로 보면 아래와 같을 수 있습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//MemberHelperService</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Member <span class=\"title\">findById</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> id)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Member member = memberRepository.findOne(id);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(member == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MemberNotFoundException();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> member;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">verifyEmailIsDuplicated</span><span class=\"params\">(<span class=\"keyword\">final</span> Email email)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(isEmailDuplicated(email)) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MemberDuplicationException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위와 같이 HelperService를 사용하게 되면 아이디 중복체크 외에도 특정 필드로 객체를 조회한 후 NULL을 검사하는 반복 로직들을 해당 클래스를 통해 제거할 수 있습니다.</p>\n<h2><span id=\"null을-지양하기\">NULL을 지양하기</span></h2>\n<p>위 클래스가 바로 3장에서 말했던 부분인 NULL을 지양하게 도와주는 역할을 하는 클래스입니다. 위 소스에서 findById 후 NULL이면 그냥 MemberNotFoundException()을 던지는 부분이 있습니다. 사실 디비로부터 NULL을 받은 후 NULL을 리턴해봤자 그 후에 어디에선가 NullPointerException이 발생합니다. 그렇게 되면 오히려 더 디버깅하기 힘들어집니다. 그렇기 때문에 차라리 조회하자마자 NULL 인지 검사를 하고 해당 조회 id를 조회 하고 바로 NullPointerException를 던지는 게 더 디버깅하기 효율적입니다. NULL은 최대한 주지도 말고 받지도 말아야합니다.</p>\n<h1><span id=\"6-dto-사용하기\">6. DTO 사용하기</span></h1>\n<p>메서드에 전달할 파라미터가 많다면 dto를 사용하는 것을 추천드립니다. 그 이유는 표현 계층에서 말했던 이유와 비슷합니다.</p>\n<ol>\n<li>해당 메서드의 파라미터가 명세화가 됩니다.</li>\n<li>추가적인 파라미터가 있다면 유연하게 대응할 수 있습니다.</li>\n</ol>\n<h1><span id=\"7-최종적인-회원가입-코드\">7. 최종적인 회원가입 코드</span></h1>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span> <span class=\"comment\">// 옆에 어노테이션을 통해 아래에 멤버필드들이 자동으로 스프링 빈으로 등록됨.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MemberSignUpService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MemberRepository memberRepository;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MemberHelperService memberHelperService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Member <span class=\"title\">signUp</span><span class=\"params\">(<span class=\"keyword\">final</span> MemberSignupRequest request)</span></span>&#123;</span><br><span class=\"line\">        memberHelperService.verifyEmailIsDuplicated(request.getEmail());</span><br><span class=\"line\">        Member member = request.toMember();</span><br><span class=\"line\">        memberRepository.save(member);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> member;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>모바일 인증부분은 예제 설명을 위해 추가한 부분이라 코드에서 제거했습니다.</li>\n</ul>\n<p><strong>드디어 회원가입 API가 완성되었습니다. 위에 소스를 보시면 아시겠지만 응용서비스는 직접 로직을 수행하기보다는 도메인 모델에 로직 수행시키거나 각각의 모듈들을 연결하는 역할을 합니다. 그래야 서비스 영역은 단순한 구조를 가지게 되고, 가독성이 좋아지고, 그럼으로써 품질좋은 코드를 유지할 수 있게 해줍니다.</strong></p>\n<h2><span id=\"swagger-를-통한-회원-가입-api-call\">Swagger 를 통한 회원 가입 API CALL</span></h2>\n<p>다음과 같이 Swagger 홈페이지를 통해 회원가입 API를 테스트 해보실 수 있습니다.</p>\n<p><img src=\"https://github.com/minwan1/online-book-store/blob/master/img/swagger-test.gif\" alt=\"\"></p>\n<p>다음은 Swagger Test URL입니다. - <a href=\"http://localhost:8080/swagger-ui.html\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/swagger-ui.html</a></p>\n<p><strong>회원가입 Request Body</strong></p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"email\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"value\"</span>: <span class=\"string\">\"test@naver.com\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"firstname\"</span>: <span class=\"string\">\"test\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"lastname\"</span>: <span class=\"string\">\"test\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"password\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"value\"</span>: <span class=\"string\">\"12345\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>회원가입 Response Body</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;email&quot;: &#123;</span><br><span class=\"line\">    &quot;value&quot;: &quot;test@naver.com&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;name&quot;: &#123;</span><br><span class=\"line\">    &quot;firstname&quot;: &quot;test&quot;,</span><br><span class=\"line\">    &quot;lastname&quot;: &quot;test&quot;,</span><br><span class=\"line\">    &quot;fullName&quot;: &quot;test test&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"마치며\">마치며</span></h1>\n<p>회원가입 API가 드디어 만들어졌습니다. 사실 위에 초난강 회원가입 서비스처럼 생각 없이 의식의 흐름대로 코드를 작성한다면 30분 안에도 회원가입 기능을 구현할 수 있습니다. 하지만 그렇게 코드를 작성하게 되면 지금 당장은 돌아가겠지만 아마 후에 그 코드를 유지 보수하기 위해 300분 이상에 시간을 쓰고 있을 것입니다. 아주 간단한 기능 변경인데도 엄청난 리소스가 들어가게 되고, 간단한 확장인데도 코드를 손댈 수 가없어 꼼짝할 수 없는 상태가 됩니다.</p>\n<p>이러한 일이 발생하지 않도록 코드 하나를 작성하더라도 변경, 확장을 생각하면서 코드를 만들어야 합니다. 그래야 기능이 변경되더라도 유연하게 변경하고, 확장해나갈 수 있기 때문입니다. 이러한 기준을 잡게 도와주는 원칙이 위에서 말한 SOLID 원칙이라는게 있습니다.</p>\n<p>위에 예제 코드에서도 좀 부족한 부분이 있습니다. 확장 부분이나, codeVerificationService 클래스에 너무 의존하고 있는 모습들이 대표적인 예입니다. 이러한 문제들을 어떻게 풀어갈지에 대한 방법들은 주문 API를 만들면서 알아보도록 하겠습니다.</p>\n<p>아마 다음 장에서는 주문 API를 만들기 전에 테스트 코드에 대한 내용을 다룰 것 같습니다. 긴 내용 읽어주셔서 감사합니다.(__)</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>Step-04 회원가입 Service 만들기 : 응용영역 효율적으로 관리하기 - Part2</h1>\n<h1>응용 영역(서비스)</h1>\n<p>이번 단계는 <code>응용영역</code> 효율적으로 관리하기 - Part2 편으로 어떻게 하면 <code>응용영역</code>을 응집력 있고, 변경에 유연하고, 가독성 좋은 코드를 작성할지에 대해 알아볼 것입니다. 이장에서는 크게 아래와 같은 주제로 <code>응용영역</code>을 효율적으로 관리하는 방법에 대해 알아보겠습니다.</p>\n<ul>\n<li>책임</li>\n<li>도메인 HelperService 만들기</li>\n<li>DTO 사용하기</li>\n<li>최종적인 회원가입 코드</li>\n<li>Swagger를 통한 회원 가입 API CALL</li>\n</ul>\n<h1>4. 책임(단일책임원칙)</h1>\n<p>객체지향 설계를 하는 데 있어 기준을 잡아주는 원칙들이 있는데 이것을 SOLID 원칙이라고 합니다. 이중 먼저 단일 책임 원칙에 대한 내용을 얘기하려고 합니다. 단일 책임 원칙은 클래스는 하나의 책임을 가져야 한다는 내용입니다. 왜 클래스는 하나의 책임을 가져야 하는지에 대해 알아보겠습니다.</p>\n<blockquote>\n<p>좀 더 책임의 의미를 잘 전달하기 위해 처음 작성한 초난감 회원가입 코드를 기반으로 이 단락을 설명하겠습니다.</p>\n</blockquote>\n<p><strong>초난감 회원가입 서비스 코드</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span><span class=\"comment\">// 옆에 어노테이션을 통해 아래에 멤버필드들이 자동으로 스프링 빈으로 등록됨.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MemberSignUpService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MemberRepository memberRepository;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CodeVerificationService codeVerificationService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Member <span class=\"title\">signUp</span><span class=\"params\">(<span class=\"keyword\">final</span> MemberSignupRequest request)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Member duplicator = memberRepository.findByEmail(request.getEmail());</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(duplicator != <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MemberDuplicationException();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> CodeVerification CodeVerification = codeVerificationService.findByMobile(request.getMobile()); <span class=\"comment\">// 유저가 있는지 여부를 확인할 수 있는데 인증코드 정보 객체</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(codeVerification.getAuthCode().equals(request.getAuthCode()))&#123;</span><br><span class=\"line\">            Member member = request.toMember();<span class=\"comment\">//성공</span></span><br><span class=\"line\">            memberRepository.save(member);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> member;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MobileAuthenticationCodeFaildException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>책임의 중요성</h2>\n<p>먼저 책임이 뭔지 간단하게 알아보겠습니다. 클래스에서 책임의 기준은 요구 사항을 기반으로 누구에 의해 이 기능이 변경될 수 있는가를 생각하는 것입니다. 이 변경은 곧 <code>책임</code>을 의미하기 때문입니다. 각각의 책임들은 하나의 서비스 또는 클래스로 분리되어야 합니다. 그래야 변경에 유연하고 응집력 있는 코드를 가질 수 있기 때문입니다. 변경에 유연함은 버그가 없고 안정적인 코드가 되는것을 의미합니다.</p>\n<p>사실 처음 회원가입 요구 사항 분석 단계에서 구현할 기능들을 나열하면서 각각의 책임들을 분리하는 게 좋습니다. 또 개인적으로는 이러한 이유 때문에 기능 구현에 앞서 구현할 기능들을 나열해 책임들을 정리하는편입니다.</p>\n<blockquote>\n<ul>\n<li>처음에는 요구 사항에 나열된 기능들로 바로 책임을 분리하는 게 어려울 수 있습니다. 이럴 경우 Test 코드를 작성하면서 책임을 찾아내는 게 좋은 방법일 수 있습니다. (이과정은 다음 장에서 알아보도록 하겠습니다.)</li>\n</ul>\n</blockquote>\n<p>다음은 왜 변경사항을 책임이라고 하고 또 분리되어야 하는지 예제를 통해 알아보겠습니다.</p>\n<h2>책임 찾기</h2>\n<p>먼저 회원가입 서비스에 어떤 <code>책임</code>들이 있는지 생각해보겠습니다. 위의 책임을 나누는 기준인 코드의 변경을 기반으로 책임을 찾아 보면 <code>회원가입</code>, <code>모바일 인증</code> 2가지 책임이 있을 수 있습니다.</p>\n<p>초난감 회원가입 코드를 기반으로 보면 회원가입에 대한 로직이 변경이 일어난다면 모바일 인증이라는 코드와 결합되어 있어 변경하는 로직이 쉽지 않습니다. 반대로 인증 코드 부분을보면 인증코드 이외에도 만료시간 등을 체크해야 한다고 하면 전반적인 회원가입 소스 로직을 이해한 후에야 비로소 인증 코드에 대한 로직을 수정할 수 있습니다. 단지 회원가입이 아닌 인증코드 정책에 대한 소스 수정인데도 불구하고 회원가입 로직을 이해해야 하는 상황이 발생하게 됩니다.</p>\n<blockquote>\n<p>Email 중복 여부 체크 같은 경우에는 이메일 중복체크라는 기능이 변경이 일어날 수 없다고 생각하기 때문에 책임의 부분에서 뺏습니다. 하지만 이곳저곳 클래스에서 Email을 디비에서 검색 시 NULL 인지 검사하는 중복 소스가 발생할 수 있습니다. 이 부분은 밑에 단락에서 다루도록 하겠습니다.</p>\n</blockquote>\n<h2>책임 분리</h2>\n<p>만약 다른 클래스에서도 모바일 인증코드 기능을 구현해서 쓰고 있다면 사용하는 곳을 모두 변경해줘야 할 것입니다. 이렇듯 클래스 또는 서비스가 하나의 책임만을 다루지 않게 되면 변경에 엄청나게 취약하다는것을 알게되었습니다.</p>\n<p>그렇기 때문에 회원가입과 인증 코드를 확인하는 소스는 다음과 같이 별도의 서비스로 분리해야 할 것입니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MemberSignUpService.class</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Member <span class=\"title\">signUp</span><span class=\"params\">(<span class=\"keyword\">final</span> MemberSignupRequest request)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Member duplicator = memberRepository.findByEmail(email);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(duplicator != <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MemberDuplicationException();</span><br><span class=\"line\"></span><br><span class=\"line\">    codeVerificationService.verify(request.getMobile(),request.getAuthCode());</span><br><span class=\"line\">    Member member = request.toMember();<span class=\"comment\">//성공</span></span><br><span class=\"line\">    memberRepository.save(member);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> member;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//CodeVerificationService.class</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">verify</span><span class=\"params\">(<span class=\"keyword\">final</span> String mobile, <span class=\"keyword\">final</span> String authCode)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> CodeVerification codeVerification = codeVerificationRepository.findByMobile(mobile);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!codeVerification.getAuthCode().equals(request.getAuthCod))) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MobileAuthenticationCodeFaildException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>MemberSignUpService에서 인증 기능의 책임을 분리한 구조입니다. 이렇게 되면 회원가입 로직이 변경되거나 모바일 인증 로직이 변경된다고 해도 서로에 영향을 주지 않게 됩니다. 이제 인증 정책이 변경된다거나 회원가입 로직이 변경된다고 해도 서로의 책임만 다해준다면 둘한테 영향을 주지 않습니다.</p>\n<p>사실 이것만으로도 기능면만 놓고 보면 코드의 응집력 + 코드 변경에 대한 유연성이 높아졌다고 할 수 있습니다. 물론 여기에 앞에 part1에서 다루었던 CodeVerification의 캡슐화된 verify() 함수를 사용한다면 더욱더 변경에 유연한 코드가 될 것입니다.</p>\n<h2>모바일 인증과 책임을 분리한 회원가입 메소드</h2>\n<p>아래는 리팩토링되어진 회원가입이 기능입니다. 이제 회원가입을 하기위해 아까와 같이 복잡합 인증코드의 로직을 이해할필요가없어졌습니다. 회원가입에 어떤 변화가 생긴다고 해도 회원가입에 대한 로직에만 집중하면 되니까 좀 더 과감하게 개발할 수 있게 되었습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Member <span class=\"title\">signUp</span><span class=\"params\">(<span class=\"keyword\">final</span> MemberSignupRequest request)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Member duplicator = memberRepository.findByEmail(email);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(duplicator != <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MemberDuplicationException();</span><br><span class=\"line\">    codeVerificationService.verify(request.getMobile(), request.getAuthCode());</span><br><span class=\"line\">    Member member = request.toMember();</span><br><span class=\"line\">    memberRepository.save(member);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> member;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>5.도메인 HelperService 만들기</h1>\n<p>위에서 설명하지 않은 부분이 있습니다. 바로 Email 중복 체크를 하는 로직입니다. 여기에서 이메일 중복체크 여부는 사실 변경이 되거나 확장될 일이 거의 없습니다. 단순히 디비에서 해당 Email이 있는지 확인하는 로직이기 때문입니다.(물론 캐시 등을 적용할 수 도 있을 것입니다.) 사실 위에서 사용한 것처럼 아래와 같이 사용해도 크게 무방합니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Member duplicator = memberRepository.findByEmail(email);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(duplicator != <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MemberDuplicationException();</span><br></pre></td></tr></table></figure>\n<p>하지만 아무래도 Email 중복체크를 하기 위해서는 전방위적으로 유저를 조회하고 NULL 인지 검사하는 로직이 중복되어야 하는 문제가 있습니다</p>\n<p>그래서 이렇게 변경이 없고 단순 조회이거나, 조회 후 NULL 체크하는 코드들은 해당 도메인에 helperService를 통해 관리하는 방법이 있습니다. 코드로 보면 아래와 같을 수 있습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//MemberHelperService</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Member <span class=\"title\">findById</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> id)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Member member = memberRepository.findOne(id);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(member == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MemberNotFoundException();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> member;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">verifyEmailIsDuplicated</span><span class=\"params\">(<span class=\"keyword\">final</span> Email email)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(isEmailDuplicated(email)) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MemberDuplicationException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위와 같이 HelperService를 사용하게 되면 아이디 중복체크 외에도 특정 필드로 객체를 조회한 후 NULL을 검사하는 반복 로직들을 해당 클래스를 통해 제거할 수 있습니다.</p>\n<h2>NULL을 지양하기</h2>\n<p>위 클래스가 바로 3장에서 말했던 부분인 NULL을 지양하게 도와주는 역할을 하는 클래스입니다. 위 소스에서 findById 후 NULL이면 그냥 MemberNotFoundException()을 던지는 부분이 있습니다. 사실 디비로부터 NULL을 받은 후 NULL을 리턴해봤자 그 후에 어디에선가 NullPointerException이 발생합니다. 그렇게 되면 오히려 더 디버깅하기 힘들어집니다. 그렇기 때문에 차라리 조회하자마자 NULL 인지 검사를 하고 해당 조회 id를 조회 하고 바로 NullPointerException를 던지는 게 더 디버깅하기 효율적입니다. NULL은 최대한 주지도 말고 받지도 말아야합니다.</p>\n<h1>6. DTO 사용하기</h1>\n<p>메서드에 전달할 파라미터가 많다면 dto를 사용하는 것을 추천드립니다. 그 이유는 표현 계층에서 말했던 이유와 비슷합니다.</p>\n<ol>\n<li>해당 메서드의 파라미터가 명세화가 됩니다.</li>\n<li>추가적인 파라미터가 있다면 유연하게 대응할 수 있습니다.</li>\n</ol>\n<h1>7. 최종적인 회원가입 코드</h1>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span> <span class=\"comment\">// 옆에 어노테이션을 통해 아래에 멤버필드들이 자동으로 스프링 빈으로 등록됨.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MemberSignUpService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MemberRepository memberRepository;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MemberHelperService memberHelperService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Member <span class=\"title\">signUp</span><span class=\"params\">(<span class=\"keyword\">final</span> MemberSignupRequest request)</span></span>&#123;</span><br><span class=\"line\">        memberHelperService.verifyEmailIsDuplicated(request.getEmail());</span><br><span class=\"line\">        Member member = request.toMember();</span><br><span class=\"line\">        memberRepository.save(member);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> member;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>모바일 인증부분은 예제 설명을 위해 추가한 부분이라 코드에서 제거했습니다.</li>\n</ul>\n<p><strong>드디어 회원가입 API가 완성되었습니다. 위에 소스를 보시면 아시겠지만 응용서비스는 직접 로직을 수행하기보다는 도메인 모델에 로직 수행시키거나 각각의 모듈들을 연결하는 역할을 합니다. 그래야 서비스 영역은 단순한 구조를 가지게 되고, 가독성이 좋아지고, 그럼으로써 품질좋은 코드를 유지할 수 있게 해줍니다.</strong></p>\n<h2>Swagger 를 통한 회원 가입 API CALL</h2>\n<p>다음과 같이 Swagger 홈페이지를 통해 회원가입 API를 테스트 해보실 수 있습니다.</p>\n<p><img src=\"https://github.com/minwan1/online-book-store/blob/master/img/swagger-test.gif\" alt=\"\"></p>\n<p>다음은 Swagger Test URL입니다. - <a href=\"http://localhost:8080/swagger-ui.html\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/swagger-ui.html</a></p>\n<p><strong>회원가입 Request Body</strong></p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"email\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"value\"</span>: <span class=\"string\">\"test@naver.com\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"firstname\"</span>: <span class=\"string\">\"test\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">\"lastname\"</span>: <span class=\"string\">\"test\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"password\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"value\"</span>: <span class=\"string\">\"12345\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>회원가입 Response Body</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;email&quot;: &#123;</span><br><span class=\"line\">    &quot;value&quot;: &quot;test@naver.com&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;name&quot;: &#123;</span><br><span class=\"line\">    &quot;firstname&quot;: &quot;test&quot;,</span><br><span class=\"line\">    &quot;lastname&quot;: &quot;test&quot;,</span><br><span class=\"line\">    &quot;fullName&quot;: &quot;test test&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>마치며</h1>\n<p>회원가입 API가 드디어 만들어졌습니다. 사실 위에 초난강 회원가입 서비스처럼 생각 없이 의식의 흐름대로 코드를 작성한다면 30분 안에도 회원가입 기능을 구현할 수 있습니다. 하지만 그렇게 코드를 작성하게 되면 지금 당장은 돌아가겠지만 아마 후에 그 코드를 유지 보수하기 위해 300분 이상에 시간을 쓰고 있을 것입니다. 아주 간단한 기능 변경인데도 엄청난 리소스가 들어가게 되고, 간단한 확장인데도 코드를 손댈 수 가없어 꼼짝할 수 없는 상태가 됩니다.</p>\n<p>이러한 일이 발생하지 않도록 코드 하나를 작성하더라도 변경, 확장을 생각하면서 코드를 만들어야 합니다. 그래야 기능이 변경되더라도 유연하게 변경하고, 확장해나갈 수 있기 때문입니다. 이러한 기준을 잡게 도와주는 원칙이 위에서 말한 SOLID 원칙이라는게 있습니다.</p>\n<p>위에 예제 코드에서도 좀 부족한 부분이 있습니다. 확장 부분이나, codeVerificationService 클래스에 너무 의존하고 있는 모습들이 대표적인 예입니다. 이러한 문제들을 어떻게 풀어갈지에 대한 방법들은 주문 API를 만들면서 알아보도록 하겠습니다.</p>\n<p>아마 다음 장에서는 주문 API를 만들기 전에 테스트 코드에 대한 내용을 다룰 것 같습니다. 긴 내용 읽어주셔서 감사합니다.(__)</p>\n"},{"title":"Network-2:TCP/IP 송수신 과정","catalog":true,"date":"2018-10-27T15:00:00.000Z","subtitle":"TCP/IP 송수신 과정","header-img":null,"_content":"\n# TCP/IP 송수신 과정\n\n<!-- TOC -->\n\n- [TCP/IP 송수신 과정](#tcpip-송수신-과정)\n    - [소켓 생성](#소켓-생성)\n    - [소켓 연결 설정](#소켓-연결-설정)\n        - [Three way handshake](#three-way-handshake)\n    - [데이터 송수신](#데이터-송수신)\n    - [소켓 연결 종료](#소켓-연결-종료)\n        - [Four way handshake](#four-way-handshake)\n\n<!-- /TOC -->\n\n인터넷 웹 개발을 하기 위해서는 네트워크 통신은 필수입니다. 모든 사용자 프로그램들은 네트워크 통신을 하기 위해서 아래와 같은 과정을 거쳐 통신을 하게 됩니다.\n\n![](https://i.imgur.com/uMyrjMJ.gif)\n\n네트워크 통신과정을 요약하면 다음과 같을 수 있습니다.\n1. 클라이언트 소켓 생성\n2. 클라이언트와 서버 소켓 연결\n3. 데이터 송수신\n4. 소켓 연결 종료\n\n아래 내용에서는 클라이언트와 서버가 어떻게 실제로 연결이 맺어지고 데이터 송수신을 하고 연결이 끊어지는지 좀 더 세부적으로 알아보겠습니다.\n\n## 소켓 생성\n1. 클라이언트가 특정 서버와 통신을 하기 위해서는 운영체제에 socket() 시스템콜을 통해 소켓을 생성해야 합니다. \n2. 운영체제 내부 프로토콜 스택은 소켓의 정보를 저장하기 위해 메모리 영역을 할당하고 그곳에 소켓 제어 정보(상대 IP, 소켓 상태 정보 등)를 저장합니다. \n3. 운영체제는 생성된 소켓의 정보의 파일 디스크립터를 사용자 프로그램에게 반환해줍니다.\n\n> File discripter : 프로토콜 스택의 내부에 이는 다수의 소켓 중 어느 것을 가리키는지를 나타내는 번호표와 같은 존재이다.\n\n\n## 소켓 연결 설정\n아직 소켓은 만들었지만 아직 그 소켓에 아무런 정보도 없기 때문에 통신 상대가 누구인지 누구한테 통신을 해야 하는지 모른다. 그렇기 때문에 서버쪽 소켓과 연결 신청을 해 파이프를 구축해야 한다. \n\n그래서 다음과 같이 connect() 시스템콜을 호출하여 서버와 커넥션을 맺어야 한다. 운영체제는 데이터 송수신을 하기 위해서 사용자 프로그램에 도달하기 전에 일시적으로 데이터를 저장하기 위해서 버퍼 메모리 영역을 할당을 하고 데이터 송수신을 할 준비를 마치게 된다.\n\n이렇게 연결을 맺는 단계를 `Three way handshake`라고 한다.\n\n\n### Three way handshake\n다음은 Three way handshanking을 도식화한 것입니다.\n\n![](https://i.imgur.com/QR9GyHH.png)\n\n1. 클라이언트는 서버에게 연결 요청의 SYN이라는 비트를 1을 만들어 TCP 헤더 정보를 설정하고 패킷을 생성하여 보낸다.\n2. 서버는 받은 패킷을 기반으로 수신처 포트 번호에 해당하는 소켓을 찾고 거기에 해당 클라이언트에 대한 정보를 저장한다.\n3. 서버는 마찬가지로 SYN 비트를 만들고 정상적으로 처리했다는 걸 알리기 위해 ACK 비트를 1로 해서 클라이언트에게 패킷을 보냅니다.\n4. 클라이언트는 받은 패킷 정보를 기반으로 서버 측의 접속 동작이 성공했는지 확인합니다. \n5. 클라이언트는 서버가 정상적으로 처리됐다는 것을 인지하고 자신도 패킷을 제대로 받았다는 것을 알리기 위해 ACK 비트를 1로 만들고 패킷을 만들어 서버에게 전송을 합니다.\n6. 이로써 소켓은 데이터를 송수신할 수 있는 상태가 됩니다.\n\n\n>커넥션 : 위와 같이 서버와 클라이언트가 송수신할 수 있는 상태가 파이와 같은 것으로 소켓이 연결되었다고 할 수 있다. 이렇게 접속이 안료 된 상태를 '커넥션'을 맺었다고 한다. 혹은 '세션'이라고도 부른다.\n\n>윈도우 : 수신 측에서 송신 측에 윈도우 사이즈(수신 확인을 기다리지 않고 묶어서 송신할 수 있는 데이터양)를 즉 받을 수 있는 사이즈를 통지하기 위해 사용합니다.\n\n## 데이터 송수신\n데이터 송수신은 write(), read() 시스템 콜로 실행할 수 있습니다. 프로토콜 스택은 받은 데이터에 내용을 바로 송신하는 것이 아니라 일단 자체 송신용 버퍼 메모리 영역에 저장하고, 애플리케이션 다음 데이터를 건네주기를 기다립니다. 각 애플리케이션마다 송신 의뢰하는 데이터양 등이 적으면 너무 빈번하게 송신이 일어나면 네트워크의 이용 효율이 좋지 않기 때문에 한 번에 모아서 전송할 수도 있습니다.\n\n또 반대로 데이터가 너무 클 때는 이것을 분할하여 보냅니다. 아래는 MTU와 MSS에 대한 그림입니다. 일반적으로 TCP 통신을 하기 위해서 이더넷에 송신할 수 있는 MTU는 1500 바이트이다. 그리고 MTU에서 TCP 헤더가 40이라고 하면 이것을 뺀 1460바이트가 MSS이다.\n\n![](https://i.imgur.com/3z6WHLT.png)\n* MTU : 패킷 한 개로 운반할 수 있는 디지털 데이터의 최대 길이. 이더넷에서는 보통 1,500 바이트\n* MSS : 헤더를 제외하고 한개의 패킷으로 운반할 수 있는 TCP의 최대 데이터 길이\n\n만약 송신하고자 하는 데이터가 MSS(1460) 바이트를 넘는다고 하면 이것을 분할하여 데이터를 보내야 합니다. 그럼 지금부터 어떻게 데이터를 분할해서 보내고 또 받는지 다음 그림을 통해서 알아보겠습니다.\n\n![](https://i.imgur.com/iMqN5Ky.png)\n\n1. 먼저 클라이언트가 데이터를 보내기 전에 자신이 보내려고 하는 데이터의 바이트를 세서 TCP 헤더에 기록하여 초기 `SEQ`를 생성해서 서버로 보낸다.\n2. 그리고 서버는 수신한 데이터 크기를 계산하여 그 값에 1을 더하여 `ACK 번호`넘긴다.\n3. 클라이언트는 나머지 분할 된 데이터 바이트를 읽어 `SEQ`를 생성해서 패킷을 보낸다.\n4. 만약 이 과정 중에 서버가 받았다는 `ACK`를 보내주지 않는다면 클라이언트는 다시 한번 요청하게 해준다.(ACK를 기다리는 시간이 초과한 것을 Time out이라 한다.)\n5. 그리고 서버는 다시 한번 패킷을 수신하면 `SEQ`번호 기반으로 패킷을 비교하여 기존에 도착한 패킷을 연결한다.(만약 이 과정 중에 SEQ 번호가 맞지 않다는 것은 데이터가 누락되었다는 것을 의미한다.)\n\n* 실제로는 시퀀스 번호가 1부터 시작하지 않고 난수를 바탕으로 산출한 초기값으로 시작한다. 시퀀스 번호를 항상 1부터 시작한다고 예측할 수 있으면 거기에 악의적인 공격을 할 우려가 있기 때문이다. 그러나 난수값으로하면 서버측에서 초기 `SEQ`을 알 수 없기 때문에 초기 Connect 단계에서 초기 `SEQ` 설정을 해줍니다.\n\n\n\n## 소켓 연결 종료\nTCP/IP 종료는 close() 시스템콜 함수로 종료할 수 있습니다. 일반적으로 HTTP 메시지를 송수신 한 뒤 다음과 같이 `four way handshake` 으로 연결을 종료합니다.(HTTP 1.1 이후부터는 바로 연결을 끊지는 않습니다.) 다음 그림은 서버의 요청으로 연결을 끊는 모습을 도식화 한 것입니다. \n\n\n### Four way handshake\n다음은 Four way handshake을 도식화한 것입니다.\n\n![](https://i.imgur.com/fTUTkfc.png)\n\n1. 클라이언트는 서버는 FIN에 1을 설정한 TCP 헤더가 도착하면 자신의 소켓에 서버가 연결 종료에 들어갔다는 것을 표시합니다.\n2. 클라이언트는 자신이 FIN 플래그를 받았다는 것을 알리기 위해 서버에게 ACK를 서버 측으로 반송한다.\n3. 그와 동시에 Server에서는 해당 포트에 연결되어 있는 Application에게 Close()를 요청한다.\n4. 애플리케이션의 네트워크 연결 종료 준비가 끝나면 클라이언트도 마찬가지로 FIN 플래그를 서버에게 보냅니다.\n5. 서버는 FIN 플래그를 받게 되면 받았다는 것을 클라이언트에게 알리기 위해 ACK 플래그를 보냅니다.\n6. 클라이언트가 ACK를 받게 되면 네트워크 연결이 종료가 됩니다.\n\n\n>FIN_WAIT : FIN_WAIT 상태에서 클라이언트로부터 특정 시간 동안 응답이 오지 않는다면 특정 시간 이후에 서버는 자동으로 Closed가 된다.\n\n>TIME_WAIT: 서버에서 세션을 종료시킨 후 뒤늦게 도착하는 패킷이 있다면 이 패킷은 Drop 되고 데이터는 유실될 것입니다. \n이러한 현상에 대비하여 서버는 클라이언트로부터 FIN을 수신하더라도 일정 시간(디폴트 240초) 동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거치게 되는데 이 과정을 \"TIME_WAIT\"라고 합니다. 240초 후에는 CLOSED가 됩니다.\n\n\n참고\n\n* [MindNet](http://mindnet.tistory.com/entry/네트워크-쉽게-이해하기-22편-TCP-3-WayHandshake-4-WayHandshake)\n\n* [D2](https://d2.naver.com/helloworld/47667)\n\n","source":"_posts/2018-10-28-TCP-IP-DATA-PROCESSING.md","raw":"---\ntitle: Network-2:TCP/IP 송수신 과정\ncatalog: true\ndate: 2018-10-28\nsubtitle: TCP/IP 송수신 과정\nheader-img:\ntags:\n- Netowork\n\n\n\n---\n\n# TCP/IP 송수신 과정\n\n<!-- TOC -->\n\n- [TCP/IP 송수신 과정](#tcpip-송수신-과정)\n    - [소켓 생성](#소켓-생성)\n    - [소켓 연결 설정](#소켓-연결-설정)\n        - [Three way handshake](#three-way-handshake)\n    - [데이터 송수신](#데이터-송수신)\n    - [소켓 연결 종료](#소켓-연결-종료)\n        - [Four way handshake](#four-way-handshake)\n\n<!-- /TOC -->\n\n인터넷 웹 개발을 하기 위해서는 네트워크 통신은 필수입니다. 모든 사용자 프로그램들은 네트워크 통신을 하기 위해서 아래와 같은 과정을 거쳐 통신을 하게 됩니다.\n\n![](https://i.imgur.com/uMyrjMJ.gif)\n\n네트워크 통신과정을 요약하면 다음과 같을 수 있습니다.\n1. 클라이언트 소켓 생성\n2. 클라이언트와 서버 소켓 연결\n3. 데이터 송수신\n4. 소켓 연결 종료\n\n아래 내용에서는 클라이언트와 서버가 어떻게 실제로 연결이 맺어지고 데이터 송수신을 하고 연결이 끊어지는지 좀 더 세부적으로 알아보겠습니다.\n\n## 소켓 생성\n1. 클라이언트가 특정 서버와 통신을 하기 위해서는 운영체제에 socket() 시스템콜을 통해 소켓을 생성해야 합니다. \n2. 운영체제 내부 프로토콜 스택은 소켓의 정보를 저장하기 위해 메모리 영역을 할당하고 그곳에 소켓 제어 정보(상대 IP, 소켓 상태 정보 등)를 저장합니다. \n3. 운영체제는 생성된 소켓의 정보의 파일 디스크립터를 사용자 프로그램에게 반환해줍니다.\n\n> File discripter : 프로토콜 스택의 내부에 이는 다수의 소켓 중 어느 것을 가리키는지를 나타내는 번호표와 같은 존재이다.\n\n\n## 소켓 연결 설정\n아직 소켓은 만들었지만 아직 그 소켓에 아무런 정보도 없기 때문에 통신 상대가 누구인지 누구한테 통신을 해야 하는지 모른다. 그렇기 때문에 서버쪽 소켓과 연결 신청을 해 파이프를 구축해야 한다. \n\n그래서 다음과 같이 connect() 시스템콜을 호출하여 서버와 커넥션을 맺어야 한다. 운영체제는 데이터 송수신을 하기 위해서 사용자 프로그램에 도달하기 전에 일시적으로 데이터를 저장하기 위해서 버퍼 메모리 영역을 할당을 하고 데이터 송수신을 할 준비를 마치게 된다.\n\n이렇게 연결을 맺는 단계를 `Three way handshake`라고 한다.\n\n\n### Three way handshake\n다음은 Three way handshanking을 도식화한 것입니다.\n\n![](https://i.imgur.com/QR9GyHH.png)\n\n1. 클라이언트는 서버에게 연결 요청의 SYN이라는 비트를 1을 만들어 TCP 헤더 정보를 설정하고 패킷을 생성하여 보낸다.\n2. 서버는 받은 패킷을 기반으로 수신처 포트 번호에 해당하는 소켓을 찾고 거기에 해당 클라이언트에 대한 정보를 저장한다.\n3. 서버는 마찬가지로 SYN 비트를 만들고 정상적으로 처리했다는 걸 알리기 위해 ACK 비트를 1로 해서 클라이언트에게 패킷을 보냅니다.\n4. 클라이언트는 받은 패킷 정보를 기반으로 서버 측의 접속 동작이 성공했는지 확인합니다. \n5. 클라이언트는 서버가 정상적으로 처리됐다는 것을 인지하고 자신도 패킷을 제대로 받았다는 것을 알리기 위해 ACK 비트를 1로 만들고 패킷을 만들어 서버에게 전송을 합니다.\n6. 이로써 소켓은 데이터를 송수신할 수 있는 상태가 됩니다.\n\n\n>커넥션 : 위와 같이 서버와 클라이언트가 송수신할 수 있는 상태가 파이와 같은 것으로 소켓이 연결되었다고 할 수 있다. 이렇게 접속이 안료 된 상태를 '커넥션'을 맺었다고 한다. 혹은 '세션'이라고도 부른다.\n\n>윈도우 : 수신 측에서 송신 측에 윈도우 사이즈(수신 확인을 기다리지 않고 묶어서 송신할 수 있는 데이터양)를 즉 받을 수 있는 사이즈를 통지하기 위해 사용합니다.\n\n## 데이터 송수신\n데이터 송수신은 write(), read() 시스템 콜로 실행할 수 있습니다. 프로토콜 스택은 받은 데이터에 내용을 바로 송신하는 것이 아니라 일단 자체 송신용 버퍼 메모리 영역에 저장하고, 애플리케이션 다음 데이터를 건네주기를 기다립니다. 각 애플리케이션마다 송신 의뢰하는 데이터양 등이 적으면 너무 빈번하게 송신이 일어나면 네트워크의 이용 효율이 좋지 않기 때문에 한 번에 모아서 전송할 수도 있습니다.\n\n또 반대로 데이터가 너무 클 때는 이것을 분할하여 보냅니다. 아래는 MTU와 MSS에 대한 그림입니다. 일반적으로 TCP 통신을 하기 위해서 이더넷에 송신할 수 있는 MTU는 1500 바이트이다. 그리고 MTU에서 TCP 헤더가 40이라고 하면 이것을 뺀 1460바이트가 MSS이다.\n\n![](https://i.imgur.com/3z6WHLT.png)\n* MTU : 패킷 한 개로 운반할 수 있는 디지털 데이터의 최대 길이. 이더넷에서는 보통 1,500 바이트\n* MSS : 헤더를 제외하고 한개의 패킷으로 운반할 수 있는 TCP의 최대 데이터 길이\n\n만약 송신하고자 하는 데이터가 MSS(1460) 바이트를 넘는다고 하면 이것을 분할하여 데이터를 보내야 합니다. 그럼 지금부터 어떻게 데이터를 분할해서 보내고 또 받는지 다음 그림을 통해서 알아보겠습니다.\n\n![](https://i.imgur.com/iMqN5Ky.png)\n\n1. 먼저 클라이언트가 데이터를 보내기 전에 자신이 보내려고 하는 데이터의 바이트를 세서 TCP 헤더에 기록하여 초기 `SEQ`를 생성해서 서버로 보낸다.\n2. 그리고 서버는 수신한 데이터 크기를 계산하여 그 값에 1을 더하여 `ACK 번호`넘긴다.\n3. 클라이언트는 나머지 분할 된 데이터 바이트를 읽어 `SEQ`를 생성해서 패킷을 보낸다.\n4. 만약 이 과정 중에 서버가 받았다는 `ACK`를 보내주지 않는다면 클라이언트는 다시 한번 요청하게 해준다.(ACK를 기다리는 시간이 초과한 것을 Time out이라 한다.)\n5. 그리고 서버는 다시 한번 패킷을 수신하면 `SEQ`번호 기반으로 패킷을 비교하여 기존에 도착한 패킷을 연결한다.(만약 이 과정 중에 SEQ 번호가 맞지 않다는 것은 데이터가 누락되었다는 것을 의미한다.)\n\n* 실제로는 시퀀스 번호가 1부터 시작하지 않고 난수를 바탕으로 산출한 초기값으로 시작한다. 시퀀스 번호를 항상 1부터 시작한다고 예측할 수 있으면 거기에 악의적인 공격을 할 우려가 있기 때문이다. 그러나 난수값으로하면 서버측에서 초기 `SEQ`을 알 수 없기 때문에 초기 Connect 단계에서 초기 `SEQ` 설정을 해줍니다.\n\n\n\n## 소켓 연결 종료\nTCP/IP 종료는 close() 시스템콜 함수로 종료할 수 있습니다. 일반적으로 HTTP 메시지를 송수신 한 뒤 다음과 같이 `four way handshake` 으로 연결을 종료합니다.(HTTP 1.1 이후부터는 바로 연결을 끊지는 않습니다.) 다음 그림은 서버의 요청으로 연결을 끊는 모습을 도식화 한 것입니다. \n\n\n### Four way handshake\n다음은 Four way handshake을 도식화한 것입니다.\n\n![](https://i.imgur.com/fTUTkfc.png)\n\n1. 클라이언트는 서버는 FIN에 1을 설정한 TCP 헤더가 도착하면 자신의 소켓에 서버가 연결 종료에 들어갔다는 것을 표시합니다.\n2. 클라이언트는 자신이 FIN 플래그를 받았다는 것을 알리기 위해 서버에게 ACK를 서버 측으로 반송한다.\n3. 그와 동시에 Server에서는 해당 포트에 연결되어 있는 Application에게 Close()를 요청한다.\n4. 애플리케이션의 네트워크 연결 종료 준비가 끝나면 클라이언트도 마찬가지로 FIN 플래그를 서버에게 보냅니다.\n5. 서버는 FIN 플래그를 받게 되면 받았다는 것을 클라이언트에게 알리기 위해 ACK 플래그를 보냅니다.\n6. 클라이언트가 ACK를 받게 되면 네트워크 연결이 종료가 됩니다.\n\n\n>FIN_WAIT : FIN_WAIT 상태에서 클라이언트로부터 특정 시간 동안 응답이 오지 않는다면 특정 시간 이후에 서버는 자동으로 Closed가 된다.\n\n>TIME_WAIT: 서버에서 세션을 종료시킨 후 뒤늦게 도착하는 패킷이 있다면 이 패킷은 Drop 되고 데이터는 유실될 것입니다. \n이러한 현상에 대비하여 서버는 클라이언트로부터 FIN을 수신하더라도 일정 시간(디폴트 240초) 동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거치게 되는데 이 과정을 \"TIME_WAIT\"라고 합니다. 240초 후에는 CLOSED가 됩니다.\n\n\n참고\n\n* [MindNet](http://mindnet.tistory.com/entry/네트워크-쉽게-이해하기-22편-TCP-3-WayHandshake-4-WayHandshake)\n\n* [D2](https://d2.naver.com/helloworld/47667)\n\n","slug":"2018-10-28-TCP-IP-DATA-PROCESSING","published":1,"updated":"2018-10-28T14:35:08.730Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27e3002zjjpex4x94vpi","content":"<h1><span id=\"tcpip-송수신-과정\">TCP/IP 송수신 과정</span></h1>\n<!-- TOC -->\n<ul>\n<li><a href=\"#tcpip-%EC%86%A1%EC%88%98%EC%8B%A0-%EA%B3%BC%EC%A0%95\">TCP/IP 송수신 과정</a>\n<ul>\n<li><a href=\"#%EC%86%8C%EC%BC%93-%EC%83%9D%EC%84%B1\">소켓 생성</a></li>\n<li><a href=\"#%EC%86%8C%EC%BC%93-%EC%97%B0%EA%B2%B0-%EC%84%A4%EC%A0%95\">소켓 연결 설정</a>\n<ul>\n<li><a href=\"#three-way-handshake\">Three way handshake</a></li>\n</ul>\n</li>\n<li><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%86%A1%EC%88%98%EC%8B%A0\">데이터 송수신</a></li>\n<li><a href=\"#%EC%86%8C%EC%BC%93-%EC%97%B0%EA%B2%B0-%EC%A2%85%EB%A3%8C\">소켓 연결 종료</a>\n<ul>\n<li><a href=\"#four-way-handshake\">Four way handshake</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<p>인터넷 웹 개발을 하기 위해서는 네트워크 통신은 필수입니다. 모든 사용자 프로그램들은 네트워크 통신을 하기 위해서 아래와 같은 과정을 거쳐 통신을 하게 됩니다.</p>\n<p><img src=\"https://i.imgur.com/uMyrjMJ.gif\" alt=\"\"></p>\n<p>네트워크 통신과정을 요약하면 다음과 같을 수 있습니다.</p>\n<ol>\n<li>클라이언트 소켓 생성</li>\n<li>클라이언트와 서버 소켓 연결</li>\n<li>데이터 송수신</li>\n<li>소켓 연결 종료</li>\n</ol>\n<p>아래 내용에서는 클라이언트와 서버가 어떻게 실제로 연결이 맺어지고 데이터 송수신을 하고 연결이 끊어지는지 좀 더 세부적으로 알아보겠습니다.</p>\n<h2><span id=\"소켓-생성\">소켓 생성</span></h2>\n<ol>\n<li>클라이언트가 특정 서버와 통신을 하기 위해서는 운영체제에 socket() 시스템콜을 통해 소켓을 생성해야 합니다.</li>\n<li>운영체제 내부 프로토콜 스택은 소켓의 정보를 저장하기 위해 메모리 영역을 할당하고 그곳에 소켓 제어 정보(상대 IP, 소켓 상태 정보 등)를 저장합니다.</li>\n<li>운영체제는 생성된 소켓의 정보의 파일 디스크립터를 사용자 프로그램에게 반환해줍니다.</li>\n</ol>\n<blockquote>\n<p>File discripter : 프로토콜 스택의 내부에 이는 다수의 소켓 중 어느 것을 가리키는지를 나타내는 번호표와 같은 존재이다.</p>\n</blockquote>\n<h2><span id=\"소켓-연결-설정\">소켓 연결 설정</span></h2>\n<p>아직 소켓은 만들었지만 아직 그 소켓에 아무런 정보도 없기 때문에 통신 상대가 누구인지 누구한테 통신을 해야 하는지 모른다. 그렇기 때문에 서버쪽 소켓과 연결 신청을 해 파이프를 구축해야 한다.</p>\n<p>그래서 다음과 같이 connect() 시스템콜을 호출하여 서버와 커넥션을 맺어야 한다. 운영체제는 데이터 송수신을 하기 위해서 사용자 프로그램에 도달하기 전에 일시적으로 데이터를 저장하기 위해서 버퍼 메모리 영역을 할당을 하고 데이터 송수신을 할 준비를 마치게 된다.</p>\n<p>이렇게 연결을 맺는 단계를 <code>Three way handshake</code>라고 한다.</p>\n<h3><span id=\"three-way-handshake\">Three way handshake</span></h3>\n<p>다음은 Three way handshanking을 도식화한 것입니다.</p>\n<p><img src=\"https://i.imgur.com/QR9GyHH.png\" alt=\"\"></p>\n<ol>\n<li>클라이언트는 서버에게 연결 요청의 SYN이라는 비트를 1을 만들어 TCP 헤더 정보를 설정하고 패킷을 생성하여 보낸다.</li>\n<li>서버는 받은 패킷을 기반으로 수신처 포트 번호에 해당하는 소켓을 찾고 거기에 해당 클라이언트에 대한 정보를 저장한다.</li>\n<li>서버는 마찬가지로 SYN 비트를 만들고 정상적으로 처리했다는 걸 알리기 위해 ACK 비트를 1로 해서 클라이언트에게 패킷을 보냅니다.</li>\n<li>클라이언트는 받은 패킷 정보를 기반으로 서버 측의 접속 동작이 성공했는지 확인합니다.</li>\n<li>클라이언트는 서버가 정상적으로 처리됐다는 것을 인지하고 자신도 패킷을 제대로 받았다는 것을 알리기 위해 ACK 비트를 1로 만들고 패킷을 만들어 서버에게 전송을 합니다.</li>\n<li>이로써 소켓은 데이터를 송수신할 수 있는 상태가 됩니다.</li>\n</ol>\n<blockquote>\n<p>커넥션 : 위와 같이 서버와 클라이언트가 송수신할 수 있는 상태가 파이와 같은 것으로 소켓이 연결되었다고 할 수 있다. 이렇게 접속이 안료 된 상태를 '커넥션’을 맺었다고 한다. 혹은 '세션’이라고도 부른다.</p>\n</blockquote>\n<blockquote>\n<p>윈도우 : 수신 측에서 송신 측에 윈도우 사이즈(수신 확인을 기다리지 않고 묶어서 송신할 수 있는 데이터양)를 즉 받을 수 있는 사이즈를 통지하기 위해 사용합니다.</p>\n</blockquote>\n<h2><span id=\"데이터-송수신\">데이터 송수신</span></h2>\n<p>데이터 송수신은 write(), read() 시스템 콜로 실행할 수 있습니다. 프로토콜 스택은 받은 데이터에 내용을 바로 송신하는 것이 아니라 일단 자체 송신용 버퍼 메모리 영역에 저장하고, 애플리케이션 다음 데이터를 건네주기를 기다립니다. 각 애플리케이션마다 송신 의뢰하는 데이터양 등이 적으면 너무 빈번하게 송신이 일어나면 네트워크의 이용 효율이 좋지 않기 때문에 한 번에 모아서 전송할 수도 있습니다.</p>\n<p>또 반대로 데이터가 너무 클 때는 이것을 분할하여 보냅니다. 아래는 MTU와 MSS에 대한 그림입니다. 일반적으로 TCP 통신을 하기 위해서 이더넷에 송신할 수 있는 MTU는 1500 바이트이다. 그리고 MTU에서 TCP 헤더가 40이라고 하면 이것을 뺀 1460바이트가 MSS이다.</p>\n<p><img src=\"https://i.imgur.com/3z6WHLT.png\" alt=\"\"></p>\n<ul>\n<li>MTU : 패킷 한 개로 운반할 수 있는 디지털 데이터의 최대 길이. 이더넷에서는 보통 1,500 바이트</li>\n<li>MSS : 헤더를 제외하고 한개의 패킷으로 운반할 수 있는 TCP의 최대 데이터 길이</li>\n</ul>\n<p>만약 송신하고자 하는 데이터가 MSS(1460) 바이트를 넘는다고 하면 이것을 분할하여 데이터를 보내야 합니다. 그럼 지금부터 어떻게 데이터를 분할해서 보내고 또 받는지 다음 그림을 통해서 알아보겠습니다.</p>\n<p><img src=\"https://i.imgur.com/iMqN5Ky.png\" alt=\"\"></p>\n<ol>\n<li>먼저 클라이언트가 데이터를 보내기 전에 자신이 보내려고 하는 데이터의 바이트를 세서 TCP 헤더에 기록하여 초기 <code>SEQ</code>를 생성해서 서버로 보낸다.</li>\n<li>그리고 서버는 수신한 데이터 크기를 계산하여 그 값에 1을 더하여 <code>ACK 번호</code>넘긴다.</li>\n<li>클라이언트는 나머지 분할 된 데이터 바이트를 읽어 <code>SEQ</code>를 생성해서 패킷을 보낸다.</li>\n<li>만약 이 과정 중에 서버가 받았다는 <code>ACK</code>를 보내주지 않는다면 클라이언트는 다시 한번 요청하게 해준다.(ACK를 기다리는 시간이 초과한 것을 Time out이라 한다.)</li>\n<li>그리고 서버는 다시 한번 패킷을 수신하면 <code>SEQ</code>번호 기반으로 패킷을 비교하여 기존에 도착한 패킷을 연결한다.(만약 이 과정 중에 SEQ 번호가 맞지 않다는 것은 데이터가 누락되었다는 것을 의미한다.)</li>\n</ol>\n<ul>\n<li>실제로는 시퀀스 번호가 1부터 시작하지 않고 난수를 바탕으로 산출한 초기값으로 시작한다. 시퀀스 번호를 항상 1부터 시작한다고 예측할 수 있으면 거기에 악의적인 공격을 할 우려가 있기 때문이다. 그러나 난수값으로하면 서버측에서 초기 <code>SEQ</code>을 알 수 없기 때문에 초기 Connect 단계에서 초기 <code>SEQ</code> 설정을 해줍니다.</li>\n</ul>\n<h2><span id=\"소켓-연결-종료\">소켓 연결 종료</span></h2>\n<p>TCP/IP 종료는 close() 시스템콜 함수로 종료할 수 있습니다. 일반적으로 HTTP 메시지를 송수신 한 뒤 다음과 같이 <code>four way handshake</code> 으로 연결을 종료합니다.(HTTP 1.1 이후부터는 바로 연결을 끊지는 않습니다.) 다음 그림은 서버의 요청으로 연결을 끊는 모습을 도식화 한 것입니다.</p>\n<h3><span id=\"four-way-handshake\">Four way handshake</span></h3>\n<p>다음은 Four way handshake을 도식화한 것입니다.</p>\n<p><img src=\"https://i.imgur.com/fTUTkfc.png\" alt=\"\"></p>\n<ol>\n<li>클라이언트는 서버는 FIN에 1을 설정한 TCP 헤더가 도착하면 자신의 소켓에 서버가 연결 종료에 들어갔다는 것을 표시합니다.</li>\n<li>클라이언트는 자신이 FIN 플래그를 받았다는 것을 알리기 위해 서버에게 ACK를 서버 측으로 반송한다.</li>\n<li>그와 동시에 Server에서는 해당 포트에 연결되어 있는 Application에게 Close()를 요청한다.</li>\n<li>애플리케이션의 네트워크 연결 종료 준비가 끝나면 클라이언트도 마찬가지로 FIN 플래그를 서버에게 보냅니다.</li>\n<li>서버는 FIN 플래그를 받게 되면 받았다는 것을 클라이언트에게 알리기 위해 ACK 플래그를 보냅니다.</li>\n<li>클라이언트가 ACK를 받게 되면 네트워크 연결이 종료가 됩니다.</li>\n</ol>\n<blockquote>\n<p>FIN_WAIT : FIN_WAIT 상태에서 클라이언트로부터 특정 시간 동안 응답이 오지 않는다면 특정 시간 이후에 서버는 자동으로 Closed가 된다.</p>\n</blockquote>\n<blockquote>\n<p>TIME_WAIT: 서버에서 세션을 종료시킨 후 뒤늦게 도착하는 패킷이 있다면 이 패킷은 Drop 되고 데이터는 유실될 것입니다.<br>\n이러한 현상에 대비하여 서버는 클라이언트로부터 FIN을 수신하더라도 일정 시간(디폴트 240초) 동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거치게 되는데 이 과정을 &quot;TIME_WAIT&quot;라고 합니다. 240초 후에는 CLOSED가 됩니다.</p>\n</blockquote>\n<p>참고</p>\n<ul>\n<li>\n<p><a href=\"http://mindnet.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-22%ED%8E%B8-TCP-3-WayHandshake-4-WayHandshake\" target=\"_blank\" rel=\"noopener\">MindNet</a></p>\n</li>\n<li>\n<p><a href=\"https://d2.naver.com/helloworld/47667\" target=\"_blank\" rel=\"noopener\">D2</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>TCP/IP 송수신 과정</h1>\n<!-- TOC -->\n<ul>\n<li><a href=\"#tcpip-%EC%86%A1%EC%88%98%EC%8B%A0-%EA%B3%BC%EC%A0%95\">TCP/IP 송수신 과정</a>\n<ul>\n<li><a href=\"#%EC%86%8C%EC%BC%93-%EC%83%9D%EC%84%B1\">소켓 생성</a></li>\n<li><a href=\"#%EC%86%8C%EC%BC%93-%EC%97%B0%EA%B2%B0-%EC%84%A4%EC%A0%95\">소켓 연결 설정</a>\n<ul>\n<li><a href=\"#three-way-handshake\">Three way handshake</a></li>\n</ul>\n</li>\n<li><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%86%A1%EC%88%98%EC%8B%A0\">데이터 송수신</a></li>\n<li><a href=\"#%EC%86%8C%EC%BC%93-%EC%97%B0%EA%B2%B0-%EC%A2%85%EB%A3%8C\">소켓 연결 종료</a>\n<ul>\n<li><a href=\"#four-way-handshake\">Four way handshake</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<p>인터넷 웹 개발을 하기 위해서는 네트워크 통신은 필수입니다. 모든 사용자 프로그램들은 네트워크 통신을 하기 위해서 아래와 같은 과정을 거쳐 통신을 하게 됩니다.</p>\n<p><img src=\"https://i.imgur.com/uMyrjMJ.gif\" alt=\"\"></p>\n<p>네트워크 통신과정을 요약하면 다음과 같을 수 있습니다.</p>\n<ol>\n<li>클라이언트 소켓 생성</li>\n<li>클라이언트와 서버 소켓 연결</li>\n<li>데이터 송수신</li>\n<li>소켓 연결 종료</li>\n</ol>\n<p>아래 내용에서는 클라이언트와 서버가 어떻게 실제로 연결이 맺어지고 데이터 송수신을 하고 연결이 끊어지는지 좀 더 세부적으로 알아보겠습니다.</p>\n<h2>소켓 생성</h2>\n<ol>\n<li>클라이언트가 특정 서버와 통신을 하기 위해서는 운영체제에 socket() 시스템콜을 통해 소켓을 생성해야 합니다.</li>\n<li>운영체제 내부 프로토콜 스택은 소켓의 정보를 저장하기 위해 메모리 영역을 할당하고 그곳에 소켓 제어 정보(상대 IP, 소켓 상태 정보 등)를 저장합니다.</li>\n<li>운영체제는 생성된 소켓의 정보의 파일 디스크립터를 사용자 프로그램에게 반환해줍니다.</li>\n</ol>\n<blockquote>\n<p>File discripter : 프로토콜 스택의 내부에 이는 다수의 소켓 중 어느 것을 가리키는지를 나타내는 번호표와 같은 존재이다.</p>\n</blockquote>\n<h2>소켓 연결 설정</h2>\n<p>아직 소켓은 만들었지만 아직 그 소켓에 아무런 정보도 없기 때문에 통신 상대가 누구인지 누구한테 통신을 해야 하는지 모른다. 그렇기 때문에 서버쪽 소켓과 연결 신청을 해 파이프를 구축해야 한다.</p>\n<p>그래서 다음과 같이 connect() 시스템콜을 호출하여 서버와 커넥션을 맺어야 한다. 운영체제는 데이터 송수신을 하기 위해서 사용자 프로그램에 도달하기 전에 일시적으로 데이터를 저장하기 위해서 버퍼 메모리 영역을 할당을 하고 데이터 송수신을 할 준비를 마치게 된다.</p>\n<p>이렇게 연결을 맺는 단계를 <code>Three way handshake</code>라고 한다.</p>\n<h3>Three way handshake</h3>\n<p>다음은 Three way handshanking을 도식화한 것입니다.</p>\n<p><img src=\"https://i.imgur.com/QR9GyHH.png\" alt=\"\"></p>\n<ol>\n<li>클라이언트는 서버에게 연결 요청의 SYN이라는 비트를 1을 만들어 TCP 헤더 정보를 설정하고 패킷을 생성하여 보낸다.</li>\n<li>서버는 받은 패킷을 기반으로 수신처 포트 번호에 해당하는 소켓을 찾고 거기에 해당 클라이언트에 대한 정보를 저장한다.</li>\n<li>서버는 마찬가지로 SYN 비트를 만들고 정상적으로 처리했다는 걸 알리기 위해 ACK 비트를 1로 해서 클라이언트에게 패킷을 보냅니다.</li>\n<li>클라이언트는 받은 패킷 정보를 기반으로 서버 측의 접속 동작이 성공했는지 확인합니다.</li>\n<li>클라이언트는 서버가 정상적으로 처리됐다는 것을 인지하고 자신도 패킷을 제대로 받았다는 것을 알리기 위해 ACK 비트를 1로 만들고 패킷을 만들어 서버에게 전송을 합니다.</li>\n<li>이로써 소켓은 데이터를 송수신할 수 있는 상태가 됩니다.</li>\n</ol>\n<blockquote>\n<p>커넥션 : 위와 같이 서버와 클라이언트가 송수신할 수 있는 상태가 파이와 같은 것으로 소켓이 연결되었다고 할 수 있다. 이렇게 접속이 안료 된 상태를 '커넥션’을 맺었다고 한다. 혹은 '세션’이라고도 부른다.</p>\n</blockquote>\n<blockquote>\n<p>윈도우 : 수신 측에서 송신 측에 윈도우 사이즈(수신 확인을 기다리지 않고 묶어서 송신할 수 있는 데이터양)를 즉 받을 수 있는 사이즈를 통지하기 위해 사용합니다.</p>\n</blockquote>\n<h2>데이터 송수신</h2>\n<p>데이터 송수신은 write(), read() 시스템 콜로 실행할 수 있습니다. 프로토콜 스택은 받은 데이터에 내용을 바로 송신하는 것이 아니라 일단 자체 송신용 버퍼 메모리 영역에 저장하고, 애플리케이션 다음 데이터를 건네주기를 기다립니다. 각 애플리케이션마다 송신 의뢰하는 데이터양 등이 적으면 너무 빈번하게 송신이 일어나면 네트워크의 이용 효율이 좋지 않기 때문에 한 번에 모아서 전송할 수도 있습니다.</p>\n<p>또 반대로 데이터가 너무 클 때는 이것을 분할하여 보냅니다. 아래는 MTU와 MSS에 대한 그림입니다. 일반적으로 TCP 통신을 하기 위해서 이더넷에 송신할 수 있는 MTU는 1500 바이트이다. 그리고 MTU에서 TCP 헤더가 40이라고 하면 이것을 뺀 1460바이트가 MSS이다.</p>\n<p><img src=\"https://i.imgur.com/3z6WHLT.png\" alt=\"\"></p>\n<ul>\n<li>MTU : 패킷 한 개로 운반할 수 있는 디지털 데이터의 최대 길이. 이더넷에서는 보통 1,500 바이트</li>\n<li>MSS : 헤더를 제외하고 한개의 패킷으로 운반할 수 있는 TCP의 최대 데이터 길이</li>\n</ul>\n<p>만약 송신하고자 하는 데이터가 MSS(1460) 바이트를 넘는다고 하면 이것을 분할하여 데이터를 보내야 합니다. 그럼 지금부터 어떻게 데이터를 분할해서 보내고 또 받는지 다음 그림을 통해서 알아보겠습니다.</p>\n<p><img src=\"https://i.imgur.com/iMqN5Ky.png\" alt=\"\"></p>\n<ol>\n<li>먼저 클라이언트가 데이터를 보내기 전에 자신이 보내려고 하는 데이터의 바이트를 세서 TCP 헤더에 기록하여 초기 <code>SEQ</code>를 생성해서 서버로 보낸다.</li>\n<li>그리고 서버는 수신한 데이터 크기를 계산하여 그 값에 1을 더하여 <code>ACK 번호</code>넘긴다.</li>\n<li>클라이언트는 나머지 분할 된 데이터 바이트를 읽어 <code>SEQ</code>를 생성해서 패킷을 보낸다.</li>\n<li>만약 이 과정 중에 서버가 받았다는 <code>ACK</code>를 보내주지 않는다면 클라이언트는 다시 한번 요청하게 해준다.(ACK를 기다리는 시간이 초과한 것을 Time out이라 한다.)</li>\n<li>그리고 서버는 다시 한번 패킷을 수신하면 <code>SEQ</code>번호 기반으로 패킷을 비교하여 기존에 도착한 패킷을 연결한다.(만약 이 과정 중에 SEQ 번호가 맞지 않다는 것은 데이터가 누락되었다는 것을 의미한다.)</li>\n</ol>\n<ul>\n<li>실제로는 시퀀스 번호가 1부터 시작하지 않고 난수를 바탕으로 산출한 초기값으로 시작한다. 시퀀스 번호를 항상 1부터 시작한다고 예측할 수 있으면 거기에 악의적인 공격을 할 우려가 있기 때문이다. 그러나 난수값으로하면 서버측에서 초기 <code>SEQ</code>을 알 수 없기 때문에 초기 Connect 단계에서 초기 <code>SEQ</code> 설정을 해줍니다.</li>\n</ul>\n<h2>소켓 연결 종료</h2>\n<p>TCP/IP 종료는 close() 시스템콜 함수로 종료할 수 있습니다. 일반적으로 HTTP 메시지를 송수신 한 뒤 다음과 같이 <code>four way handshake</code> 으로 연결을 종료합니다.(HTTP 1.1 이후부터는 바로 연결을 끊지는 않습니다.) 다음 그림은 서버의 요청으로 연결을 끊는 모습을 도식화 한 것입니다.</p>\n<h3>Four way handshake</h3>\n<p>다음은 Four way handshake을 도식화한 것입니다.</p>\n<p><img src=\"https://i.imgur.com/fTUTkfc.png\" alt=\"\"></p>\n<ol>\n<li>클라이언트는 서버는 FIN에 1을 설정한 TCP 헤더가 도착하면 자신의 소켓에 서버가 연결 종료에 들어갔다는 것을 표시합니다.</li>\n<li>클라이언트는 자신이 FIN 플래그를 받았다는 것을 알리기 위해 서버에게 ACK를 서버 측으로 반송한다.</li>\n<li>그와 동시에 Server에서는 해당 포트에 연결되어 있는 Application에게 Close()를 요청한다.</li>\n<li>애플리케이션의 네트워크 연결 종료 준비가 끝나면 클라이언트도 마찬가지로 FIN 플래그를 서버에게 보냅니다.</li>\n<li>서버는 FIN 플래그를 받게 되면 받았다는 것을 클라이언트에게 알리기 위해 ACK 플래그를 보냅니다.</li>\n<li>클라이언트가 ACK를 받게 되면 네트워크 연결이 종료가 됩니다.</li>\n</ol>\n<blockquote>\n<p>FIN_WAIT : FIN_WAIT 상태에서 클라이언트로부터 특정 시간 동안 응답이 오지 않는다면 특정 시간 이후에 서버는 자동으로 Closed가 된다.</p>\n</blockquote>\n<blockquote>\n<p>TIME_WAIT: 서버에서 세션을 종료시킨 후 뒤늦게 도착하는 패킷이 있다면 이 패킷은 Drop 되고 데이터는 유실될 것입니다.<br>\n이러한 현상에 대비하여 서버는 클라이언트로부터 FIN을 수신하더라도 일정 시간(디폴트 240초) 동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거치게 되는데 이 과정을 &quot;TIME_WAIT&quot;라고 합니다. 240초 후에는 CLOSED가 됩니다.</p>\n</blockquote>\n<p>참고</p>\n<ul>\n<li>\n<p><a href=\"http://mindnet.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-22%ED%8E%B8-TCP-3-WayHandshake-4-WayHandshake\" target=\"_blank\" rel=\"noopener\">MindNet</a></p>\n</li>\n<li>\n<p><a href=\"https://d2.naver.com/helloworld/47667\" target=\"_blank\" rel=\"noopener\">D2</a></p>\n</li>\n</ul>\n"},{"title":"정규식이란 ? - Java","catalog":true,"date":"2018-09-22T15:00:00.000Z","subtitle":"정규식","header-img":null,"_content":"\n\n\n# 정규식 / 정규표현식 (Regular Expressions; Regex)\n\n정규표현식은 문자열을 처리하는 방법 중의 하나로 특정한 조건의 문자를 '검색'하거나 '치환'하는 과정을 매우 간편하게 처리 할 수 있도록 하는 수단이다.\n\n## 대표적인 정규표현식\n표현식  | 설명\n------- | ------- \n^ | 문자열의 시작 ([]대괄호 안에서는 부정을 의미한다.)\n$ | 문자열의 종료\n. | 임의의 한 문자 (문자의 종류 가리지 않음)\n* | 앞 문자가 없을 수도 무한정 많을 수도 있음\n+ | 앞 문자가 하나 이상\n? | 앞 문자가 없거나 하나있음\n[] | 문자의 집합이나 범위를 나타내며 두 문자 사이는 - 기호로 범위를 나타낸다. []내에서 ^가 선행하여 존재하면 not 을 나타낸다.\n{} | 횟수 또는 범위를 나타낸다.\n() | 소괄호 안의 문자를 하나의 문자로 인식\n\\| | 패턴 안에서 or 연산을 수행할 때 사용\n\\s | 공백 문자\n\\S | 공백 문자가 아닌 나머지 문자\n\\w | 알파벳이나 숫자 또는 _ 포함\n\\W | 알파벳이나 숫자를 제외한 문자\n\\d | 숫자 [0-9]와 동일\n\\D | 숫자를 제외한 모든 문자\n\\A | 맨 앞을 의미한다.\n\\A | 맨 뒤를 의미한다.\n\\ | \"정규표현식 역슬래시(\\)는 확장 문자 <br>역슬래시 다음에 일반 문자가 오면 특수문자로 취급하고 역슬래시 다음에 특수문자가 오면 그 문자 자체를 의미\"\n(?i) | 앞 부분에 (?i) 라는 옵션을 넣어주면 대소문자를 구분하지 않음\n\n\n\n## 간단한 예제 분석 1 .\n예제의 `^[0-9]*$` 를 분석해보면 \n\n>^ 으로 우선 패턴의 시작을 알립니다.\n>[0-9] 괄호사이에 두 숫자를 넣어 범위를 지정해줄 수 있습니다.\n>\\* 를 넣으면 글자 수를 상관하지 않고 검사합니다.\n>$ 으로 패턴의 종료를 알립니다.\n\n\n## 간단한 예제 분석 2.\n1. 숫자로 시작하는것 검색\n>\\d+(숫자로시작하는것)\n\n2. 문장안에서 날짜값 빼오기\n\n>2018/7/3 테스트행 크크크를 손에 넣었다.\n>자동차를 탄다 18년06월13일 날에\n>\\d+.\\d+.\\d+ -> 2018/7/3 , 18년06월13 잡힌다.\n\n\n\n\n## 간단한 예제 분석3.\n\n1. \n```java\n\n        Pattern pattern = Pattern.compile(\"\\d+.\\d+.\\d+\");\n        final Matcher matcher = pattern.matcher(\"2018/7/3 테스트행 크크크를 손에 넣었다. 2018/7/4\");\n\n        if(matcher.find()){ //find 안쓰고 바로 group뽑으려고하면 Exception남.\n            final String group = matcher.group();// 2018/7/3 \n        }\n\n        final String group = matcher.group();// 2018/7/3 \n        matcher.find(); // find안하면 안바뀐다.\n        final String group = matcher.group();// 2018/7/4\n```\n\n\n2. replace(패턴에 맞는 값을 새로운 값으로 치환)\n\n​\n```java\npublic void replaceRegEx() {\n    String target = \"나는 2008년도에 입학했다.\";\n    String regEx = \"[0-9]\";\n    Pattern pat = Pattern.compile(regEx);\n  \n    Matcher m = pat.matcher(target);\n    String result = m.replaceAll(\"2\"); // 패턴과 일치할 경우 \"2\"로 변경\n     \n    System.out.println(\"출력 : \" + result);\n    // 출력 : 나는 2222년도에 입학했다.\n}\n```\n\n## 예제 1\n**대소문자를 구분한다.**\n\nCase 1\nRegular Expression:\tHello\nmatches:\t`Hello`, world!\n\nCase 2\nRegular Expression:\thello\nmatches:\tHello, world!\n\n* [example1 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example1.java)\n## 예제 2\n공백, 스페이스, 탭을 고려해야한다. \n\nCase 1 \nRegular Expression:\tHello, world\nmatches:\t`Hello, world`!\nCase 2\nRegular Expression:\tHello,    world\nmatches:\tHello, world!\n\n* [example2 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example2.java)\n\n## 예제 3\n^는 시작하는 문자열에 대해서 매치를 해준다.\n\\$는 끝나는 문자열에 대해서 매치를 해준다.\nCase 1\nRegular Expression:\t^who\nmatches:\t`who` is who\nCase 2\nRegular Expression:\twho$\nmatches:\twho is `who`\n* [example3 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example3.java)\n## 예제 4\n특수 문자 예를들어 위의 $같이 이런것에 정규 표현식을 정욕하려면 \\를 적용해야한다. \n\nCase 1\nRegular Expression:\t^\\$\nmatches:\t\\$12\\$ \\\\-\\ \\$25\\$\n\nCase 2\nRegular Expression:\t\\\\\\\\\\$\nmatches:\t`$`12`$` \\\\-\\\\ `$` 25 `$`\n\nCase 3\nRegular Expression:\t^\\\\\\\\\\$\nmatches:\t`$`12\\$ \\\\-\\ $25$\n\nCase 4\nRegular Expression:\t\\\\\\$\\$\nmatches:\t$12$ \\\\-\\ \\$25`$`\n\n\n* [example4 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example4.java)\n\n## 예제 5\n.은 어떤 문자든 정규 표현식에 해당 된다.\n\nCase 1\nRegular Expression:\t.\nmatches:\t`Regular expressions are powerful!!!`\n\n\nCase 2\n아래는 . 갯수대로 문자열 그룹을 묶는다. Regular, r expr 등 처럼 문자 갯수가 6개이면 그룹으로 묶고 아니면 해당 표현식에 해당하지 않는다. 그래서 ul!!!부분은 매치에 해당되지 않는다.\n\nRegular Expression:\t......\nmatches:\t`Regular expressions are powerf`ul!!!\n\n* [example5 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example5.java)\n## 예제 6\n정규표현식에서 문자 . 을 찾는다면 \\를 사용해야한다.\n\nCase 1\nRegular Expression:\t\\\\.\nmatches:\tO`.`K`.`\n\nCase 2\nRegular Expression:\t\\\\..\\\\.\nmatches:\tO`.K.`\n* [example6 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example6.java)\n## 예제 7\n[]안에 있는 문자중 하나라도 존재하면 매치가 된다.\n\nCase 1\nRegular Expression:\t[oyu]\nmatches:\tH`o`w d`o` `you` d`o`?\n\nCase 2\nd또는H이면서 뒤에 문자가 하나 붙어있는것\nRegular Expression:\t[dH].\nmatches:\t`Ho`w `do` you `do`?\n\nCase 3\n두개의 [][]에서 []에 들어잇는 문자열중 하나 &&(있으면서) 두번째 []에 문자열중 하나라도 있는경우\nRegular Expression:\t[owy][yow]\nmatches:\tH`ow` do `yo`u do?\n* [example7 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example7.java)\n## 예제 8\n[]대괄호 사이에 문자에 범위를 넣으면 그 범위부분을 매치 해준다. 여기에서 주의할점은 문자하나하나가 매치된다. 예를들어 a-b이면 a,b 문자하나를 의미한다.\n\nCase 1\nRegular Expression:\t[a-d]\nmatches:\tABCDEFGHIJKLMNOPQRSTUVWXYZ `abcd`efghijklmnopqrstuvwxyz 0123456789\n\nCase 2\nRegular Expression:\t[2-6]\nmatches:\tABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 01`23456`789\n\nCase 3\nC~K, a~d, 2~6의 범위를 매치해준다.\nRegular Expression:\t[C-Ka-d2-6]\nmatches:\tAB`CDEFGHIJK`LMNOPQRSTUVWXYZ `abcd`efghijklmnopqrstuvwxyz 01`23456`789\n\n* [example8 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example8.java)\n## 예제 9\n[] 대괄호안에서 ^를 사용한다면 그 문자는 선택되지 않을것이다.\n\nCase 1\nRegular Expression:\t[^CDghi45]\nmatches:\t`AB`CD`EFGHIJKLMNOPQRSTUVWXYZ abcdef`ghi`jklmnopqrstuvwxyz 0123`45`6789`\nCase 2\nRegular Expression:\t[^W-Z]\nmatches:\t`ABCDEFGHIJKLMNOPQRSTUV`WXYZ` abcdefghijklmnopqrstuvwxyz 0123456789`\n\n* [example9 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example9.java)\n## 예제 10\n소괄호로 문자들를 단어로 묶을수 있습니다. 그리고 | 를 이용하여 한문장에 여러개의 단어를 매치할 수 있습니다.\n\nCase 1\nRegular Expression:\t(on|ues|rida)\nmatches:\tM`on`day T`ues`day F`rida`y\n\nCase 2\nRegular Expression:\t(Mon|Tues|Fri)day\nmatches:\t`Monday` `Tuesday` `Friday`\n\nCase 3\nRegular Expression:\t..(id|esd|nd)ay\nmatches:\t`Monday` `Tuesday` `Friday`\n\n* [example10 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example10.java)\n## 예제 11\n\\* \\+ ? \n이수량주 문자는 얼마나 앞에 많은 문자열들이 존재가능할지를 나타낸다.\n\nCase 1\n* 을넣게되면 앞에에 문자가 있을수도있고 없을 수 도 있음\nRegular Expression:\ta*b\nmatches:\t`aab`c `ab`c `b`c ac`b`\n\nCase 2\n+ 앞에 문자를 두면 그 앞에 문자가 반드시 하나이상있어야 매치된다.\nRegular Expression:\ta+b\nmatches:\t`aab`c `ab`c bc\n\nCase 3\n? 앞에 문자가 있으면 그 앞에 문자가 없거나 하나인 문자만 매치된다.\nRegular Expression:\ta?b\nmatches:\ta`ab`c `ab`c `b`c\n* [example11 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example11.java)\n## 예제 12\n*를 사용한 예제.(앞에 문자가 무한정있거나 없을 수 있음.)\n\nCase 1 : *앞에 . 이 있으니 모든 텍스트를 매치한것이다.\nRegular Expression:\t.*\nmatches:\t`-@- *** -- \"*\" -- *** -@-`\nCase 2\n\nRegular Expression:\t-A*-\n*앞에 A가 있으니 있을수도있고 무한정 많을 수 도 있다는것을 의미한다. 아래의 문자열을 매치하면 아래와갘이 매치될것이다.\nmatches:\t-@- *** `--` \"*\" `--` *** -@-\n* [example12 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example12.java)\n## 예제 13\n+를 사용한 예제.(앞에 문자가 무조건 하나 이상 있어야한다.)\n\nCase 1\n\\*이 앞에 하나이상 반드시 있어야한다.\nRegular Expression:\t\\\\\\*+\nmatches:\t-@@@- `*` `**` - - \"`*`\" -- `*` `**` -@@@-\n\nCase 2\nRegular Expression:\t-@+-\nmatches:\t`-@@@-` * ** - - \"*\" -- * ** `-@@@-`\n\nCase 3\n공백을 제외하고 매치한다.\nRegular Expression:\t[^ ]+\nmatches:\t-@@@- * ** - - \"*\" -- * ** -@@@-\n\n* [example13 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example13.java)\n## 예제 14\n?를 사용한 예제(앞문자가 하나거있거나 없음.)\nCase 1\nRegular Expression:\t-X?XX?X\nmatches:\t-`-XX`-@`-XX`-@@`-XX`-@@@`-XX`-@@@@`-XX`-@@-@@-\nCase 2\nRegular Expression:\t-@?@?@?-\n\nmatches:\t--XX`-@-`XX`-@@-`XX`-@@@-`XX-@@@@-XX`-@@-`@@-\nCase 3\n@가맨뒤에 있으면서 앞에@가 있을수도있고 없을 수 도 있으면서 앞에는@아니면 매치된다.\nRegular Expression:\t[^@]@?@\nmatches:\t--XX`-@`-XX`-@@`-XX`-@@`@-XX`-@@`@@-XX`-@@` `-@@`-\n\n* [example14 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example14.java)\n## 예제 15\n{} 중괄호안에 숫자들을 통해 매치해준다. 예를들어 {3} 이면 3글자씩, {3,5} 이면 3이상 5이하인 숫자를, {3,} 3글자이상을 의미한다.\n\nCase 1\nRegular Expression:\t.{5}\nmatches:\t`One r` `ing t` `o bri` `ng th` `em al` `l and` `  in t` `he da` `rknes` `s bin` `d the`m\nCase 2\nRegular Expression:\t[els]{1,3}\nmatches:\tOn`e` ring to bring th`e`m a`ll` and in th`e` darkn`ess` bind th`e`m\nCase 3\nRegular Expression:\t[a-z]{3,}\nmatches:\tOne `ring` to `bring` `them` `all` `and` in `the` `darkness` `bind` `them`\n* [example15 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example15.java)\n## 예제 16\n\n\nCase 1\nRegular Expression:\tAB*A\nmatches:\t`AA` `ABA` `ABBBBA` `ABBCBA`\nCase 2\nRegular Expression:\tAB{0,}A\nmatches:\t`AA` `ABA` `ABBBBA` ABBCBA\nCase 3\nRegular Expression:\tAB+A\nmatches:\tAA `ABA` `ABBBBA` ABBCBA\nCase 4\nRegular Expression:\tAB{1,}A\nmatches:\tAA `ABA` `ABBBBA` ABBCBA\nCase 5\nRegular Expression:\tAB?A\nmatches:\t`AA` `ABA` ABBBBA ABBCBA\nCase 6\nRegular Expression:\tAB{0,1}A\nmatches:\t`AA` `ABA` ABBBBA ABBCBA\n* [example16 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example16.java)\n## 예제 17\n\n\nCase 1\nRegular Expression:\tr.*\nmatches:\tOne `ring to bring them all and in the darkness bind them`\nCase 2\n아래 같은경우 ?앞에 * 수량자가 나왔다. 원래 문자가 와야하는데 * 수량자가 왔다. 이렇게되면 앞에 * 수량자의 의미는 0으로 바뀐다. * 원래 의미가 0개 아니면 1개 혹은 그이상을 의미한다. ?가 앞에 오게되면 처음의미인 0을 의미한다. 그렇기 때문에 앞에 .*은 0개를 의미한다.\nRegular Expression:\tr.\\*\\?\nmatches:\tOne `r`ing to b`r`ing them all and in the da`r`kness bind them\nCase 3\nRegular Expression:\tr.+\nmatches:\tOne `ring to bring them all and in the darkness bind them`\nCase 4\n여기에서도 ?앞에 수량자가 나왔다. +는 1혹은 그이상의 단어를 의미하기 떄문에 첫 의미인 1을 가져와 r그리고 어떤 문자가 반드시 하나 있어야하면서\nRegular Expression:\tr.+?\nmatches:\tOne `ri`ng to b`ri`ng them all and in the da`rk`ness bind them\nCase 5\nRegular Expression:\tr.?\nmatches:\tOne `ri`ng to b`ri`ng them all and in the da`rk`ness bind them\nCase 6\n밑에서도 ?앞에 ? 가있는데 ?는 0아니면 1을의미하기때문에 앞에 의미인 0이 들어가 r만 매치된다.\nRegular Expression:\tr.??\nmatches:\tOne `r`ing to b`r`ing them all and in the da`r`kness bind them\n\nCase 7\nResgular Expression : \\<div>.+</div> \nmatches:`\\<div>test\\<div><div>test\\<div>`\nResgular Expression : \\<div>.+?\\</div> \nmatches:`\\<div>test\\<div>`<div>test\\<div> \n* [example17 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example17.java)\n## 예제 18\n\\w는  모든 문자('_')를 매치해준다. 단 특수문자는 제외한다.\n\nCase 1\nRegular Expression:\t\\w\nmatches:\t`A` `1`  `B` `2` `c` `3` `d` `_` `4` `e` : `5` `f` `f` `G` `G` `7` `7`--`_` `_`--\nCase 2\nRegular Expression:\t\\w+\nmatches:\t`A1` `B2` `c3` `d_4` `e`:`5` `ffGG77`--`__`--\nCase 3\nRegular Expression:\t[a-z]\\w*\nmatches:\tA1 B2 `c3` `d_4` `e`:5 `ffGG77`--__--\nCase 4\nRegular Expression:\t\\w{5}\nmatches:\tA1 B2 c3 d_4 e:5 `ffGG7`7--__--\nCase 5\nRegular Expression:\t[A-z0-9_]\nmatches:\t`A` `1`  `B` `2` `c` `3` `d` `_` `4` `e` : `5` `f` `f` `G` `G` `7` `7`--`_` `_`--\n\n* [example18 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example18.java)\n## 예제 19\n?=문자를 제외하고 그앞에 선택한 문자들이 매치된다.\n\nCase 1\nRegular Expression:\t\\w+(?=X)\nmatches:\t`AAA`X---aaax---111\nCase 2\nRegular Expression:\t\\w+(?=\\w)\nmatches:\t`AAA`X---`aaa`x---111\n\n\n참고\n* [HighCode](http://highcode.tistory.com/6)\n* [자바 정규식 기본정리](http://blog.naver.com/PostView.nhn?blogId=bb_&logNo=220863282423&parentCategoryNo=&categoryNo=103&viewDate=&isShowPopularPosts=true&from=search)\n* [ZVON](http://zvon.org/comp/r/tut-Regexp.html#Pages~Contents)","source":"_posts/2018-09-03-java-reg.md","raw":"---\ntitle: 정규식이란 ? - Java\ncatalog: true\ndate: 2018-09-23\nsubtitle: 정규식\nheader-img:\ntags:\n- Java\n\n\n\n---\n\n\n\n# 정규식 / 정규표현식 (Regular Expressions; Regex)\n\n정규표현식은 문자열을 처리하는 방법 중의 하나로 특정한 조건의 문자를 '검색'하거나 '치환'하는 과정을 매우 간편하게 처리 할 수 있도록 하는 수단이다.\n\n## 대표적인 정규표현식\n표현식  | 설명\n------- | ------- \n^ | 문자열의 시작 ([]대괄호 안에서는 부정을 의미한다.)\n$ | 문자열의 종료\n. | 임의의 한 문자 (문자의 종류 가리지 않음)\n* | 앞 문자가 없을 수도 무한정 많을 수도 있음\n+ | 앞 문자가 하나 이상\n? | 앞 문자가 없거나 하나있음\n[] | 문자의 집합이나 범위를 나타내며 두 문자 사이는 - 기호로 범위를 나타낸다. []내에서 ^가 선행하여 존재하면 not 을 나타낸다.\n{} | 횟수 또는 범위를 나타낸다.\n() | 소괄호 안의 문자를 하나의 문자로 인식\n\\| | 패턴 안에서 or 연산을 수행할 때 사용\n\\s | 공백 문자\n\\S | 공백 문자가 아닌 나머지 문자\n\\w | 알파벳이나 숫자 또는 _ 포함\n\\W | 알파벳이나 숫자를 제외한 문자\n\\d | 숫자 [0-9]와 동일\n\\D | 숫자를 제외한 모든 문자\n\\A | 맨 앞을 의미한다.\n\\A | 맨 뒤를 의미한다.\n\\ | \"정규표현식 역슬래시(\\)는 확장 문자 <br>역슬래시 다음에 일반 문자가 오면 특수문자로 취급하고 역슬래시 다음에 특수문자가 오면 그 문자 자체를 의미\"\n(?i) | 앞 부분에 (?i) 라는 옵션을 넣어주면 대소문자를 구분하지 않음\n\n\n\n## 간단한 예제 분석 1 .\n예제의 `^[0-9]*$` 를 분석해보면 \n\n>^ 으로 우선 패턴의 시작을 알립니다.\n>[0-9] 괄호사이에 두 숫자를 넣어 범위를 지정해줄 수 있습니다.\n>\\* 를 넣으면 글자 수를 상관하지 않고 검사합니다.\n>$ 으로 패턴의 종료를 알립니다.\n\n\n## 간단한 예제 분석 2.\n1. 숫자로 시작하는것 검색\n>\\d+(숫자로시작하는것)\n\n2. 문장안에서 날짜값 빼오기\n\n>2018/7/3 테스트행 크크크를 손에 넣었다.\n>자동차를 탄다 18년06월13일 날에\n>\\d+.\\d+.\\d+ -> 2018/7/3 , 18년06월13 잡힌다.\n\n\n\n\n## 간단한 예제 분석3.\n\n1. \n```java\n\n        Pattern pattern = Pattern.compile(\"\\d+.\\d+.\\d+\");\n        final Matcher matcher = pattern.matcher(\"2018/7/3 테스트행 크크크를 손에 넣었다. 2018/7/4\");\n\n        if(matcher.find()){ //find 안쓰고 바로 group뽑으려고하면 Exception남.\n            final String group = matcher.group();// 2018/7/3 \n        }\n\n        final String group = matcher.group();// 2018/7/3 \n        matcher.find(); // find안하면 안바뀐다.\n        final String group = matcher.group();// 2018/7/4\n```\n\n\n2. replace(패턴에 맞는 값을 새로운 값으로 치환)\n\n​\n```java\npublic void replaceRegEx() {\n    String target = \"나는 2008년도에 입학했다.\";\n    String regEx = \"[0-9]\";\n    Pattern pat = Pattern.compile(regEx);\n  \n    Matcher m = pat.matcher(target);\n    String result = m.replaceAll(\"2\"); // 패턴과 일치할 경우 \"2\"로 변경\n     \n    System.out.println(\"출력 : \" + result);\n    // 출력 : 나는 2222년도에 입학했다.\n}\n```\n\n## 예제 1\n**대소문자를 구분한다.**\n\nCase 1\nRegular Expression:\tHello\nmatches:\t`Hello`, world!\n\nCase 2\nRegular Expression:\thello\nmatches:\tHello, world!\n\n* [example1 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example1.java)\n## 예제 2\n공백, 스페이스, 탭을 고려해야한다. \n\nCase 1 \nRegular Expression:\tHello, world\nmatches:\t`Hello, world`!\nCase 2\nRegular Expression:\tHello,    world\nmatches:\tHello, world!\n\n* [example2 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example2.java)\n\n## 예제 3\n^는 시작하는 문자열에 대해서 매치를 해준다.\n\\$는 끝나는 문자열에 대해서 매치를 해준다.\nCase 1\nRegular Expression:\t^who\nmatches:\t`who` is who\nCase 2\nRegular Expression:\twho$\nmatches:\twho is `who`\n* [example3 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example3.java)\n## 예제 4\n특수 문자 예를들어 위의 $같이 이런것에 정규 표현식을 정욕하려면 \\를 적용해야한다. \n\nCase 1\nRegular Expression:\t^\\$\nmatches:\t\\$12\\$ \\\\-\\ \\$25\\$\n\nCase 2\nRegular Expression:\t\\\\\\\\\\$\nmatches:\t`$`12`$` \\\\-\\\\ `$` 25 `$`\n\nCase 3\nRegular Expression:\t^\\\\\\\\\\$\nmatches:\t`$`12\\$ \\\\-\\ $25$\n\nCase 4\nRegular Expression:\t\\\\\\$\\$\nmatches:\t$12$ \\\\-\\ \\$25`$`\n\n\n* [example4 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example4.java)\n\n## 예제 5\n.은 어떤 문자든 정규 표현식에 해당 된다.\n\nCase 1\nRegular Expression:\t.\nmatches:\t`Regular expressions are powerful!!!`\n\n\nCase 2\n아래는 . 갯수대로 문자열 그룹을 묶는다. Regular, r expr 등 처럼 문자 갯수가 6개이면 그룹으로 묶고 아니면 해당 표현식에 해당하지 않는다. 그래서 ul!!!부분은 매치에 해당되지 않는다.\n\nRegular Expression:\t......\nmatches:\t`Regular expressions are powerf`ul!!!\n\n* [example5 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example5.java)\n## 예제 6\n정규표현식에서 문자 . 을 찾는다면 \\를 사용해야한다.\n\nCase 1\nRegular Expression:\t\\\\.\nmatches:\tO`.`K`.`\n\nCase 2\nRegular Expression:\t\\\\..\\\\.\nmatches:\tO`.K.`\n* [example6 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example6.java)\n## 예제 7\n[]안에 있는 문자중 하나라도 존재하면 매치가 된다.\n\nCase 1\nRegular Expression:\t[oyu]\nmatches:\tH`o`w d`o` `you` d`o`?\n\nCase 2\nd또는H이면서 뒤에 문자가 하나 붙어있는것\nRegular Expression:\t[dH].\nmatches:\t`Ho`w `do` you `do`?\n\nCase 3\n두개의 [][]에서 []에 들어잇는 문자열중 하나 &&(있으면서) 두번째 []에 문자열중 하나라도 있는경우\nRegular Expression:\t[owy][yow]\nmatches:\tH`ow` do `yo`u do?\n* [example7 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example7.java)\n## 예제 8\n[]대괄호 사이에 문자에 범위를 넣으면 그 범위부분을 매치 해준다. 여기에서 주의할점은 문자하나하나가 매치된다. 예를들어 a-b이면 a,b 문자하나를 의미한다.\n\nCase 1\nRegular Expression:\t[a-d]\nmatches:\tABCDEFGHIJKLMNOPQRSTUVWXYZ `abcd`efghijklmnopqrstuvwxyz 0123456789\n\nCase 2\nRegular Expression:\t[2-6]\nmatches:\tABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 01`23456`789\n\nCase 3\nC~K, a~d, 2~6의 범위를 매치해준다.\nRegular Expression:\t[C-Ka-d2-6]\nmatches:\tAB`CDEFGHIJK`LMNOPQRSTUVWXYZ `abcd`efghijklmnopqrstuvwxyz 01`23456`789\n\n* [example8 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example8.java)\n## 예제 9\n[] 대괄호안에서 ^를 사용한다면 그 문자는 선택되지 않을것이다.\n\nCase 1\nRegular Expression:\t[^CDghi45]\nmatches:\t`AB`CD`EFGHIJKLMNOPQRSTUVWXYZ abcdef`ghi`jklmnopqrstuvwxyz 0123`45`6789`\nCase 2\nRegular Expression:\t[^W-Z]\nmatches:\t`ABCDEFGHIJKLMNOPQRSTUV`WXYZ` abcdefghijklmnopqrstuvwxyz 0123456789`\n\n* [example9 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example9.java)\n## 예제 10\n소괄호로 문자들를 단어로 묶을수 있습니다. 그리고 | 를 이용하여 한문장에 여러개의 단어를 매치할 수 있습니다.\n\nCase 1\nRegular Expression:\t(on|ues|rida)\nmatches:\tM`on`day T`ues`day F`rida`y\n\nCase 2\nRegular Expression:\t(Mon|Tues|Fri)day\nmatches:\t`Monday` `Tuesday` `Friday`\n\nCase 3\nRegular Expression:\t..(id|esd|nd)ay\nmatches:\t`Monday` `Tuesday` `Friday`\n\n* [example10 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example10.java)\n## 예제 11\n\\* \\+ ? \n이수량주 문자는 얼마나 앞에 많은 문자열들이 존재가능할지를 나타낸다.\n\nCase 1\n* 을넣게되면 앞에에 문자가 있을수도있고 없을 수 도 있음\nRegular Expression:\ta*b\nmatches:\t`aab`c `ab`c `b`c ac`b`\n\nCase 2\n+ 앞에 문자를 두면 그 앞에 문자가 반드시 하나이상있어야 매치된다.\nRegular Expression:\ta+b\nmatches:\t`aab`c `ab`c bc\n\nCase 3\n? 앞에 문자가 있으면 그 앞에 문자가 없거나 하나인 문자만 매치된다.\nRegular Expression:\ta?b\nmatches:\ta`ab`c `ab`c `b`c\n* [example11 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example11.java)\n## 예제 12\n*를 사용한 예제.(앞에 문자가 무한정있거나 없을 수 있음.)\n\nCase 1 : *앞에 . 이 있으니 모든 텍스트를 매치한것이다.\nRegular Expression:\t.*\nmatches:\t`-@- *** -- \"*\" -- *** -@-`\nCase 2\n\nRegular Expression:\t-A*-\n*앞에 A가 있으니 있을수도있고 무한정 많을 수 도 있다는것을 의미한다. 아래의 문자열을 매치하면 아래와갘이 매치될것이다.\nmatches:\t-@- *** `--` \"*\" `--` *** -@-\n* [example12 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example12.java)\n## 예제 13\n+를 사용한 예제.(앞에 문자가 무조건 하나 이상 있어야한다.)\n\nCase 1\n\\*이 앞에 하나이상 반드시 있어야한다.\nRegular Expression:\t\\\\\\*+\nmatches:\t-@@@- `*` `**` - - \"`*`\" -- `*` `**` -@@@-\n\nCase 2\nRegular Expression:\t-@+-\nmatches:\t`-@@@-` * ** - - \"*\" -- * ** `-@@@-`\n\nCase 3\n공백을 제외하고 매치한다.\nRegular Expression:\t[^ ]+\nmatches:\t-@@@- * ** - - \"*\" -- * ** -@@@-\n\n* [example13 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example13.java)\n## 예제 14\n?를 사용한 예제(앞문자가 하나거있거나 없음.)\nCase 1\nRegular Expression:\t-X?XX?X\nmatches:\t-`-XX`-@`-XX`-@@`-XX`-@@@`-XX`-@@@@`-XX`-@@-@@-\nCase 2\nRegular Expression:\t-@?@?@?-\n\nmatches:\t--XX`-@-`XX`-@@-`XX`-@@@-`XX-@@@@-XX`-@@-`@@-\nCase 3\n@가맨뒤에 있으면서 앞에@가 있을수도있고 없을 수 도 있으면서 앞에는@아니면 매치된다.\nRegular Expression:\t[^@]@?@\nmatches:\t--XX`-@`-XX`-@@`-XX`-@@`@-XX`-@@`@@-XX`-@@` `-@@`-\n\n* [example14 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example14.java)\n## 예제 15\n{} 중괄호안에 숫자들을 통해 매치해준다. 예를들어 {3} 이면 3글자씩, {3,5} 이면 3이상 5이하인 숫자를, {3,} 3글자이상을 의미한다.\n\nCase 1\nRegular Expression:\t.{5}\nmatches:\t`One r` `ing t` `o bri` `ng th` `em al` `l and` `  in t` `he da` `rknes` `s bin` `d the`m\nCase 2\nRegular Expression:\t[els]{1,3}\nmatches:\tOn`e` ring to bring th`e`m a`ll` and in th`e` darkn`ess` bind th`e`m\nCase 3\nRegular Expression:\t[a-z]{3,}\nmatches:\tOne `ring` to `bring` `them` `all` `and` in `the` `darkness` `bind` `them`\n* [example15 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example15.java)\n## 예제 16\n\n\nCase 1\nRegular Expression:\tAB*A\nmatches:\t`AA` `ABA` `ABBBBA` `ABBCBA`\nCase 2\nRegular Expression:\tAB{0,}A\nmatches:\t`AA` `ABA` `ABBBBA` ABBCBA\nCase 3\nRegular Expression:\tAB+A\nmatches:\tAA `ABA` `ABBBBA` ABBCBA\nCase 4\nRegular Expression:\tAB{1,}A\nmatches:\tAA `ABA` `ABBBBA` ABBCBA\nCase 5\nRegular Expression:\tAB?A\nmatches:\t`AA` `ABA` ABBBBA ABBCBA\nCase 6\nRegular Expression:\tAB{0,1}A\nmatches:\t`AA` `ABA` ABBBBA ABBCBA\n* [example16 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example16.java)\n## 예제 17\n\n\nCase 1\nRegular Expression:\tr.*\nmatches:\tOne `ring to bring them all and in the darkness bind them`\nCase 2\n아래 같은경우 ?앞에 * 수량자가 나왔다. 원래 문자가 와야하는데 * 수량자가 왔다. 이렇게되면 앞에 * 수량자의 의미는 0으로 바뀐다. * 원래 의미가 0개 아니면 1개 혹은 그이상을 의미한다. ?가 앞에 오게되면 처음의미인 0을 의미한다. 그렇기 때문에 앞에 .*은 0개를 의미한다.\nRegular Expression:\tr.\\*\\?\nmatches:\tOne `r`ing to b`r`ing them all and in the da`r`kness bind them\nCase 3\nRegular Expression:\tr.+\nmatches:\tOne `ring to bring them all and in the darkness bind them`\nCase 4\n여기에서도 ?앞에 수량자가 나왔다. +는 1혹은 그이상의 단어를 의미하기 떄문에 첫 의미인 1을 가져와 r그리고 어떤 문자가 반드시 하나 있어야하면서\nRegular Expression:\tr.+?\nmatches:\tOne `ri`ng to b`ri`ng them all and in the da`rk`ness bind them\nCase 5\nRegular Expression:\tr.?\nmatches:\tOne `ri`ng to b`ri`ng them all and in the da`rk`ness bind them\nCase 6\n밑에서도 ?앞에 ? 가있는데 ?는 0아니면 1을의미하기때문에 앞에 의미인 0이 들어가 r만 매치된다.\nRegular Expression:\tr.??\nmatches:\tOne `r`ing to b`r`ing them all and in the da`r`kness bind them\n\nCase 7\nResgular Expression : \\<div>.+</div> \nmatches:`\\<div>test\\<div><div>test\\<div>`\nResgular Expression : \\<div>.+?\\</div> \nmatches:`\\<div>test\\<div>`<div>test\\<div> \n* [example17 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example17.java)\n## 예제 18\n\\w는  모든 문자('_')를 매치해준다. 단 특수문자는 제외한다.\n\nCase 1\nRegular Expression:\t\\w\nmatches:\t`A` `1`  `B` `2` `c` `3` `d` `_` `4` `e` : `5` `f` `f` `G` `G` `7` `7`--`_` `_`--\nCase 2\nRegular Expression:\t\\w+\nmatches:\t`A1` `B2` `c3` `d_4` `e`:`5` `ffGG77`--`__`--\nCase 3\nRegular Expression:\t[a-z]\\w*\nmatches:\tA1 B2 `c3` `d_4` `e`:5 `ffGG77`--__--\nCase 4\nRegular Expression:\t\\w{5}\nmatches:\tA1 B2 c3 d_4 e:5 `ffGG7`7--__--\nCase 5\nRegular Expression:\t[A-z0-9_]\nmatches:\t`A` `1`  `B` `2` `c` `3` `d` `_` `4` `e` : `5` `f` `f` `G` `G` `7` `7`--`_` `_`--\n\n* [example18 소스 보기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example18.java)\n## 예제 19\n?=문자를 제외하고 그앞에 선택한 문자들이 매치된다.\n\nCase 1\nRegular Expression:\t\\w+(?=X)\nmatches:\t`AAA`X---aaax---111\nCase 2\nRegular Expression:\t\\w+(?=\\w)\nmatches:\t`AAA`X---`aaa`x---111\n\n\n참고\n* [HighCode](http://highcode.tistory.com/6)\n* [자바 정규식 기본정리](http://blog.naver.com/PostView.nhn?blogId=bb_&logNo=220863282423&parentCategoryNo=&categoryNo=103&viewDate=&isShowPopularPosts=true&from=search)\n* [ZVON](http://zvon.org/comp/r/tut-Regexp.html#Pages~Contents)","slug":"2018-09-03-java-reg","published":1,"updated":"2018-09-22T16:15:45.029Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27e40031jjpecvfde8l0","content":"<h1><span id=\"정규식-정규표현식-regular-expressions-regex\">정규식 / 정규표현식 (Regular Expressions; Regex)</span></h1>\n<p>정규표현식은 문자열을 처리하는 방법 중의 하나로 특정한 조건의 문자를 '검색’하거나 '치환’하는 과정을 매우 간편하게 처리 할 수 있도록 하는 수단이다.</p>\n<h2><span id=\"대표적인-정규표현식\">대표적인 정규표현식</span></h2>\n<table>\n<thead>\n<tr>\n<th>표현식</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>^</td>\n<td>문자열의 시작 ([]대괄호 안에서는 부정을 의미한다.)</td>\n</tr>\n<tr>\n<td>$</td>\n<td>문자열의 종료</td>\n</tr>\n<tr>\n<td>.</td>\n<td>임의의 한 문자 (문자의 종류 가리지 않음)</td>\n</tr>\n<tr>\n<td>*</td>\n<td>앞 문자가 없을 수도 무한정 많을 수도 있음</td>\n</tr>\n<tr>\n<td>+</td>\n<td>앞 문자가 하나 이상</td>\n</tr>\n<tr>\n<td>?</td>\n<td>앞 문자가 없거나 하나있음</td>\n</tr>\n<tr>\n<td>[]</td>\n<td>문자의 집합이나 범위를 나타내며 두 문자 사이는 - 기호로 범위를 나타낸다. []내에서 ^가 선행하여 존재하면 not 을 나타낸다.</td>\n</tr>\n<tr>\n<td>{}</td>\n<td>횟수 또는 범위를 나타낸다.</td>\n</tr>\n<tr>\n<td>()</td>\n<td>소괄호 안의 문자를 하나의 문자로 인식</td>\n</tr>\n<tr>\n<td>|</td>\n<td>패턴 안에서 or 연산을 수행할 때 사용</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>공백 문자</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>공백 문자가 아닌 나머지 문자</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>알파벳이나 숫자 또는 _ 포함</td>\n</tr>\n<tr>\n<td>\\W</td>\n<td>알파벳이나 숫자를 제외한 문자</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>숫자 [0-9]와 동일</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>숫자를 제외한 모든 문자</td>\n</tr>\n<tr>\n<td>\\A</td>\n<td>맨 앞을 의미한다.</td>\n</tr>\n<tr>\n<td>\\A</td>\n<td>맨 뒤를 의미한다.</td>\n</tr>\n<tr>\n<td>\\</td>\n<td>“정규표현식 역슬래시()는 확장 문자 <br>역슬래시 다음에 일반 문자가 오면 특수문자로 취급하고 역슬래시 다음에 특수문자가 오면 그 문자 자체를 의미”</td>\n</tr>\n<tr>\n<td>(?i)</td>\n<td>앞 부분에 (?i) 라는 옵션을 넣어주면 대소문자를 구분하지 않음</td>\n</tr>\n</tbody>\n</table>\n<h2><span id=\"간단한-예제-분석-1\">간단한 예제 분석 1 .</span></h2>\n<p>예제의 <code>^[0-9]*$</code> 를 분석해보면</p>\n<blockquote>\n<p>^ 으로 우선 패턴의 시작을 알립니다.<br>\n[0-9] 괄호사이에 두 숫자를 넣어 범위를 지정해줄 수 있습니다.<br>\n* 를 넣으면 글자 수를 상관하지 않고 검사합니다.<br>\n$ 으로 패턴의 종료를 알립니다.</p>\n</blockquote>\n<h2><span id=\"간단한-예제-분석-2\">간단한 예제 분석 2.</span></h2>\n<ol>\n<li>숫자로 시작하는것 검색</li>\n</ol>\n<blockquote>\n<p>\\d+(숫자로시작하는것)</p>\n</blockquote>\n<ol start=\"2\">\n<li>문장안에서 날짜값 빼오기</li>\n</ol>\n<blockquote>\n<p>2018/7/3 테스트행 크크크를 손에 넣었다.<br>\n자동차를 탄다 18년06월13일 날에<br>\n\\d+.\\d+.\\d+ -&gt; 2018/7/3 , 18년06월13 잡힌다.</p>\n</blockquote>\n<h2><span id=\"간단한-예제-분석3\">간단한 예제 분석3.</span></h2>\n<ol>\n<li></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Pattern pattern = Pattern.compile(<span class=\"string\">\"\\d+.\\d+.\\d+\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">final</span> Matcher matcher = pattern.matcher(<span class=\"string\">\"2018/7/3 테스트행 크크크를 손에 넣었다. 2018/7/4\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(matcher.find())&#123; <span class=\"comment\">//find 안쓰고 바로 group뽑으려고하면 Exception남.</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String group = matcher.group();<span class=\"comment\">// 2018/7/3 </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> String group = matcher.group();<span class=\"comment\">// 2018/7/3 </span></span><br><span class=\"line\">matcher.find(); <span class=\"comment\">// find안하면 안바뀐다.</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> String group = matcher.group();<span class=\"comment\">// 2018/7/4</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>replace(패턴에 맞는 값을 새로운 값으로 치환)</li>\n</ol>\n<p>​</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">replaceRegEx</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    String target = <span class=\"string\">\"나는 2008년도에 입학했다.\"</span>;</span><br><span class=\"line\">    String regEx = <span class=\"string\">\"[0-9]\"</span>;</span><br><span class=\"line\">    Pattern pat = Pattern.compile(regEx);</span><br><span class=\"line\">  </span><br><span class=\"line\">    Matcher m = pat.matcher(target);</span><br><span class=\"line\">    String result = m.replaceAll(<span class=\"string\">\"2\"</span>); <span class=\"comment\">// 패턴과 일치할 경우 \"2\"로 변경</span></span><br><span class=\"line\">     </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"출력 : \"</span> + result);</span><br><span class=\"line\">    <span class=\"comment\">// 출력 : 나는 2222년도에 입학했다.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"예제-1\">예제 1</span></h2>\n<p><strong>대소문자를 구분한다.</strong></p>\n<p>Case 1<br>\nRegular Expression:\tHello<br>\nmatches:\t<code>Hello</code>, world!</p>\n<p>Case 2<br>\nRegular Expression:\thello<br>\nmatches:\tHello, world!</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example1.java\" target=\"_blank\" rel=\"noopener\">example1 소스 보기</a></li>\n</ul>\n<h2><span id=\"예제-2\">예제 2</span></h2>\n<p>공백, 스페이스, 탭을 고려해야한다.</p>\n<p>Case 1<br>\nRegular Expression:\tHello, world<br>\nmatches:\t<code>Hello, world</code>!<br>\nCase 2<br>\nRegular Expression:\tHello,    world<br>\nmatches:\tHello, world!</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example2.java\" target=\"_blank\" rel=\"noopener\">example2 소스 보기</a></li>\n</ul>\n<h2><span id=\"예제-3\">예제 3</span></h2>\n<p>^는 시작하는 문자열에 대해서 매치를 해준다.<br>\n$는 끝나는 문자열에 대해서 매치를 해준다.<br>\nCase 1<br>\nRegular Expression:\t^who<br>\nmatches:\t<code>who</code> is who<br>\nCase 2<br>\nRegular Expression:\twho$<br>\nmatches:\twho is <code>who</code></p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example3.java\" target=\"_blank\" rel=\"noopener\">example3 소스 보기</a></li>\n</ul>\n<h2><span id=\"예제-4\">예제 4</span></h2>\n<p>특수 문자 예를들어 위의 $같이 이런것에 정규 표현식을 정욕하려면 \\를 적용해야한다.</p>\n<p>Case 1<br>\nRegular Expression:\t^$<br>\nmatches:\t$12$ \\-\\ $25$</p>\n<p>Case 2<br>\nRegular Expression:\t\\\\$<br>\nmatches:\t<code>$</code>12<code>$</code> \\-\\ <code>$</code> 25 <code>$</code></p>\n<p>Case 3<br>\nRegular Expression:\t^\\\\$<br>\nmatches:\t<code>$</code>12$ \\-\\ $25$</p>\n<p>Case 4<br>\nRegular Expression:\t\\$$<br>\nmatches:\t$12$ \\-\\ $25<code>$</code></p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example4.java\" target=\"_blank\" rel=\"noopener\">example4 소스 보기</a></li>\n</ul>\n<h2><span id=\"예제-5\">예제 5</span></h2>\n<p>.은 어떤 문자든 정규 표현식에 해당 된다.</p>\n<p>Case 1<br>\nRegular Expression:\t.<br>\nmatches:\t<code>Regular expressions are powerful!!!</code></p>\n<p>Case 2<br>\n아래는 . 갯수대로 문자열 그룹을 묶는다. Regular, r expr 등 처럼 문자 갯수가 6개이면 그룹으로 묶고 아니면 해당 표현식에 해당하지 않는다. 그래서 ul!!!부분은 매치에 해당되지 않는다.</p>\n<p>Regular Expression:\t…<br>\nmatches:\t<code>Regular expressions are powerf</code>ul!!!</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example5.java\" target=\"_blank\" rel=\"noopener\">example5 소스 보기</a></li>\n</ul>\n<h2><span id=\"예제-6\">예제 6</span></h2>\n<p>정규표현식에서 문자 . 을 찾는다면 \\를 사용해야한다.</p>\n<p>Case 1<br>\nRegular Expression:\t\\.<br>\nmatches:\tO<code>.</code>K<code>.</code></p>\n<p>Case 2<br>\nRegular Expression:\t\\…\\.<br>\nmatches:\tO<code>.K.</code></p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example6.java\" target=\"_blank\" rel=\"noopener\">example6 소스 보기</a></li>\n</ul>\n<h2><span id=\"예제-7\">예제 7</span></h2>\n<p>[]안에 있는 문자중 하나라도 존재하면 매치가 된다.</p>\n<p>Case 1<br>\nRegular Expression:\t[oyu]<br>\nmatches:\tH<code>o</code>w d<code>o</code> <code>you</code> d<code>o</code>?</p>\n<p>Case 2<br>\nd또는H이면서 뒤에 문자가 하나 붙어있는것<br>\nRegular Expression:\t[dH].<br>\nmatches:\t<code>Ho</code>w <code>do</code> you <code>do</code>?</p>\n<p>Case 3<br>\n두개의 [][]에서 []에 들어잇는 문자열중 하나 &amp;&amp;(있으면서) 두번째 []에 문자열중 하나라도 있는경우<br>\nRegular Expression:\t[owy][yow]<br>\nmatches:\tH<code>ow</code> do <code>yo</code>u do?</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example7.java\" target=\"_blank\" rel=\"noopener\">example7 소스 보기</a></li>\n</ul>\n<h2><span id=\"예제-8\">예제 8</span></h2>\n<p>[]대괄호 사이에 문자에 범위를 넣으면 그 범위부분을 매치 해준다. 여기에서 주의할점은 문자하나하나가 매치된다. 예를들어 a-b이면 a,b 문자하나를 의미한다.</p>\n<p>Case 1<br>\nRegular Expression:\t[a-d]<br>\nmatches:\tABCDEFGHIJKLMNOPQRSTUVWXYZ <code>abcd</code>efghijklmnopqrstuvwxyz 0123456789</p>\n<p>Case 2<br>\nRegular Expression:\t[2-6]<br>\nmatches:\tABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 01<code>23456</code>789</p>\n<p>Case 3<br>\nC~K, a~d, 2~6의 범위를 매치해준다.<br>\nRegular Expression:\t[C-Ka-d2-6]<br>\nmatches:\tAB<code>CDEFGHIJK</code>LMNOPQRSTUVWXYZ <code>abcd</code>efghijklmnopqrstuvwxyz 01<code>23456</code>789</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example8.java\" target=\"_blank\" rel=\"noopener\">example8 소스 보기</a></li>\n</ul>\n<h2><span id=\"예제-9\">예제 9</span></h2>\n<p>[] 대괄호안에서 ^를 사용한다면 그 문자는 선택되지 않을것이다.</p>\n<p>Case 1<br>\nRegular Expression:\t[^CDghi45]<br>\nmatches:\t<code>AB</code>CD<code>EFGHIJKLMNOPQRSTUVWXYZ abcdef</code>ghi<code>jklmnopqrstuvwxyz 0123</code>45<code>6789</code><br>\nCase 2<br>\nRegular Expression:\t[^W-Z]<br>\nmatches:\t<code>ABCDEFGHIJKLMNOPQRSTUV</code>WXYZ<code>abcdefghijklmnopqrstuvwxyz 0123456789</code></p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example9.java\" target=\"_blank\" rel=\"noopener\">example9 소스 보기</a></li>\n</ul>\n<h2><span id=\"예제-10\">예제 10</span></h2>\n<p>소괄호로 문자들를 단어로 묶을수 있습니다. 그리고 | 를 이용하여 한문장에 여러개의 단어를 매치할 수 있습니다.</p>\n<p>Case 1<br>\nRegular Expression:\t(on|ues|rida)<br>\nmatches:\tM<code>on</code>day T<code>ues</code>day F<code>rida</code>y</p>\n<p>Case 2<br>\nRegular Expression:\t(Mon|Tues|Fri)day<br>\nmatches:\t<code>Monday</code> <code>Tuesday</code> <code>Friday</code></p>\n<p>Case 3<br>\nRegular Expression:\t…(id|esd|nd)ay<br>\nmatches:\t<code>Monday</code> <code>Tuesday</code> <code>Friday</code></p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example10.java\" target=\"_blank\" rel=\"noopener\">example10 소스 보기</a></li>\n</ul>\n<h2><span id=\"예제-11\">예제 11</span></h2>\n<p>* + ?<br>\n이수량주 문자는 얼마나 앞에 많은 문자열들이 존재가능할지를 나타낸다.</p>\n<p>Case 1</p>\n<ul>\n<li>을넣게되면 앞에에 문자가 있을수도있고 없을 수 도 있음<br>\nRegular Expression:\ta*b<br>\nmatches:\t<code>aab</code>c <code>ab</code>c <code>b</code>c ac<code>b</code></li>\n</ul>\n<p>Case 2</p>\n<ul>\n<li>앞에 문자를 두면 그 앞에 문자가 반드시 하나이상있어야 매치된다.<br>\nRegular Expression:\ta+b<br>\nmatches:\t<code>aab</code>c <code>ab</code>c bc</li>\n</ul>\n<p>Case 3<br>\n? 앞에 문자가 있으면 그 앞에 문자가 없거나 하나인 문자만 매치된다.<br>\nRegular Expression:\ta?b<br>\nmatches:\ta<code>ab</code>c <code>ab</code>c <code>b</code>c</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example11.java\" target=\"_blank\" rel=\"noopener\">example11 소스 보기</a></li>\n</ul>\n<h2><span id=\"예제-12\">예제 12</span></h2>\n<p>*를 사용한 예제.(앞에 문자가 무한정있거나 없을 수 있음.)</p>\n<p>Case 1 : <em>앞에 . 이 있으니 모든 텍스트를 매치한것이다.<br>\nRegular Expression:\t.</em><br>\nmatches:\t<code>-@- *** -- &quot;*&quot; -- *** -@-</code><br>\nCase 2</p>\n<p>Regular Expression:\t-A*-<br>\n<em>앞에 A가 있으니 있을수도있고 무한정 많을 수 도 있다는것을 의미한다. 아래의 문자열을 매치하면 아래와갘이 매치될것이다.<br>\nmatches:\t-@- *** <code>--</code> &quot;</em>&quot; <code>--</code> *** -@-</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example12.java\" target=\"_blank\" rel=\"noopener\">example12 소스 보기</a></li>\n</ul>\n<h2><span id=\"예제-13\">예제 13</span></h2>\n<p>+를 사용한 예제.(앞에 문자가 무조건 하나 이상 있어야한다.)</p>\n<p>Case 1<br>\n*이 앞에 하나이상 반드시 있어야한다.<br>\nRegular Expression:\t\\*+<br>\nmatches:\t-@@@- <code>*</code> <code>**</code> - - “<code>*</code>” – <code>*</code> <code>**</code> -@@@-</p>\n<p>Case 2<br>\nRegular Expression:\t-@±<br>\nmatches:\t<code>-@@@-</code> * ** - - “*” – * ** <code>-@@@-</code></p>\n<p>Case 3<br>\n공백을 제외하고 매치한다.<br>\nRegular Expression:\t[^ ]+<br>\nmatches:\t-@@@- * ** - - “*” – * ** -@@@-</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example13.java\" target=\"_blank\" rel=\"noopener\">example13 소스 보기</a></li>\n</ul>\n<h2><span id=\"예제-14\">예제 14</span></h2>\n<p>?를 사용한 예제(앞문자가 하나거있거나 없음.)<br>\nCase 1<br>\nRegular Expression:\t-X?XX?X<br>\nmatches:\t-<code>-XX</code>-@<code>-XX</code>-@@<code>-XX</code>-@@@<code>-XX</code>-@@@@<code>-XX</code>-@@-@@-<br>\nCase 2<br>\nRegular Expression:\t-@?@?@?-</p>\n<p>matches:\t--XX<code>-@-</code>XX<code>-@@-</code>XX<code>-@@@-</code>XX-@@@@-XX<code>-@@-</code>@@-<br>\nCase 3<br>\n@가맨뒤에 있으면서 앞에@가 있을수도있고 없을 수 도 있으면서 앞에는@아니면 매치된다.<br>\nRegular Expression:\t[^@]@?@<br>\nmatches:\t--XX<code>-@</code>-XX<code>-@@</code>-XX<code>-@@</code>@-XX<code>-@@</code>@@-XX<code>-@@</code> <code>-@@</code>-</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example14.java\" target=\"_blank\" rel=\"noopener\">example14 소스 보기</a></li>\n</ul>\n<h2><span id=\"예제-15\">예제 15</span></h2>\n<p>{} 중괄호안에 숫자들을 통해 매치해준다. 예를들어 {3} 이면 3글자씩, {3,5} 이면 3이상 5이하인 숫자를, {3,} 3글자이상을 의미한다.</p>\n<p>Case 1<br>\nRegular Expression:\t.{5}<br>\nmatches:\t<code>One r</code> <code>ing t</code> <code>o bri</code> <code>ng th</code> <code>em al</code> <code>l and</code> <code>in t</code> <code>he da</code> <code>rknes</code> <code>s bin</code> <code>d the</code>m<br>\nCase 2<br>\nRegular Expression:\t[els]{1,3}<br>\nmatches:\tOn<code>e</code> ring to bring th<code>e</code>m a<code>ll</code> and in th<code>e</code> darkn<code>ess</code> bind th<code>e</code>m<br>\nCase 3<br>\nRegular Expression:\t[a-z]{3,}<br>\nmatches:\tOne <code>ring</code> to <code>bring</code> <code>them</code> <code>all</code> <code>and</code> in <code>the</code> <code>darkness</code> <code>bind</code> <code>them</code></p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example15.java\" target=\"_blank\" rel=\"noopener\">example15 소스 보기</a></li>\n</ul>\n<h2><span id=\"예제-16\">예제 16</span></h2>\n<p>Case 1<br>\nRegular Expression:\tAB*A<br>\nmatches:\t<code>AA</code> <code>ABA</code> <code>ABBBBA</code> <code>ABBCBA</code><br>\nCase 2<br>\nRegular Expression:\tAB{0,}A<br>\nmatches:\t<code>AA</code> <code>ABA</code> <code>ABBBBA</code> ABBCBA<br>\nCase 3<br>\nRegular Expression:\tAB+A<br>\nmatches:\tAA <code>ABA</code> <code>ABBBBA</code> ABBCBA<br>\nCase 4<br>\nRegular Expression:\tAB{1,}A<br>\nmatches:\tAA <code>ABA</code> <code>ABBBBA</code> ABBCBA<br>\nCase 5<br>\nRegular Expression:\tAB?A<br>\nmatches:\t<code>AA</code> <code>ABA</code> ABBBBA ABBCBA<br>\nCase 6<br>\nRegular Expression:\tAB{0,1}A<br>\nmatches:\t<code>AA</code> <code>ABA</code> ABBBBA ABBCBA</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example16.java\" target=\"_blank\" rel=\"noopener\">example16 소스 보기</a></li>\n</ul>\n<h2><span id=\"예제-17\">예제 17</span></h2>\n<p>Case 1<br>\nRegular Expression:\tr.*<br>\nmatches:\tOne <code>ring to bring them all and in the darkness bind them</code><br>\nCase 2<br>\n아래 같은경우 ?앞에 * 수량자가 나왔다. 원래 문자가 와야하는데 * 수량자가 왔다. 이렇게되면 앞에 * 수량자의 의미는 0으로 바뀐다. * 원래 의미가 0개 아니면 1개 혹은 그이상을 의미한다. ?가 앞에 오게되면 처음의미인 0을 의미한다. 그렇기 때문에 앞에 .*은 0개를 의미한다.<br>\nRegular Expression:\tr.*?<br>\nmatches:\tOne <code>r</code>ing to b<code>r</code>ing them all and in the da<code>r</code>kness bind them<br>\nCase 3<br>\nRegular Expression:\tr.+<br>\nmatches:\tOne <code>ring to bring them all and in the darkness bind them</code><br>\nCase 4<br>\n여기에서도 ?앞에 수량자가 나왔다. +는 1혹은 그이상의 단어를 의미하기 떄문에 첫 의미인 1을 가져와 r그리고 어떤 문자가 반드시 하나 있어야하면서<br>\nRegular Expression:\tr.+?<br>\nmatches:\tOne <code>ri</code>ng to b<code>ri</code>ng them all and in the da<code>rk</code>ness bind them<br>\nCase 5<br>\nRegular Expression:\tr.?<br>\nmatches:\tOne <code>ri</code>ng to b<code>ri</code>ng them all and in the da<code>rk</code>ness bind them<br>\nCase 6<br>\n밑에서도 ?앞에 ? 가있는데 ?는 0아니면 1을의미하기때문에 앞에 의미인 0이 들어가 r만 매치된다.<br>\nRegular Expression:\tr.??<br>\nmatches:\tOne <code>r</code>ing to b<code>r</code>ing them all and in the da<code>r</code>kness bind them</p>\n<p>Case 7<br>\nResgular Expression : &lt;div&gt;.+<br>\nmatches:<code>\\&lt;div&gt;test\\&lt;div&gt;&lt;div&gt;test\\&lt;div&gt;</code><br>\nResgular Expression : &lt;div&gt;.+?&lt;/div&gt;<br>\nmatches:<code>\\&lt;div&gt;test\\&lt;div&gt;</code><div>test&lt;div&gt;</div></p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example17.java\" target=\"_blank\" rel=\"noopener\">example17 소스 보기</a></li>\n</ul>\n<h2><span id=\"예제-18\">예제 18</span></h2>\n<p>\\w는  모든 문자(’_’)를 매치해준다. 단 특수문자는 제외한다.</p>\n<p>Case 1<br>\nRegular Expression:\t\\w<br>\nmatches:\t<code>A</code> <code>1</code>  <code>B</code> <code>2</code> <code>c</code> <code>3</code> <code>d</code> <code>_</code> <code>4</code> <code>e</code> : <code>5</code> <code>f</code> <code>f</code> <code>G</code> <code>G</code> <code>7</code> <code>7</code>–<code>_</code> <code>_</code>–<br>\nCase 2<br>\nRegular Expression:\t\\w+<br>\nmatches:\t<code>A1</code> <code>B2</code> <code>c3</code> <code>d_4</code> <code>e</code>:<code>5</code> <code>ffGG77</code>–<code>__</code>–<br>\nCase 3<br>\nRegular Expression:\t[a-z]\\w*<br>\nmatches:\tA1 B2 <code>c3</code> <code>d_4</code> <code>e</code>:5 <code>ffGG77</code>–<strong>–<br>\nCase 4<br>\nRegular Expression:\t\\w{5}<br>\nmatches:\tA1 B2 c3 d_4 e:5 <code>ffGG7</code>7–</strong>–<br>\nCase 5<br>\nRegular Expression:\t[A-z0-9_]<br>\nmatches:\t<code>A</code> <code>1</code>  <code>B</code> <code>2</code> <code>c</code> <code>3</code> <code>d</code> <code>_</code> <code>4</code> <code>e</code> : <code>5</code> <code>f</code> <code>f</code> <code>G</code> <code>G</code> <code>7</code> <code>7</code>–<code>_</code> <code>_</code>–</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example18.java\" target=\"_blank\" rel=\"noopener\">example18 소스 보기</a></li>\n</ul>\n<h2><span id=\"예제-19\">예제 19</span></h2>\n<p>?=문자를 제외하고 그앞에 선택한 문자들이 매치된다.</p>\n<p>Case 1<br>\nRegular Expression:\t\\w+(?=X)<br>\nmatches:\t<code>AAA</code>X—aaax—111<br>\nCase 2<br>\nRegular Expression:\t\\w+(?=\\w)<br>\nmatches:\t<code>AAA</code>X—<code>aaa</code>x—111</p>\n<p>참고</p>\n<ul>\n<li><a href=\"http://highcode.tistory.com/6\" target=\"_blank\" rel=\"noopener\">HighCode</a></li>\n<li><a href=\"http://blog.naver.com/PostView.nhn?blogId=bb_&amp;logNo=220863282423&amp;parentCategoryNo=&amp;categoryNo=103&amp;viewDate=&amp;isShowPopularPosts=true&amp;from=search\" target=\"_blank\" rel=\"noopener\">자바 정규식 기본정리</a></li>\n<li><a href=\"http://zvon.org/comp/r/tut-Regexp.html#Pages~Contents\" target=\"_blank\" rel=\"noopener\">ZVON</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>정규식 / 정규표현식 (Regular Expressions; Regex)</h1>\n<p>정규표현식은 문자열을 처리하는 방법 중의 하나로 특정한 조건의 문자를 '검색’하거나 '치환’하는 과정을 매우 간편하게 처리 할 수 있도록 하는 수단이다.</p>\n<h2>대표적인 정규표현식</h2>\n<table>\n<thead>\n<tr>\n<th>표현식</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>^</td>\n<td>문자열의 시작 ([]대괄호 안에서는 부정을 의미한다.)</td>\n</tr>\n<tr>\n<td>$</td>\n<td>문자열의 종료</td>\n</tr>\n<tr>\n<td>.</td>\n<td>임의의 한 문자 (문자의 종류 가리지 않음)</td>\n</tr>\n<tr>\n<td>*</td>\n<td>앞 문자가 없을 수도 무한정 많을 수도 있음</td>\n</tr>\n<tr>\n<td>+</td>\n<td>앞 문자가 하나 이상</td>\n</tr>\n<tr>\n<td>?</td>\n<td>앞 문자가 없거나 하나있음</td>\n</tr>\n<tr>\n<td>[]</td>\n<td>문자의 집합이나 범위를 나타내며 두 문자 사이는 - 기호로 범위를 나타낸다. []내에서 ^가 선행하여 존재하면 not 을 나타낸다.</td>\n</tr>\n<tr>\n<td>{}</td>\n<td>횟수 또는 범위를 나타낸다.</td>\n</tr>\n<tr>\n<td>()</td>\n<td>소괄호 안의 문자를 하나의 문자로 인식</td>\n</tr>\n<tr>\n<td>|</td>\n<td>패턴 안에서 or 연산을 수행할 때 사용</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td>공백 문자</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td>공백 문자가 아닌 나머지 문자</td>\n</tr>\n<tr>\n<td>\\w</td>\n<td>알파벳이나 숫자 또는 _ 포함</td>\n</tr>\n<tr>\n<td>\\W</td>\n<td>알파벳이나 숫자를 제외한 문자</td>\n</tr>\n<tr>\n<td>\\d</td>\n<td>숫자 [0-9]와 동일</td>\n</tr>\n<tr>\n<td>\\D</td>\n<td>숫자를 제외한 모든 문자</td>\n</tr>\n<tr>\n<td>\\A</td>\n<td>맨 앞을 의미한다.</td>\n</tr>\n<tr>\n<td>\\A</td>\n<td>맨 뒤를 의미한다.</td>\n</tr>\n<tr>\n<td>\\</td>\n<td>“정규표현식 역슬래시()는 확장 문자 <br>역슬래시 다음에 일반 문자가 오면 특수문자로 취급하고 역슬래시 다음에 특수문자가 오면 그 문자 자체를 의미”</td>\n</tr>\n<tr>\n<td>(?i)</td>\n<td>앞 부분에 (?i) 라는 옵션을 넣어주면 대소문자를 구분하지 않음</td>\n</tr>\n</tbody>\n</table>\n<h2>간단한 예제 분석 1 .</h2>\n<p>예제의 <code>^[0-9]*$</code> 를 분석해보면</p>\n<blockquote>\n<p>^ 으로 우선 패턴의 시작을 알립니다.<br>\n[0-9] 괄호사이에 두 숫자를 넣어 범위를 지정해줄 수 있습니다.<br>\n* 를 넣으면 글자 수를 상관하지 않고 검사합니다.<br>\n$ 으로 패턴의 종료를 알립니다.</p>\n</blockquote>\n<h2>간단한 예제 분석 2.</h2>\n<ol>\n<li>숫자로 시작하는것 검색</li>\n</ol>\n<blockquote>\n<p>\\d+(숫자로시작하는것)</p>\n</blockquote>\n<ol start=\"2\">\n<li>문장안에서 날짜값 빼오기</li>\n</ol>\n<blockquote>\n<p>2018/7/3 테스트행 크크크를 손에 넣었다.<br>\n자동차를 탄다 18년06월13일 날에<br>\n\\d+.\\d+.\\d+ -&gt; 2018/7/3 , 18년06월13 잡힌다.</p>\n</blockquote>\n<h2>간단한 예제 분석3.</h2>\n<ol>\n<li></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Pattern pattern = Pattern.compile(<span class=\"string\">\"\\d+.\\d+.\\d+\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">final</span> Matcher matcher = pattern.matcher(<span class=\"string\">\"2018/7/3 테스트행 크크크를 손에 넣었다. 2018/7/4\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(matcher.find())&#123; <span class=\"comment\">//find 안쓰고 바로 group뽑으려고하면 Exception남.</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String group = matcher.group();<span class=\"comment\">// 2018/7/3 </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> String group = matcher.group();<span class=\"comment\">// 2018/7/3 </span></span><br><span class=\"line\">matcher.find(); <span class=\"comment\">// find안하면 안바뀐다.</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> String group = matcher.group();<span class=\"comment\">// 2018/7/4</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>replace(패턴에 맞는 값을 새로운 값으로 치환)</li>\n</ol>\n<p>​</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">replaceRegEx</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    String target = <span class=\"string\">\"나는 2008년도에 입학했다.\"</span>;</span><br><span class=\"line\">    String regEx = <span class=\"string\">\"[0-9]\"</span>;</span><br><span class=\"line\">    Pattern pat = Pattern.compile(regEx);</span><br><span class=\"line\">  </span><br><span class=\"line\">    Matcher m = pat.matcher(target);</span><br><span class=\"line\">    String result = m.replaceAll(<span class=\"string\">\"2\"</span>); <span class=\"comment\">// 패턴과 일치할 경우 \"2\"로 변경</span></span><br><span class=\"line\">     </span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"출력 : \"</span> + result);</span><br><span class=\"line\">    <span class=\"comment\">// 출력 : 나는 2222년도에 입학했다.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>예제 1</h2>\n<p><strong>대소문자를 구분한다.</strong></p>\n<p>Case 1<br>\nRegular Expression:\tHello<br>\nmatches:\t<code>Hello</code>, world!</p>\n<p>Case 2<br>\nRegular Expression:\thello<br>\nmatches:\tHello, world!</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example1.java\" target=\"_blank\" rel=\"noopener\">example1 소스 보기</a></li>\n</ul>\n<h2>예제 2</h2>\n<p>공백, 스페이스, 탭을 고려해야한다.</p>\n<p>Case 1<br>\nRegular Expression:\tHello, world<br>\nmatches:\t<code>Hello, world</code>!<br>\nCase 2<br>\nRegular Expression:\tHello,    world<br>\nmatches:\tHello, world!</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example2.java\" target=\"_blank\" rel=\"noopener\">example2 소스 보기</a></li>\n</ul>\n<h2>예제 3</h2>\n<p>^는 시작하는 문자열에 대해서 매치를 해준다.<br>\n$는 끝나는 문자열에 대해서 매치를 해준다.<br>\nCase 1<br>\nRegular Expression:\t^who<br>\nmatches:\t<code>who</code> is who<br>\nCase 2<br>\nRegular Expression:\twho$<br>\nmatches:\twho is <code>who</code></p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example3.java\" target=\"_blank\" rel=\"noopener\">example3 소스 보기</a></li>\n</ul>\n<h2>예제 4</h2>\n<p>특수 문자 예를들어 위의 $같이 이런것에 정규 표현식을 정욕하려면 \\를 적용해야한다.</p>\n<p>Case 1<br>\nRegular Expression:\t^$<br>\nmatches:\t$12$ \\-\\ $25$</p>\n<p>Case 2<br>\nRegular Expression:\t\\\\$<br>\nmatches:\t<code>$</code>12<code>$</code> \\-\\ <code>$</code> 25 <code>$</code></p>\n<p>Case 3<br>\nRegular Expression:\t^\\\\$<br>\nmatches:\t<code>$</code>12$ \\-\\ $25$</p>\n<p>Case 4<br>\nRegular Expression:\t\\$$<br>\nmatches:\t$12$ \\-\\ $25<code>$</code></p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example4.java\" target=\"_blank\" rel=\"noopener\">example4 소스 보기</a></li>\n</ul>\n<h2>예제 5</h2>\n<p>.은 어떤 문자든 정규 표현식에 해당 된다.</p>\n<p>Case 1<br>\nRegular Expression:\t.<br>\nmatches:\t<code>Regular expressions are powerful!!!</code></p>\n<p>Case 2<br>\n아래는 . 갯수대로 문자열 그룹을 묶는다. Regular, r expr 등 처럼 문자 갯수가 6개이면 그룹으로 묶고 아니면 해당 표현식에 해당하지 않는다. 그래서 ul!!!부분은 매치에 해당되지 않는다.</p>\n<p>Regular Expression:\t…<br>\nmatches:\t<code>Regular expressions are powerf</code>ul!!!</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example5.java\" target=\"_blank\" rel=\"noopener\">example5 소스 보기</a></li>\n</ul>\n<h2>예제 6</h2>\n<p>정규표현식에서 문자 . 을 찾는다면 \\를 사용해야한다.</p>\n<p>Case 1<br>\nRegular Expression:\t\\.<br>\nmatches:\tO<code>.</code>K<code>.</code></p>\n<p>Case 2<br>\nRegular Expression:\t\\…\\.<br>\nmatches:\tO<code>.K.</code></p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example6.java\" target=\"_blank\" rel=\"noopener\">example6 소스 보기</a></li>\n</ul>\n<h2>예제 7</h2>\n<p>[]안에 있는 문자중 하나라도 존재하면 매치가 된다.</p>\n<p>Case 1<br>\nRegular Expression:\t[oyu]<br>\nmatches:\tH<code>o</code>w d<code>o</code> <code>you</code> d<code>o</code>?</p>\n<p>Case 2<br>\nd또는H이면서 뒤에 문자가 하나 붙어있는것<br>\nRegular Expression:\t[dH].<br>\nmatches:\t<code>Ho</code>w <code>do</code> you <code>do</code>?</p>\n<p>Case 3<br>\n두개의 [][]에서 []에 들어잇는 문자열중 하나 &amp;&amp;(있으면서) 두번째 []에 문자열중 하나라도 있는경우<br>\nRegular Expression:\t[owy][yow]<br>\nmatches:\tH<code>ow</code> do <code>yo</code>u do?</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example7.java\" target=\"_blank\" rel=\"noopener\">example7 소스 보기</a></li>\n</ul>\n<h2>예제 8</h2>\n<p>[]대괄호 사이에 문자에 범위를 넣으면 그 범위부분을 매치 해준다. 여기에서 주의할점은 문자하나하나가 매치된다. 예를들어 a-b이면 a,b 문자하나를 의미한다.</p>\n<p>Case 1<br>\nRegular Expression:\t[a-d]<br>\nmatches:\tABCDEFGHIJKLMNOPQRSTUVWXYZ <code>abcd</code>efghijklmnopqrstuvwxyz 0123456789</p>\n<p>Case 2<br>\nRegular Expression:\t[2-6]<br>\nmatches:\tABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 01<code>23456</code>789</p>\n<p>Case 3<br>\nC~K, a~d, 2~6의 범위를 매치해준다.<br>\nRegular Expression:\t[C-Ka-d2-6]<br>\nmatches:\tAB<code>CDEFGHIJK</code>LMNOPQRSTUVWXYZ <code>abcd</code>efghijklmnopqrstuvwxyz 01<code>23456</code>789</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example8.java\" target=\"_blank\" rel=\"noopener\">example8 소스 보기</a></li>\n</ul>\n<h2>예제 9</h2>\n<p>[] 대괄호안에서 ^를 사용한다면 그 문자는 선택되지 않을것이다.</p>\n<p>Case 1<br>\nRegular Expression:\t[^CDghi45]<br>\nmatches:\t<code>AB</code>CD<code>EFGHIJKLMNOPQRSTUVWXYZ abcdef</code>ghi<code>jklmnopqrstuvwxyz 0123</code>45<code>6789</code><br>\nCase 2<br>\nRegular Expression:\t[^W-Z]<br>\nmatches:\t<code>ABCDEFGHIJKLMNOPQRSTUV</code>WXYZ<code>abcdefghijklmnopqrstuvwxyz 0123456789</code></p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example9.java\" target=\"_blank\" rel=\"noopener\">example9 소스 보기</a></li>\n</ul>\n<h2>예제 10</h2>\n<p>소괄호로 문자들를 단어로 묶을수 있습니다. 그리고 | 를 이용하여 한문장에 여러개의 단어를 매치할 수 있습니다.</p>\n<p>Case 1<br>\nRegular Expression:\t(on|ues|rida)<br>\nmatches:\tM<code>on</code>day T<code>ues</code>day F<code>rida</code>y</p>\n<p>Case 2<br>\nRegular Expression:\t(Mon|Tues|Fri)day<br>\nmatches:\t<code>Monday</code> <code>Tuesday</code> <code>Friday</code></p>\n<p>Case 3<br>\nRegular Expression:\t…(id|esd|nd)ay<br>\nmatches:\t<code>Monday</code> <code>Tuesday</code> <code>Friday</code></p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example10.java\" target=\"_blank\" rel=\"noopener\">example10 소스 보기</a></li>\n</ul>\n<h2>예제 11</h2>\n<p>* + ?<br>\n이수량주 문자는 얼마나 앞에 많은 문자열들이 존재가능할지를 나타낸다.</p>\n<p>Case 1</p>\n<ul>\n<li>을넣게되면 앞에에 문자가 있을수도있고 없을 수 도 있음<br>\nRegular Expression:\ta*b<br>\nmatches:\t<code>aab</code>c <code>ab</code>c <code>b</code>c ac<code>b</code></li>\n</ul>\n<p>Case 2</p>\n<ul>\n<li>앞에 문자를 두면 그 앞에 문자가 반드시 하나이상있어야 매치된다.<br>\nRegular Expression:\ta+b<br>\nmatches:\t<code>aab</code>c <code>ab</code>c bc</li>\n</ul>\n<p>Case 3<br>\n? 앞에 문자가 있으면 그 앞에 문자가 없거나 하나인 문자만 매치된다.<br>\nRegular Expression:\ta?b<br>\nmatches:\ta<code>ab</code>c <code>ab</code>c <code>b</code>c</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example11.java\" target=\"_blank\" rel=\"noopener\">example11 소스 보기</a></li>\n</ul>\n<h2>예제 12</h2>\n<p>*를 사용한 예제.(앞에 문자가 무한정있거나 없을 수 있음.)</p>\n<p>Case 1 : <em>앞에 . 이 있으니 모든 텍스트를 매치한것이다.<br>\nRegular Expression:\t.</em><br>\nmatches:\t<code>-@- *** -- &quot;*&quot; -- *** -@-</code><br>\nCase 2</p>\n<p>Regular Expression:\t-A*-<br>\n<em>앞에 A가 있으니 있을수도있고 무한정 많을 수 도 있다는것을 의미한다. 아래의 문자열을 매치하면 아래와갘이 매치될것이다.<br>\nmatches:\t-@- *** <code>--</code> &quot;</em>&quot; <code>--</code> *** -@-</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example12.java\" target=\"_blank\" rel=\"noopener\">example12 소스 보기</a></li>\n</ul>\n<h2>예제 13</h2>\n<p>+를 사용한 예제.(앞에 문자가 무조건 하나 이상 있어야한다.)</p>\n<p>Case 1<br>\n*이 앞에 하나이상 반드시 있어야한다.<br>\nRegular Expression:\t\\*+<br>\nmatches:\t-@@@- <code>*</code> <code>**</code> - - “<code>*</code>” – <code>*</code> <code>**</code> -@@@-</p>\n<p>Case 2<br>\nRegular Expression:\t-@±<br>\nmatches:\t<code>-@@@-</code> * ** - - “*” – * ** <code>-@@@-</code></p>\n<p>Case 3<br>\n공백을 제외하고 매치한다.<br>\nRegular Expression:\t[^ ]+<br>\nmatches:\t-@@@- * ** - - “*” – * ** -@@@-</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example13.java\" target=\"_blank\" rel=\"noopener\">example13 소스 보기</a></li>\n</ul>\n<h2>예제 14</h2>\n<p>?를 사용한 예제(앞문자가 하나거있거나 없음.)<br>\nCase 1<br>\nRegular Expression:\t-X?XX?X<br>\nmatches:\t-<code>-XX</code>-@<code>-XX</code>-@@<code>-XX</code>-@@@<code>-XX</code>-@@@@<code>-XX</code>-@@-@@-<br>\nCase 2<br>\nRegular Expression:\t-@?@?@?-</p>\n<p>matches:\t--XX<code>-@-</code>XX<code>-@@-</code>XX<code>-@@@-</code>XX-@@@@-XX<code>-@@-</code>@@-<br>\nCase 3<br>\n@가맨뒤에 있으면서 앞에@가 있을수도있고 없을 수 도 있으면서 앞에는@아니면 매치된다.<br>\nRegular Expression:\t[^@]@?@<br>\nmatches:\t--XX<code>-@</code>-XX<code>-@@</code>-XX<code>-@@</code>@-XX<code>-@@</code>@@-XX<code>-@@</code> <code>-@@</code>-</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example14.java\" target=\"_blank\" rel=\"noopener\">example14 소스 보기</a></li>\n</ul>\n<h2>예제 15</h2>\n<p>{} 중괄호안에 숫자들을 통해 매치해준다. 예를들어 {3} 이면 3글자씩, {3,5} 이면 3이상 5이하인 숫자를, {3,} 3글자이상을 의미한다.</p>\n<p>Case 1<br>\nRegular Expression:\t.{5}<br>\nmatches:\t<code>One r</code> <code>ing t</code> <code>o bri</code> <code>ng th</code> <code>em al</code> <code>l and</code> <code>in t</code> <code>he da</code> <code>rknes</code> <code>s bin</code> <code>d the</code>m<br>\nCase 2<br>\nRegular Expression:\t[els]{1,3}<br>\nmatches:\tOn<code>e</code> ring to bring th<code>e</code>m a<code>ll</code> and in th<code>e</code> darkn<code>ess</code> bind th<code>e</code>m<br>\nCase 3<br>\nRegular Expression:\t[a-z]{3,}<br>\nmatches:\tOne <code>ring</code> to <code>bring</code> <code>them</code> <code>all</code> <code>and</code> in <code>the</code> <code>darkness</code> <code>bind</code> <code>them</code></p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example15.java\" target=\"_blank\" rel=\"noopener\">example15 소스 보기</a></li>\n</ul>\n<h2>예제 16</h2>\n<p>Case 1<br>\nRegular Expression:\tAB*A<br>\nmatches:\t<code>AA</code> <code>ABA</code> <code>ABBBBA</code> <code>ABBCBA</code><br>\nCase 2<br>\nRegular Expression:\tAB{0,}A<br>\nmatches:\t<code>AA</code> <code>ABA</code> <code>ABBBBA</code> ABBCBA<br>\nCase 3<br>\nRegular Expression:\tAB+A<br>\nmatches:\tAA <code>ABA</code> <code>ABBBBA</code> ABBCBA<br>\nCase 4<br>\nRegular Expression:\tAB{1,}A<br>\nmatches:\tAA <code>ABA</code> <code>ABBBBA</code> ABBCBA<br>\nCase 5<br>\nRegular Expression:\tAB?A<br>\nmatches:\t<code>AA</code> <code>ABA</code> ABBBBA ABBCBA<br>\nCase 6<br>\nRegular Expression:\tAB{0,1}A<br>\nmatches:\t<code>AA</code> <code>ABA</code> ABBBBA ABBCBA</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example16.java\" target=\"_blank\" rel=\"noopener\">example16 소스 보기</a></li>\n</ul>\n<h2>예제 17</h2>\n<p>Case 1<br>\nRegular Expression:\tr.*<br>\nmatches:\tOne <code>ring to bring them all and in the darkness bind them</code><br>\nCase 2<br>\n아래 같은경우 ?앞에 * 수량자가 나왔다. 원래 문자가 와야하는데 * 수량자가 왔다. 이렇게되면 앞에 * 수량자의 의미는 0으로 바뀐다. * 원래 의미가 0개 아니면 1개 혹은 그이상을 의미한다. ?가 앞에 오게되면 처음의미인 0을 의미한다. 그렇기 때문에 앞에 .*은 0개를 의미한다.<br>\nRegular Expression:\tr.*?<br>\nmatches:\tOne <code>r</code>ing to b<code>r</code>ing them all and in the da<code>r</code>kness bind them<br>\nCase 3<br>\nRegular Expression:\tr.+<br>\nmatches:\tOne <code>ring to bring them all and in the darkness bind them</code><br>\nCase 4<br>\n여기에서도 ?앞에 수량자가 나왔다. +는 1혹은 그이상의 단어를 의미하기 떄문에 첫 의미인 1을 가져와 r그리고 어떤 문자가 반드시 하나 있어야하면서<br>\nRegular Expression:\tr.+?<br>\nmatches:\tOne <code>ri</code>ng to b<code>ri</code>ng them all and in the da<code>rk</code>ness bind them<br>\nCase 5<br>\nRegular Expression:\tr.?<br>\nmatches:\tOne <code>ri</code>ng to b<code>ri</code>ng them all and in the da<code>rk</code>ness bind them<br>\nCase 6<br>\n밑에서도 ?앞에 ? 가있는데 ?는 0아니면 1을의미하기때문에 앞에 의미인 0이 들어가 r만 매치된다.<br>\nRegular Expression:\tr.??<br>\nmatches:\tOne <code>r</code>ing to b<code>r</code>ing them all and in the da<code>r</code>kness bind them</p>\n<p>Case 7<br>\nResgular Expression : &lt;div&gt;.+<br>\nmatches:<code>\\&lt;div&gt;test\\&lt;div&gt;&lt;div&gt;test\\&lt;div&gt;</code><br>\nResgular Expression : &lt;div&gt;.+?&lt;/div&gt;<br>\nmatches:<code>\\&lt;div&gt;test\\&lt;div&gt;</code><div>test&lt;div&gt;</div></p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example17.java\" target=\"_blank\" rel=\"noopener\">example17 소스 보기</a></li>\n</ul>\n<h2>예제 18</h2>\n<p>\\w는  모든 문자(’_’)를 매치해준다. 단 특수문자는 제외한다.</p>\n<p>Case 1<br>\nRegular Expression:\t\\w<br>\nmatches:\t<code>A</code> <code>1</code>  <code>B</code> <code>2</code> <code>c</code> <code>3</code> <code>d</code> <code>_</code> <code>4</code> <code>e</code> : <code>5</code> <code>f</code> <code>f</code> <code>G</code> <code>G</code> <code>7</code> <code>7</code>–<code>_</code> <code>_</code>–<br>\nCase 2<br>\nRegular Expression:\t\\w+<br>\nmatches:\t<code>A1</code> <code>B2</code> <code>c3</code> <code>d_4</code> <code>e</code>:<code>5</code> <code>ffGG77</code>–<code>__</code>–<br>\nCase 3<br>\nRegular Expression:\t[a-z]\\w*<br>\nmatches:\tA1 B2 <code>c3</code> <code>d_4</code> <code>e</code>:5 <code>ffGG77</code>–<strong>–<br>\nCase 4<br>\nRegular Expression:\t\\w{5}<br>\nmatches:\tA1 B2 c3 d_4 e:5 <code>ffGG7</code>7–</strong>–<br>\nCase 5<br>\nRegular Expression:\t[A-z0-9_]<br>\nmatches:\t<code>A</code> <code>1</code>  <code>B</code> <code>2</code> <code>c</code> <code>3</code> <code>d</code> <code>_</code> <code>4</code> <code>e</code> : <code>5</code> <code>f</code> <code>f</code> <code>G</code> <code>G</code> <code>7</code> <code>7</code>–<code>_</code> <code>_</code>–</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/reg/Example18.java\" target=\"_blank\" rel=\"noopener\">example18 소스 보기</a></li>\n</ul>\n<h2>예제 19</h2>\n<p>?=문자를 제외하고 그앞에 선택한 문자들이 매치된다.</p>\n<p>Case 1<br>\nRegular Expression:\t\\w+(?=X)<br>\nmatches:\t<code>AAA</code>X—aaax—111<br>\nCase 2<br>\nRegular Expression:\t\\w+(?=\\w)<br>\nmatches:\t<code>AAA</code>X—<code>aaa</code>x—111</p>\n<p>참고</p>\n<ul>\n<li><a href=\"http://highcode.tistory.com/6\" target=\"_blank\" rel=\"noopener\">HighCode</a></li>\n<li><a href=\"http://blog.naver.com/PostView.nhn?blogId=bb_&amp;logNo=220863282423&amp;parentCategoryNo=&amp;categoryNo=103&amp;viewDate=&amp;isShowPopularPosts=true&amp;from=search\" target=\"_blank\" rel=\"noopener\">자바 정규식 기본정리</a></li>\n<li><a href=\"http://zvon.org/comp/r/tut-Regexp.html#Pages~Contents\" target=\"_blank\" rel=\"noopener\">ZVON</a></li>\n</ul>\n"},{"title":"서블릿 컨테이너, 스프링부트 동작 과정","catalog":true,"date":"2018-11-20T15:00:00.000Z","subtitle":"서블릿 컨테이너, 스프링부트 동작 과정","header-img":null,"_content":"\n\n# 서블릿 컨테이너, 스프링부트 동작 과정\n<!-- TOC -->\n\n- [서블릿 컨테이너, 스프링부트 동작 과정](#서블릿-컨테이너-스프링부트-동작-과정)\n    - [서블릿 컨테이너](#서블릿-컨테이너)\n    - [서블릿 구현](#서블릿-구현)\n        - [Servlet](#servlet)\n        - [GenericServlet](#genericservlet)\n        - [HttpServlet](#httpservlet)\n        - [서블릿 실행순서](#서블릿-실행순서)\n    - [Spring boot와 Servlet](#spring-boot와-servlet)\n        - [스프링 부트 실행과정](#스프링-부트-실행과정)\n        - [클라이언트 요청으로부터 DispatchServlet의 전체 흐름](#클라이언트-요청으로부터-dispatchservlet의-전체-흐름)\n            - [Application context](#application-context)\n\n<!-- /TOC -->\n톰켓 즉 서블릿 컨테이너에 의해 개발자가 정의한 프로그램들이 실행되고, 더 나아가 스프링 부트는 어떻게 실행될까 해서 글을 정리하게 되었습니다.\n\n# 서블릿 컨테이너\n먼저 서블릿컨테이너를 정의하면 다음과 같을 수 있다. 서블릿 컨테이너는 웹 애플리케이션 서버중에서 HTTP 요청을 받아 처리하는 기초 역할을 맡고 있다. 대부분의 웹 프레임워크가 제공하는 기능은 서블릿 컨테이너 위에서 동작하는 서블릿, 필터, 이벤트 리스너등을 적절하게 구현한 것이다. 따라서 사용자가 웹 프레임워크로 작성한 웹애플리케이션은 결국 서블릿 컨테이너 위에서 동작한다. 서블릿컨테이너의 종류로는 아파치 톰켓, 제티등이 서블릿 컨테이너로 현재 널리사용 된다.\n\n# 서블릿 구현\n먼저 톰캣 즉 서블릿 컨테이너에 의해 프로그램이 실행되기 위해서는 표준 즉 Servlet interface를 구현해줘야 한다.**사용자 정의 서블릿은 서블릿 컨테이너 내에 등록된 후 서블릿 컨테이너에 의해 생성, 호출, 소멸이 이루어진다.**\n\n\n\n때로는 서블릿은 자신의 상태 변경 시점을 알아내 적절한 리소스 획득/ 반환 등의 처리를 해야 하므로 Servlet 인터페이스에 int/destroy 메서드가 정의됩니다. 다시 말해 서블릿 컨테이너는 서블릿의 생명주기에 따라 서블릿의 상태를 변경하면서 서블릿 인터페이스에 정의된 각 메서드를 불러준다.\n\n`HTTP 프로토콜`로 전달된 메시지는 서블릿 컨테이너에서 해석되고 재조합돼 웹프로그래머가 작성한 서블릿으로 전달되는 과정을 거친다. \n\n## Servlet\nServlet은 서블릿 프로그램을 개발할 때 반드시 구현해야 하는 메서드를 선언하고 있는 인터페이스이다. 이 표준을 구현해야 서블릿 컨테이너가 해당 서블릿을 실행할 수 있다.\n\n## GenericServlet\nGenericServlet은 Servelet 인터페이스를 상속하여 클라이언트 - 서버 환경에서 서버단의 애플리케이션으로서 필요한 기능을 구현한 추상 클래스이다. service() 메서드를 제외 한 모든 메서드를 재정의하여 적절한 기능으로 구현했다. GenericServlet 클래스를 상속하면 애플리케이션의 프로토콜에 따라 메서드 재정의 구문을 적용해야 한다.\n\n## HttpServlet\n일반적으로 서블릿이라하면 거의 대부분 HttpServlet을 상속받은 서블릿을 의미한다. HttpServlet은 `GenericServlet`을 상속받았으며, GenericServlet의 유일한 추상 메서드인 service를 HTTP 프로토콜 요청 메서드에 적합하게 재구현해놨다.\n\n이미 DELETE, GET, HEAD, OPTIONS, POST, PUT, TRAC를 처리하는 메소드가 모두 정의되어 있다.\n\n\n## 서블릿 실행순서\n서블릿의 실행 순서는 개발자가 관리하는 게 아닌 서블릿 컨테이너가 관리를 한다. 즉 서블릿에 의해 사용자가 정의한 서블릿 객체가 생성되고 호출되고 사라진다. 즉 이렇게 개발자가 아닌 프로그램에 의해 객체들이 관리되는 것을 Ioc(Inversion of Control)이라고 한다.\n\n다음은 서블릿 컨테이너의 생명주기를 도식화한것이다. \n![](https://i.imgur.com/pQLeJ9z.jpg)\n\n* 서블릿 컨테이너는 클라이언트로 부터 처음 요청이 들어오면 현재 실행할 서블릿이 최초의 요청인지 판단하고 없으면 해당 서블릿을 새로 생성한다. 이작업은 최초 1회만 일어난다.\n* init() 메소드는 해당 사용자 서블릿이 최초 생성되고 바로 호출되는 메소드이다.\n* service() 메소드는 최초의 요청이든 2번쨰 요청이든 계속 호출되는 메소드이다.\n\n>여기에서 서블릿컨테이너가 종료된다면 사용자 정의 HttpServlet의 destroy() 메소드가 호출될것이다.\n\n다음은 HttpServlet의 구현체 내부이다.\n\n```java\n\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String protocol = req.getProtocol();\n        String msg = lStrings.getString(\"http.method_get_not_supported\");\n        if (protocol.endsWith(\"1.1\")) {\n            resp.sendError(405, msg);\n        } else {\n            resp.sendError(400, msg);\n        }\n\n}\n...//post, put 등등에 메소드가 존재함.\n\nprotected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String method = req.getMethod();\n        long lastModified;\n        if (method.equals(\"GET\")) {\n            lastModified = this.getLastModified(req);\n            if (lastModified == -1L) {\n                this.doGet(req, resp);\n            } else {\n                long ifModifiedSince;\n                try {\n                    ifModifiedSince = req.getDateHeader(\"If-Modified-Since\");\n                } catch (IllegalArgumentException var9) {\n                    ifModifiedSince = -1L;\n                }\n\n                if (ifModifiedSince < lastModified / 1000L * 1000L) {\n                    this.maybeSetLastModified(resp, lastModified);\n                    this.doGet(req, resp);\n                } else {\n                    resp.setStatus(304);\n                }\n            }\n        } else if (method.equals(\"HEAD\")) {\n            lastModified = this.getLastModified(req);\n            this.maybeSetLastModified(resp, lastModified);\n            this.doHead(req, resp);\n        } else if (method.equals(\"POST\")) {\n            this.doPost(req, resp);\n        } else if (method.equals(\"PUT\")) {\n            this.doPut(req, resp);\n        } else if (method.equals(\"DELETE\")) {\n            this.doDelete(req, resp);\n        } else if (method.equals(\"OPTIONS\")) {\n            this.doOptions(req, resp);\n        } else if (method.equals(\"TRACE\")) {\n            this.doTrace(req, resp);\n        } else {\n            String errMsg = lStrings.getString(\"http.method_not_implemented\");\n            Object[] errArgs = new Object[]{method};\n            errMsg = MessageFormat.format(errMsg, errArgs);\n            resp.sendError(501, errMsg);\n        }\n\n    }\n```\n\n위에서 설명한 Servlet들의 상속 구조는 다음과 같을 것이다. 개발자가 정의한 MemberServlet이 구현한 service를 서블릿 컨테이너가 실행할 것이다. 만약 service가 아닌 method 방식으로 처리하고 싶다면 해당 HTTP Method 방식을 구현하면 된다.\n\n![](https://i.imgur.com/NF8qy4D.jpg)\n\n위에서 말한 대로 개발자는 HttpServlet을 상속받고 HTTP Method에 맞게 서블릿을 구현해 기능을 구현할 수 있다. 그런데 여기에서 HTTPServlet을 상속하고 구현한 클래스들이 많을 텐데 어떻게 요청된 URL에 따라 각각에 서블릿으로 보내줄 수 있을까.\n\n답은 web.xml 또는 @WebServlet어노테이션이다. 서블릿2.5까지만해도 web.xml로만 제어가 가능했지만 3.0부터 어노테이션으로 클라이언트에 접근을 제어할 수 있게 되었다. 다음과 같이 URL에 맞게 서블릿을 매핑할 수 있다.\n\n```xml\n<servlet>\n    <servlet-name>member<servlet-name>\n    <servlet-class>com.wan.test.MemberServlet<servlet-class>\n</servlet>\n<Servlet-mapping>\n    <servlet-name>member</servlet-name>\n    <url-pattern>/member</url-pattern>\n</Servlet-mapping>\n```\n\n```java\n@WebServlet(\"/member\")\npublic class MemberServlet extends HttpServlet{\n    ...\n}\n```\n\n하지만 위에 방식대로 url마다 모두 매핑해서 사용해야 한다면 유지 보수, 확장성 등을 생각한다면 저러한 방법으로 개발을 계속 해나가는 것은 무모하다. 그래서 여기에서 한 단계 더 진보한 것 MVC 패턴이다. MVC 패턴은 모델(비즈니스로 직), 뷰(화면), Controller(최초 Request를 받는 곳)으로 나누고 개발을 하는 것이다.\n\n그럼 MVC 패턴에서는 어떻게 사용자 URL을 받는 것일까. 그것은 FrontController 패턴이다. FrontController 패턴은 모든 클라이언트에 요청을 최 앞단에 FrontController를 두고 각각에 컨트롤러에 매핑을 해주는 방식이다.\n\n모든 요청을 다음과같이 frontController로 넘긴다.\n```xml\n<servlet>\n    <servlet-name>front</servlet-name>\n    <servlet-class>com.wan.test.FrontController</servlet-class>\n</servlet>\n\n<servlet-name>front</servlet-name>\n<uri-pattern>*</uri-pattern>\n\n```\n\n\n그리고 다음과 같이 HttpServlet을 상속한 FrontController를 구현한다.\n```java\npublic class FrontController extends HttpServlet{\n    HashMap<String, Controller> controllerUrls = null;\n\n    @Override\n    public void init(ServletConfig sc) throws ServletException{\n        controllerUrls = new HashMap<String, Controller>();\n        controllerUrls.put(\"/memberInsert.do\", new MemberInsertController()));\n        controllerUrls.put(\"/memberDelete.do\", new MemberDeleteController()));\n    }\n\n    public void service(HttpServletRequest request, HttpServletResponse response){\n        String uri = request.getRequestURI();\n        Controller subController = controllerUrls.get(uri);\n        subController.execute(request, response);\n    }\n\n}\n\npublic interface Controller {\n    public void execute(HttpServletRequest, HttpServletResponse);\n}\n\npublic class MemberInsertController implements Controller{\n\n    public void execute(HttpServletRequest, HttpServletResponse){\n        //...\n    }\n}\n...\n```\n\nFrontController는 이제 요청되어진 URI에 따라 등록되어진 Contrller를 실행할것이다. 컨트롤러는 그뒤에 서비스, 레파지토리를 실행하고 최종적으로 뷰를 화면에 그리게 될것이다.\n\n\n# Spring boot와 Servlet\nSpring boot는 내부적으로 내장 톰켓을 가지고 있다. 즉 스프링 부트가 실행되면서 내부적으로 내장톰켓 즉 서블릿 컨테이너가 실행된다. 스프링 부트에서 사용자 정의 프로그램를 구현한 프로그램인 서블릿은 DispatchServlet이다. 스프링부트에서 DispatchServlet이 FrontController 역할을 한다.\n\n스프링 부트에 DispatchServlet의 상속 구조이다.\n\n\n![](https://i.imgur.com/hIBT4mn.jpg)\n\n\n## 스프링 부트 실행과정\nSpring boot는 ServletContainerInitializer를 구현한 TomcatStarter의 onStartup 메소드를 먼저 실행한다. 톰켓이 실행되고 다음 조건이 만족하면 디스팻처 서블릿이 등록 되어진다.\n\nDispatcherServletAutoConfiguration.clas에 구성되어져있는 DispatchServlet 빈 등록으로 자동 등록되어진다. 다음은 해당 소스 내용이다.\n\n```java\norg.springframework.boot.autoconfigure.web;\nDispatcherServletAutoConfiguration.class\n@Configuration\n@Conditional({DispatcherServletAutoConfiguration.DefaultDispatcherServletCondition.class})\n@ConditionalOnClass({ServletRegistration.class})\n@EnableConfigurationProperties({WebMvcProperties.class})\nprotected static class DispatcherServletConfiguration {\n        @Bean(\n            name = {\"dispatcherServlet\"}\n        )\n        public DispatcherServlet dispatcherServlet() {\n            DispatcherServlet dispatcherServlet = new DispatcherServlet();\n            dispatcherServlet.setDispatchOptionsRequest(this.webMvcProperties.isDispatchOptionsRequest());\n            dispatcherServlet.setDispatchTraceRequest(this.webMvcProperties.isDispatchTraceRequest());\n            dispatcherServlet.setThrowExceptionIfNoHandlerFound(this.webMvcProperties.isThrowExceptionIfNoHandlerFound());\n            return dispatcherServlet;\n        }\n}\n```\n\n* 디스팻처 서블릿이 스프링에 빈으로 등록되어진다.\n* 서블릿 컨테이너(디스팻처서블릿) 컨텍스트에 서블릿을등록한다.\n* 서블릿 컨테이너 필터에 등록설정 해놓은 필터들을 등록한다.\n* 디스팻처서블릿에 각종 핸들러 매핑(자원 URL)들이 등록 한다.(컨트롤러 빈들이 다 생성되어 싱글톤으로 관리되어진다.)\n\n\n\n![](https://i.imgur.com/CvVBmhQ.png)\n\n\n\n\n## 클라이언트 요청으로부터 DispatchServlet의 전체 흐름\nFrameworkServlet은 HttpServlet를 상속하고 있다. DispatcherServlet은 FrameworkServlet를 상속하고 있다. 이말은 즉슨 DispatcherServlet이 FrontController라는것이다. 다음은 요청후 실행 순서를 설명한것이다. \n**여기에서 주의할점은 서블릿컨테이너처럼 요청이왔을때 객체를 생성하는게 아닌 이미 컨트롤러들이 빈으로 등록되어져 있다는것을 생각해야한다.**\n\n* FrameworkServlet.service()를 먼저 탄다.\n* FrameworkServlet.service()는 dispatch.doService()를 호출한다.\n* dispatch.doService()는 dispatch.doDispatch()를 실행한다.\n    * doDispatch는 AbstractHandlerMapping매핑에서 핸들러(컨틀롤러)를 가져온다.\n    * 인터셉트 등을 지나서 해당 컨트롤러 메소드로 이동한다\u001c.\n    * 해당 핸들러는 MV를 리턴한다.\n    * @Restoroller 컨트롤 같은경우 컨버터를 이용해 바로 결과값을 리턴한다.\n    * 만약 view에 대한 정보가 있으면 viewresolver에 들려 뷰객체를 얻는다.\n    * 뷰를 통해 렌더링을한다.\n\n\n도식화한다면 다음과 같을 수 있다.\n\n\n\n![](https://i.imgur.com/BJUx5fJ.jpg)\n\n\n\n\n## Application context\n\n여기에서 Dispatcher 서블릿이 생성되면서 주의할 점이 하나 있다. 디스패처 서블릿이 생성되면서 WebapplicationContext가 생성된다. 하나는 dispatch에 의해 생성되는 WebApplicationContext 그리고 스프링에 ContextLoader에 의해 생성되는 Root WebapplicationContext가 있다. 이 둘은 부모 자식 관계이다. 구조는 아래와 같을 수 있다.\n\n그러면 최종적으로 아래와 같은 구조로 스프링이 돌아가게 된다.\n\n![](https://i.imgur.com/VGR5aQx.png)\n\n위와같이 구성이유는 2개이상의 DispatchServlet을 등록을하게 되면 RootWebApplicationContext를 공유하기위해서 사용할 수 있다.\n\n```java\npublic class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return new Class<?>[] { RootConfig.class };\n    }\n\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class<?>[] { App1Config.class };\n    }\n\n    @Override\n    protected String[] getServletMappings() {\n        return new String[] { \"/app1/*\" };\n    }\n}\n```\n\n참고\n\n* [처음 해보는 Servlet & JSP 웹 프로그래밍](http://www.yes24.com/24/Goods/37235901?Acode=101)\n* [https://docs.spring.io/](https://docs.spring.io/)\n* [스프링 부트로 배우는 자바 웹 개발](http://www.yes24.com/24/goods/61793313)\n","source":"_posts/2018-11-21-jsp-springboot-동작과정.md","raw":"---\ntitle: 서블릿 컨테이너, 스프링부트 동작 과정\ncatalog: true\ndate: 2018-11-21\nsubtitle: 서블릿 컨테이너, 스프링부트 동작 과정\nheader-img:\ntags:\n- Java\n- Spring\n\n\n\n---\n\n\n# 서블릿 컨테이너, 스프링부트 동작 과정\n<!-- TOC -->\n\n- [서블릿 컨테이너, 스프링부트 동작 과정](#서블릿-컨테이너-스프링부트-동작-과정)\n    - [서블릿 컨테이너](#서블릿-컨테이너)\n    - [서블릿 구현](#서블릿-구현)\n        - [Servlet](#servlet)\n        - [GenericServlet](#genericservlet)\n        - [HttpServlet](#httpservlet)\n        - [서블릿 실행순서](#서블릿-실행순서)\n    - [Spring boot와 Servlet](#spring-boot와-servlet)\n        - [스프링 부트 실행과정](#스프링-부트-실행과정)\n        - [클라이언트 요청으로부터 DispatchServlet의 전체 흐름](#클라이언트-요청으로부터-dispatchservlet의-전체-흐름)\n            - [Application context](#application-context)\n\n<!-- /TOC -->\n톰켓 즉 서블릿 컨테이너에 의해 개발자가 정의한 프로그램들이 실행되고, 더 나아가 스프링 부트는 어떻게 실행될까 해서 글을 정리하게 되었습니다.\n\n# 서블릿 컨테이너\n먼저 서블릿컨테이너를 정의하면 다음과 같을 수 있다. 서블릿 컨테이너는 웹 애플리케이션 서버중에서 HTTP 요청을 받아 처리하는 기초 역할을 맡고 있다. 대부분의 웹 프레임워크가 제공하는 기능은 서블릿 컨테이너 위에서 동작하는 서블릿, 필터, 이벤트 리스너등을 적절하게 구현한 것이다. 따라서 사용자가 웹 프레임워크로 작성한 웹애플리케이션은 결국 서블릿 컨테이너 위에서 동작한다. 서블릿컨테이너의 종류로는 아파치 톰켓, 제티등이 서블릿 컨테이너로 현재 널리사용 된다.\n\n# 서블릿 구현\n먼저 톰캣 즉 서블릿 컨테이너에 의해 프로그램이 실행되기 위해서는 표준 즉 Servlet interface를 구현해줘야 한다.**사용자 정의 서블릿은 서블릿 컨테이너 내에 등록된 후 서블릿 컨테이너에 의해 생성, 호출, 소멸이 이루어진다.**\n\n\n\n때로는 서블릿은 자신의 상태 변경 시점을 알아내 적절한 리소스 획득/ 반환 등의 처리를 해야 하므로 Servlet 인터페이스에 int/destroy 메서드가 정의됩니다. 다시 말해 서블릿 컨테이너는 서블릿의 생명주기에 따라 서블릿의 상태를 변경하면서 서블릿 인터페이스에 정의된 각 메서드를 불러준다.\n\n`HTTP 프로토콜`로 전달된 메시지는 서블릿 컨테이너에서 해석되고 재조합돼 웹프로그래머가 작성한 서블릿으로 전달되는 과정을 거친다. \n\n## Servlet\nServlet은 서블릿 프로그램을 개발할 때 반드시 구현해야 하는 메서드를 선언하고 있는 인터페이스이다. 이 표준을 구현해야 서블릿 컨테이너가 해당 서블릿을 실행할 수 있다.\n\n## GenericServlet\nGenericServlet은 Servelet 인터페이스를 상속하여 클라이언트 - 서버 환경에서 서버단의 애플리케이션으로서 필요한 기능을 구현한 추상 클래스이다. service() 메서드를 제외 한 모든 메서드를 재정의하여 적절한 기능으로 구현했다. GenericServlet 클래스를 상속하면 애플리케이션의 프로토콜에 따라 메서드 재정의 구문을 적용해야 한다.\n\n## HttpServlet\n일반적으로 서블릿이라하면 거의 대부분 HttpServlet을 상속받은 서블릿을 의미한다. HttpServlet은 `GenericServlet`을 상속받았으며, GenericServlet의 유일한 추상 메서드인 service를 HTTP 프로토콜 요청 메서드에 적합하게 재구현해놨다.\n\n이미 DELETE, GET, HEAD, OPTIONS, POST, PUT, TRAC를 처리하는 메소드가 모두 정의되어 있다.\n\n\n## 서블릿 실행순서\n서블릿의 실행 순서는 개발자가 관리하는 게 아닌 서블릿 컨테이너가 관리를 한다. 즉 서블릿에 의해 사용자가 정의한 서블릿 객체가 생성되고 호출되고 사라진다. 즉 이렇게 개발자가 아닌 프로그램에 의해 객체들이 관리되는 것을 Ioc(Inversion of Control)이라고 한다.\n\n다음은 서블릿 컨테이너의 생명주기를 도식화한것이다. \n![](https://i.imgur.com/pQLeJ9z.jpg)\n\n* 서블릿 컨테이너는 클라이언트로 부터 처음 요청이 들어오면 현재 실행할 서블릿이 최초의 요청인지 판단하고 없으면 해당 서블릿을 새로 생성한다. 이작업은 최초 1회만 일어난다.\n* init() 메소드는 해당 사용자 서블릿이 최초 생성되고 바로 호출되는 메소드이다.\n* service() 메소드는 최초의 요청이든 2번쨰 요청이든 계속 호출되는 메소드이다.\n\n>여기에서 서블릿컨테이너가 종료된다면 사용자 정의 HttpServlet의 destroy() 메소드가 호출될것이다.\n\n다음은 HttpServlet의 구현체 내부이다.\n\n```java\n\nprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String protocol = req.getProtocol();\n        String msg = lStrings.getString(\"http.method_get_not_supported\");\n        if (protocol.endsWith(\"1.1\")) {\n            resp.sendError(405, msg);\n        } else {\n            resp.sendError(400, msg);\n        }\n\n}\n...//post, put 등등에 메소드가 존재함.\n\nprotected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String method = req.getMethod();\n        long lastModified;\n        if (method.equals(\"GET\")) {\n            lastModified = this.getLastModified(req);\n            if (lastModified == -1L) {\n                this.doGet(req, resp);\n            } else {\n                long ifModifiedSince;\n                try {\n                    ifModifiedSince = req.getDateHeader(\"If-Modified-Since\");\n                } catch (IllegalArgumentException var9) {\n                    ifModifiedSince = -1L;\n                }\n\n                if (ifModifiedSince < lastModified / 1000L * 1000L) {\n                    this.maybeSetLastModified(resp, lastModified);\n                    this.doGet(req, resp);\n                } else {\n                    resp.setStatus(304);\n                }\n            }\n        } else if (method.equals(\"HEAD\")) {\n            lastModified = this.getLastModified(req);\n            this.maybeSetLastModified(resp, lastModified);\n            this.doHead(req, resp);\n        } else if (method.equals(\"POST\")) {\n            this.doPost(req, resp);\n        } else if (method.equals(\"PUT\")) {\n            this.doPut(req, resp);\n        } else if (method.equals(\"DELETE\")) {\n            this.doDelete(req, resp);\n        } else if (method.equals(\"OPTIONS\")) {\n            this.doOptions(req, resp);\n        } else if (method.equals(\"TRACE\")) {\n            this.doTrace(req, resp);\n        } else {\n            String errMsg = lStrings.getString(\"http.method_not_implemented\");\n            Object[] errArgs = new Object[]{method};\n            errMsg = MessageFormat.format(errMsg, errArgs);\n            resp.sendError(501, errMsg);\n        }\n\n    }\n```\n\n위에서 설명한 Servlet들의 상속 구조는 다음과 같을 것이다. 개발자가 정의한 MemberServlet이 구현한 service를 서블릿 컨테이너가 실행할 것이다. 만약 service가 아닌 method 방식으로 처리하고 싶다면 해당 HTTP Method 방식을 구현하면 된다.\n\n![](https://i.imgur.com/NF8qy4D.jpg)\n\n위에서 말한 대로 개발자는 HttpServlet을 상속받고 HTTP Method에 맞게 서블릿을 구현해 기능을 구현할 수 있다. 그런데 여기에서 HTTPServlet을 상속하고 구현한 클래스들이 많을 텐데 어떻게 요청된 URL에 따라 각각에 서블릿으로 보내줄 수 있을까.\n\n답은 web.xml 또는 @WebServlet어노테이션이다. 서블릿2.5까지만해도 web.xml로만 제어가 가능했지만 3.0부터 어노테이션으로 클라이언트에 접근을 제어할 수 있게 되었다. 다음과 같이 URL에 맞게 서블릿을 매핑할 수 있다.\n\n```xml\n<servlet>\n    <servlet-name>member<servlet-name>\n    <servlet-class>com.wan.test.MemberServlet<servlet-class>\n</servlet>\n<Servlet-mapping>\n    <servlet-name>member</servlet-name>\n    <url-pattern>/member</url-pattern>\n</Servlet-mapping>\n```\n\n```java\n@WebServlet(\"/member\")\npublic class MemberServlet extends HttpServlet{\n    ...\n}\n```\n\n하지만 위에 방식대로 url마다 모두 매핑해서 사용해야 한다면 유지 보수, 확장성 등을 생각한다면 저러한 방법으로 개발을 계속 해나가는 것은 무모하다. 그래서 여기에서 한 단계 더 진보한 것 MVC 패턴이다. MVC 패턴은 모델(비즈니스로 직), 뷰(화면), Controller(최초 Request를 받는 곳)으로 나누고 개발을 하는 것이다.\n\n그럼 MVC 패턴에서는 어떻게 사용자 URL을 받는 것일까. 그것은 FrontController 패턴이다. FrontController 패턴은 모든 클라이언트에 요청을 최 앞단에 FrontController를 두고 각각에 컨트롤러에 매핑을 해주는 방식이다.\n\n모든 요청을 다음과같이 frontController로 넘긴다.\n```xml\n<servlet>\n    <servlet-name>front</servlet-name>\n    <servlet-class>com.wan.test.FrontController</servlet-class>\n</servlet>\n\n<servlet-name>front</servlet-name>\n<uri-pattern>*</uri-pattern>\n\n```\n\n\n그리고 다음과 같이 HttpServlet을 상속한 FrontController를 구현한다.\n```java\npublic class FrontController extends HttpServlet{\n    HashMap<String, Controller> controllerUrls = null;\n\n    @Override\n    public void init(ServletConfig sc) throws ServletException{\n        controllerUrls = new HashMap<String, Controller>();\n        controllerUrls.put(\"/memberInsert.do\", new MemberInsertController()));\n        controllerUrls.put(\"/memberDelete.do\", new MemberDeleteController()));\n    }\n\n    public void service(HttpServletRequest request, HttpServletResponse response){\n        String uri = request.getRequestURI();\n        Controller subController = controllerUrls.get(uri);\n        subController.execute(request, response);\n    }\n\n}\n\npublic interface Controller {\n    public void execute(HttpServletRequest, HttpServletResponse);\n}\n\npublic class MemberInsertController implements Controller{\n\n    public void execute(HttpServletRequest, HttpServletResponse){\n        //...\n    }\n}\n...\n```\n\nFrontController는 이제 요청되어진 URI에 따라 등록되어진 Contrller를 실행할것이다. 컨트롤러는 그뒤에 서비스, 레파지토리를 실행하고 최종적으로 뷰를 화면에 그리게 될것이다.\n\n\n# Spring boot와 Servlet\nSpring boot는 내부적으로 내장 톰켓을 가지고 있다. 즉 스프링 부트가 실행되면서 내부적으로 내장톰켓 즉 서블릿 컨테이너가 실행된다. 스프링 부트에서 사용자 정의 프로그램를 구현한 프로그램인 서블릿은 DispatchServlet이다. 스프링부트에서 DispatchServlet이 FrontController 역할을 한다.\n\n스프링 부트에 DispatchServlet의 상속 구조이다.\n\n\n![](https://i.imgur.com/hIBT4mn.jpg)\n\n\n## 스프링 부트 실행과정\nSpring boot는 ServletContainerInitializer를 구현한 TomcatStarter의 onStartup 메소드를 먼저 실행한다. 톰켓이 실행되고 다음 조건이 만족하면 디스팻처 서블릿이 등록 되어진다.\n\nDispatcherServletAutoConfiguration.clas에 구성되어져있는 DispatchServlet 빈 등록으로 자동 등록되어진다. 다음은 해당 소스 내용이다.\n\n```java\norg.springframework.boot.autoconfigure.web;\nDispatcherServletAutoConfiguration.class\n@Configuration\n@Conditional({DispatcherServletAutoConfiguration.DefaultDispatcherServletCondition.class})\n@ConditionalOnClass({ServletRegistration.class})\n@EnableConfigurationProperties({WebMvcProperties.class})\nprotected static class DispatcherServletConfiguration {\n        @Bean(\n            name = {\"dispatcherServlet\"}\n        )\n        public DispatcherServlet dispatcherServlet() {\n            DispatcherServlet dispatcherServlet = new DispatcherServlet();\n            dispatcherServlet.setDispatchOptionsRequest(this.webMvcProperties.isDispatchOptionsRequest());\n            dispatcherServlet.setDispatchTraceRequest(this.webMvcProperties.isDispatchTraceRequest());\n            dispatcherServlet.setThrowExceptionIfNoHandlerFound(this.webMvcProperties.isThrowExceptionIfNoHandlerFound());\n            return dispatcherServlet;\n        }\n}\n```\n\n* 디스팻처 서블릿이 스프링에 빈으로 등록되어진다.\n* 서블릿 컨테이너(디스팻처서블릿) 컨텍스트에 서블릿을등록한다.\n* 서블릿 컨테이너 필터에 등록설정 해놓은 필터들을 등록한다.\n* 디스팻처서블릿에 각종 핸들러 매핑(자원 URL)들이 등록 한다.(컨트롤러 빈들이 다 생성되어 싱글톤으로 관리되어진다.)\n\n\n\n![](https://i.imgur.com/CvVBmhQ.png)\n\n\n\n\n## 클라이언트 요청으로부터 DispatchServlet의 전체 흐름\nFrameworkServlet은 HttpServlet를 상속하고 있다. DispatcherServlet은 FrameworkServlet를 상속하고 있다. 이말은 즉슨 DispatcherServlet이 FrontController라는것이다. 다음은 요청후 실행 순서를 설명한것이다. \n**여기에서 주의할점은 서블릿컨테이너처럼 요청이왔을때 객체를 생성하는게 아닌 이미 컨트롤러들이 빈으로 등록되어져 있다는것을 생각해야한다.**\n\n* FrameworkServlet.service()를 먼저 탄다.\n* FrameworkServlet.service()는 dispatch.doService()를 호출한다.\n* dispatch.doService()는 dispatch.doDispatch()를 실행한다.\n    * doDispatch는 AbstractHandlerMapping매핑에서 핸들러(컨틀롤러)를 가져온다.\n    * 인터셉트 등을 지나서 해당 컨트롤러 메소드로 이동한다\u001c.\n    * 해당 핸들러는 MV를 리턴한다.\n    * @Restoroller 컨트롤 같은경우 컨버터를 이용해 바로 결과값을 리턴한다.\n    * 만약 view에 대한 정보가 있으면 viewresolver에 들려 뷰객체를 얻는다.\n    * 뷰를 통해 렌더링을한다.\n\n\n도식화한다면 다음과 같을 수 있다.\n\n\n\n![](https://i.imgur.com/BJUx5fJ.jpg)\n\n\n\n\n## Application context\n\n여기에서 Dispatcher 서블릿이 생성되면서 주의할 점이 하나 있다. 디스패처 서블릿이 생성되면서 WebapplicationContext가 생성된다. 하나는 dispatch에 의해 생성되는 WebApplicationContext 그리고 스프링에 ContextLoader에 의해 생성되는 Root WebapplicationContext가 있다. 이 둘은 부모 자식 관계이다. 구조는 아래와 같을 수 있다.\n\n그러면 최종적으로 아래와 같은 구조로 스프링이 돌아가게 된다.\n\n![](https://i.imgur.com/VGR5aQx.png)\n\n위와같이 구성이유는 2개이상의 DispatchServlet을 등록을하게 되면 RootWebApplicationContext를 공유하기위해서 사용할 수 있다.\n\n```java\npublic class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    @Override\n    protected Class<?>[] getRootConfigClasses() {\n        return new Class<?>[] { RootConfig.class };\n    }\n\n    @Override\n    protected Class<?>[] getServletConfigClasses() {\n        return new Class<?>[] { App1Config.class };\n    }\n\n    @Override\n    protected String[] getServletMappings() {\n        return new String[] { \"/app1/*\" };\n    }\n}\n```\n\n참고\n\n* [처음 해보는 Servlet & JSP 웹 프로그래밍](http://www.yes24.com/24/Goods/37235901?Acode=101)\n* [https://docs.spring.io/](https://docs.spring.io/)\n* [스프링 부트로 배우는 자바 웹 개발](http://www.yes24.com/24/goods/61793313)\n","slug":"2018-11-21-jsp-springboot-동작과정","published":1,"updated":"2018-12-25T15:44:30.217Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27e60033jjpe50xsebgl","content":"<h1><span id=\"서블릿-컨테이너-스프링부트-동작-과정\">서블릿 컨테이너, 스프링부트 동작 과정</span></h1>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%EC%84%9C%EB%B8%94%EB%A6%BF-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">서블릿 컨테이너, 스프링부트 동작 과정</a>\n<ul>\n<li><a href=\"#%EC%84%9C%EB%B8%94%EB%A6%BF-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88\">서블릿 컨테이너</a></li>\n<li><a href=\"#%EC%84%9C%EB%B8%94%EB%A6%BF-%EA%B5%AC%ED%98%84\">서블릿 구현</a>\n<ul>\n<li><a href=\"#servlet\">Servlet</a></li>\n<li><a href=\"#genericservlet\">GenericServlet</a></li>\n<li><a href=\"#httpservlet\">HttpServlet</a></li>\n<li><a href=\"#%EC%84%9C%EB%B8%94%EB%A6%BF-%EC%8B%A4%ED%96%89%EC%88%9C%EC%84%9C\">서블릿 실행순서</a></li>\n</ul>\n</li>\n<li><a href=\"#spring-boot%EC%99%80-servlet\">Spring boot와 Servlet</a>\n<ul>\n<li><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8-%EC%8B%A4%ED%96%89%EA%B3%BC%EC%A0%95\">스프링 부트 실행과정</a></li>\n<li><a href=\"#%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%9A%94%EC%B2%AD%EC%9C%BC%EB%A1%9C%EB%B6%80%ED%84%B0-dispatchservlet%EC%9D%98-%EC%A0%84%EC%B2%B4-%ED%9D%90%EB%A6%84\">클라이언트 요청으로부터 DispatchServlet의 전체 흐름</a>\n<ul>\n<li><a href=\"#application-context\">Application context</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<p>톰켓 즉 서블릿 컨테이너에 의해 개발자가 정의한 프로그램들이 실행되고, 더 나아가 스프링 부트는 어떻게 실행될까 해서 글을 정리하게 되었습니다.</p>\n<h1><span id=\"서블릿-컨테이너\">서블릿 컨테이너</span></h1>\n<p>먼저 서블릿컨테이너를 정의하면 다음과 같을 수 있다. 서블릿 컨테이너는 웹 애플리케이션 서버중에서 HTTP 요청을 받아 처리하는 기초 역할을 맡고 있다. 대부분의 웹 프레임워크가 제공하는 기능은 서블릿 컨테이너 위에서 동작하는 서블릿, 필터, 이벤트 리스너등을 적절하게 구현한 것이다. 따라서 사용자가 웹 프레임워크로 작성한 웹애플리케이션은 결국 서블릿 컨테이너 위에서 동작한다. 서블릿컨테이너의 종류로는 아파치 톰켓, 제티등이 서블릿 컨테이너로 현재 널리사용 된다.</p>\n<h1><span id=\"서블릿-구현\">서블릿 구현</span></h1>\n<p>먼저 톰캣 즉 서블릿 컨테이너에 의해 프로그램이 실행되기 위해서는 표준 즉 Servlet interface를 구현해줘야 한다.<strong>사용자 정의 서블릿은 서블릿 컨테이너 내에 등록된 후 서블릿 컨테이너에 의해 생성, 호출, 소멸이 이루어진다.</strong></p>\n<p>때로는 서블릿은 자신의 상태 변경 시점을 알아내 적절한 리소스 획득/ 반환 등의 처리를 해야 하므로 Servlet 인터페이스에 int/destroy 메서드가 정의됩니다. 다시 말해 서블릿 컨테이너는 서블릿의 생명주기에 따라 서블릿의 상태를 변경하면서 서블릿 인터페이스에 정의된 각 메서드를 불러준다.</p>\n<p><code>HTTP 프로토콜</code>로 전달된 메시지는 서블릿 컨테이너에서 해석되고 재조합돼 웹프로그래머가 작성한 서블릿으로 전달되는 과정을 거친다.</p>\n<h2><span id=\"servlet\">Servlet</span></h2>\n<p>Servlet은 서블릿 프로그램을 개발할 때 반드시 구현해야 하는 메서드를 선언하고 있는 인터페이스이다. 이 표준을 구현해야 서블릿 컨테이너가 해당 서블릿을 실행할 수 있다.</p>\n<h2><span id=\"genericservlet\">GenericServlet</span></h2>\n<p>GenericServlet은 Servelet 인터페이스를 상속하여 클라이언트 - 서버 환경에서 서버단의 애플리케이션으로서 필요한 기능을 구현한 추상 클래스이다. service() 메서드를 제외 한 모든 메서드를 재정의하여 적절한 기능으로 구현했다. GenericServlet 클래스를 상속하면 애플리케이션의 프로토콜에 따라 메서드 재정의 구문을 적용해야 한다.</p>\n<h2><span id=\"httpservlet\">HttpServlet</span></h2>\n<p>일반적으로 서블릿이라하면 거의 대부분 HttpServlet을 상속받은 서블릿을 의미한다. HttpServlet은 <code>GenericServlet</code>을 상속받았으며, GenericServlet의 유일한 추상 메서드인 service를 HTTP 프로토콜 요청 메서드에 적합하게 재구현해놨다.</p>\n<p>이미 DELETE, GET, HEAD, OPTIONS, POST, PUT, TRAC를 처리하는 메소드가 모두 정의되어 있다.</p>\n<h2><span id=\"서블릿-실행순서\">서블릿 실행순서</span></h2>\n<p>서블릿의 실행 순서는 개발자가 관리하는 게 아닌 서블릿 컨테이너가 관리를 한다. 즉 서블릿에 의해 사용자가 정의한 서블릿 객체가 생성되고 호출되고 사라진다. 즉 이렇게 개발자가 아닌 프로그램에 의해 객체들이 관리되는 것을 Ioc(Inversion of Control)이라고 한다.</p>\n<p>다음은 서블릿 컨테이너의 생명주기를 도식화한것이다.<br>\n<img src=\"https://i.imgur.com/pQLeJ9z.jpg\" alt=\"\"></p>\n<ul>\n<li>서블릿 컨테이너는 클라이언트로 부터 처음 요청이 들어오면 현재 실행할 서블릿이 최초의 요청인지 판단하고 없으면 해당 서블릿을 새로 생성한다. 이작업은 최초 1회만 일어난다.</li>\n<li>init() 메소드는 해당 사용자 서블릿이 최초 생성되고 바로 호출되는 메소드이다.</li>\n<li>service() 메소드는 최초의 요청이든 2번쨰 요청이든 계속 호출되는 메소드이다.</li>\n</ul>\n<blockquote>\n<p>여기에서 서블릿컨테이너가 종료된다면 사용자 정의 HttpServlet의 destroy() 메소드가 호출될것이다.</p>\n</blockquote>\n<p>다음은 HttpServlet의 구현체 내부이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">        String protocol = req.getProtocol();</span><br><span class=\"line\">        String msg = lStrings.getString(<span class=\"string\">\"http.method_get_not_supported\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (protocol.endsWith(<span class=\"string\">\"1.1\"</span>)) &#123;</span><br><span class=\"line\">            resp.sendError(<span class=\"number\">405</span>, msg);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            resp.sendError(<span class=\"number\">400</span>, msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...<span class=\"comment\">//post, put 등등에 메소드가 존재함.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">service</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">        String method = req.getMethod();</span><br><span class=\"line\">        <span class=\"keyword\">long</span> lastModified;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (method.equals(<span class=\"string\">\"GET\"</span>)) &#123;</span><br><span class=\"line\">            lastModified = <span class=\"keyword\">this</span>.getLastModified(req);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (lastModified == -<span class=\"number\">1L</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.doGet(req, resp);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> ifModifiedSince;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    ifModifiedSince = req.getDateHeader(<span class=\"string\">\"If-Modified-Since\"</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class=\"line\">                    ifModifiedSince = -<span class=\"number\">1L</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ifModifiedSince &lt; lastModified / <span class=\"number\">1000L</span> * <span class=\"number\">1000L</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.doGet(req, resp);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    resp.setStatus(<span class=\"number\">304</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(<span class=\"string\">\"HEAD\"</span>)) &#123;</span><br><span class=\"line\">            lastModified = <span class=\"keyword\">this</span>.getLastModified(req);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.doHead(req, resp);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(<span class=\"string\">\"POST\"</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.doPost(req, resp);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(<span class=\"string\">\"PUT\"</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.doPut(req, resp);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(<span class=\"string\">\"DELETE\"</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.doDelete(req, resp);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(<span class=\"string\">\"OPTIONS\"</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.doOptions(req, resp);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(<span class=\"string\">\"TRACE\"</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.doTrace(req, resp);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            String errMsg = lStrings.getString(<span class=\"string\">\"http.method_not_implemented\"</span>);</span><br><span class=\"line\">            Object[] errArgs = <span class=\"keyword\">new</span> Object[]&#123;method&#125;;</span><br><span class=\"line\">            errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class=\"line\">            resp.sendError(<span class=\"number\">501</span>, errMsg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>위에서 설명한 Servlet들의 상속 구조는 다음과 같을 것이다. 개발자가 정의한 MemberServlet이 구현한 service를 서블릿 컨테이너가 실행할 것이다. 만약 service가 아닌 method 방식으로 처리하고 싶다면 해당 HTTP Method 방식을 구현하면 된다.</p>\n<p><img src=\"https://i.imgur.com/NF8qy4D.jpg\" alt=\"\"></p>\n<p>위에서 말한 대로 개발자는 HttpServlet을 상속받고 HTTP Method에 맞게 서블릿을 구현해 기능을 구현할 수 있다. 그런데 여기에서 HTTPServlet을 상속하고 구현한 클래스들이 많을 텐데 어떻게 요청된 URL에 따라 각각에 서블릿으로 보내줄 수 있을까.</p>\n<p>답은 web.xml 또는 @WebServlet어노테이션이다. 서블릿2.5까지만해도 web.xml로만 제어가 가능했지만 3.0부터 어노테이션으로 클라이언트에 접근을 제어할 수 있게 되었다. 다음과 같이 URL에 맞게 서블릿을 매핑할 수 있다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>member<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>com.wan.test.MemberServlet<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>member<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/member<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebServlet</span>(<span class=\"string\">\"/member\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MemberServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>하지만 위에 방식대로 url마다 모두 매핑해서 사용해야 한다면 유지 보수, 확장성 등을 생각한다면 저러한 방법으로 개발을 계속 해나가는 것은 무모하다. 그래서 여기에서 한 단계 더 진보한 것 MVC 패턴이다. MVC 패턴은 모델(비즈니스로 직), 뷰(화면), Controller(최초 Request를 받는 곳)으로 나누고 개발을 하는 것이다.</p>\n<p>그럼 MVC 패턴에서는 어떻게 사용자 URL을 받는 것일까. 그것은 FrontController 패턴이다. FrontController 패턴은 모든 클라이언트에 요청을 최 앞단에 FrontController를 두고 각각에 컨트롤러에 매핑을 해주는 방식이다.</p>\n<p>모든 요청을 다음과같이 frontController로 넘긴다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>front<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>com.wan.test.FrontController<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>front<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uri-pattern</span>&gt;</span>*<span class=\"tag\">&lt;/<span class=\"name\">uri-pattern</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>그리고 다음과 같이 HttpServlet을 상속한 FrontController를 구현한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FrontController</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span></span>&#123;</span><br><span class=\"line\">    HashMap&lt;String, Controller&gt; controllerUrls = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ServletConfig sc)</span> <span class=\"keyword\">throws</span> ServletException</span>&#123;</span><br><span class=\"line\">        controllerUrls = <span class=\"keyword\">new</span> HashMap&lt;String, Controller&gt;();</span><br><span class=\"line\">        controllerUrls.put(<span class=\"string\">\"/memberInsert.do\"</span>, <span class=\"keyword\">new</span> MemberInsertController()));</span><br><span class=\"line\">        controllerUrls.put(<span class=\"string\">\"/memberDelete.do\"</span>, <span class=\"keyword\">new</span> MemberDeleteController()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">service</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class=\"line\">        String uri = request.getRequestURI();</span><br><span class=\"line\">        Controller subController = controllerUrls.get(uri);</span><br><span class=\"line\">        subController.execute(request, response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Controller</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(HttpServletRequest, HttpServletResponse)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MemberInsertController</span> <span class=\"keyword\">implements</span> <span class=\"title\">Controller</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(HttpServletRequest, HttpServletResponse)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>FrontController는 이제 요청되어진 URI에 따라 등록되어진 Contrller를 실행할것이다. 컨트롤러는 그뒤에 서비스, 레파지토리를 실행하고 최종적으로 뷰를 화면에 그리게 될것이다.</p>\n<h1><span id=\"spring-boot와-servlet\">Spring boot와 Servlet</span></h1>\n<p>Spring boot는 내부적으로 내장 톰켓을 가지고 있다. 즉 스프링 부트가 실행되면서 내부적으로 내장톰켓 즉 서블릿 컨테이너가 실행된다. 스프링 부트에서 사용자 정의 프로그램를 구현한 프로그램인 서블릿은 DispatchServlet이다. 스프링부트에서 DispatchServlet이 FrontController 역할을 한다.</p>\n<p>스프링 부트에 DispatchServlet의 상속 구조이다.</p>\n<p><img src=\"https://i.imgur.com/hIBT4mn.jpg\" alt=\"\"></p>\n<h2><span id=\"스프링-부트-실행과정\">스프링 부트 실행과정</span></h2>\n<p>Spring boot는 ServletContainerInitializer를 구현한 TomcatStarter의 onStartup 메소드를 먼저 실행한다. 톰켓이 실행되고 다음 조건이 만족하면 디스팻처 서블릿이 등록 되어진다.</p>\n<p>DispatcherServletAutoConfiguration.clas에 구성되어져있는 DispatchServlet 빈 등록으로 자동 등록되어진다. 다음은 해당 소스 내용이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">org.springframework.boot.autoconfigure.web;</span><br><span class=\"line\">DispatcherServletAutoConfiguration.class</span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@Conditional</span>(&#123;DispatcherServletAutoConfiguration.DefaultDispatcherServletCondition.class&#125;)</span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnClass</span>(&#123;ServletRegistration.class&#125;)</span><br><span class=\"line\"><span class=\"meta\">@EnableConfigurationProperties</span>(&#123;WebMvcProperties.class&#125;)</span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DispatcherServletConfiguration</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Bean</span>(</span><br><span class=\"line\">            name = &#123;<span class=\"string\">\"dispatcherServlet\"</span>&#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> DispatcherServlet <span class=\"title\">dispatcherServlet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            DispatcherServlet dispatcherServlet = <span class=\"keyword\">new</span> DispatcherServlet();</span><br><span class=\"line\">            dispatcherServlet.setDispatchOptionsRequest(<span class=\"keyword\">this</span>.webMvcProperties.isDispatchOptionsRequest());</span><br><span class=\"line\">            dispatcherServlet.setDispatchTraceRequest(<span class=\"keyword\">this</span>.webMvcProperties.isDispatchTraceRequest());</span><br><span class=\"line\">            dispatcherServlet.setThrowExceptionIfNoHandlerFound(<span class=\"keyword\">this</span>.webMvcProperties.isThrowExceptionIfNoHandlerFound());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> dispatcherServlet;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>디스팻처 서블릿이 스프링에 빈으로 등록되어진다.</li>\n<li>서블릿 컨테이너(디스팻처서블릿) 컨텍스트에 서블릿을등록한다.</li>\n<li>서블릿 컨테이너 필터에 등록설정 해놓은 필터들을 등록한다.</li>\n<li>디스팻처서블릿에 각종 핸들러 매핑(자원 URL)들이 등록 한다.(컨트롤러 빈들이 다 생성되어 싱글톤으로 관리되어진다.)</li>\n</ul>\n<p><img src=\"https://i.imgur.com/CvVBmhQ.png\" alt=\"\"></p>\n<h2><span id=\"클라이언트-요청으로부터-dispatchservlet의-전체-흐름\">클라이언트 요청으로부터 DispatchServlet의 전체 흐름</span></h2>\n<p>FrameworkServlet은 HttpServlet를 상속하고 있다. DispatcherServlet은 FrameworkServlet를 상속하고 있다. 이말은 즉슨 DispatcherServlet이 FrontController라는것이다. 다음은 요청후 실행 순서를 설명한것이다.<br>\n<strong>여기에서 주의할점은 서블릿컨테이너처럼 요청이왔을때 객체를 생성하는게 아닌 이미 컨트롤러들이 빈으로 등록되어져 있다는것을 생각해야한다.</strong></p>\n<ul>\n<li>FrameworkServlet.service()를 먼저 탄다.</li>\n<li>FrameworkServlet.service()는 dispatch.doService()를 호출한다.</li>\n<li>dispatch.doService()는 dispatch.doDispatch()를 실행한다.\n<ul>\n<li>doDispatch는 AbstractHandlerMapping매핑에서 핸들러(컨틀롤러)를 가져온다.</li>\n<li>인터셉트 등을 지나서 해당 컨트롤러 메소드로 이동한다\u001c.</li>\n<li>해당 핸들러는 MV를 리턴한다.</li>\n<li>@Restoroller 컨트롤 같은경우 컨버터를 이용해 바로 결과값을 리턴한다.</li>\n<li>만약 view에 대한 정보가 있으면 viewresolver에 들려 뷰객체를 얻는다.</li>\n<li>뷰를 통해 렌더링을한다.</li>\n</ul>\n</li>\n</ul>\n<p>도식화한다면 다음과 같을 수 있다.</p>\n<p><img src=\"https://i.imgur.com/BJUx5fJ.jpg\" alt=\"\"></p>\n<h2><span id=\"application-context\">Application context</span></h2>\n<p>여기에서 Dispatcher 서블릿이 생성되면서 주의할 점이 하나 있다. 디스패처 서블릿이 생성되면서 WebapplicationContext가 생성된다. 하나는 dispatch에 의해 생성되는 WebApplicationContext 그리고 스프링에 ContextLoader에 의해 생성되는 Root WebapplicationContext가 있다. 이 둘은 부모 자식 관계이다. 구조는 아래와 같을 수 있다.</p>\n<p>그러면 최종적으로 아래와 같은 구조로 스프링이 돌아가게 된다.</p>\n<p><img src=\"https://i.imgur.com/VGR5aQx.png\" alt=\"\"></p>\n<p>위와같이 구성이유는 2개이상의 DispatchServlet을 등록을하게 되면 RootWebApplicationContext를 공유하기위해서 사용할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyWebAppInitializer</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Class&lt;?&gt;[] &#123; RootConfig.class &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Class&lt;?&gt;[] &#123; App1Config.class &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String[] getServletMappings() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String[] &#123; <span class=\"string\">\"/app1/*\"</span> &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>참고</p>\n<ul>\n<li><a href=\"http://www.yes24.com/24/Goods/37235901?Acode=101\" target=\"_blank\" rel=\"noopener\">처음 해보는 Servlet &amp; JSP 웹 프로그래밍</a></li>\n<li><a href=\"https://docs.spring.io/\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/</a></li>\n<li><a href=\"http://www.yes24.com/24/goods/61793313\" target=\"_blank\" rel=\"noopener\">스프링 부트로 배우는 자바 웹 개발</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>서블릿 컨테이너, 스프링부트 동작 과정</h1>\n<!-- TOC -->\n<ul>\n<li><a href=\"#%EC%84%9C%EB%B8%94%EB%A6%BF-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95\">서블릿 컨테이너, 스프링부트 동작 과정</a>\n<ul>\n<li><a href=\"#%EC%84%9C%EB%B8%94%EB%A6%BF-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88\">서블릿 컨테이너</a></li>\n<li><a href=\"#%EC%84%9C%EB%B8%94%EB%A6%BF-%EA%B5%AC%ED%98%84\">서블릿 구현</a>\n<ul>\n<li><a href=\"#servlet\">Servlet</a></li>\n<li><a href=\"#genericservlet\">GenericServlet</a></li>\n<li><a href=\"#httpservlet\">HttpServlet</a></li>\n<li><a href=\"#%EC%84%9C%EB%B8%94%EB%A6%BF-%EC%8B%A4%ED%96%89%EC%88%9C%EC%84%9C\">서블릿 실행순서</a></li>\n</ul>\n</li>\n<li><a href=\"#spring-boot%EC%99%80-servlet\">Spring boot와 Servlet</a>\n<ul>\n<li><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81-%EB%B6%80%ED%8A%B8-%EC%8B%A4%ED%96%89%EA%B3%BC%EC%A0%95\">스프링 부트 실행과정</a></li>\n<li><a href=\"#%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EC%9A%94%EC%B2%AD%EC%9C%BC%EB%A1%9C%EB%B6%80%ED%84%B0-dispatchservlet%EC%9D%98-%EC%A0%84%EC%B2%B4-%ED%9D%90%EB%A6%84\">클라이언트 요청으로부터 DispatchServlet의 전체 흐름</a>\n<ul>\n<li><a href=\"#application-context\">Application context</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<p>톰켓 즉 서블릿 컨테이너에 의해 개발자가 정의한 프로그램들이 실행되고, 더 나아가 스프링 부트는 어떻게 실행될까 해서 글을 정리하게 되었습니다.</p>\n<h1>서블릿 컨테이너</h1>\n<p>먼저 서블릿컨테이너를 정의하면 다음과 같을 수 있다. 서블릿 컨테이너는 웹 애플리케이션 서버중에서 HTTP 요청을 받아 처리하는 기초 역할을 맡고 있다. 대부분의 웹 프레임워크가 제공하는 기능은 서블릿 컨테이너 위에서 동작하는 서블릿, 필터, 이벤트 리스너등을 적절하게 구현한 것이다. 따라서 사용자가 웹 프레임워크로 작성한 웹애플리케이션은 결국 서블릿 컨테이너 위에서 동작한다. 서블릿컨테이너의 종류로는 아파치 톰켓, 제티등이 서블릿 컨테이너로 현재 널리사용 된다.</p>\n<h1>서블릿 구현</h1>\n<p>먼저 톰캣 즉 서블릿 컨테이너에 의해 프로그램이 실행되기 위해서는 표준 즉 Servlet interface를 구현해줘야 한다.<strong>사용자 정의 서블릿은 서블릿 컨테이너 내에 등록된 후 서블릿 컨테이너에 의해 생성, 호출, 소멸이 이루어진다.</strong></p>\n<p>때로는 서블릿은 자신의 상태 변경 시점을 알아내 적절한 리소스 획득/ 반환 등의 처리를 해야 하므로 Servlet 인터페이스에 int/destroy 메서드가 정의됩니다. 다시 말해 서블릿 컨테이너는 서블릿의 생명주기에 따라 서블릿의 상태를 변경하면서 서블릿 인터페이스에 정의된 각 메서드를 불러준다.</p>\n<p><code>HTTP 프로토콜</code>로 전달된 메시지는 서블릿 컨테이너에서 해석되고 재조합돼 웹프로그래머가 작성한 서블릿으로 전달되는 과정을 거친다.</p>\n<h2>Servlet</h2>\n<p>Servlet은 서블릿 프로그램을 개발할 때 반드시 구현해야 하는 메서드를 선언하고 있는 인터페이스이다. 이 표준을 구현해야 서블릿 컨테이너가 해당 서블릿을 실행할 수 있다.</p>\n<h2>GenericServlet</h2>\n<p>GenericServlet은 Servelet 인터페이스를 상속하여 클라이언트 - 서버 환경에서 서버단의 애플리케이션으로서 필요한 기능을 구현한 추상 클래스이다. service() 메서드를 제외 한 모든 메서드를 재정의하여 적절한 기능으로 구현했다. GenericServlet 클래스를 상속하면 애플리케이션의 프로토콜에 따라 메서드 재정의 구문을 적용해야 한다.</p>\n<h2>HttpServlet</h2>\n<p>일반적으로 서블릿이라하면 거의 대부분 HttpServlet을 상속받은 서블릿을 의미한다. HttpServlet은 <code>GenericServlet</code>을 상속받았으며, GenericServlet의 유일한 추상 메서드인 service를 HTTP 프로토콜 요청 메서드에 적합하게 재구현해놨다.</p>\n<p>이미 DELETE, GET, HEAD, OPTIONS, POST, PUT, TRAC를 처리하는 메소드가 모두 정의되어 있다.</p>\n<h2>서블릿 실행순서</h2>\n<p>서블릿의 실행 순서는 개발자가 관리하는 게 아닌 서블릿 컨테이너가 관리를 한다. 즉 서블릿에 의해 사용자가 정의한 서블릿 객체가 생성되고 호출되고 사라진다. 즉 이렇게 개발자가 아닌 프로그램에 의해 객체들이 관리되는 것을 Ioc(Inversion of Control)이라고 한다.</p>\n<p>다음은 서블릿 컨테이너의 생명주기를 도식화한것이다.<br>\n<img src=\"https://i.imgur.com/pQLeJ9z.jpg\" alt=\"\"></p>\n<ul>\n<li>서블릿 컨테이너는 클라이언트로 부터 처음 요청이 들어오면 현재 실행할 서블릿이 최초의 요청인지 판단하고 없으면 해당 서블릿을 새로 생성한다. 이작업은 최초 1회만 일어난다.</li>\n<li>init() 메소드는 해당 사용자 서블릿이 최초 생성되고 바로 호출되는 메소드이다.</li>\n<li>service() 메소드는 최초의 요청이든 2번쨰 요청이든 계속 호출되는 메소드이다.</li>\n</ul>\n<blockquote>\n<p>여기에서 서블릿컨테이너가 종료된다면 사용자 정의 HttpServlet의 destroy() 메소드가 호출될것이다.</p>\n</blockquote>\n<p>다음은 HttpServlet의 구현체 내부이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doGet</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">        String protocol = req.getProtocol();</span><br><span class=\"line\">        String msg = lStrings.getString(<span class=\"string\">\"http.method_get_not_supported\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (protocol.endsWith(<span class=\"string\">\"1.1\"</span>)) &#123;</span><br><span class=\"line\">            resp.sendError(<span class=\"number\">405</span>, msg);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            resp.sendError(<span class=\"number\">400</span>, msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...<span class=\"comment\">//post, put 등등에 메소드가 존재함.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">service</span><span class=\"params\">(HttpServletRequest req, HttpServletResponse resp)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">        String method = req.getMethod();</span><br><span class=\"line\">        <span class=\"keyword\">long</span> lastModified;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (method.equals(<span class=\"string\">\"GET\"</span>)) &#123;</span><br><span class=\"line\">            lastModified = <span class=\"keyword\">this</span>.getLastModified(req);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (lastModified == -<span class=\"number\">1L</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">this</span>.doGet(req, resp);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> ifModifiedSince;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    ifModifiedSince = req.getDateHeader(<span class=\"string\">\"If-Modified-Since\"</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class=\"line\">                    ifModifiedSince = -<span class=\"number\">1L</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ifModifiedSince &lt; lastModified / <span class=\"number\">1000L</span> * <span class=\"number\">1000L</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class=\"line\">                    <span class=\"keyword\">this</span>.doGet(req, resp);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    resp.setStatus(<span class=\"number\">304</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(<span class=\"string\">\"HEAD\"</span>)) &#123;</span><br><span class=\"line\">            lastModified = <span class=\"keyword\">this</span>.getLastModified(req);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.doHead(req, resp);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(<span class=\"string\">\"POST\"</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.doPost(req, resp);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(<span class=\"string\">\"PUT\"</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.doPut(req, resp);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(<span class=\"string\">\"DELETE\"</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.doDelete(req, resp);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(<span class=\"string\">\"OPTIONS\"</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.doOptions(req, resp);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (method.equals(<span class=\"string\">\"TRACE\"</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.doTrace(req, resp);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            String errMsg = lStrings.getString(<span class=\"string\">\"http.method_not_implemented\"</span>);</span><br><span class=\"line\">            Object[] errArgs = <span class=\"keyword\">new</span> Object[]&#123;method&#125;;</span><br><span class=\"line\">            errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class=\"line\">            resp.sendError(<span class=\"number\">501</span>, errMsg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>위에서 설명한 Servlet들의 상속 구조는 다음과 같을 것이다. 개발자가 정의한 MemberServlet이 구현한 service를 서블릿 컨테이너가 실행할 것이다. 만약 service가 아닌 method 방식으로 처리하고 싶다면 해당 HTTP Method 방식을 구현하면 된다.</p>\n<p><img src=\"https://i.imgur.com/NF8qy4D.jpg\" alt=\"\"></p>\n<p>위에서 말한 대로 개발자는 HttpServlet을 상속받고 HTTP Method에 맞게 서블릿을 구현해 기능을 구현할 수 있다. 그런데 여기에서 HTTPServlet을 상속하고 구현한 클래스들이 많을 텐데 어떻게 요청된 URL에 따라 각각에 서블릿으로 보내줄 수 있을까.</p>\n<p>답은 web.xml 또는 @WebServlet어노테이션이다. 서블릿2.5까지만해도 web.xml로만 제어가 가능했지만 3.0부터 어노테이션으로 클라이언트에 접근을 제어할 수 있게 되었다. 다음과 같이 URL에 맞게 서블릿을 매핑할 수 있다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>member<span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>com.wan.test.MemberServlet<span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">Servlet-mapping</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>member<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">url-pattern</span>&gt;</span>/member<span class=\"tag\">&lt;/<span class=\"name\">url-pattern</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">Servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@WebServlet</span>(<span class=\"string\">\"/member\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MemberServlet</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span></span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>하지만 위에 방식대로 url마다 모두 매핑해서 사용해야 한다면 유지 보수, 확장성 등을 생각한다면 저러한 방법으로 개발을 계속 해나가는 것은 무모하다. 그래서 여기에서 한 단계 더 진보한 것 MVC 패턴이다. MVC 패턴은 모델(비즈니스로 직), 뷰(화면), Controller(최초 Request를 받는 곳)으로 나누고 개발을 하는 것이다.</p>\n<p>그럼 MVC 패턴에서는 어떻게 사용자 URL을 받는 것일까. 그것은 FrontController 패턴이다. FrontController 패턴은 모든 클라이언트에 요청을 최 앞단에 FrontController를 두고 각각에 컨트롤러에 매핑을 해주는 방식이다.</p>\n<p>모든 요청을 다음과같이 frontController로 넘긴다.</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>front<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">servlet-class</span>&gt;</span>com.wan.test.FrontController<span class=\"tag\">&lt;/<span class=\"name\">servlet-class</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">servlet</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">servlet-name</span>&gt;</span>front<span class=\"tag\">&lt;/<span class=\"name\">servlet-name</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">uri-pattern</span>&gt;</span>*<span class=\"tag\">&lt;/<span class=\"name\">uri-pattern</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>그리고 다음과 같이 HttpServlet을 상속한 FrontController를 구현한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FrontController</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span></span>&#123;</span><br><span class=\"line\">    HashMap&lt;String, Controller&gt; controllerUrls = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(ServletConfig sc)</span> <span class=\"keyword\">throws</span> ServletException</span>&#123;</span><br><span class=\"line\">        controllerUrls = <span class=\"keyword\">new</span> HashMap&lt;String, Controller&gt;();</span><br><span class=\"line\">        controllerUrls.put(<span class=\"string\">\"/memberInsert.do\"</span>, <span class=\"keyword\">new</span> MemberInsertController()));</span><br><span class=\"line\">        controllerUrls.put(<span class=\"string\">\"/memberDelete.do\"</span>, <span class=\"keyword\">new</span> MemberDeleteController()));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">service</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span></span>&#123;</span><br><span class=\"line\">        String uri = request.getRequestURI();</span><br><span class=\"line\">        Controller subController = controllerUrls.get(uri);</span><br><span class=\"line\">        subController.execute(request, response);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Controller</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(HttpServletRequest, HttpServletResponse)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MemberInsertController</span> <span class=\"keyword\">implements</span> <span class=\"title\">Controller</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(HttpServletRequest, HttpServletResponse)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>FrontController는 이제 요청되어진 URI에 따라 등록되어진 Contrller를 실행할것이다. 컨트롤러는 그뒤에 서비스, 레파지토리를 실행하고 최종적으로 뷰를 화면에 그리게 될것이다.</p>\n<h1>Spring boot와 Servlet</h1>\n<p>Spring boot는 내부적으로 내장 톰켓을 가지고 있다. 즉 스프링 부트가 실행되면서 내부적으로 내장톰켓 즉 서블릿 컨테이너가 실행된다. 스프링 부트에서 사용자 정의 프로그램를 구현한 프로그램인 서블릿은 DispatchServlet이다. 스프링부트에서 DispatchServlet이 FrontController 역할을 한다.</p>\n<p>스프링 부트에 DispatchServlet의 상속 구조이다.</p>\n<p><img src=\"https://i.imgur.com/hIBT4mn.jpg\" alt=\"\"></p>\n<h2>스프링 부트 실행과정</h2>\n<p>Spring boot는 ServletContainerInitializer를 구현한 TomcatStarter의 onStartup 메소드를 먼저 실행한다. 톰켓이 실행되고 다음 조건이 만족하면 디스팻처 서블릿이 등록 되어진다.</p>\n<p>DispatcherServletAutoConfiguration.clas에 구성되어져있는 DispatchServlet 빈 등록으로 자동 등록되어진다. 다음은 해당 소스 내용이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">org.springframework.boot.autoconfigure.web;</span><br><span class=\"line\">DispatcherServletAutoConfiguration.class</span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@Conditional</span>(&#123;DispatcherServletAutoConfiguration.DefaultDispatcherServletCondition.class&#125;)</span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnClass</span>(&#123;ServletRegistration.class&#125;)</span><br><span class=\"line\"><span class=\"meta\">@EnableConfigurationProperties</span>(&#123;WebMvcProperties.class&#125;)</span><br><span class=\"line\"><span class=\"keyword\">protected</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DispatcherServletConfiguration</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Bean</span>(</span><br><span class=\"line\">            name = &#123;<span class=\"string\">\"dispatcherServlet\"</span>&#125;</span><br><span class=\"line\">        )</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> DispatcherServlet <span class=\"title\">dispatcherServlet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            DispatcherServlet dispatcherServlet = <span class=\"keyword\">new</span> DispatcherServlet();</span><br><span class=\"line\">            dispatcherServlet.setDispatchOptionsRequest(<span class=\"keyword\">this</span>.webMvcProperties.isDispatchOptionsRequest());</span><br><span class=\"line\">            dispatcherServlet.setDispatchTraceRequest(<span class=\"keyword\">this</span>.webMvcProperties.isDispatchTraceRequest());</span><br><span class=\"line\">            dispatcherServlet.setThrowExceptionIfNoHandlerFound(<span class=\"keyword\">this</span>.webMvcProperties.isThrowExceptionIfNoHandlerFound());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> dispatcherServlet;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>디스팻처 서블릿이 스프링에 빈으로 등록되어진다.</li>\n<li>서블릿 컨테이너(디스팻처서블릿) 컨텍스트에 서블릿을등록한다.</li>\n<li>서블릿 컨테이너 필터에 등록설정 해놓은 필터들을 등록한다.</li>\n<li>디스팻처서블릿에 각종 핸들러 매핑(자원 URL)들이 등록 한다.(컨트롤러 빈들이 다 생성되어 싱글톤으로 관리되어진다.)</li>\n</ul>\n<p><img src=\"https://i.imgur.com/CvVBmhQ.png\" alt=\"\"></p>\n<h2>클라이언트 요청으로부터 DispatchServlet의 전체 흐름</h2>\n<p>FrameworkServlet은 HttpServlet를 상속하고 있다. DispatcherServlet은 FrameworkServlet를 상속하고 있다. 이말은 즉슨 DispatcherServlet이 FrontController라는것이다. 다음은 요청후 실행 순서를 설명한것이다.<br>\n<strong>여기에서 주의할점은 서블릿컨테이너처럼 요청이왔을때 객체를 생성하는게 아닌 이미 컨트롤러들이 빈으로 등록되어져 있다는것을 생각해야한다.</strong></p>\n<ul>\n<li>FrameworkServlet.service()를 먼저 탄다.</li>\n<li>FrameworkServlet.service()는 dispatch.doService()를 호출한다.</li>\n<li>dispatch.doService()는 dispatch.doDispatch()를 실행한다.\n<ul>\n<li>doDispatch는 AbstractHandlerMapping매핑에서 핸들러(컨틀롤러)를 가져온다.</li>\n<li>인터셉트 등을 지나서 해당 컨트롤러 메소드로 이동한다\u001c.</li>\n<li>해당 핸들러는 MV를 리턴한다.</li>\n<li>@Restoroller 컨트롤 같은경우 컨버터를 이용해 바로 결과값을 리턴한다.</li>\n<li>만약 view에 대한 정보가 있으면 viewresolver에 들려 뷰객체를 얻는다.</li>\n<li>뷰를 통해 렌더링을한다.</li>\n</ul>\n</li>\n</ul>\n<p>도식화한다면 다음과 같을 수 있다.</p>\n<p><img src=\"https://i.imgur.com/BJUx5fJ.jpg\" alt=\"\"></p>\n<h2>Application context</h2>\n<p>여기에서 Dispatcher 서블릿이 생성되면서 주의할 점이 하나 있다. 디스패처 서블릿이 생성되면서 WebapplicationContext가 생성된다. 하나는 dispatch에 의해 생성되는 WebApplicationContext 그리고 스프링에 ContextLoader에 의해 생성되는 Root WebapplicationContext가 있다. 이 둘은 부모 자식 관계이다. 구조는 아래와 같을 수 있다.</p>\n<p>그러면 최종적으로 아래와 같은 구조로 스프링이 돌아가게 된다.</p>\n<p><img src=\"https://i.imgur.com/VGR5aQx.png\" alt=\"\"></p>\n<p>위와같이 구성이유는 2개이상의 DispatchServlet을 등록을하게 되면 RootWebApplicationContext를 공유하기위해서 사용할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyWebAppInitializer</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Class&lt;?&gt;[] &#123; RootConfig.class &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Class&lt;?&gt;[] &#123; App1Config.class &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> String[] getServletMappings() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String[] &#123; <span class=\"string\">\"/app1/*\"</span> &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>참고</p>\n<ul>\n<li><a href=\"http://www.yes24.com/24/Goods/37235901?Acode=101\" target=\"_blank\" rel=\"noopener\">처음 해보는 Servlet &amp; JSP 웹 프로그래밍</a></li>\n<li><a href=\"https://docs.spring.io/\" target=\"_blank\" rel=\"noopener\">https://docs.spring.io/</a></li>\n<li><a href=\"http://www.yes24.com/24/goods/61793313\" target=\"_blank\" rel=\"noopener\">스프링 부트로 배우는 자바 웹 개발</a></li>\n</ul>\n"},{"title":"JPA - 관계설정","catalog":true,"date":"2018-12-20T15:00:00.000Z","subtitle":"관계설정","header-img":null,"_content":"\n\n\n# JPA 관계 설정\n<!-- TOC -->\n\n- [JPA 관계 설정](#jpa-관계-설정)\n    - [JPA 관계 설정이란](#jpa-관계-설정이란)\n    - [단방향 연관관계 매핑](#단방향-연관관계-매핑)\n        - [일대다 단방향[1:N]](#일대다-단방향1n)\n        - [일대다 단방향[1:N] 예제](#일대다-단방향1n-예제)\n        - [다대일 단방향[N:1]](#다대일-단방향n1)\n        - [다대일 단방향[N:1] 예제](#다대일-단방향n1-예제)\n    - [다대일 양방향[N:1]](#다대일-양방향n1)\n        - [다대일 양방향[N:1] 예제](#다대일-양방향n1-예제)\n        - [편의 메소드](#편의-메소드)\n    - [다대다(N:N) 양방향](#다대다nn-양방향)\n        - [다대다(N:N) 양방향 예제](#다대다nn-양방향-예제)\n    - [다대다 연관관계 정리](#다대다-연관관계-정리)\n    - [마치며](#마치며)\n\n<!-- /TOC -->\n## JPA 관계 설정이란\n엔터티 또는 도메인들은 각각 관계를 맺고 있습니다. 예를 들어 유저는 여러 개의 제품을 주문할 수 있다고 하면 유저 엔터티는 주문 엔터티와 관계를 갖습니다. 또 주문 엔터티는 어떠한 제품이 주문됐는지 알아야 하기 때문에 제품엔터티와 관계를 맺습니다.\n\nJPA에서 관계 설정을 하게 되면 알아서 객체에서는 참조를 사용해서 관계를 맺고 테이블은 외래 키를 통해 관계를 맺은 후 서로 매핑을 해놓습니다. 이제 이렇게 되면 개발자는 객체 간의 관계 또 그사이에서 생성되어야만 하는 SQL 문들을 신경 쓸 필요 없이 객체 간의 관계만 신경 쓰면 되기 때문에 비즈니스 로직에 집중할 수 있습니다.\n\n**방향**\n관계 설정은 단방향, 양방향으로 관계를 맺을 수 있습니다. 예를 들어 회원 -> 주문, 주문 -> 회원 한쪽만 참고가 필요하다면 단순 당 방향으로 설정할 수 있고, 반대로 양쪽 다 회원 -> 주문, 주문 -> 회원을 둘 다 참고해야 한다면 양방향으로 설정할 수 있습니다. **방향은 객체 관계에만 존재하고 테이블 관계는 항상 양방향입니다.**\n\n\n**연관관계의 주인**\n객체를 양방향 연관 관계로 만들면 연관관계의 주인을 정해야 합니다. 이러한 주인은 보통 외래 키를 관리하는 엔터티가 주인이 됩니다. 연관 관계의 주인을 정한다는 것은 사실 외래 키 관리자를 선택하는 것입니다.\n\n**관계 종류**\n관계 설정은 일대일, 일대다, 다대일, 다대다 관계가 있을 수 있습니다.\n\n**@JoinColumn**\n\n이 어노테이션은 객체 간에 관계를 설정한 후 외래 키를 매핑할 때 사용합니다. 그냥 객체 간에 관계 설정을 해주면 필드 + _ + 참조하는 테이블의 기본 키 칼럼명으로 가져가게 됩니다.\n\n|속성|기능|기본값|\n|-|-|-|\n|name |매핑할 외래 키 이름 | 필드 + _ + 참조하는 테이블의 기본키 컬럼명 |\n| referencedColumnName | 외래키가 참조하는 대상 테이블의 컬럼명 |참조하는 테이블의 기본키 컬럼명 |\n| foreignKey(DDL) | 외래 키 제약 조건을 직접 지정할 수 있다.<br> 이 속성은 테이블을 생성할 때만 사용한다. |\n\n아래에서는 1:N, N:1, N:N에 관계 설정을 하겠습니다.\n\n## 단방향 연관관계 매핑\n\n### 일대다 단방향[1:N]\n일대다 단방향 관계 설정을 해보겠습니다. 예제는 아래의 테이블을 기반으로 설명하겠습니다. 아래는 회원과 주문테이블이 존재합니다. 회원은 자기가 주문한 정보를 참조할 필요가 있습니다. 그런데 주문에서는 회원정보를 참조할 필요가 없을 경우 일대다 단방향을 구성할 수 있습니다.\n\n![](https://i.imgur.com/aQdhBN6.png)\n\n### 일대다 단방향[1:N] 예제\n그렇게 되면 다음과 같이 1:N 단방향 관계 설정을 할 수 있습니다.\n```java\n@Entity\n@Getter\n@Table(name = \"member\")\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\npublic class Member {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\")\n    private long id;\n\n    @OneToMany\n    @JoinColumn(name = \"member_id\")\n    private List<Order> orders= new ArrayList<>();\n\n}\n```\n\n```java\n@Getter\n@Entity\n@Table(name = \"purchase_order\")\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\npublic class Order {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\")\n    private long id;\n\n}\n```\n\n**일대다 단방향 관계 주의할점**\n일대다 단방향 관계를 매핑할 때는 @JoinColumn을 명시해야 합니다. 그렇지 않으면 JPA는 연결 테이블을 중간에 두고 연관관계를 관리하는 조인 테이블 전략을 기본으로 사용해서 매핑하게 됩니다.\n\n**일대다 단방향 매핑의 단점**\n일대다 단방향 단점은 매핑 한 객체가 관리하는 외래 키가 다른 테이블에 있다는 점입니다. 본인 테이블에 외래 키가 있으면 엔터티의 저장과 연관 관계 처리를 INSERT SQL 한 번으로 끝낼 수 있지만, 다른 테이블에 외래 키가 있으면 연관관계 처리를 위한 UPDATE SQL을 추가로 실행해야 합니다.\n\n```sql\nHibernate: insert into purchase_order values ( )\nHibernate: insert into purchase_order values ( )\nHibernate: insert into member values ( )\nHibernate: update purchase_order set member_id=? where id=?\nHibernate: update purchase_order set member_id=? where id=?\n\n```\n\n다대일 단방향 또는 다대일 양방향은 아래와 같이 insert문 만으로 데이터가 테이블에 넣어집니다.\n\n```sql\nHibernate: insert into member values ( )\nHibernate: insert into purchase_order (member_id) values (?)\nHibernate: insert into purchase_order (member_id) values (?)\n```\n\n### 다대일 단방향[N:1]\n이번에는 반대로 회원 객체로는 주문한 정보를 참조할 일이 없고, 주문 객체가 회원정보를 참조해야 한다면 아까와 반대로 N:1 단방향의 관계 설정을 할 수 있을 것입니다. 다음과 같이 설정할 수 있습니다.\n\n### 다대일 단방향[N:1] 예제\n\n```java\n@Entity\n@Getter\n@Table(name = \"member\")\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\npublic class Member {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\")\n    private long id;\n\n}\n\n```\n\n\n```java\n\n\n@Getter\n@Entity\n@Table(name = \"purchase_order\")\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\npublic class Order {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\")\n    private long id;\n\n    @ManyToOne\n    @JoinColumn(name = \"member_id\", nullable = false, updatable = false)\n    private Member member;\n\n}\n\n```\n\n\n\n\n## 다대일 양방향[N:1]\n양방향 연관관계 설정은 주로 member에서도 order 객체를 참조할 일이 있고, order 객체에서도 member 객체를 참조해야 할 일이 있을 때 사용할 수 있습니다.\n\n### 다대일 양방향[N:1] 예제\n다음은 회원과 주문은 일대다 관계 설정을 양방향 관계로 한 예제입니다. 일대다 관계를 매핑하기 위해 @OneToMany 매핑 정보를 사용했습니다. mappedBy 속성은 양방향 매핑일 때 사용하는데 반대쪽 매핑의 필드 이름을 값으로 주면 됩니다. 이렇게되면 서로 참조할 수 있는 구조를 가지게됩니다.\n\n```java\n@Entity\n@Getter\n@Table(name = \"member\")\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\npublic class Member {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\")\n    private long id;\n\n    @OneToMany(mappedBy = \"member\")\n    private List<Order> orders= new ArrayList<>();\n\n}\n```\n\n\n```java\n@Getter\n@Entity\n@Table(name = \"purchase_order\")\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\npublic class Order {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\")\n    private long id;\n\n    @ManyToOne\n    @JoinColumn(name = \"member_id\", nullable = false, updatable = false)\n    private Member member;\n\n}\n\n```\n\n\n### 편의 메소드\n양방향 연관관계는 항상 서로 참조해야 합니다. 어느 한쪽만 참조하면 양방향 연관관계가 성립하지 않습니다. 물론 양방향 연관 관계의 주인만 변경해줘도 데이터베이스 외래 키 변경에 문제를 가지지는 않습니다. \n\n하지만 영속성 컨텍스트 내에서 연관관계 주인만 변경하고 참조되는 쪽에서 조회를 하면 변경되기 전 내용이 조회되기 때문에 문제를 가질 수 있습니다. \n\n먄약 주문내역에 회원이 변경된다면 다음과 같이 객체에 관계도 정리를 해줘야 합니다. 그렇기 때문에 주인이 변경될 때같이 참조되어 지는 쪽도 변경되어야 합니다. 위의 예제인 회원과 주문을 기반으로 편의 메서드를 만들어보겠습니다.\n\n* 회원을 변경하려는 주문 내역에 회원에서 해당 주문 내역을 제거한다.\n* 회원을 변경하려는 주문 내역에 새로운 회원을 설정한다.\n* 변경된 주문 내역 회원에도 해당 변경된 주문 내역을 설정해준다.\n\n위의 설명을 소스로 표현하면 다음과 같은 편의 메소드를 제공할 수 있습니다.\n\n```java\npublic void setMember(Member member) {\n    if(this.member !=null){\n      this.member.getOrders().remove(this);\n    }\n    this.member = member;\n    member.getOrders().add(this);\n}\n```\n\n\n## 다대다(N:N) 양방향\n\n관계형 데잍터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없습니다. 그래서 보통 다대다 관계를 일대다, 다대일 관계로 풀어내는 연결 테이블을 사용합니다. \n\n그래서 다음과 같이 주문을 할 때 여러 개의 제품을 주문해야 한다면 중간에 order_line이라는 연결 테이블을 두어 표현할 수 있습니다. 이것을 표현하는 방법은 @OneToMany @ManyToOne, 를 이용하는 방법이나 @ManyToMany 또는 @CollectionTable 등을 이용하는 방법이 있습니다.\n\n사실 @ManyToMany는 많이 사용되지 않는 어노테이션입니다. 보통 아래와 같이 테이블 구조를 가지게 되면 order_line에는 각각 제품에 주문량 주문금액 등이 표시되어야 하는데 @ManyToMany를 사용하면 order_line 테이블을 확장해나갈 수 없기 때문에 보통 @OneToMany @ManyToOne,@CollectionTable을 이용해 다대다를 풀어냅니다. 보통 @ManyToMany는 해당 매핑 테이블이 확장해나갈 일이 없는 경우에 사용할 수 있습니다.\n\n![](https://i.imgur.com/Zb1iB6I.png)\n\n여기에서는 ManyToMany 어노테이션을 이용해 테이블과 객체를 매핑할 것입니다.\n\n@ManyToMany 속성\n\n|속성|기능|\n|-|-|\n|name |매핑할 외래 키 이름 |\n| joinColumns | 현재 테이블과 조인할 컬럼 명을 정한다. |\n| inverseJoinColumns | 반대 방향인 상품과 매핑할 조인 컬럼 정보를 지정한다. |\n\n### 다대다(N:N) 양방향 예제\n\n```java\n@Getter\n@Entity\n@Table(name = \"purchase_order\")\n@NoArgsConstructor\npublic class Order {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\")\n    private long id;\n\n    @ManyToMany\n    @JoinTable(name = \"order_line\",\n            joinColumns = @JoinColumn(name = \"order_id\"),\n            inverseJoinColumns = @JoinColumn(name = \"product_id\")\n    )\n    private List<Product> products = new ArrayList<>();\n\n}\n\n```\n\n\n\n```java\n@Entity\n@Getter\n@Table(name = \"product\")\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\npublic class Product {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\")\n    private long id;\n\n    @ManyToMany(mappedBy = \"products\")\n    private List<Order> orders = new ArrayList<>();\n    \n}\n\n```\n\n\n\n## 다대다 연관관계 정리\n다대다 관계 설정이나 외래 키를 설정하다 보면 해당 외래 키를 사용하여 복합키를 사용할 건지 단순히 외래 키로 사용할지 선택해야 합니다. 아래는 이 외래 키를 가지고 어떻게 설정하느냐에 따라 식별 관계, 비실 별 관계가 되는지에 대한 설명입니다.\n\n식별 관계 : 받아온 식별자를 기본 키 + 외래 키로 사용한다.\n비식별 관계 : 받아온 식별자는 외래키로만 사용하고 새로운 식별자를 추가한다.\n\n보통 JPA에서는 식별 관계를 사용하기 보다는 비식별관계로 사용합니다. 이유는 복합키를 위한 식별자 클래스를 만들지 않아도 되기 때문입니다.\n\n\n[예제소스](https://github.com/minwan1/blog-example/tree/master/jpa-relation)\n\n## 마치며\nJPA에서 사용하는 관계 설정에 대해 짧게 알아봤습니다. 여기에서 중요한 것은 위에서 설명했던 예제 중에 상황에 맞게 잘 선택해서 관계 설정을 하면 된다는 것입니다. 굳이 사용하지 않는 참조를 사용해서 순환 참조를 만난다거나 의미 없는 도메인 관계를 만들 수 있기 때문입니다. 이렇게 되면 각각 도메인이 표현하고자 하는 범위를 넘어선 책임을 할 수 있기 때문에 좋지 않은 설계가 될 수 있습니다.\n\n\n참고\n\n* [자바 ORM 표준 JPA 프로그래밍](http://book.naver.com/bookdb/book_detail.nhn?bid=9252528)\n","source":"_posts/2018-12-26-jpa-관계설정.md","raw":"---\ntitle: JPA - 관계설정\ncatalog: true\ndate: 2018-12-21\nsubtitle: 관계설정\nheader-img:\ntags:\n- Java\n- Spring\n- JPA\n\n\n\n---\n\n\n\n# JPA 관계 설정\n<!-- TOC -->\n\n- [JPA 관계 설정](#jpa-관계-설정)\n    - [JPA 관계 설정이란](#jpa-관계-설정이란)\n    - [단방향 연관관계 매핑](#단방향-연관관계-매핑)\n        - [일대다 단방향[1:N]](#일대다-단방향1n)\n        - [일대다 단방향[1:N] 예제](#일대다-단방향1n-예제)\n        - [다대일 단방향[N:1]](#다대일-단방향n1)\n        - [다대일 단방향[N:1] 예제](#다대일-단방향n1-예제)\n    - [다대일 양방향[N:1]](#다대일-양방향n1)\n        - [다대일 양방향[N:1] 예제](#다대일-양방향n1-예제)\n        - [편의 메소드](#편의-메소드)\n    - [다대다(N:N) 양방향](#다대다nn-양방향)\n        - [다대다(N:N) 양방향 예제](#다대다nn-양방향-예제)\n    - [다대다 연관관계 정리](#다대다-연관관계-정리)\n    - [마치며](#마치며)\n\n<!-- /TOC -->\n## JPA 관계 설정이란\n엔터티 또는 도메인들은 각각 관계를 맺고 있습니다. 예를 들어 유저는 여러 개의 제품을 주문할 수 있다고 하면 유저 엔터티는 주문 엔터티와 관계를 갖습니다. 또 주문 엔터티는 어떠한 제품이 주문됐는지 알아야 하기 때문에 제품엔터티와 관계를 맺습니다.\n\nJPA에서 관계 설정을 하게 되면 알아서 객체에서는 참조를 사용해서 관계를 맺고 테이블은 외래 키를 통해 관계를 맺은 후 서로 매핑을 해놓습니다. 이제 이렇게 되면 개발자는 객체 간의 관계 또 그사이에서 생성되어야만 하는 SQL 문들을 신경 쓸 필요 없이 객체 간의 관계만 신경 쓰면 되기 때문에 비즈니스 로직에 집중할 수 있습니다.\n\n**방향**\n관계 설정은 단방향, 양방향으로 관계를 맺을 수 있습니다. 예를 들어 회원 -> 주문, 주문 -> 회원 한쪽만 참고가 필요하다면 단순 당 방향으로 설정할 수 있고, 반대로 양쪽 다 회원 -> 주문, 주문 -> 회원을 둘 다 참고해야 한다면 양방향으로 설정할 수 있습니다. **방향은 객체 관계에만 존재하고 테이블 관계는 항상 양방향입니다.**\n\n\n**연관관계의 주인**\n객체를 양방향 연관 관계로 만들면 연관관계의 주인을 정해야 합니다. 이러한 주인은 보통 외래 키를 관리하는 엔터티가 주인이 됩니다. 연관 관계의 주인을 정한다는 것은 사실 외래 키 관리자를 선택하는 것입니다.\n\n**관계 종류**\n관계 설정은 일대일, 일대다, 다대일, 다대다 관계가 있을 수 있습니다.\n\n**@JoinColumn**\n\n이 어노테이션은 객체 간에 관계를 설정한 후 외래 키를 매핑할 때 사용합니다. 그냥 객체 간에 관계 설정을 해주면 필드 + _ + 참조하는 테이블의 기본 키 칼럼명으로 가져가게 됩니다.\n\n|속성|기능|기본값|\n|-|-|-|\n|name |매핑할 외래 키 이름 | 필드 + _ + 참조하는 테이블의 기본키 컬럼명 |\n| referencedColumnName | 외래키가 참조하는 대상 테이블의 컬럼명 |참조하는 테이블의 기본키 컬럼명 |\n| foreignKey(DDL) | 외래 키 제약 조건을 직접 지정할 수 있다.<br> 이 속성은 테이블을 생성할 때만 사용한다. |\n\n아래에서는 1:N, N:1, N:N에 관계 설정을 하겠습니다.\n\n## 단방향 연관관계 매핑\n\n### 일대다 단방향[1:N]\n일대다 단방향 관계 설정을 해보겠습니다. 예제는 아래의 테이블을 기반으로 설명하겠습니다. 아래는 회원과 주문테이블이 존재합니다. 회원은 자기가 주문한 정보를 참조할 필요가 있습니다. 그런데 주문에서는 회원정보를 참조할 필요가 없을 경우 일대다 단방향을 구성할 수 있습니다.\n\n![](https://i.imgur.com/aQdhBN6.png)\n\n### 일대다 단방향[1:N] 예제\n그렇게 되면 다음과 같이 1:N 단방향 관계 설정을 할 수 있습니다.\n```java\n@Entity\n@Getter\n@Table(name = \"member\")\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\npublic class Member {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\")\n    private long id;\n\n    @OneToMany\n    @JoinColumn(name = \"member_id\")\n    private List<Order> orders= new ArrayList<>();\n\n}\n```\n\n```java\n@Getter\n@Entity\n@Table(name = \"purchase_order\")\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\npublic class Order {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\")\n    private long id;\n\n}\n```\n\n**일대다 단방향 관계 주의할점**\n일대다 단방향 관계를 매핑할 때는 @JoinColumn을 명시해야 합니다. 그렇지 않으면 JPA는 연결 테이블을 중간에 두고 연관관계를 관리하는 조인 테이블 전략을 기본으로 사용해서 매핑하게 됩니다.\n\n**일대다 단방향 매핑의 단점**\n일대다 단방향 단점은 매핑 한 객체가 관리하는 외래 키가 다른 테이블에 있다는 점입니다. 본인 테이블에 외래 키가 있으면 엔터티의 저장과 연관 관계 처리를 INSERT SQL 한 번으로 끝낼 수 있지만, 다른 테이블에 외래 키가 있으면 연관관계 처리를 위한 UPDATE SQL을 추가로 실행해야 합니다.\n\n```sql\nHibernate: insert into purchase_order values ( )\nHibernate: insert into purchase_order values ( )\nHibernate: insert into member values ( )\nHibernate: update purchase_order set member_id=? where id=?\nHibernate: update purchase_order set member_id=? where id=?\n\n```\n\n다대일 단방향 또는 다대일 양방향은 아래와 같이 insert문 만으로 데이터가 테이블에 넣어집니다.\n\n```sql\nHibernate: insert into member values ( )\nHibernate: insert into purchase_order (member_id) values (?)\nHibernate: insert into purchase_order (member_id) values (?)\n```\n\n### 다대일 단방향[N:1]\n이번에는 반대로 회원 객체로는 주문한 정보를 참조할 일이 없고, 주문 객체가 회원정보를 참조해야 한다면 아까와 반대로 N:1 단방향의 관계 설정을 할 수 있을 것입니다. 다음과 같이 설정할 수 있습니다.\n\n### 다대일 단방향[N:1] 예제\n\n```java\n@Entity\n@Getter\n@Table(name = \"member\")\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\npublic class Member {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\")\n    private long id;\n\n}\n\n```\n\n\n```java\n\n\n@Getter\n@Entity\n@Table(name = \"purchase_order\")\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\npublic class Order {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\")\n    private long id;\n\n    @ManyToOne\n    @JoinColumn(name = \"member_id\", nullable = false, updatable = false)\n    private Member member;\n\n}\n\n```\n\n\n\n\n## 다대일 양방향[N:1]\n양방향 연관관계 설정은 주로 member에서도 order 객체를 참조할 일이 있고, order 객체에서도 member 객체를 참조해야 할 일이 있을 때 사용할 수 있습니다.\n\n### 다대일 양방향[N:1] 예제\n다음은 회원과 주문은 일대다 관계 설정을 양방향 관계로 한 예제입니다. 일대다 관계를 매핑하기 위해 @OneToMany 매핑 정보를 사용했습니다. mappedBy 속성은 양방향 매핑일 때 사용하는데 반대쪽 매핑의 필드 이름을 값으로 주면 됩니다. 이렇게되면 서로 참조할 수 있는 구조를 가지게됩니다.\n\n```java\n@Entity\n@Getter\n@Table(name = \"member\")\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\npublic class Member {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\")\n    private long id;\n\n    @OneToMany(mappedBy = \"member\")\n    private List<Order> orders= new ArrayList<>();\n\n}\n```\n\n\n```java\n@Getter\n@Entity\n@Table(name = \"purchase_order\")\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\npublic class Order {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\")\n    private long id;\n\n    @ManyToOne\n    @JoinColumn(name = \"member_id\", nullable = false, updatable = false)\n    private Member member;\n\n}\n\n```\n\n\n### 편의 메소드\n양방향 연관관계는 항상 서로 참조해야 합니다. 어느 한쪽만 참조하면 양방향 연관관계가 성립하지 않습니다. 물론 양방향 연관 관계의 주인만 변경해줘도 데이터베이스 외래 키 변경에 문제를 가지지는 않습니다. \n\n하지만 영속성 컨텍스트 내에서 연관관계 주인만 변경하고 참조되는 쪽에서 조회를 하면 변경되기 전 내용이 조회되기 때문에 문제를 가질 수 있습니다. \n\n먄약 주문내역에 회원이 변경된다면 다음과 같이 객체에 관계도 정리를 해줘야 합니다. 그렇기 때문에 주인이 변경될 때같이 참조되어 지는 쪽도 변경되어야 합니다. 위의 예제인 회원과 주문을 기반으로 편의 메서드를 만들어보겠습니다.\n\n* 회원을 변경하려는 주문 내역에 회원에서 해당 주문 내역을 제거한다.\n* 회원을 변경하려는 주문 내역에 새로운 회원을 설정한다.\n* 변경된 주문 내역 회원에도 해당 변경된 주문 내역을 설정해준다.\n\n위의 설명을 소스로 표현하면 다음과 같은 편의 메소드를 제공할 수 있습니다.\n\n```java\npublic void setMember(Member member) {\n    if(this.member !=null){\n      this.member.getOrders().remove(this);\n    }\n    this.member = member;\n    member.getOrders().add(this);\n}\n```\n\n\n## 다대다(N:N) 양방향\n\n관계형 데잍터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없습니다. 그래서 보통 다대다 관계를 일대다, 다대일 관계로 풀어내는 연결 테이블을 사용합니다. \n\n그래서 다음과 같이 주문을 할 때 여러 개의 제품을 주문해야 한다면 중간에 order_line이라는 연결 테이블을 두어 표현할 수 있습니다. 이것을 표현하는 방법은 @OneToMany @ManyToOne, 를 이용하는 방법이나 @ManyToMany 또는 @CollectionTable 등을 이용하는 방법이 있습니다.\n\n사실 @ManyToMany는 많이 사용되지 않는 어노테이션입니다. 보통 아래와 같이 테이블 구조를 가지게 되면 order_line에는 각각 제품에 주문량 주문금액 등이 표시되어야 하는데 @ManyToMany를 사용하면 order_line 테이블을 확장해나갈 수 없기 때문에 보통 @OneToMany @ManyToOne,@CollectionTable을 이용해 다대다를 풀어냅니다. 보통 @ManyToMany는 해당 매핑 테이블이 확장해나갈 일이 없는 경우에 사용할 수 있습니다.\n\n![](https://i.imgur.com/Zb1iB6I.png)\n\n여기에서는 ManyToMany 어노테이션을 이용해 테이블과 객체를 매핑할 것입니다.\n\n@ManyToMany 속성\n\n|속성|기능|\n|-|-|\n|name |매핑할 외래 키 이름 |\n| joinColumns | 현재 테이블과 조인할 컬럼 명을 정한다. |\n| inverseJoinColumns | 반대 방향인 상품과 매핑할 조인 컬럼 정보를 지정한다. |\n\n### 다대다(N:N) 양방향 예제\n\n```java\n@Getter\n@Entity\n@Table(name = \"purchase_order\")\n@NoArgsConstructor\npublic class Order {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\")\n    private long id;\n\n    @ManyToMany\n    @JoinTable(name = \"order_line\",\n            joinColumns = @JoinColumn(name = \"order_id\"),\n            inverseJoinColumns = @JoinColumn(name = \"product_id\")\n    )\n    private List<Product> products = new ArrayList<>();\n\n}\n\n```\n\n\n\n```java\n@Entity\n@Getter\n@Table(name = \"product\")\n@NoArgsConstructor(access = AccessLevel.PROTECTED)\npublic class Product {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\")\n    private long id;\n\n    @ManyToMany(mappedBy = \"products\")\n    private List<Order> orders = new ArrayList<>();\n    \n}\n\n```\n\n\n\n## 다대다 연관관계 정리\n다대다 관계 설정이나 외래 키를 설정하다 보면 해당 외래 키를 사용하여 복합키를 사용할 건지 단순히 외래 키로 사용할지 선택해야 합니다. 아래는 이 외래 키를 가지고 어떻게 설정하느냐에 따라 식별 관계, 비실 별 관계가 되는지에 대한 설명입니다.\n\n식별 관계 : 받아온 식별자를 기본 키 + 외래 키로 사용한다.\n비식별 관계 : 받아온 식별자는 외래키로만 사용하고 새로운 식별자를 추가한다.\n\n보통 JPA에서는 식별 관계를 사용하기 보다는 비식별관계로 사용합니다. 이유는 복합키를 위한 식별자 클래스를 만들지 않아도 되기 때문입니다.\n\n\n[예제소스](https://github.com/minwan1/blog-example/tree/master/jpa-relation)\n\n## 마치며\nJPA에서 사용하는 관계 설정에 대해 짧게 알아봤습니다. 여기에서 중요한 것은 위에서 설명했던 예제 중에 상황에 맞게 잘 선택해서 관계 설정을 하면 된다는 것입니다. 굳이 사용하지 않는 참조를 사용해서 순환 참조를 만난다거나 의미 없는 도메인 관계를 만들 수 있기 때문입니다. 이렇게 되면 각각 도메인이 표현하고자 하는 범위를 넘어선 책임을 할 수 있기 때문에 좋지 않은 설계가 될 수 있습니다.\n\n\n참고\n\n* [자바 ORM 표준 JPA 프로그래밍](http://book.naver.com/bookdb/book_detail.nhn?bid=9252528)\n","slug":"2018-12-26-jpa-관계설정","published":1,"updated":"2018-12-25T15:44:30.209Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27e70035jjpefv4w3w33","content":"<h1><span id=\"jpa-관계-설정\">JPA 관계 설정</span></h1>\n<!-- TOC -->\n<ul>\n<li><a href=\"#jpa-%EA%B4%80%EA%B3%84-%EC%84%A4%EC%A0%95\">JPA 관계 설정</a>\n<ul>\n<li><a href=\"#jpa-%EA%B4%80%EA%B3%84-%EC%84%A4%EC%A0%95%EC%9D%B4%EB%9E%80\">JPA 관계 설정이란</a></li>\n<li><a href=\"#%EB%8B%A8%EB%B0%A9%ED%96%A5-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91\">단방향 연관관계 매핑</a>\n<ul>\n<li><a href=\"#%EC%9D%BC%EB%8C%80%EB%8B%A4-%EB%8B%A8%EB%B0%A9%ED%96%A51n\">일대다 단방향[1:N]</a></li>\n<li><a href=\"#%EC%9D%BC%EB%8C%80%EB%8B%A4-%EB%8B%A8%EB%B0%A9%ED%96%A51n-%EC%98%88%EC%A0%9C\">일대다 단방향[1:N] 예제</a></li>\n<li><a href=\"#%EB%8B%A4%EB%8C%80%EC%9D%BC-%EB%8B%A8%EB%B0%A9%ED%96%A5n1\">다대일 단방향[N:1]</a></li>\n<li><a href=\"#%EB%8B%A4%EB%8C%80%EC%9D%BC-%EB%8B%A8%EB%B0%A9%ED%96%A5n1-%EC%98%88%EC%A0%9C\">다대일 단방향[N:1] 예제</a></li>\n</ul>\n</li>\n<li><a href=\"#%EB%8B%A4%EB%8C%80%EC%9D%BC-%EC%96%91%EB%B0%A9%ED%96%A5n1\">다대일 양방향[N:1]</a>\n<ul>\n<li><a href=\"#%EB%8B%A4%EB%8C%80%EC%9D%BC-%EC%96%91%EB%B0%A9%ED%96%A5n1-%EC%98%88%EC%A0%9C\">다대일 양방향[N:1] 예제</a></li>\n<li><a href=\"#%ED%8E%B8%EC%9D%98-%EB%A9%94%EC%86%8C%EB%93%9C\">편의 메소드</a></li>\n</ul>\n</li>\n<li><a href=\"#%EB%8B%A4%EB%8C%80%EB%8B%A4nn-%EC%96%91%EB%B0%A9%ED%96%A5\">다대다(N:N) 양방향</a>\n<ul>\n<li><a href=\"#%EB%8B%A4%EB%8C%80%EB%8B%A4nn-%EC%96%91%EB%B0%A9%ED%96%A5-%EC%98%88%EC%A0%9C\">다대다(N:N) 양방향 예제</a></li>\n</ul>\n</li>\n<li><a href=\"#%EB%8B%A4%EB%8C%80%EB%8B%A4-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EC%A0%95%EB%A6%AC\">다대다 연관관계 정리</a></li>\n<li><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h2><span id=\"jpa-관계-설정이란\">JPA 관계 설정이란</span></h2>\n<p>엔터티 또는 도메인들은 각각 관계를 맺고 있습니다. 예를 들어 유저는 여러 개의 제품을 주문할 수 있다고 하면 유저 엔터티는 주문 엔터티와 관계를 갖습니다. 또 주문 엔터티는 어떠한 제품이 주문됐는지 알아야 하기 때문에 제품엔터티와 관계를 맺습니다.</p>\n<p>JPA에서 관계 설정을 하게 되면 알아서 객체에서는 참조를 사용해서 관계를 맺고 테이블은 외래 키를 통해 관계를 맺은 후 서로 매핑을 해놓습니다. 이제 이렇게 되면 개발자는 객체 간의 관계 또 그사이에서 생성되어야만 하는 SQL 문들을 신경 쓸 필요 없이 객체 간의 관계만 신경 쓰면 되기 때문에 비즈니스 로직에 집중할 수 있습니다.</p>\n<p><strong>방향</strong><br>\n관계 설정은 단방향, 양방향으로 관계를 맺을 수 있습니다. 예를 들어 회원 -&gt; 주문, 주문 -&gt; 회원 한쪽만 참고가 필요하다면 단순 당 방향으로 설정할 수 있고, 반대로 양쪽 다 회원 -&gt; 주문, 주문 -&gt; 회원을 둘 다 참고해야 한다면 양방향으로 설정할 수 있습니다. <strong>방향은 객체 관계에만 존재하고 테이블 관계는 항상 양방향입니다.</strong></p>\n<p><strong>연관관계의 주인</strong><br>\n객체를 양방향 연관 관계로 만들면 연관관계의 주인을 정해야 합니다. 이러한 주인은 보통 외래 키를 관리하는 엔터티가 주인이 됩니다. 연관 관계의 주인을 정한다는 것은 사실 외래 키 관리자를 선택하는 것입니다.</p>\n<p><strong>관계 종류</strong><br>\n관계 설정은 일대일, 일대다, 다대일, 다대다 관계가 있을 수 있습니다.</p>\n<p><strong>@JoinColumn</strong></p>\n<p>이 어노테이션은 객체 간에 관계를 설정한 후 외래 키를 매핑할 때 사용합니다. 그냥 객체 간에 관계 설정을 해주면 필드 + _ + 참조하는 테이블의 기본 키 칼럼명으로 가져가게 됩니다.</p>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>기능</th>\n<th>기본값</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td>매핑할 외래 키 이름</td>\n<td>필드 + _ + 참조하는 테이블의 기본키 컬럼명</td>\n</tr>\n<tr>\n<td>referencedColumnName</td>\n<td>외래키가 참조하는 대상 테이블의 컬럼명</td>\n<td>참조하는 테이블의 기본키 컬럼명</td>\n</tr>\n<tr>\n<td>foreignKey(DDL)</td>\n<td>외래 키 제약 조건을 직접 지정할 수 있다.<br> 이 속성은 테이블을 생성할 때만 사용한다.</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>아래에서는 1:N, N:1, N:N에 관계 설정을 하겠습니다.</p>\n<h2><span id=\"단방향-연관관계-매핑\">단방향 연관관계 매핑</span></h2>\n<h3><span id=\"일대다-단방향1n\">일대다 단방향[1:N]</span></h3>\n<p>일대다 단방향 관계 설정을 해보겠습니다. 예제는 아래의 테이블을 기반으로 설명하겠습니다. 아래는 회원과 주문테이블이 존재합니다. 회원은 자기가 주문한 정보를 참조할 필요가 있습니다. 그런데 주문에서는 회원정보를 참조할 필요가 없을 경우 일대다 단방향을 구성할 수 있습니다.</p>\n<p><img src=\"https://i.imgur.com/aQdhBN6.png\" alt=\"\"></p>\n<h3><span id=\"일대다-단방향1n-예제\">일대다 단방향[1:N] 예제</span></h3>\n<p>그렇게 되면 다음과 같이 1:N 단방향 관계 설정을 할 수 있습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Table</span>(name = <span class=\"string\">\"member\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PROTECTED)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"id\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OneToMany</span></span><br><span class=\"line\">    <span class=\"meta\">@JoinColumn</span>(name = <span class=\"string\">\"member_id\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Order&gt; orders= <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Table</span>(name = <span class=\"string\">\"purchase_order\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PROTECTED)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Order</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"id\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>일대다 단방향 관계 주의할점</strong><br>\n일대다 단방향 관계를 매핑할 때는 @JoinColumn을 명시해야 합니다. 그렇지 않으면 JPA는 연결 테이블을 중간에 두고 연관관계를 관리하는 조인 테이블 전략을 기본으로 사용해서 매핑하게 됩니다.</p>\n<p><strong>일대다 단방향 매핑의 단점</strong><br>\n일대다 단방향 단점은 매핑 한 객체가 관리하는 외래 키가 다른 테이블에 있다는 점입니다. 본인 테이블에 외래 키가 있으면 엔터티의 저장과 연관 관계 처리를 INSERT SQL 한 번으로 끝낼 수 있지만, 다른 테이블에 외래 키가 있으면 연관관계 처리를 위한 UPDATE SQL을 추가로 실행해야 합니다.</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hibernate: <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> purchase_order <span class=\"keyword\">values</span> ( )</span><br><span class=\"line\">Hibernate: <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> purchase_order <span class=\"keyword\">values</span> ( )</span><br><span class=\"line\">Hibernate: <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> <span class=\"keyword\">member</span> <span class=\"keyword\">values</span> ( )</span><br><span class=\"line\">Hibernate: <span class=\"keyword\">update</span> purchase_order <span class=\"keyword\">set</span> member_id=? <span class=\"keyword\">where</span> <span class=\"keyword\">id</span>=?</span><br><span class=\"line\">Hibernate: <span class=\"keyword\">update</span> purchase_order <span class=\"keyword\">set</span> member_id=? <span class=\"keyword\">where</span> <span class=\"keyword\">id</span>=?</span><br></pre></td></tr></table></figure>\n<p>다대일 단방향 또는 다대일 양방향은 아래와 같이 insert문 만으로 데이터가 테이블에 넣어집니다.</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hibernate: <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> <span class=\"keyword\">member</span> <span class=\"keyword\">values</span> ( )</span><br><span class=\"line\">Hibernate: <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> purchase_order (member_id) <span class=\"keyword\">values</span> (?)</span><br><span class=\"line\">Hibernate: <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> purchase_order (member_id) <span class=\"keyword\">values</span> (?)</span><br></pre></td></tr></table></figure>\n<h3><span id=\"다대일-단방향n1\">다대일 단방향[N:1]</span></h3>\n<p>이번에는 반대로 회원 객체로는 주문한 정보를 참조할 일이 없고, 주문 객체가 회원정보를 참조해야 한다면 아까와 반대로 N:1 단방향의 관계 설정을 할 수 있을 것입니다. 다음과 같이 설정할 수 있습니다.</p>\n<h3><span id=\"다대일-단방향n1-예제\">다대일 단방향[N:1] 예제</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Table</span>(name = <span class=\"string\">\"member\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PROTECTED)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"id\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Table</span>(name = <span class=\"string\">\"purchase_order\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PROTECTED)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Order</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"id\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ManyToOne</span></span><br><span class=\"line\">    <span class=\"meta\">@JoinColumn</span>(name = <span class=\"string\">\"member_id\"</span>, nullable = <span class=\"keyword\">false</span>, updatable = <span class=\"keyword\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Member member;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"다대일-양방향n1\">다대일 양방향[N:1]</span></h2>\n<p>양방향 연관관계 설정은 주로 member에서도 order 객체를 참조할 일이 있고, order 객체에서도 member 객체를 참조해야 할 일이 있을 때 사용할 수 있습니다.</p>\n<h3><span id=\"다대일-양방향n1-예제\">다대일 양방향[N:1] 예제</span></h3>\n<p>다음은 회원과 주문은 일대다 관계 설정을 양방향 관계로 한 예제입니다. 일대다 관계를 매핑하기 위해 @OneToMany 매핑 정보를 사용했습니다. mappedBy 속성은 양방향 매핑일 때 사용하는데 반대쪽 매핑의 필드 이름을 값으로 주면 됩니다. 이렇게되면 서로 참조할 수 있는 구조를 가지게됩니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Table</span>(name = <span class=\"string\">\"member\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PROTECTED)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"id\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OneToMany</span>(mappedBy = <span class=\"string\">\"member\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Order&gt; orders= <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Table</span>(name = <span class=\"string\">\"purchase_order\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PROTECTED)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Order</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"id\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ManyToOne</span></span><br><span class=\"line\">    <span class=\"meta\">@JoinColumn</span>(name = <span class=\"string\">\"member_id\"</span>, nullable = <span class=\"keyword\">false</span>, updatable = <span class=\"keyword\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Member member;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"편의-메소드\">편의 메소드</span></h3>\n<p>양방향 연관관계는 항상 서로 참조해야 합니다. 어느 한쪽만 참조하면 양방향 연관관계가 성립하지 않습니다. 물론 양방향 연관 관계의 주인만 변경해줘도 데이터베이스 외래 키 변경에 문제를 가지지는 않습니다.</p>\n<p>하지만 영속성 컨텍스트 내에서 연관관계 주인만 변경하고 참조되는 쪽에서 조회를 하면 변경되기 전 내용이 조회되기 때문에 문제를 가질 수 있습니다.</p>\n<p>먄약 주문내역에 회원이 변경된다면 다음과 같이 객체에 관계도 정리를 해줘야 합니다. 그렇기 때문에 주인이 변경될 때같이 참조되어 지는 쪽도 변경되어야 합니다. 위의 예제인 회원과 주문을 기반으로 편의 메서드를 만들어보겠습니다.</p>\n<ul>\n<li>회원을 변경하려는 주문 내역에 회원에서 해당 주문 내역을 제거한다.</li>\n<li>회원을 변경하려는 주문 내역에 새로운 회원을 설정한다.</li>\n<li>변경된 주문 내역 회원에도 해당 변경된 주문 내역을 설정해준다.</li>\n</ul>\n<p>위의 설명을 소스로 표현하면 다음과 같은 편의 메소드를 제공할 수 있습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMember</span><span class=\"params\">(Member member)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.member !=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.member.getOrders().remove(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.member = member;</span><br><span class=\"line\">    member.getOrders().add(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"다대다nn-양방향\">다대다(N:N) 양방향</span></h2>\n<p>관계형 데잍터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없습니다. 그래서 보통 다대다 관계를 일대다, 다대일 관계로 풀어내는 연결 테이블을 사용합니다.</p>\n<p>그래서 다음과 같이 주문을 할 때 여러 개의 제품을 주문해야 한다면 중간에 order_line이라는 연결 테이블을 두어 표현할 수 있습니다. 이것을 표현하는 방법은 @OneToMany @ManyToOne, 를 이용하는 방법이나 @ManyToMany 또는 @CollectionTable 등을 이용하는 방법이 있습니다.</p>\n<p>사실 @ManyToMany는 많이 사용되지 않는 어노테이션입니다. 보통 아래와 같이 테이블 구조를 가지게 되면 order_line에는 각각 제품에 주문량 주문금액 등이 표시되어야 하는데 @ManyToMany를 사용하면 order_line 테이블을 확장해나갈 수 없기 때문에 보통 @OneToMany @ManyToOne,@CollectionTable을 이용해 다대다를 풀어냅니다. 보통 @ManyToMany는 해당 매핑 테이블이 확장해나갈 일이 없는 경우에 사용할 수 있습니다.</p>\n<p><img src=\"https://i.imgur.com/Zb1iB6I.png\" alt=\"\"></p>\n<p>여기에서는 ManyToMany 어노테이션을 이용해 테이블과 객체를 매핑할 것입니다.</p>\n<p>@ManyToMany 속성</p>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>기능</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td>매핑할 외래 키 이름</td>\n</tr>\n<tr>\n<td>joinColumns</td>\n<td>현재 테이블과 조인할 컬럼 명을 정한다.</td>\n</tr>\n<tr>\n<td>inverseJoinColumns</td>\n<td>반대 방향인 상품과 매핑할 조인 컬럼 정보를 지정한다.</td>\n</tr>\n</tbody>\n</table>\n<h3><span id=\"다대다nn-양방향-예제\">다대다(N:N) 양방향 예제</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Table</span>(name = <span class=\"string\">\"purchase_order\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Order</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"id\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ManyToMany</span></span><br><span class=\"line\">    <span class=\"meta\">@JoinTable</span>(name = <span class=\"string\">\"order_line\"</span>,</span><br><span class=\"line\">            joinColumns = <span class=\"meta\">@JoinColumn</span>(name = <span class=\"string\">\"order_id\"</span>),</span><br><span class=\"line\">            inverseJoinColumns = <span class=\"meta\">@JoinColumn</span>(name = <span class=\"string\">\"product_id\"</span>)</span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Product&gt; products = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Table</span>(name = <span class=\"string\">\"product\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PROTECTED)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Product</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"id\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ManyToMany</span>(mappedBy = <span class=\"string\">\"products\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Order&gt; orders = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"다대다-연관관계-정리\">다대다 연관관계 정리</span></h2>\n<p>다대다 관계 설정이나 외래 키를 설정하다 보면 해당 외래 키를 사용하여 복합키를 사용할 건지 단순히 외래 키로 사용할지 선택해야 합니다. 아래는 이 외래 키를 가지고 어떻게 설정하느냐에 따라 식별 관계, 비실 별 관계가 되는지에 대한 설명입니다.</p>\n<p>식별 관계 : 받아온 식별자를 기본 키 + 외래 키로 사용한다.<br>\n비식별 관계 : 받아온 식별자는 외래키로만 사용하고 새로운 식별자를 추가한다.</p>\n<p>보통 JPA에서는 식별 관계를 사용하기 보다는 비식별관계로 사용합니다. 이유는 복합키를 위한 식별자 클래스를 만들지 않아도 되기 때문입니다.</p>\n<p><a href=\"https://github.com/minwan1/blog-example/tree/master/jpa-relation\" target=\"_blank\" rel=\"noopener\">예제소스</a></p>\n<h2><span id=\"마치며\">마치며</span></h2>\n<p>JPA에서 사용하는 관계 설정에 대해 짧게 알아봤습니다. 여기에서 중요한 것은 위에서 설명했던 예제 중에 상황에 맞게 잘 선택해서 관계 설정을 하면 된다는 것입니다. 굳이 사용하지 않는 참조를 사용해서 순환 참조를 만난다거나 의미 없는 도메인 관계를 만들 수 있기 때문입니다. 이렇게 되면 각각 도메인이 표현하고자 하는 범위를 넘어선 책임을 할 수 있기 때문에 좋지 않은 설계가 될 수 있습니다.</p>\n<p>참고</p>\n<ul>\n<li><a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=9252528\" target=\"_blank\" rel=\"noopener\">자바 ORM 표준 JPA 프로그래밍</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>JPA 관계 설정</h1>\n<!-- TOC -->\n<ul>\n<li><a href=\"#jpa-%EA%B4%80%EA%B3%84-%EC%84%A4%EC%A0%95\">JPA 관계 설정</a>\n<ul>\n<li><a href=\"#jpa-%EA%B4%80%EA%B3%84-%EC%84%A4%EC%A0%95%EC%9D%B4%EB%9E%80\">JPA 관계 설정이란</a></li>\n<li><a href=\"#%EB%8B%A8%EB%B0%A9%ED%96%A5-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91\">단방향 연관관계 매핑</a>\n<ul>\n<li><a href=\"#%EC%9D%BC%EB%8C%80%EB%8B%A4-%EB%8B%A8%EB%B0%A9%ED%96%A51n\">일대다 단방향[1:N]</a></li>\n<li><a href=\"#%EC%9D%BC%EB%8C%80%EB%8B%A4-%EB%8B%A8%EB%B0%A9%ED%96%A51n-%EC%98%88%EC%A0%9C\">일대다 단방향[1:N] 예제</a></li>\n<li><a href=\"#%EB%8B%A4%EB%8C%80%EC%9D%BC-%EB%8B%A8%EB%B0%A9%ED%96%A5n1\">다대일 단방향[N:1]</a></li>\n<li><a href=\"#%EB%8B%A4%EB%8C%80%EC%9D%BC-%EB%8B%A8%EB%B0%A9%ED%96%A5n1-%EC%98%88%EC%A0%9C\">다대일 단방향[N:1] 예제</a></li>\n</ul>\n</li>\n<li><a href=\"#%EB%8B%A4%EB%8C%80%EC%9D%BC-%EC%96%91%EB%B0%A9%ED%96%A5n1\">다대일 양방향[N:1]</a>\n<ul>\n<li><a href=\"#%EB%8B%A4%EB%8C%80%EC%9D%BC-%EC%96%91%EB%B0%A9%ED%96%A5n1-%EC%98%88%EC%A0%9C\">다대일 양방향[N:1] 예제</a></li>\n<li><a href=\"#%ED%8E%B8%EC%9D%98-%EB%A9%94%EC%86%8C%EB%93%9C\">편의 메소드</a></li>\n</ul>\n</li>\n<li><a href=\"#%EB%8B%A4%EB%8C%80%EB%8B%A4nn-%EC%96%91%EB%B0%A9%ED%96%A5\">다대다(N:N) 양방향</a>\n<ul>\n<li><a href=\"#%EB%8B%A4%EB%8C%80%EB%8B%A4nn-%EC%96%91%EB%B0%A9%ED%96%A5-%EC%98%88%EC%A0%9C\">다대다(N:N) 양방향 예제</a></li>\n</ul>\n</li>\n<li><a href=\"#%EB%8B%A4%EB%8C%80%EB%8B%A4-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EC%A0%95%EB%A6%AC\">다대다 연관관계 정리</a></li>\n<li><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B0\">마치며</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h2>JPA 관계 설정이란</h2>\n<p>엔터티 또는 도메인들은 각각 관계를 맺고 있습니다. 예를 들어 유저는 여러 개의 제품을 주문할 수 있다고 하면 유저 엔터티는 주문 엔터티와 관계를 갖습니다. 또 주문 엔터티는 어떠한 제품이 주문됐는지 알아야 하기 때문에 제품엔터티와 관계를 맺습니다.</p>\n<p>JPA에서 관계 설정을 하게 되면 알아서 객체에서는 참조를 사용해서 관계를 맺고 테이블은 외래 키를 통해 관계를 맺은 후 서로 매핑을 해놓습니다. 이제 이렇게 되면 개발자는 객체 간의 관계 또 그사이에서 생성되어야만 하는 SQL 문들을 신경 쓸 필요 없이 객체 간의 관계만 신경 쓰면 되기 때문에 비즈니스 로직에 집중할 수 있습니다.</p>\n<p><strong>방향</strong><br>\n관계 설정은 단방향, 양방향으로 관계를 맺을 수 있습니다. 예를 들어 회원 -&gt; 주문, 주문 -&gt; 회원 한쪽만 참고가 필요하다면 단순 당 방향으로 설정할 수 있고, 반대로 양쪽 다 회원 -&gt; 주문, 주문 -&gt; 회원을 둘 다 참고해야 한다면 양방향으로 설정할 수 있습니다. <strong>방향은 객체 관계에만 존재하고 테이블 관계는 항상 양방향입니다.</strong></p>\n<p><strong>연관관계의 주인</strong><br>\n객체를 양방향 연관 관계로 만들면 연관관계의 주인을 정해야 합니다. 이러한 주인은 보통 외래 키를 관리하는 엔터티가 주인이 됩니다. 연관 관계의 주인을 정한다는 것은 사실 외래 키 관리자를 선택하는 것입니다.</p>\n<p><strong>관계 종류</strong><br>\n관계 설정은 일대일, 일대다, 다대일, 다대다 관계가 있을 수 있습니다.</p>\n<p><strong>@JoinColumn</strong></p>\n<p>이 어노테이션은 객체 간에 관계를 설정한 후 외래 키를 매핑할 때 사용합니다. 그냥 객체 간에 관계 설정을 해주면 필드 + _ + 참조하는 테이블의 기본 키 칼럼명으로 가져가게 됩니다.</p>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>기능</th>\n<th>기본값</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td>매핑할 외래 키 이름</td>\n<td>필드 + _ + 참조하는 테이블의 기본키 컬럼명</td>\n</tr>\n<tr>\n<td>referencedColumnName</td>\n<td>외래키가 참조하는 대상 테이블의 컬럼명</td>\n<td>참조하는 테이블의 기본키 컬럼명</td>\n</tr>\n<tr>\n<td>foreignKey(DDL)</td>\n<td>외래 키 제약 조건을 직접 지정할 수 있다.<br> 이 속성은 테이블을 생성할 때만 사용한다.</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>아래에서는 1:N, N:1, N:N에 관계 설정을 하겠습니다.</p>\n<h2>단방향 연관관계 매핑</h2>\n<h3>일대다 단방향[1:N]</h3>\n<p>일대다 단방향 관계 설정을 해보겠습니다. 예제는 아래의 테이블을 기반으로 설명하겠습니다. 아래는 회원과 주문테이블이 존재합니다. 회원은 자기가 주문한 정보를 참조할 필요가 있습니다. 그런데 주문에서는 회원정보를 참조할 필요가 없을 경우 일대다 단방향을 구성할 수 있습니다.</p>\n<p><img src=\"https://i.imgur.com/aQdhBN6.png\" alt=\"\"></p>\n<h3>일대다 단방향[1:N] 예제</h3>\n<p>그렇게 되면 다음과 같이 1:N 단방향 관계 설정을 할 수 있습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Table</span>(name = <span class=\"string\">\"member\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PROTECTED)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"id\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OneToMany</span></span><br><span class=\"line\">    <span class=\"meta\">@JoinColumn</span>(name = <span class=\"string\">\"member_id\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Order&gt; orders= <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Table</span>(name = <span class=\"string\">\"purchase_order\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PROTECTED)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Order</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"id\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>일대다 단방향 관계 주의할점</strong><br>\n일대다 단방향 관계를 매핑할 때는 @JoinColumn을 명시해야 합니다. 그렇지 않으면 JPA는 연결 테이블을 중간에 두고 연관관계를 관리하는 조인 테이블 전략을 기본으로 사용해서 매핑하게 됩니다.</p>\n<p><strong>일대다 단방향 매핑의 단점</strong><br>\n일대다 단방향 단점은 매핑 한 객체가 관리하는 외래 키가 다른 테이블에 있다는 점입니다. 본인 테이블에 외래 키가 있으면 엔터티의 저장과 연관 관계 처리를 INSERT SQL 한 번으로 끝낼 수 있지만, 다른 테이블에 외래 키가 있으면 연관관계 처리를 위한 UPDATE SQL을 추가로 실행해야 합니다.</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hibernate: <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> purchase_order <span class=\"keyword\">values</span> ( )</span><br><span class=\"line\">Hibernate: <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> purchase_order <span class=\"keyword\">values</span> ( )</span><br><span class=\"line\">Hibernate: <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> <span class=\"keyword\">member</span> <span class=\"keyword\">values</span> ( )</span><br><span class=\"line\">Hibernate: <span class=\"keyword\">update</span> purchase_order <span class=\"keyword\">set</span> member_id=? <span class=\"keyword\">where</span> <span class=\"keyword\">id</span>=?</span><br><span class=\"line\">Hibernate: <span class=\"keyword\">update</span> purchase_order <span class=\"keyword\">set</span> member_id=? <span class=\"keyword\">where</span> <span class=\"keyword\">id</span>=?</span><br></pre></td></tr></table></figure>\n<p>다대일 단방향 또는 다대일 양방향은 아래와 같이 insert문 만으로 데이터가 테이블에 넣어집니다.</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hibernate: <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> <span class=\"keyword\">member</span> <span class=\"keyword\">values</span> ( )</span><br><span class=\"line\">Hibernate: <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> purchase_order (member_id) <span class=\"keyword\">values</span> (?)</span><br><span class=\"line\">Hibernate: <span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> purchase_order (member_id) <span class=\"keyword\">values</span> (?)</span><br></pre></td></tr></table></figure>\n<h3>다대일 단방향[N:1]</h3>\n<p>이번에는 반대로 회원 객체로는 주문한 정보를 참조할 일이 없고, 주문 객체가 회원정보를 참조해야 한다면 아까와 반대로 N:1 단방향의 관계 설정을 할 수 있을 것입니다. 다음과 같이 설정할 수 있습니다.</p>\n<h3>다대일 단방향[N:1] 예제</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Table</span>(name = <span class=\"string\">\"member\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PROTECTED)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"id\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Table</span>(name = <span class=\"string\">\"purchase_order\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PROTECTED)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Order</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"id\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ManyToOne</span></span><br><span class=\"line\">    <span class=\"meta\">@JoinColumn</span>(name = <span class=\"string\">\"member_id\"</span>, nullable = <span class=\"keyword\">false</span>, updatable = <span class=\"keyword\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Member member;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>다대일 양방향[N:1]</h2>\n<p>양방향 연관관계 설정은 주로 member에서도 order 객체를 참조할 일이 있고, order 객체에서도 member 객체를 참조해야 할 일이 있을 때 사용할 수 있습니다.</p>\n<h3>다대일 양방향[N:1] 예제</h3>\n<p>다음은 회원과 주문은 일대다 관계 설정을 양방향 관계로 한 예제입니다. 일대다 관계를 매핑하기 위해 @OneToMany 매핑 정보를 사용했습니다. mappedBy 속성은 양방향 매핑일 때 사용하는데 반대쪽 매핑의 필드 이름을 값으로 주면 됩니다. 이렇게되면 서로 참조할 수 있는 구조를 가지게됩니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Table</span>(name = <span class=\"string\">\"member\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PROTECTED)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Member</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"id\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OneToMany</span>(mappedBy = <span class=\"string\">\"member\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Order&gt; orders= <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Table</span>(name = <span class=\"string\">\"purchase_order\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PROTECTED)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Order</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"id\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ManyToOne</span></span><br><span class=\"line\">    <span class=\"meta\">@JoinColumn</span>(name = <span class=\"string\">\"member_id\"</span>, nullable = <span class=\"keyword\">false</span>, updatable = <span class=\"keyword\">false</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Member member;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>편의 메소드</h3>\n<p>양방향 연관관계는 항상 서로 참조해야 합니다. 어느 한쪽만 참조하면 양방향 연관관계가 성립하지 않습니다. 물론 양방향 연관 관계의 주인만 변경해줘도 데이터베이스 외래 키 변경에 문제를 가지지는 않습니다.</p>\n<p>하지만 영속성 컨텍스트 내에서 연관관계 주인만 변경하고 참조되는 쪽에서 조회를 하면 변경되기 전 내용이 조회되기 때문에 문제를 가질 수 있습니다.</p>\n<p>먄약 주문내역에 회원이 변경된다면 다음과 같이 객체에 관계도 정리를 해줘야 합니다. 그렇기 때문에 주인이 변경될 때같이 참조되어 지는 쪽도 변경되어야 합니다. 위의 예제인 회원과 주문을 기반으로 편의 메서드를 만들어보겠습니다.</p>\n<ul>\n<li>회원을 변경하려는 주문 내역에 회원에서 해당 주문 내역을 제거한다.</li>\n<li>회원을 변경하려는 주문 내역에 새로운 회원을 설정한다.</li>\n<li>변경된 주문 내역 회원에도 해당 변경된 주문 내역을 설정해준다.</li>\n</ul>\n<p>위의 설명을 소스로 표현하면 다음과 같은 편의 메소드를 제공할 수 있습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setMember</span><span class=\"params\">(Member member)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.member !=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.member.getOrders().remove(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.member = member;</span><br><span class=\"line\">    member.getOrders().add(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>다대다(N:N) 양방향</h2>\n<p>관계형 데잍터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없습니다. 그래서 보통 다대다 관계를 일대다, 다대일 관계로 풀어내는 연결 테이블을 사용합니다.</p>\n<p>그래서 다음과 같이 주문을 할 때 여러 개의 제품을 주문해야 한다면 중간에 order_line이라는 연결 테이블을 두어 표현할 수 있습니다. 이것을 표현하는 방법은 @OneToMany @ManyToOne, 를 이용하는 방법이나 @ManyToMany 또는 @CollectionTable 등을 이용하는 방법이 있습니다.</p>\n<p>사실 @ManyToMany는 많이 사용되지 않는 어노테이션입니다. 보통 아래와 같이 테이블 구조를 가지게 되면 order_line에는 각각 제품에 주문량 주문금액 등이 표시되어야 하는데 @ManyToMany를 사용하면 order_line 테이블을 확장해나갈 수 없기 때문에 보통 @OneToMany @ManyToOne,@CollectionTable을 이용해 다대다를 풀어냅니다. 보통 @ManyToMany는 해당 매핑 테이블이 확장해나갈 일이 없는 경우에 사용할 수 있습니다.</p>\n<p><img src=\"https://i.imgur.com/Zb1iB6I.png\" alt=\"\"></p>\n<p>여기에서는 ManyToMany 어노테이션을 이용해 테이블과 객체를 매핑할 것입니다.</p>\n<p>@ManyToMany 속성</p>\n<table>\n<thead>\n<tr>\n<th>속성</th>\n<th>기능</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>name</td>\n<td>매핑할 외래 키 이름</td>\n</tr>\n<tr>\n<td>joinColumns</td>\n<td>현재 테이블과 조인할 컬럼 명을 정한다.</td>\n</tr>\n<tr>\n<td>inverseJoinColumns</td>\n<td>반대 방향인 상품과 매핑할 조인 컬럼 정보를 지정한다.</td>\n</tr>\n</tbody>\n</table>\n<h3>다대다(N:N) 양방향 예제</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Table</span>(name = <span class=\"string\">\"purchase_order\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Order</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"id\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ManyToMany</span></span><br><span class=\"line\">    <span class=\"meta\">@JoinTable</span>(name = <span class=\"string\">\"order_line\"</span>,</span><br><span class=\"line\">            joinColumns = <span class=\"meta\">@JoinColumn</span>(name = <span class=\"string\">\"order_id\"</span>),</span><br><span class=\"line\">            inverseJoinColumns = <span class=\"meta\">@JoinColumn</span>(name = <span class=\"string\">\"product_id\"</span>)</span><br><span class=\"line\">    )</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Product&gt; products = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Table</span>(name = <span class=\"string\">\"product\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span>(access = AccessLevel.PROTECTED)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Product</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Id</span></span><br><span class=\"line\">    <span class=\"meta\">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class=\"line\">    <span class=\"meta\">@Column</span>(name = <span class=\"string\">\"id\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@ManyToMany</span>(mappedBy = <span class=\"string\">\"products\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;Order&gt; orders = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>다대다 연관관계 정리</h2>\n<p>다대다 관계 설정이나 외래 키를 설정하다 보면 해당 외래 키를 사용하여 복합키를 사용할 건지 단순히 외래 키로 사용할지 선택해야 합니다. 아래는 이 외래 키를 가지고 어떻게 설정하느냐에 따라 식별 관계, 비실 별 관계가 되는지에 대한 설명입니다.</p>\n<p>식별 관계 : 받아온 식별자를 기본 키 + 외래 키로 사용한다.<br>\n비식별 관계 : 받아온 식별자는 외래키로만 사용하고 새로운 식별자를 추가한다.</p>\n<p>보통 JPA에서는 식별 관계를 사용하기 보다는 비식별관계로 사용합니다. 이유는 복합키를 위한 식별자 클래스를 만들지 않아도 되기 때문입니다.</p>\n<p><a href=\"https://github.com/minwan1/blog-example/tree/master/jpa-relation\" target=\"_blank\" rel=\"noopener\">예제소스</a></p>\n<h2>마치며</h2>\n<p>JPA에서 사용하는 관계 설정에 대해 짧게 알아봤습니다. 여기에서 중요한 것은 위에서 설명했던 예제 중에 상황에 맞게 잘 선택해서 관계 설정을 하면 된다는 것입니다. 굳이 사용하지 않는 참조를 사용해서 순환 참조를 만난다거나 의미 없는 도메인 관계를 만들 수 있기 때문입니다. 이렇게 되면 각각 도메인이 표현하고자 하는 범위를 넘어선 책임을 할 수 있기 때문에 좋지 않은 설계가 될 수 있습니다.</p>\n<p>참고</p>\n<ul>\n<li><a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=9252528\" target=\"_blank\" rel=\"noopener\">자바 ORM 표준 JPA 프로그래밍</a></li>\n</ul>\n"},{"title":"Network-3:HTTPS란?","catalog":true,"date":"2019-01-08T15:00:00.000Z","subtitle":"HTTPS","header-img":null,"_content":"\n\n# HTTPS란\n\n<!-- TOC -->\n\n- [HTTPS란](#https란)\n    - [HTTP란](#http란)\n    - [HTTPS란](#https란-1)\n    - [HTTPS와 SSL](#https와-ssl)\n    - [SSL과 TLS](#ssl과-tls)\n    - [SSL 디지털 인증서](#ssl-디지털-인증서)\n    - [SSL에서 사용하는 암호화의 종류](#ssl에서-사용하는-암호화의-종류)\n        - [대칭키](#대칭키)\n        - [공개키(비대칭키)](#공개키비대칭키)\n    - [CA](#ca)\n    - [SSL인증서가 서비스를 보장하는 방법](#ssl인증서가-서비스를-보장하는-방법)\n    - [SSL의 동작 방법](#ssl의-동작-방법)\n        - [HandShake](#handshake)\n        - [세션](#세션)\n        - [세션 종료](#세션-종료)\n        - [정리](#정리)\n    - [참고](#참고)\n\n<!-- /TOC -->\n\n## HTTP란\nHTTP는 Hypertext Transfer Protocol의 약자다. 즉 Hypertext인 HTML을 전송하기 위한 통신규약을 의미한다. HTTP는 암호화되지 않은 방법으로 데이터를 전송하기 때문에 서버와 클라이언트가 주고받는 메시지를 감청하는 것이 매우 쉽다. 예를 들어 로그인을 위해서 서버로 비밀번호를 전송하거나, 또는 중요한 기밀문서를 열람하는 과정에서 악의적인 감청이나 데이터의 변조 등이 일어날 수 있다는 것이다.\n\n## HTTPS란\n이를 보안한 것이 HTTPS다. 여기에서 뒤에 S는 Over Secure Socket Layer(SSL)의 약자로 Secure라는 말을 통해서 알 수 있듯이 보안이 강화된 HTTP라는 것을 알 수 있다. HTTPS는 기본적으로 데이터를 암호화해서 통신을 한다. SSL은 표현 계층의 프로토콜로 응용 계층 아래에 있기 때문에, 어떤 응용 계층의 데이터라도 암호화해서 보낼 수 있다.\n\n\n## HTTPS와 SSL\nHTTPS와 SSL를 같은 의미로 이해하고 있는 경우가 많다. 이것은 맞기도 틀리기도 하다. 그것은 마치 인터넷과 웹을 같은 의미로 이해하는 것과 같다. 결론적으로 말하면 웹이 인터넷 위에서 돌아가는 서비스 중의 하나인 것처럼 HTTPS도 SSL 프로토콜 위에서 돌아가는 프로토콜이다.\n\n## SSL과 TLS\n같은 말이다. 네스케이프에 의해서 SSL이 발명되었고, 이것이 점차 폭넓게 사용되다가 표준화 기구인 IETF의 관리로 변경되면서 TLS라는 이름으로 바뀌었다. TLS 1.0은 SSL 3.0을 계승한다. 하지만 TLS라는 이름보다 SSL이라는 이름이 훨씬 많이 사용되고 있다.\n\n## SSL 디지털 인증서\nSSL 인증서는 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서다. 클라이언트가 서버에 접속한 직후에 서버는 클라이언트에게 이 인증서 정보를 전달한다. 클라이언트는 이 인증서 정보가 신뢰할 수 있는 것인지를 검증 한 후에 다음 절차를 수행하게 된다. SSL과 SSL 디지털 인증서를 이용했을 때의 이점은 아래와 같다.\n\n* 통신 내용이 공격자에게 노출되는 것을 막을 수 있다. \n* 클라이언트가 접속하려는 서버가 신뢰 할 수 있는 서버인지를 판단할 수 있다.\n* 통신 내용의 악의적인 변경을 방지할 수 있다. \n* SSL 통신에 사용할 공개키를 클라이언트에게 제공한다.\n\n## SSL에서 사용하는 암호화의 종류 \nSSL의 핵심은 암호화다. SSL은 보안과 성능상의 이유로 두 가지 암호화 기법을 혼용해서 사용하고 있는데 SSL 동작방법을 이해하기 위해서는 이 암호화 기법들에 대한 이해가 필요하다.\n\n### 대칭키\n암호화는 복호화될 수 있는 것을 말한다. **단방향으로 암호화되는 것을 해쉬화라고 하는데 이 해시는 복호화할 수 없는 값을 말한다.** 그렇기 때문에 해시는 암호화가 아니다. 이 암호화는 대칭키와 비대칭키(공개키)로 나눌 수 있다. 여기에서 대칭키는 동일한 키로 암호화와 복호화를 같이 하는것을 말한다. 즉 암호화키를 wan으로 했으면 복호화도 wan의 키값으로할 수 있는 것을 대칭키 방식이라 한다.\n\n\n### 공개키(비대칭키)\n**공개키 방식은 두개의 키를 갖게 되는데 A키로 암호화를 하면 B키로 복호화 할 수 있고, B키로 암호화하면 A키로 복호화 할 수 있는 방식이다.** 이 방식에 착안해서 두개의 키 중 하나를 비공개키(private key, 개인키, 비밀키라고도 부른다)로하고, 나머지를 공개키(public key)로 지정한다. 비공개키는 자신만이 가지고 있고, 공개키를 타인에게 제공한다. 공개키를 제공 받은 타인은 공개키를 이용해서 정보를 암호화한다. 암호화한 정보를 비공개키를 가지고 있는 사람에게 전송한다. 비공개키의 소유자는 이 키를 이용해서 암호화된 정보를 복호화 한다. 이 과정에서 공개키가 유출된다고해도 비공개키를 모르면 정보를 복호화 할 수 없기 때문에 안전하다. 공개키로는 암호화는 할 수 있지만 복호화는 할 수 없기 때문이다.\n\n\n## CA\n인증서의 역할은 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지를 보장하는 역할을 한다. 이 역할을 하는 민간기업들이 있는데 이런 기업들을 CA(Certificate authority) 혹은 Root Certificate 라고 부른다. CA는 아무 기업이나 할 수 있는 것이 아니고 신뢰성이 엄격하게 공인된 기업들만이 참여할 수 있다. \n\n\n## SSL인증서가 서비스를 보장하는 방법\n웹 브라우저가 서버에 접속할 때 서버는 제일 먼저 인증서를 제공한다. 브라우저는 이 인증서를 발급한 CA가 자신이 내장한 CA의 리스트에 있는지를 확인한다. 확인 결과 서버를 통해서 다운받은 인증서가 내장된 CA 리스트에 포함되어 있다면 해당 CA의 공개키를 이용해서 인증서를 복호화 한다. \n\n\n## SSL의 동작 방법\n**결론부터 말하면 SSL은 암호화된 데이터를 전송하기 위해서 공개키와 대칭키를 혼합해서 사용한다.** \n* 클라이언트와 서버가 주고 받는 실제 정보는 대칭키 방식으로 암호화를한다\n* 대칭키 방식으로 암호화된 실제 정보를 복호화할 때사용할 대칭키는 공개키 방식으로 암호화해서 클라이언트와 서버가 주고 받는다.\n\n위에 내용에 세부적으로 알아보기 이전에 먼저 간단하게 네트워크 통신이 어떻게 이루어지는지 알아보자. 컴퓨터와 컴퓨터가 네트워크를 이용해서 통신을 할 때는 내부적으로 3가지 단계가 있다. 아래와 같다.\n\n```\n악수(3way HandShake) -> 전송 -> 세션종료(4way HandShake)\n```\n\n이 설명만으로는 https가 어떻게 동작하는지 이해하기 어려울 것이다. 어떠한 과정 속에 인증서를 인증하고 데이터를 넘기는지 알아 볼 것이다. 위의의 관계만 일단 머릿속에 기억해두고 좀 더 구체적인 설명으로 넘어가자.\n\n### HandShake\n\n사람과 사람이 소통을 할 때를 생각해보자. 우선 인사를 한다. 인사를 통해서 상대의 기분과 상황을 상호탐색을 하는 것이다. 이 과정이 잘되야 소통이 원활해진다. 클라이언트와 서버 사이도 마찬가지다. 실제 데이터를 주고 받기 전에 클라이언트와 서버는 일종의 인사인 Handshake(진짜로 사용하는 기술용어다)를 한다. 이 과정을 통해서 서로 상대방이 존재하는지, 또 상대방과 데이터를 주고 받기 위해서는 어떤 방법을 사용해야하는지를 파악한다.\n\nSSL 방식을 이용해서 통신을 하는 브라우저와 서버 역시 핸드쉐이크를 하는데, 이 때 SSL 인증서를 주고 받는다. \n\n이러한 과정을 정리하면 아래와 같다.\n\n1. 클라이언트가 서버에 접속한다. 이 단계를 Client Hello라고 한다. 이 단계에서 주고 받는 정보는 아래와 같다.\n* 클라이언트 측에서 생성한 랜덤 데이터 : 아래 3번 과정 참조\n* 클라이언트가 지원하는 암호화 방식들 : 클라이언트와 서버가 지원하는 암호화 방식이 서로 다를 수 있기 때문에 상호간에 어떤 암호화 방식을 사용할 것인지에 대한 협상을 해야 한다. 이 협상을 위해서 클라이언트 측에서는 자신이 사용할 수 있는 암호화 방식을 전송한다.\n* 세션 아이디 : 이미 SSL 핸드쉐이킹을 했다면 비용과 시간을 절약하기 위해서 기존의 세션을 재활용하게 되는데 이 때 사용할 연결에 대한 식별자를 서버 측으로 전송한다.\n \n2. 서버는 Client Hello에 대한 응답으로 Server Hello를 하게 된다. 이 단계에서 주고 받는 정보는 아래와 같다.\n* 서버 측에서 생성한 랜덤 데이터 : 아래 3번 과정 참조\n* 서버가 선택한 클라이언트의 암호화 방식 : 클라이언트가 전달한 암호화 방식 중에서 서버 쪽에서도 사용할 수 있는 암호화 방식을 선택해서 클라이언트로 전달한다. 이로써 암호화 방식에 대한 협상이 종료되고 서버와 클라이언트는 이 암호화 방식을 이용해서 정보를 교환하게 된다.\n\n \n3. 클라이언트는 서버의 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA 리스트를 확인한다. CA 리스트에 인증서가 없다면 사용자에게 경고 메시지를 출력한다. 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA의 공개키를 이용해서 인증서를 복호화한다. 복호화에 성공했다면 인증서는 CA의 개인키로 암호화된 문서임이 암시적으로 보증된 것이다. 인증서를 전송한 서버를 믿을 수 있게 된 것이다.\n\n    클라이언트는 상기 2번을 통해서 받은 서버의 랜덤 데이터와 클라이언트가 생성한 랜덤 데이터를 조합해서 pre master secret라는 키를 생성한다. 이 키는 뒤에서 살펴볼 세션 단계에서 데이터를 주고 받을 때 암호화하기 위해서 사용될 것이다. **이 때 사용할 암호화 기법은 대칭키이기 때문에 pre master secret 값은 제 3자에게 절대로 노출되어서는 안된다.**\n\n    그럼 문제는 이 pre master secret 값을 어떻게 서버에게 전달할 것인가이다. 이 때 사용하는 방법이 바로 공개키 방식이다. 서버의 공개키로 pre master secret 값을 암호화해서 서버로 전송하면 서버는 자신의 비공개키로 안전하게 복호화 할 수 있다. 공개키는 서버로부터 받은 인증서 안에 들어있다. 이 서버의 공개키를 이용해서 pre master secret 값을 암호화한 후에 서버로 전송하면 안전하게 전송할 수 있다.\n \n4. 서버는 클라이언트가 전송한 pre master secret 값을 자신의 비공개키로 복호화한다. 이로서 서버와 클라이언트가 모두 pre master secret 값을 공유하게 되었다. 그리고 서버와 클라이언트는 모두 일련의 과정을 거쳐서 pre master secret 값을 master secret 값으로 만든다. master secret는 session key를 생성하는데 이 session key 값을 이용해서 서버와 클라이언트는 데이터를 대칭키 방식으로 암호화 한 후에 주고 받는다. 이렇게해서 세션키를 클라이언트와 서버가 모두 공유하게 되었다는 점을 기억해야한다.\n \n5. 클라이언트와 서버는 핸드쉐이크 단계의 종료를 서로에게 알린다.\n\n\n\n### 세션\n세션은 실제로 서버와 클라이언트가 데이터를 주고 받는 단계이다. 이 단계에서 핵심은 정보를 상대방에게 전송하기 전에 session key 값을 이용해서 대칭키 방식으로 암호화 한다는 점이다. 암호화된 정보는 상대방에게 전송될 것이고, 상대방도 세션키 값을 알고 있기 때문에 암호를 복호화 할 수 있다.\n\n\n### 세션 종료\n데이터의 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알려준다. 이 때 통신에서 사용한 대칭키인 세션키를 폐기한다.\n\n\n\n\n### 정리\n\n위에 내용을 좀더 쉽게 설명하는 그림이 있어서 첨부했다.\n\n![](https://i.imgur.com/KYgfDFo.png)\n\n\n1. 해당사이트는  CA에 인증서를 발급요청한다\n2. CA로부터 검토를 인증기관의 개인키로 암호화하여 사이트 인증서 제작\n3. 서버로 인증서 발급\n4. 인증브라우저에게 인증기관의 공개키를 제공\n5. 브라우저가 서버에 접속 요청.\n6. 서버는 CA로부터 발급받은 인증서를 브라우저에게 전달\n7. 인증기관의 개인키로 서버로 부터 받은 인증서 해독하여 서버 공개키 획득\n8. 브라우저는 서버로부터 받은공개키로 대칭키를 암호화하여 서버로 전송\n9. 서버는 개인키로 브라우저로부터받은 정보 해독후 대칭키를 얻는다\n10. 대칭키를 이용하여 통신함.\n\n\n## 참고\n\n* [생활코딩](https://opentutorials.org/course/228/4894)\n","source":"_posts/2019-01-14-https.md","raw":"---\ntitle: Network-3:HTTPS란?\ncatalog: true\ndate: 2019-01-09\nsubtitle: HTTPS\nheader-img:\ntags:\n- Netowork\n\n\n\n---\n\n\n# HTTPS란\n\n<!-- TOC -->\n\n- [HTTPS란](#https란)\n    - [HTTP란](#http란)\n    - [HTTPS란](#https란-1)\n    - [HTTPS와 SSL](#https와-ssl)\n    - [SSL과 TLS](#ssl과-tls)\n    - [SSL 디지털 인증서](#ssl-디지털-인증서)\n    - [SSL에서 사용하는 암호화의 종류](#ssl에서-사용하는-암호화의-종류)\n        - [대칭키](#대칭키)\n        - [공개키(비대칭키)](#공개키비대칭키)\n    - [CA](#ca)\n    - [SSL인증서가 서비스를 보장하는 방법](#ssl인증서가-서비스를-보장하는-방법)\n    - [SSL의 동작 방법](#ssl의-동작-방법)\n        - [HandShake](#handshake)\n        - [세션](#세션)\n        - [세션 종료](#세션-종료)\n        - [정리](#정리)\n    - [참고](#참고)\n\n<!-- /TOC -->\n\n## HTTP란\nHTTP는 Hypertext Transfer Protocol의 약자다. 즉 Hypertext인 HTML을 전송하기 위한 통신규약을 의미한다. HTTP는 암호화되지 않은 방법으로 데이터를 전송하기 때문에 서버와 클라이언트가 주고받는 메시지를 감청하는 것이 매우 쉽다. 예를 들어 로그인을 위해서 서버로 비밀번호를 전송하거나, 또는 중요한 기밀문서를 열람하는 과정에서 악의적인 감청이나 데이터의 변조 등이 일어날 수 있다는 것이다.\n\n## HTTPS란\n이를 보안한 것이 HTTPS다. 여기에서 뒤에 S는 Over Secure Socket Layer(SSL)의 약자로 Secure라는 말을 통해서 알 수 있듯이 보안이 강화된 HTTP라는 것을 알 수 있다. HTTPS는 기본적으로 데이터를 암호화해서 통신을 한다. SSL은 표현 계층의 프로토콜로 응용 계층 아래에 있기 때문에, 어떤 응용 계층의 데이터라도 암호화해서 보낼 수 있다.\n\n\n## HTTPS와 SSL\nHTTPS와 SSL를 같은 의미로 이해하고 있는 경우가 많다. 이것은 맞기도 틀리기도 하다. 그것은 마치 인터넷과 웹을 같은 의미로 이해하는 것과 같다. 결론적으로 말하면 웹이 인터넷 위에서 돌아가는 서비스 중의 하나인 것처럼 HTTPS도 SSL 프로토콜 위에서 돌아가는 프로토콜이다.\n\n## SSL과 TLS\n같은 말이다. 네스케이프에 의해서 SSL이 발명되었고, 이것이 점차 폭넓게 사용되다가 표준화 기구인 IETF의 관리로 변경되면서 TLS라는 이름으로 바뀌었다. TLS 1.0은 SSL 3.0을 계승한다. 하지만 TLS라는 이름보다 SSL이라는 이름이 훨씬 많이 사용되고 있다.\n\n## SSL 디지털 인증서\nSSL 인증서는 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서다. 클라이언트가 서버에 접속한 직후에 서버는 클라이언트에게 이 인증서 정보를 전달한다. 클라이언트는 이 인증서 정보가 신뢰할 수 있는 것인지를 검증 한 후에 다음 절차를 수행하게 된다. SSL과 SSL 디지털 인증서를 이용했을 때의 이점은 아래와 같다.\n\n* 통신 내용이 공격자에게 노출되는 것을 막을 수 있다. \n* 클라이언트가 접속하려는 서버가 신뢰 할 수 있는 서버인지를 판단할 수 있다.\n* 통신 내용의 악의적인 변경을 방지할 수 있다. \n* SSL 통신에 사용할 공개키를 클라이언트에게 제공한다.\n\n## SSL에서 사용하는 암호화의 종류 \nSSL의 핵심은 암호화다. SSL은 보안과 성능상의 이유로 두 가지 암호화 기법을 혼용해서 사용하고 있는데 SSL 동작방법을 이해하기 위해서는 이 암호화 기법들에 대한 이해가 필요하다.\n\n### 대칭키\n암호화는 복호화될 수 있는 것을 말한다. **단방향으로 암호화되는 것을 해쉬화라고 하는데 이 해시는 복호화할 수 없는 값을 말한다.** 그렇기 때문에 해시는 암호화가 아니다. 이 암호화는 대칭키와 비대칭키(공개키)로 나눌 수 있다. 여기에서 대칭키는 동일한 키로 암호화와 복호화를 같이 하는것을 말한다. 즉 암호화키를 wan으로 했으면 복호화도 wan의 키값으로할 수 있는 것을 대칭키 방식이라 한다.\n\n\n### 공개키(비대칭키)\n**공개키 방식은 두개의 키를 갖게 되는데 A키로 암호화를 하면 B키로 복호화 할 수 있고, B키로 암호화하면 A키로 복호화 할 수 있는 방식이다.** 이 방식에 착안해서 두개의 키 중 하나를 비공개키(private key, 개인키, 비밀키라고도 부른다)로하고, 나머지를 공개키(public key)로 지정한다. 비공개키는 자신만이 가지고 있고, 공개키를 타인에게 제공한다. 공개키를 제공 받은 타인은 공개키를 이용해서 정보를 암호화한다. 암호화한 정보를 비공개키를 가지고 있는 사람에게 전송한다. 비공개키의 소유자는 이 키를 이용해서 암호화된 정보를 복호화 한다. 이 과정에서 공개키가 유출된다고해도 비공개키를 모르면 정보를 복호화 할 수 없기 때문에 안전하다. 공개키로는 암호화는 할 수 있지만 복호화는 할 수 없기 때문이다.\n\n\n## CA\n인증서의 역할은 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지를 보장하는 역할을 한다. 이 역할을 하는 민간기업들이 있는데 이런 기업들을 CA(Certificate authority) 혹은 Root Certificate 라고 부른다. CA는 아무 기업이나 할 수 있는 것이 아니고 신뢰성이 엄격하게 공인된 기업들만이 참여할 수 있다. \n\n\n## SSL인증서가 서비스를 보장하는 방법\n웹 브라우저가 서버에 접속할 때 서버는 제일 먼저 인증서를 제공한다. 브라우저는 이 인증서를 발급한 CA가 자신이 내장한 CA의 리스트에 있는지를 확인한다. 확인 결과 서버를 통해서 다운받은 인증서가 내장된 CA 리스트에 포함되어 있다면 해당 CA의 공개키를 이용해서 인증서를 복호화 한다. \n\n\n## SSL의 동작 방법\n**결론부터 말하면 SSL은 암호화된 데이터를 전송하기 위해서 공개키와 대칭키를 혼합해서 사용한다.** \n* 클라이언트와 서버가 주고 받는 실제 정보는 대칭키 방식으로 암호화를한다\n* 대칭키 방식으로 암호화된 실제 정보를 복호화할 때사용할 대칭키는 공개키 방식으로 암호화해서 클라이언트와 서버가 주고 받는다.\n\n위에 내용에 세부적으로 알아보기 이전에 먼저 간단하게 네트워크 통신이 어떻게 이루어지는지 알아보자. 컴퓨터와 컴퓨터가 네트워크를 이용해서 통신을 할 때는 내부적으로 3가지 단계가 있다. 아래와 같다.\n\n```\n악수(3way HandShake) -> 전송 -> 세션종료(4way HandShake)\n```\n\n이 설명만으로는 https가 어떻게 동작하는지 이해하기 어려울 것이다. 어떠한 과정 속에 인증서를 인증하고 데이터를 넘기는지 알아 볼 것이다. 위의의 관계만 일단 머릿속에 기억해두고 좀 더 구체적인 설명으로 넘어가자.\n\n### HandShake\n\n사람과 사람이 소통을 할 때를 생각해보자. 우선 인사를 한다. 인사를 통해서 상대의 기분과 상황을 상호탐색을 하는 것이다. 이 과정이 잘되야 소통이 원활해진다. 클라이언트와 서버 사이도 마찬가지다. 실제 데이터를 주고 받기 전에 클라이언트와 서버는 일종의 인사인 Handshake(진짜로 사용하는 기술용어다)를 한다. 이 과정을 통해서 서로 상대방이 존재하는지, 또 상대방과 데이터를 주고 받기 위해서는 어떤 방법을 사용해야하는지를 파악한다.\n\nSSL 방식을 이용해서 통신을 하는 브라우저와 서버 역시 핸드쉐이크를 하는데, 이 때 SSL 인증서를 주고 받는다. \n\n이러한 과정을 정리하면 아래와 같다.\n\n1. 클라이언트가 서버에 접속한다. 이 단계를 Client Hello라고 한다. 이 단계에서 주고 받는 정보는 아래와 같다.\n* 클라이언트 측에서 생성한 랜덤 데이터 : 아래 3번 과정 참조\n* 클라이언트가 지원하는 암호화 방식들 : 클라이언트와 서버가 지원하는 암호화 방식이 서로 다를 수 있기 때문에 상호간에 어떤 암호화 방식을 사용할 것인지에 대한 협상을 해야 한다. 이 협상을 위해서 클라이언트 측에서는 자신이 사용할 수 있는 암호화 방식을 전송한다.\n* 세션 아이디 : 이미 SSL 핸드쉐이킹을 했다면 비용과 시간을 절약하기 위해서 기존의 세션을 재활용하게 되는데 이 때 사용할 연결에 대한 식별자를 서버 측으로 전송한다.\n \n2. 서버는 Client Hello에 대한 응답으로 Server Hello를 하게 된다. 이 단계에서 주고 받는 정보는 아래와 같다.\n* 서버 측에서 생성한 랜덤 데이터 : 아래 3번 과정 참조\n* 서버가 선택한 클라이언트의 암호화 방식 : 클라이언트가 전달한 암호화 방식 중에서 서버 쪽에서도 사용할 수 있는 암호화 방식을 선택해서 클라이언트로 전달한다. 이로써 암호화 방식에 대한 협상이 종료되고 서버와 클라이언트는 이 암호화 방식을 이용해서 정보를 교환하게 된다.\n\n \n3. 클라이언트는 서버의 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA 리스트를 확인한다. CA 리스트에 인증서가 없다면 사용자에게 경고 메시지를 출력한다. 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA의 공개키를 이용해서 인증서를 복호화한다. 복호화에 성공했다면 인증서는 CA의 개인키로 암호화된 문서임이 암시적으로 보증된 것이다. 인증서를 전송한 서버를 믿을 수 있게 된 것이다.\n\n    클라이언트는 상기 2번을 통해서 받은 서버의 랜덤 데이터와 클라이언트가 생성한 랜덤 데이터를 조합해서 pre master secret라는 키를 생성한다. 이 키는 뒤에서 살펴볼 세션 단계에서 데이터를 주고 받을 때 암호화하기 위해서 사용될 것이다. **이 때 사용할 암호화 기법은 대칭키이기 때문에 pre master secret 값은 제 3자에게 절대로 노출되어서는 안된다.**\n\n    그럼 문제는 이 pre master secret 값을 어떻게 서버에게 전달할 것인가이다. 이 때 사용하는 방법이 바로 공개키 방식이다. 서버의 공개키로 pre master secret 값을 암호화해서 서버로 전송하면 서버는 자신의 비공개키로 안전하게 복호화 할 수 있다. 공개키는 서버로부터 받은 인증서 안에 들어있다. 이 서버의 공개키를 이용해서 pre master secret 값을 암호화한 후에 서버로 전송하면 안전하게 전송할 수 있다.\n \n4. 서버는 클라이언트가 전송한 pre master secret 값을 자신의 비공개키로 복호화한다. 이로서 서버와 클라이언트가 모두 pre master secret 값을 공유하게 되었다. 그리고 서버와 클라이언트는 모두 일련의 과정을 거쳐서 pre master secret 값을 master secret 값으로 만든다. master secret는 session key를 생성하는데 이 session key 값을 이용해서 서버와 클라이언트는 데이터를 대칭키 방식으로 암호화 한 후에 주고 받는다. 이렇게해서 세션키를 클라이언트와 서버가 모두 공유하게 되었다는 점을 기억해야한다.\n \n5. 클라이언트와 서버는 핸드쉐이크 단계의 종료를 서로에게 알린다.\n\n\n\n### 세션\n세션은 실제로 서버와 클라이언트가 데이터를 주고 받는 단계이다. 이 단계에서 핵심은 정보를 상대방에게 전송하기 전에 session key 값을 이용해서 대칭키 방식으로 암호화 한다는 점이다. 암호화된 정보는 상대방에게 전송될 것이고, 상대방도 세션키 값을 알고 있기 때문에 암호를 복호화 할 수 있다.\n\n\n### 세션 종료\n데이터의 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알려준다. 이 때 통신에서 사용한 대칭키인 세션키를 폐기한다.\n\n\n\n\n### 정리\n\n위에 내용을 좀더 쉽게 설명하는 그림이 있어서 첨부했다.\n\n![](https://i.imgur.com/KYgfDFo.png)\n\n\n1. 해당사이트는  CA에 인증서를 발급요청한다\n2. CA로부터 검토를 인증기관의 개인키로 암호화하여 사이트 인증서 제작\n3. 서버로 인증서 발급\n4. 인증브라우저에게 인증기관의 공개키를 제공\n5. 브라우저가 서버에 접속 요청.\n6. 서버는 CA로부터 발급받은 인증서를 브라우저에게 전달\n7. 인증기관의 개인키로 서버로 부터 받은 인증서 해독하여 서버 공개키 획득\n8. 브라우저는 서버로부터 받은공개키로 대칭키를 암호화하여 서버로 전송\n9. 서버는 개인키로 브라우저로부터받은 정보 해독후 대칭키를 얻는다\n10. 대칭키를 이용하여 통신함.\n\n\n## 참고\n\n* [생활코딩](https://opentutorials.org/course/228/4894)\n","slug":"2019-01-14-https","published":1,"updated":"2019-01-27T16:02:41.498Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27e80037jjpepsohvla5","content":"<h1><span id=\"https란\">HTTPS란</span></h1>\n<!-- TOC -->\n<ul>\n<li><a href=\"#https%EB%9E%80\">HTTPS란</a>\n<ul>\n<li><a href=\"#http%EB%9E%80\">HTTP란</a></li>\n<li><a href=\"#https%EB%9E%80-1\">HTTPS란</a></li>\n<li><a href=\"#https%EC%99%80-ssl\">HTTPS와 SSL</a></li>\n<li><a href=\"#ssl%EA%B3%BC-tls\">SSL과 TLS</a></li>\n<li><a href=\"#ssl-%EB%94%94%EC%A7%80%ED%84%B8-%EC%9D%B8%EC%A6%9D%EC%84%9C\">SSL 디지털 인증서</a></li>\n<li><a href=\"#ssl%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%95%94%ED%98%B8%ED%99%94%EC%9D%98-%EC%A2%85%EB%A5%98\">SSL에서 사용하는 암호화의 종류</a>\n<ul>\n<li><a href=\"#%EB%8C%80%EC%B9%AD%ED%82%A4\">대칭키</a></li>\n<li><a href=\"#%EA%B3%B5%EA%B0%9C%ED%82%A4%EB%B9%84%EB%8C%80%EC%B9%AD%ED%82%A4\">공개키(비대칭키)</a></li>\n</ul>\n</li>\n<li><a href=\"#ca\">CA</a></li>\n<li><a href=\"#ssl%EC%9D%B8%EC%A6%9D%EC%84%9C%EA%B0%80-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A5%BC-%EB%B3%B4%EC%9E%A5%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\">SSL인증서가 서비스를 보장하는 방법</a></li>\n<li><a href=\"#ssl%EC%9D%98-%EB%8F%99%EC%9E%91-%EB%B0%A9%EB%B2%95\">SSL의 동작 방법</a>\n<ul>\n<li><a href=\"#handshake\">HandShake</a></li>\n<li><a href=\"#%EC%84%B8%EC%85%98\">세션</a></li>\n<li><a href=\"#%EC%84%B8%EC%85%98-%EC%A2%85%EB%A3%8C\">세션 종료</a></li>\n<li><a href=\"#%EC%A0%95%EB%A6%AC\">정리</a></li>\n</ul>\n</li>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0\">참고</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h2><span id=\"http란\">HTTP란</span></h2>\n<p>HTTP는 Hypertext Transfer Protocol의 약자다. 즉 Hypertext인 HTML을 전송하기 위한 통신규약을 의미한다. HTTP는 암호화되지 않은 방법으로 데이터를 전송하기 때문에 서버와 클라이언트가 주고받는 메시지를 감청하는 것이 매우 쉽다. 예를 들어 로그인을 위해서 서버로 비밀번호를 전송하거나, 또는 중요한 기밀문서를 열람하는 과정에서 악의적인 감청이나 데이터의 변조 등이 일어날 수 있다는 것이다.</p>\n<h2><span id=\"https란\">HTTPS란</span></h2>\n<p>이를 보안한 것이 HTTPS다. 여기에서 뒤에 S는 Over Secure Socket Layer(SSL)의 약자로 Secure라는 말을 통해서 알 수 있듯이 보안이 강화된 HTTP라는 것을 알 수 있다. HTTPS는 기본적으로 데이터를 암호화해서 통신을 한다. SSL은 표현 계층의 프로토콜로 응용 계층 아래에 있기 때문에, 어떤 응용 계층의 데이터라도 암호화해서 보낼 수 있다.</p>\n<h2><span id=\"https와-ssl\">HTTPS와 SSL</span></h2>\n<p>HTTPS와 SSL를 같은 의미로 이해하고 있는 경우가 많다. 이것은 맞기도 틀리기도 하다. 그것은 마치 인터넷과 웹을 같은 의미로 이해하는 것과 같다. 결론적으로 말하면 웹이 인터넷 위에서 돌아가는 서비스 중의 하나인 것처럼 HTTPS도 SSL 프로토콜 위에서 돌아가는 프로토콜이다.</p>\n<h2><span id=\"ssl과-tls\">SSL과 TLS</span></h2>\n<p>같은 말이다. 네스케이프에 의해서 SSL이 발명되었고, 이것이 점차 폭넓게 사용되다가 표준화 기구인 IETF의 관리로 변경되면서 TLS라는 이름으로 바뀌었다. TLS 1.0은 SSL 3.0을 계승한다. 하지만 TLS라는 이름보다 SSL이라는 이름이 훨씬 많이 사용되고 있다.</p>\n<h2><span id=\"ssl-디지털-인증서\">SSL 디지털 인증서</span></h2>\n<p>SSL 인증서는 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서다. 클라이언트가 서버에 접속한 직후에 서버는 클라이언트에게 이 인증서 정보를 전달한다. 클라이언트는 이 인증서 정보가 신뢰할 수 있는 것인지를 검증 한 후에 다음 절차를 수행하게 된다. SSL과 SSL 디지털 인증서를 이용했을 때의 이점은 아래와 같다.</p>\n<ul>\n<li>통신 내용이 공격자에게 노출되는 것을 막을 수 있다.</li>\n<li>클라이언트가 접속하려는 서버가 신뢰 할 수 있는 서버인지를 판단할 수 있다.</li>\n<li>통신 내용의 악의적인 변경을 방지할 수 있다.</li>\n<li>SSL 통신에 사용할 공개키를 클라이언트에게 제공한다.</li>\n</ul>\n<h2><span id=\"ssl에서-사용하는-암호화의-종류\">SSL에서 사용하는 암호화의 종류</span></h2>\n<p>SSL의 핵심은 암호화다. SSL은 보안과 성능상의 이유로 두 가지 암호화 기법을 혼용해서 사용하고 있는데 SSL 동작방법을 이해하기 위해서는 이 암호화 기법들에 대한 이해가 필요하다.</p>\n<h3><span id=\"대칭키\">대칭키</span></h3>\n<p>암호화는 복호화될 수 있는 것을 말한다. <strong>단방향으로 암호화되는 것을 해쉬화라고 하는데 이 해시는 복호화할 수 없는 값을 말한다.</strong> 그렇기 때문에 해시는 암호화가 아니다. 이 암호화는 대칭키와 비대칭키(공개키)로 나눌 수 있다. 여기에서 대칭키는 동일한 키로 암호화와 복호화를 같이 하는것을 말한다. 즉 암호화키를 wan으로 했으면 복호화도 wan의 키값으로할 수 있는 것을 대칭키 방식이라 한다.</p>\n<h3><span id=\"공개키비대칭키\">공개키(비대칭키)</span></h3>\n<p><strong>공개키 방식은 두개의 키를 갖게 되는데 A키로 암호화를 하면 B키로 복호화 할 수 있고, B키로 암호화하면 A키로 복호화 할 수 있는 방식이다.</strong> 이 방식에 착안해서 두개의 키 중 하나를 비공개키(private key, 개인키, 비밀키라고도 부른다)로하고, 나머지를 공개키(public key)로 지정한다. 비공개키는 자신만이 가지고 있고, 공개키를 타인에게 제공한다. 공개키를 제공 받은 타인은 공개키를 이용해서 정보를 암호화한다. 암호화한 정보를 비공개키를 가지고 있는 사람에게 전송한다. 비공개키의 소유자는 이 키를 이용해서 암호화된 정보를 복호화 한다. 이 과정에서 공개키가 유출된다고해도 비공개키를 모르면 정보를 복호화 할 수 없기 때문에 안전하다. 공개키로는 암호화는 할 수 있지만 복호화는 할 수 없기 때문이다.</p>\n<h2><span id=\"ca\">CA</span></h2>\n<p>인증서의 역할은 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지를 보장하는 역할을 한다. 이 역할을 하는 민간기업들이 있는데 이런 기업들을 CA(Certificate authority) 혹은 Root Certificate 라고 부른다. CA는 아무 기업이나 할 수 있는 것이 아니고 신뢰성이 엄격하게 공인된 기업들만이 참여할 수 있다.</p>\n<h2><span id=\"ssl인증서가-서비스를-보장하는-방법\">SSL인증서가 서비스를 보장하는 방법</span></h2>\n<p>웹 브라우저가 서버에 접속할 때 서버는 제일 먼저 인증서를 제공한다. 브라우저는 이 인증서를 발급한 CA가 자신이 내장한 CA의 리스트에 있는지를 확인한다. 확인 결과 서버를 통해서 다운받은 인증서가 내장된 CA 리스트에 포함되어 있다면 해당 CA의 공개키를 이용해서 인증서를 복호화 한다.</p>\n<h2><span id=\"ssl의-동작-방법\">SSL의 동작 방법</span></h2>\n<p><strong>결론부터 말하면 SSL은 암호화된 데이터를 전송하기 위해서 공개키와 대칭키를 혼합해서 사용한다.</strong></p>\n<ul>\n<li>클라이언트와 서버가 주고 받는 실제 정보는 대칭키 방식으로 암호화를한다</li>\n<li>대칭키 방식으로 암호화된 실제 정보를 복호화할 때사용할 대칭키는 공개키 방식으로 암호화해서 클라이언트와 서버가 주고 받는다.</li>\n</ul>\n<p>위에 내용에 세부적으로 알아보기 이전에 먼저 간단하게 네트워크 통신이 어떻게 이루어지는지 알아보자. 컴퓨터와 컴퓨터가 네트워크를 이용해서 통신을 할 때는 내부적으로 3가지 단계가 있다. 아래와 같다.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">악수(3way HandShake) -&gt; 전송 -&gt; 세션종료(4way HandShake)</span><br></pre></td></tr></table></figure>\n<p>이 설명만으로는 https가 어떻게 동작하는지 이해하기 어려울 것이다. 어떠한 과정 속에 인증서를 인증하고 데이터를 넘기는지 알아 볼 것이다. 위의의 관계만 일단 머릿속에 기억해두고 좀 더 구체적인 설명으로 넘어가자.</p>\n<h3><span id=\"handshake\">HandShake</span></h3>\n<p>사람과 사람이 소통을 할 때를 생각해보자. 우선 인사를 한다. 인사를 통해서 상대의 기분과 상황을 상호탐색을 하는 것이다. 이 과정이 잘되야 소통이 원활해진다. 클라이언트와 서버 사이도 마찬가지다. 실제 데이터를 주고 받기 전에 클라이언트와 서버는 일종의 인사인 Handshake(진짜로 사용하는 기술용어다)를 한다. 이 과정을 통해서 서로 상대방이 존재하는지, 또 상대방과 데이터를 주고 받기 위해서는 어떤 방법을 사용해야하는지를 파악한다.</p>\n<p>SSL 방식을 이용해서 통신을 하는 브라우저와 서버 역시 핸드쉐이크를 하는데, 이 때 SSL 인증서를 주고 받는다.</p>\n<p>이러한 과정을 정리하면 아래와 같다.</p>\n<ol>\n<li>클라이언트가 서버에 접속한다. 이 단계를 Client Hello라고 한다. 이 단계에서 주고 받는 정보는 아래와 같다.</li>\n</ol>\n<ul>\n<li>클라이언트 측에서 생성한 랜덤 데이터 : 아래 3번 과정 참조</li>\n<li>클라이언트가 지원하는 암호화 방식들 : 클라이언트와 서버가 지원하는 암호화 방식이 서로 다를 수 있기 때문에 상호간에 어떤 암호화 방식을 사용할 것인지에 대한 협상을 해야 한다. 이 협상을 위해서 클라이언트 측에서는 자신이 사용할 수 있는 암호화 방식을 전송한다.</li>\n<li>세션 아이디 : 이미 SSL 핸드쉐이킹을 했다면 비용과 시간을 절약하기 위해서 기존의 세션을 재활용하게 되는데 이 때 사용할 연결에 대한 식별자를 서버 측으로 전송한다.</li>\n</ul>\n<ol start=\"2\">\n<li>서버는 Client Hello에 대한 응답으로 Server Hello를 하게 된다. 이 단계에서 주고 받는 정보는 아래와 같다.</li>\n</ol>\n<ul>\n<li>서버 측에서 생성한 랜덤 데이터 : 아래 3번 과정 참조</li>\n<li>서버가 선택한 클라이언트의 암호화 방식 : 클라이언트가 전달한 암호화 방식 중에서 서버 쪽에서도 사용할 수 있는 암호화 방식을 선택해서 클라이언트로 전달한다. 이로써 암호화 방식에 대한 협상이 종료되고 서버와 클라이언트는 이 암호화 방식을 이용해서 정보를 교환하게 된다.</li>\n</ul>\n<ol start=\"3\">\n<li>\n<p>클라이언트는 서버의 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA 리스트를 확인한다. CA 리스트에 인증서가 없다면 사용자에게 경고 메시지를 출력한다. 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA의 공개키를 이용해서 인증서를 복호화한다. 복호화에 성공했다면 인증서는 CA의 개인키로 암호화된 문서임이 암시적으로 보증된 것이다. 인증서를 전송한 서버를 믿을 수 있게 된 것이다.</p>\n<p>클라이언트는 상기 2번을 통해서 받은 서버의 랜덤 데이터와 클라이언트가 생성한 랜덤 데이터를 조합해서 pre master secret라는 키를 생성한다. 이 키는 뒤에서 살펴볼 세션 단계에서 데이터를 주고 받을 때 암호화하기 위해서 사용될 것이다. <strong>이 때 사용할 암호화 기법은 대칭키이기 때문에 pre master secret 값은 제 3자에게 절대로 노출되어서는 안된다.</strong></p>\n<p>그럼 문제는 이 pre master secret 값을 어떻게 서버에게 전달할 것인가이다. 이 때 사용하는 방법이 바로 공개키 방식이다. 서버의 공개키로 pre master secret 값을 암호화해서 서버로 전송하면 서버는 자신의 비공개키로 안전하게 복호화 할 수 있다. 공개키는 서버로부터 받은 인증서 안에 들어있다. 이 서버의 공개키를 이용해서 pre master secret 값을 암호화한 후에 서버로 전송하면 안전하게 전송할 수 있다.</p>\n</li>\n<li>\n<p>서버는 클라이언트가 전송한 pre master secret 값을 자신의 비공개키로 복호화한다. 이로서 서버와 클라이언트가 모두 pre master secret 값을 공유하게 되었다. 그리고 서버와 클라이언트는 모두 일련의 과정을 거쳐서 pre master secret 값을 master secret 값으로 만든다. master secret는 session key를 생성하는데 이 session key 값을 이용해서 서버와 클라이언트는 데이터를 대칭키 방식으로 암호화 한 후에 주고 받는다. 이렇게해서 세션키를 클라이언트와 서버가 모두 공유하게 되었다는 점을 기억해야한다.</p>\n</li>\n<li>\n<p>클라이언트와 서버는 핸드쉐이크 단계의 종료를 서로에게 알린다.</p>\n</li>\n</ol>\n<h3><span id=\"세션\">세션</span></h3>\n<p>세션은 실제로 서버와 클라이언트가 데이터를 주고 받는 단계이다. 이 단계에서 핵심은 정보를 상대방에게 전송하기 전에 session key 값을 이용해서 대칭키 방식으로 암호화 한다는 점이다. 암호화된 정보는 상대방에게 전송될 것이고, 상대방도 세션키 값을 알고 있기 때문에 암호를 복호화 할 수 있다.</p>\n<h3><span id=\"세션-종료\">세션 종료</span></h3>\n<p>데이터의 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알려준다. 이 때 통신에서 사용한 대칭키인 세션키를 폐기한다.</p>\n<h3><span id=\"정리\">정리</span></h3>\n<p>위에 내용을 좀더 쉽게 설명하는 그림이 있어서 첨부했다.</p>\n<p><img src=\"https://i.imgur.com/KYgfDFo.png\" alt=\"\"></p>\n<ol>\n<li>해당사이트는  CA에 인증서를 발급요청한다</li>\n<li>CA로부터 검토를 인증기관의 개인키로 암호화하여 사이트 인증서 제작</li>\n<li>서버로 인증서 발급</li>\n<li>인증브라우저에게 인증기관의 공개키를 제공</li>\n<li>브라우저가 서버에 접속 요청.</li>\n<li>서버는 CA로부터 발급받은 인증서를 브라우저에게 전달</li>\n<li>인증기관의 개인키로 서버로 부터 받은 인증서 해독하여 서버 공개키 획득</li>\n<li>브라우저는 서버로부터 받은공개키로 대칭키를 암호화하여 서버로 전송</li>\n<li>서버는 개인키로 브라우저로부터받은 정보 해독후 대칭키를 얻는다</li>\n<li>대칭키를 이용하여 통신함.</li>\n</ol>\n<h2><span id=\"참고\">참고</span></h2>\n<ul>\n<li><a href=\"https://opentutorials.org/course/228/4894\" target=\"_blank\" rel=\"noopener\">생활코딩</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>HTTPS란</h1>\n<!-- TOC -->\n<ul>\n<li><a href=\"#https%EB%9E%80\">HTTPS란</a>\n<ul>\n<li><a href=\"#http%EB%9E%80\">HTTP란</a></li>\n<li><a href=\"#https%EB%9E%80-1\">HTTPS란</a></li>\n<li><a href=\"#https%EC%99%80-ssl\">HTTPS와 SSL</a></li>\n<li><a href=\"#ssl%EA%B3%BC-tls\">SSL과 TLS</a></li>\n<li><a href=\"#ssl-%EB%94%94%EC%A7%80%ED%84%B8-%EC%9D%B8%EC%A6%9D%EC%84%9C\">SSL 디지털 인증서</a></li>\n<li><a href=\"#ssl%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%95%94%ED%98%B8%ED%99%94%EC%9D%98-%EC%A2%85%EB%A5%98\">SSL에서 사용하는 암호화의 종류</a>\n<ul>\n<li><a href=\"#%EB%8C%80%EC%B9%AD%ED%82%A4\">대칭키</a></li>\n<li><a href=\"#%EA%B3%B5%EA%B0%9C%ED%82%A4%EB%B9%84%EB%8C%80%EC%B9%AD%ED%82%A4\">공개키(비대칭키)</a></li>\n</ul>\n</li>\n<li><a href=\"#ca\">CA</a></li>\n<li><a href=\"#ssl%EC%9D%B8%EC%A6%9D%EC%84%9C%EA%B0%80-%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A5%BC-%EB%B3%B4%EC%9E%A5%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95\">SSL인증서가 서비스를 보장하는 방법</a></li>\n<li><a href=\"#ssl%EC%9D%98-%EB%8F%99%EC%9E%91-%EB%B0%A9%EB%B2%95\">SSL의 동작 방법</a>\n<ul>\n<li><a href=\"#handshake\">HandShake</a></li>\n<li><a href=\"#%EC%84%B8%EC%85%98\">세션</a></li>\n<li><a href=\"#%EC%84%B8%EC%85%98-%EC%A2%85%EB%A3%8C\">세션 종료</a></li>\n<li><a href=\"#%EC%A0%95%EB%A6%AC\">정리</a></li>\n</ul>\n</li>\n<li><a href=\"#%EC%B0%B8%EA%B3%A0\">참고</a></li>\n</ul>\n</li>\n</ul>\n<!-- /TOC -->\n<h2>HTTP란</h2>\n<p>HTTP는 Hypertext Transfer Protocol의 약자다. 즉 Hypertext인 HTML을 전송하기 위한 통신규약을 의미한다. HTTP는 암호화되지 않은 방법으로 데이터를 전송하기 때문에 서버와 클라이언트가 주고받는 메시지를 감청하는 것이 매우 쉽다. 예를 들어 로그인을 위해서 서버로 비밀번호를 전송하거나, 또는 중요한 기밀문서를 열람하는 과정에서 악의적인 감청이나 데이터의 변조 등이 일어날 수 있다는 것이다.</p>\n<h2>HTTPS란</h2>\n<p>이를 보안한 것이 HTTPS다. 여기에서 뒤에 S는 Over Secure Socket Layer(SSL)의 약자로 Secure라는 말을 통해서 알 수 있듯이 보안이 강화된 HTTP라는 것을 알 수 있다. HTTPS는 기본적으로 데이터를 암호화해서 통신을 한다. SSL은 표현 계층의 프로토콜로 응용 계층 아래에 있기 때문에, 어떤 응용 계층의 데이터라도 암호화해서 보낼 수 있다.</p>\n<h2>HTTPS와 SSL</h2>\n<p>HTTPS와 SSL를 같은 의미로 이해하고 있는 경우가 많다. 이것은 맞기도 틀리기도 하다. 그것은 마치 인터넷과 웹을 같은 의미로 이해하는 것과 같다. 결론적으로 말하면 웹이 인터넷 위에서 돌아가는 서비스 중의 하나인 것처럼 HTTPS도 SSL 프로토콜 위에서 돌아가는 프로토콜이다.</p>\n<h2>SSL과 TLS</h2>\n<p>같은 말이다. 네스케이프에 의해서 SSL이 발명되었고, 이것이 점차 폭넓게 사용되다가 표준화 기구인 IETF의 관리로 변경되면서 TLS라는 이름으로 바뀌었다. TLS 1.0은 SSL 3.0을 계승한다. 하지만 TLS라는 이름보다 SSL이라는 이름이 훨씬 많이 사용되고 있다.</p>\n<h2>SSL 디지털 인증서</h2>\n<p>SSL 인증서는 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서다. 클라이언트가 서버에 접속한 직후에 서버는 클라이언트에게 이 인증서 정보를 전달한다. 클라이언트는 이 인증서 정보가 신뢰할 수 있는 것인지를 검증 한 후에 다음 절차를 수행하게 된다. SSL과 SSL 디지털 인증서를 이용했을 때의 이점은 아래와 같다.</p>\n<ul>\n<li>통신 내용이 공격자에게 노출되는 것을 막을 수 있다.</li>\n<li>클라이언트가 접속하려는 서버가 신뢰 할 수 있는 서버인지를 판단할 수 있다.</li>\n<li>통신 내용의 악의적인 변경을 방지할 수 있다.</li>\n<li>SSL 통신에 사용할 공개키를 클라이언트에게 제공한다.</li>\n</ul>\n<h2>SSL에서 사용하는 암호화의 종류</h2>\n<p>SSL의 핵심은 암호화다. SSL은 보안과 성능상의 이유로 두 가지 암호화 기법을 혼용해서 사용하고 있는데 SSL 동작방법을 이해하기 위해서는 이 암호화 기법들에 대한 이해가 필요하다.</p>\n<h3>대칭키</h3>\n<p>암호화는 복호화될 수 있는 것을 말한다. <strong>단방향으로 암호화되는 것을 해쉬화라고 하는데 이 해시는 복호화할 수 없는 값을 말한다.</strong> 그렇기 때문에 해시는 암호화가 아니다. 이 암호화는 대칭키와 비대칭키(공개키)로 나눌 수 있다. 여기에서 대칭키는 동일한 키로 암호화와 복호화를 같이 하는것을 말한다. 즉 암호화키를 wan으로 했으면 복호화도 wan의 키값으로할 수 있는 것을 대칭키 방식이라 한다.</p>\n<h3>공개키(비대칭키)</h3>\n<p><strong>공개키 방식은 두개의 키를 갖게 되는데 A키로 암호화를 하면 B키로 복호화 할 수 있고, B키로 암호화하면 A키로 복호화 할 수 있는 방식이다.</strong> 이 방식에 착안해서 두개의 키 중 하나를 비공개키(private key, 개인키, 비밀키라고도 부른다)로하고, 나머지를 공개키(public key)로 지정한다. 비공개키는 자신만이 가지고 있고, 공개키를 타인에게 제공한다. 공개키를 제공 받은 타인은 공개키를 이용해서 정보를 암호화한다. 암호화한 정보를 비공개키를 가지고 있는 사람에게 전송한다. 비공개키의 소유자는 이 키를 이용해서 암호화된 정보를 복호화 한다. 이 과정에서 공개키가 유출된다고해도 비공개키를 모르면 정보를 복호화 할 수 없기 때문에 안전하다. 공개키로는 암호화는 할 수 있지만 복호화는 할 수 없기 때문이다.</p>\n<h2>CA</h2>\n<p>인증서의 역할은 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지를 보장하는 역할을 한다. 이 역할을 하는 민간기업들이 있는데 이런 기업들을 CA(Certificate authority) 혹은 Root Certificate 라고 부른다. CA는 아무 기업이나 할 수 있는 것이 아니고 신뢰성이 엄격하게 공인된 기업들만이 참여할 수 있다.</p>\n<h2>SSL인증서가 서비스를 보장하는 방법</h2>\n<p>웹 브라우저가 서버에 접속할 때 서버는 제일 먼저 인증서를 제공한다. 브라우저는 이 인증서를 발급한 CA가 자신이 내장한 CA의 리스트에 있는지를 확인한다. 확인 결과 서버를 통해서 다운받은 인증서가 내장된 CA 리스트에 포함되어 있다면 해당 CA의 공개키를 이용해서 인증서를 복호화 한다.</p>\n<h2>SSL의 동작 방법</h2>\n<p><strong>결론부터 말하면 SSL은 암호화된 데이터를 전송하기 위해서 공개키와 대칭키를 혼합해서 사용한다.</strong></p>\n<ul>\n<li>클라이언트와 서버가 주고 받는 실제 정보는 대칭키 방식으로 암호화를한다</li>\n<li>대칭키 방식으로 암호화된 실제 정보를 복호화할 때사용할 대칭키는 공개키 방식으로 암호화해서 클라이언트와 서버가 주고 받는다.</li>\n</ul>\n<p>위에 내용에 세부적으로 알아보기 이전에 먼저 간단하게 네트워크 통신이 어떻게 이루어지는지 알아보자. 컴퓨터와 컴퓨터가 네트워크를 이용해서 통신을 할 때는 내부적으로 3가지 단계가 있다. 아래와 같다.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">악수(3way HandShake) -&gt; 전송 -&gt; 세션종료(4way HandShake)</span><br></pre></td></tr></table></figure>\n<p>이 설명만으로는 https가 어떻게 동작하는지 이해하기 어려울 것이다. 어떠한 과정 속에 인증서를 인증하고 데이터를 넘기는지 알아 볼 것이다. 위의의 관계만 일단 머릿속에 기억해두고 좀 더 구체적인 설명으로 넘어가자.</p>\n<h3>HandShake</h3>\n<p>사람과 사람이 소통을 할 때를 생각해보자. 우선 인사를 한다. 인사를 통해서 상대의 기분과 상황을 상호탐색을 하는 것이다. 이 과정이 잘되야 소통이 원활해진다. 클라이언트와 서버 사이도 마찬가지다. 실제 데이터를 주고 받기 전에 클라이언트와 서버는 일종의 인사인 Handshake(진짜로 사용하는 기술용어다)를 한다. 이 과정을 통해서 서로 상대방이 존재하는지, 또 상대방과 데이터를 주고 받기 위해서는 어떤 방법을 사용해야하는지를 파악한다.</p>\n<p>SSL 방식을 이용해서 통신을 하는 브라우저와 서버 역시 핸드쉐이크를 하는데, 이 때 SSL 인증서를 주고 받는다.</p>\n<p>이러한 과정을 정리하면 아래와 같다.</p>\n<ol>\n<li>클라이언트가 서버에 접속한다. 이 단계를 Client Hello라고 한다. 이 단계에서 주고 받는 정보는 아래와 같다.</li>\n</ol>\n<ul>\n<li>클라이언트 측에서 생성한 랜덤 데이터 : 아래 3번 과정 참조</li>\n<li>클라이언트가 지원하는 암호화 방식들 : 클라이언트와 서버가 지원하는 암호화 방식이 서로 다를 수 있기 때문에 상호간에 어떤 암호화 방식을 사용할 것인지에 대한 협상을 해야 한다. 이 협상을 위해서 클라이언트 측에서는 자신이 사용할 수 있는 암호화 방식을 전송한다.</li>\n<li>세션 아이디 : 이미 SSL 핸드쉐이킹을 했다면 비용과 시간을 절약하기 위해서 기존의 세션을 재활용하게 되는데 이 때 사용할 연결에 대한 식별자를 서버 측으로 전송한다.</li>\n</ul>\n<ol start=\"2\">\n<li>서버는 Client Hello에 대한 응답으로 Server Hello를 하게 된다. 이 단계에서 주고 받는 정보는 아래와 같다.</li>\n</ol>\n<ul>\n<li>서버 측에서 생성한 랜덤 데이터 : 아래 3번 과정 참조</li>\n<li>서버가 선택한 클라이언트의 암호화 방식 : 클라이언트가 전달한 암호화 방식 중에서 서버 쪽에서도 사용할 수 있는 암호화 방식을 선택해서 클라이언트로 전달한다. 이로써 암호화 방식에 대한 협상이 종료되고 서버와 클라이언트는 이 암호화 방식을 이용해서 정보를 교환하게 된다.</li>\n</ul>\n<ol start=\"3\">\n<li>\n<p>클라이언트는 서버의 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA 리스트를 확인한다. CA 리스트에 인증서가 없다면 사용자에게 경고 메시지를 출력한다. 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA의 공개키를 이용해서 인증서를 복호화한다. 복호화에 성공했다면 인증서는 CA의 개인키로 암호화된 문서임이 암시적으로 보증된 것이다. 인증서를 전송한 서버를 믿을 수 있게 된 것이다.</p>\n<p>클라이언트는 상기 2번을 통해서 받은 서버의 랜덤 데이터와 클라이언트가 생성한 랜덤 데이터를 조합해서 pre master secret라는 키를 생성한다. 이 키는 뒤에서 살펴볼 세션 단계에서 데이터를 주고 받을 때 암호화하기 위해서 사용될 것이다. <strong>이 때 사용할 암호화 기법은 대칭키이기 때문에 pre master secret 값은 제 3자에게 절대로 노출되어서는 안된다.</strong></p>\n<p>그럼 문제는 이 pre master secret 값을 어떻게 서버에게 전달할 것인가이다. 이 때 사용하는 방법이 바로 공개키 방식이다. 서버의 공개키로 pre master secret 값을 암호화해서 서버로 전송하면 서버는 자신의 비공개키로 안전하게 복호화 할 수 있다. 공개키는 서버로부터 받은 인증서 안에 들어있다. 이 서버의 공개키를 이용해서 pre master secret 값을 암호화한 후에 서버로 전송하면 안전하게 전송할 수 있다.</p>\n</li>\n<li>\n<p>서버는 클라이언트가 전송한 pre master secret 값을 자신의 비공개키로 복호화한다. 이로서 서버와 클라이언트가 모두 pre master secret 값을 공유하게 되었다. 그리고 서버와 클라이언트는 모두 일련의 과정을 거쳐서 pre master secret 값을 master secret 값으로 만든다. master secret는 session key를 생성하는데 이 session key 값을 이용해서 서버와 클라이언트는 데이터를 대칭키 방식으로 암호화 한 후에 주고 받는다. 이렇게해서 세션키를 클라이언트와 서버가 모두 공유하게 되었다는 점을 기억해야한다.</p>\n</li>\n<li>\n<p>클라이언트와 서버는 핸드쉐이크 단계의 종료를 서로에게 알린다.</p>\n</li>\n</ol>\n<h3>세션</h3>\n<p>세션은 실제로 서버와 클라이언트가 데이터를 주고 받는 단계이다. 이 단계에서 핵심은 정보를 상대방에게 전송하기 전에 session key 값을 이용해서 대칭키 방식으로 암호화 한다는 점이다. 암호화된 정보는 상대방에게 전송될 것이고, 상대방도 세션키 값을 알고 있기 때문에 암호를 복호화 할 수 있다.</p>\n<h3>세션 종료</h3>\n<p>데이터의 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알려준다. 이 때 통신에서 사용한 대칭키인 세션키를 폐기한다.</p>\n<h3>정리</h3>\n<p>위에 내용을 좀더 쉽게 설명하는 그림이 있어서 첨부했다.</p>\n<p><img src=\"https://i.imgur.com/KYgfDFo.png\" alt=\"\"></p>\n<ol>\n<li>해당사이트는  CA에 인증서를 발급요청한다</li>\n<li>CA로부터 검토를 인증기관의 개인키로 암호화하여 사이트 인증서 제작</li>\n<li>서버로 인증서 발급</li>\n<li>인증브라우저에게 인증기관의 공개키를 제공</li>\n<li>브라우저가 서버에 접속 요청.</li>\n<li>서버는 CA로부터 발급받은 인증서를 브라우저에게 전달</li>\n<li>인증기관의 개인키로 서버로 부터 받은 인증서 해독하여 서버 공개키 획득</li>\n<li>브라우저는 서버로부터 받은공개키로 대칭키를 암호화하여 서버로 전송</li>\n<li>서버는 개인키로 브라우저로부터받은 정보 해독후 대칭키를 얻는다</li>\n<li>대칭키를 이용하여 통신함.</li>\n</ol>\n<h2>참고</h2>\n<ul>\n<li><a href=\"https://opentutorials.org/course/228/4894\" target=\"_blank\" rel=\"noopener\">생활코딩</a></li>\n</ul>\n"},{"title":"OAuth란?","catalog":true,"date":"2018-02-23T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n## OAuth1 란\nOAuth는 Open Authorization, Open Authentication 뜻하는 것으로 애플리케이션(페이스북,구글,트위터)(Service Provider)의 유저의 비밀번호를 Third party앱에 제공 없이 인증,인가를 할 수 있는 오픈 스탠다드 프로토콜이다. OAuth 인증을 통해 애플리케이션 API를 유저대신에 접근할 수 있는 권한을 얻을 수 있다. OAuth가 사용되기 전에는 외부 사이트와 인증기반의 데이터를 연동할 때  인증방식의 표준이 없었기 때문에 기존의 기본인증인 아이디와 비밀번호를 사용하였는데, 이는 보안상 취약한 구조였다. 유저의 비밀번호가 노출될 가망성이 크기 때문이다. 그렇기 때문에 이 문제를 보안하기 위해 OAuth의 인증은 API를 제공하는 서버에서 진행하고, 유저가 인증되었다는 Access Token을 발급하였다. 그 발급된 Access token으로 Third party(Consumer)애플리케이션에서는 Service Provider의 API를 안전하고 쉽게 사용할 수 있게 되었다.\n\n\n### 동작 방식\n먼저 OAuth의 동작 방식을 알기 위해서는 아래의 개념을 알고 있어야 한다.\n#### OAuth의 개념\n먼저 OAuth의는 아래와 같은 개념을 가지고있다.\n| 용어               | 설명                                                                                                                   |\n| ------------------ | ---------------------------------------------------------------------------------------------------------------------- |\n| User               | Service Provider에 계정을 가지고 있으면서, Consumer앱을 이용하려는 사용자                                              |\n| Service Provider   | OAuth를 사용하는 Open API를 제공하는 서비스 (facebook,google등)                                                        |\n| Protected Resource | Service Provider로부터 제공되어지는 API 자원들                                                                         |\n| Consumer           | OAuth 인증을 사용해 Service Provider의 기능을 사용하려는 애플리케이션이나 웹 서비스                                    |\n| Consumer Key       | Consumer가 Service Provider에게 자신을 식별하는 데 사용하는키                                                          |\n| Consumer Secret    | Consumer Key의 소유권을 확립하기 위해 Consumer가 사용하는 Secret                                                       |\n| Request Token      | Consumer가 Service Provider에게 접근 권한을 인증받기 위해 사용하는 값. 인증이 완료된 후에는 Access Token으로 교환한다. |\n| Access Token       | 인증 후 Consumer가 Service Provider의 자원에 접근하기 위한 키를 포함한 값                                              |\n| Token Secret       | 주어진 토큰의 소유권을 인증하기 위해 소비자가 사용하는 Secret                                                          |\n\n#### OAuth의 WorkFlow\n다음은  OAuth의 1.0의 WorkFlow이다.\n![](https://i.imgur.com/7T48KvR.png)\n\n\n위 WorkFlow 흐름은 간단하게 이렇다.\n1. 그림에는 없지만 가장 먼저 Consumer는 Service Provider로부터 Client key와 Secret을 발급 받아야한다. 이것은 Service Provider에 API를 사용할것을 등록하는것과 동시에 Service Provider가 Consmer를 식별할 수 있게 해준다.\n2. 그림에 A 처럼 Request Token을 요청할 때 Consumer 정보, Signature 정보를 포함하여 Request token을 요청을하고 B의 흐름처럼 Request token을 발급받는다.\n3. Request Token값을 받은후 Consumer는 C처럼 User를 Service Provider에 인증 사이트로 다이렉트시키고, 유저는 그곳에서 Service Provider에 유저임을 인증하게 된다.\n4. 그러면 Consumer는 D의 정보처럼 해당 유저가 인증이되면 OAuth_token와 OAuth_verifier를 넘겨준다.\n5. 그이후에 Consumer는 OAuth_token와 OAuth_verifier받았다면 E의 흐름처럼 다시 서명을 만들어 Access Token을 요청하게 된다.\n6. 그리고 Service Provider는 받은 토큰과 서명들이 인증이 되었으면 Access Token을 F의 정보 처럼 넘기게된다.\n7. 그리고 그 Access Token 및 서명정보를 통해 Service Provider에 Protected Resource에 접근할 수 있게 된다.\n\n아래는 Consumer의 요청시 매개변수의 종류에 대한 설명이다.\n\n##### Request Token 발급 매개변수\nRequest Token 발급 요청 시 사용하는 매개변수는 다음 표와 같다.\n| 매개변수               | 설명                                                                                                                                                                                           |\n| ---------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| OAuth_callback         | Service Provider가 인증을 완료한 후 리다이렉트할 Consumer의 웹 주소. 만약 Consumer가 웹 애플리케이션이 아니라 리다이렉트할 주소가 없다면 소문자로 'oob'(Out Of Band라는 뜻)를 값으로 사용한다. |\n| OAuth_consumer_key    |Consumer를 구별하는 키 값. Service Provider는 이 키 값으로 Consumer를 구분한다. |                                                                                                                                                                                                |\n| OAuth_nonce  |Consumer에서 임시로 생성한 임의의 문자열. OAuth_timestamp의 값이 같은 요청에서는 유일한 값이어야 한다. 이는 악의적인 목적으로 계속 요청을 보내는 것을 막기 위해서이다.          |                                                                                                                                                                                                |\n| OAuth_signature |OAuth 인증 정보를 암호화하고 인코딩하여 서명 값. OAuth 인증 정보는 매개변수 중에서 OAuth_signature를 제외한 나머지 매개변수와 HTTP 요청 방식을 문자열로 조합한 값이다. 암화 방식은 OAuth_signature_method에 정의된다.       |                                                                                                                                                                                                |\n| OAuth_signature_method |OAuth_signature를 암호화하는 방법. HMAC-SHA1, HMAC-MD5 등을 사용할 수 있다. |                                                                                                                                                                                                |\n| OAuth_timestamp |요청을 생성한 시점의 타임스탬프. 1970년1월 1일 00시 00분 00초 이후의 시간을 초로 환산한 초 단위의 누적 시간이다.       |                                                                                                                                                                                                |\n| OAuth_version   |\tOAuth 사용 버전. 1.0a는 1.0이라고 명시하면 된다.      |                                                                                                                    \n##### Request Token Signature 생성\n\nOAuth 1.0에서 Service Provider에게 요청을 할려면 매번 전자 서명을 만들어서 보내야한다. 아래는 전자서명을 만드는 순서이다.\n\n1. 요청 매개변수를 모두 모은다.\nOAuth_signature를 제외하고 'OAuth_'로 시작하는 OAuth 관련 매개변수를 모은다. 모든 매개변수를 사전순으로 정렬하고 각각의 키(key)와 값(value)에 URL 인코딩(rfc3986)을 적용한다. URL 인코딩을 실시한 결과를 = 형태로 나열하고 각 쌍 사이에는 &을 넣는다. 이렇게 나온 결과 전체에 또 URL 인코딩을 적용한다.\n\n2. 매개변수를 정규화(Normalize)한다.\n모든 매개변수를 사전순으로 정렬하고 각각의 키(key)와 값(value)에 URL 인코딩(rfc3986)을 적용한다. URL 인코딩을 실시한 결과를 = 형태로 나열하고 각 쌍 사이에는 &을 넣는다. 이렇게 나온 결과 전체에 또 URL 인코딩을 적용한다.\n\n3. Signature Base String을 만든다.\nHTTP method 명(GET 또는 POST), Consumer가 호출한 HTTP URL 주소(매개변수 제외), 정규화한 매개변수를 '&'를 사용해 결합한다. 즉 '[GET|POST] + & + [URL 문자열로 매개변수는 제외] + & + [정규화한 매개변수]' 형태가 된다.\n\n4. 키 생성\n3번 과정까지 거쳐 생성한 문자열을 암호화한다. 암호화할 때 Consumer Secret Key를 사용한다. Consumer Secret Key는 Consumer가 Service Provider에 사용 등록을 할 때 발급받은 값이다. HMAC-SHA1 등의 암호화 방법을 이용하여 최종적인 OAuth_signature를 생성한다.\n\n\n##### Access Token 매개변수\n다음은 Access Token 발급을 요청할 때 사용하는 매개변수 표이다.\n\n| 매개변수               | 설명 |\n| ---------------------- | ---- |\n| OAuth_consumer_key     | Consumer를 구별하는 키 값. Service Provider는 이 키 값으로 Consumer를 구분한다.     |\n| OAuth_nonce            | Consumer에서 임시로 생성한 임의의 문자열. OAuth_timestamp의 값이 같은 요청에서는 유일한 값이어야 한다. 이는 악의적인 목적으로 계속 요청을 보내는 것을 막기 위해서이다.     |\n| OAuth_signature        |OAuth 인증 정보를 암호화하고 인코딩하여 서명 값. OAuth 인증 정보는 매개변수 중에서 OAuth_signature를 제외한 나머지 매개변수와 HTTP 요청 방식을 문자열로 조합한 값이다. 암화 방식은 OAuth_signature_method에 정의된다.      |\n| OAuth_signature_method | OAuth_signature를 암호화하는 방법. HMAC-SHA1, HMAC-MD5 등을 사용할 수 있다.     |\n| OAuth_timestamp        | 요청을 생성한 시점의 타임스탬프. 1970년1월 1일 00시 00분 00초 이후의 시간을 초로 환산한 초 단위의 누적 시간이다.     |\n| OAuth_version          |  OAuth 사용 버전    |\n| OAuth_verifier         | Request Token 요청 시 OAuth_callback으로 전달받은 OAuth_verifier 값     |\n| OAuth_token            | Request Token 요청 시 OAuth_callback으로 전달받은 OAuth_token 값     |\n\n\n##### API호출을 위한 매개변수\n다음은 Access Token을 사용해 API를 호출할 때 사용하는 매개변수는 다음 표이다.\n| 매개변수               | 설명 |\n| ---------------------- | ---- |\n| OAuth_consumer_key     | Consumer를 구별하는 키 값. Service Provider는 이 키 값으로 Consumer를 구분한다.     |\n| OAuth_nonce            | Consumer에서 임시로 생성한 임의의 문자열. OAuth_timestamp의 값이 같은 요청에서는 유일한 값이어야 한다. 이는 악의적인 목적으로 계속 요청을 보내는 것을 막기 위해서이다.     |\n| OAuth_signature        | OAuth 인증 정보를 암호화하고 인코딩하여 서명 값. OAuth 인증 정보는 매개변수 중에서 OAuth_signature를 제외한 나머지 매개변수와 HTTP 요청 방식을 문자열로 조합한 값이다. 암화 방식은 OAuth_signature_method에 정의된다.     |\n| OAuth_signature_method | OAuth_signature를 암호화하는 방법. HMAC-SHA1, HMAC-MD5 등을 사용할 수 있다.     |\n| OAuth_timestamp        |요청을 생성한 시점의 타임스탬프. 1970년1월 1일 00시 00분 00초 이후의 시간을 초로 환산한 초 단위의 누적 시간이다.      |\n| OAuth_version          | OAuth 버전     |\n| OAuth_token                       | OAuth_callback으로 전달받은 OAuth_token     |\n\n\n## OAuth2란\nOAuth의2는 OAuth의1의 유저의 인증플로우, 전반적인 목적만 공유하고 OAuth의1.0을 새로 작성한것이다. OAuth의1.0과 OAuth의2.0의 차이는 앱 애플리케이션, 웹 애플리케이션, 데스크탑 애플리케이션등의 인증방식을 강화하고 Consumer에 개발 간소화를 중심으로 개발 되었다.\n\n### OAuth의1.0 과 OAuth의2.0차이점\n아래는 OAuth 1.0 에서 OAuth2.0 차이점은 일단 인증 절차 간소화 됨으로써 개발자들이 구현하기 더쉬워졌고, 기존에 사용하던 용어도 바뀌면서 Authorizaiton server와 Resource서버의 분리가 명시적으로 되었다. 또한 다양한 인증 방식을 지원하게 됐다. 아래는 1.0과 2.0의 차이점을 나열한것이다.\n#### 인증 절차 간소화\n* 기능의 단순화, 기능과 규모의 확장성 등을 지원하기 위해 만들어 졌다.\n* 기존의 OAuth1.0은 디지털 서명 기반이었지만 OAuth2.0의 암호화는 https에 맡김으로써 복잡한 디지털 서명에관한 로직을 요구하지 않기때문에 구현 자체가 개발자입장에서 쉬워짐.\n\n#### 용어 변경\n* Resource Owner : 사용자 (1.0 User해당)\n* Resource Server : REST API 서버 (1.0 Protected Resource)\n* Authorization Server : 인증서버 (API 서버와 같을 수도 있음)(1.0 Service Provider)\n* Client : 써드파티 어플리케이션 (1.0 Service Provider 해당)\n\n#### Resource Server와 Authorization Server서버의 분리\n* 커다란 서비스는 인증 서버를 분리하거나 다중화 할 수 있어야 함.\n* Authorization Server의 역할을 명확히 함.\n\n#### 다양한 인증 방식(Grant_type)\n* Authorization Code Grant\n* Implicit Grant\n* Resource Owner Password Credentials Grant\n* Client Credentials Grant\n* Device Code Grant\n* Refresh Token Grant\n\n### 인증 종류\nOAuth 2.0의 인증종류는 6가지 입니다. 아래는 각각의 인증방식의 flow와 간단한 설명입니다.\n\n#### Authorization Code Grant\n일반적인 웹사이트에서 소셜로그인과 같은 인증을 받을 때 가장 많이 쓰는 방식으로 기본적으로 지원하고 있는 방식이다. 아래는 Authorization Code Grant type 으로 Access Token을 얻어오는 시퀀스 다이어그램이다.\n![](https://i.imgur.com/xaKCz9E.png)\n1. 먼저 클라이언트가 Redirect URL을 포함하여 Authorization server 인증 요청을 한다.\n2. AuthorizationServer는 유저에게 로그인창을 제공하여 유저를 인증하게 된다.\n3. AuthorizationServer는 Authorization code를 클라이언트에게 제공해준다.\n4. Client는 코드를 Authorization server에 Access Token을 요청한다.\n5. Authorization 서버는 클라이언트에게 Access token을 발급해준다.\n6. 그 Access token을 이용하여 Resource server에 자원을 접근할 수 있게 된다.\n7. 그이후에 토큰이 만료된다면 refresh token을 이용하여 토큰을 재발급 받을 수 있다.\n\n#### Implicit Grant\nPublic Client인 브라우저 기반의 애플리케이션(Javascript application)이나 모바일 애플리케이션에서 바로 Resource Server에 접근하여 사용할 수 있는 방식이다.\n![](https://i.imgur.com/DayLoth.png)\n1. 클라이언트는 Authorization server에 인증을 요청한다.\n2. 유저는 Authorization server를 통해 인증한다.\n3. Authorization server는 Access token을 포함하여 클라이언트의 Redirect url을 호출한다.\n4. 클라이언트는 해당 Access token이 유효한지 Authorization server에 인증요청한다.\n5. 인증서버는 그 토큰이 유효하다면 토큰의 만기시간과함께 리턴해준다.\n6. 클라이언트는 Resource server에 접근할 수 있게된다.\n\n\n#### Resource Owner Password Credentials Grant\nClient에 아이디/패스워드를 받아 아이디/패스워드로 직접 access token을 받아오는 방식이다. Client가 신용이 없을 때에는 사용하기에 위험하다는 단점이 있다. 클라이언트가 확실한 신용이 보장될 때 사용할 수 있는 방식이다.\n![](https://i.imgur.com/FVv86QT.png)\n1. User가 Id와 Password를 입력한다\n2. 클라이언트는 유저의 id와 password와 클라이언트 정보를 넘긴다.\n3. Authorization sever는 Access token을 넘긴다.\n\n\n#### Client Credentials Grant\n애플리케이션이 Confidential Client일 때 id와 secret을 가지고 인증하는 방식이다.\n![](https://i.imgur.com/TMXAjvo.png)\n1. 클라이언트 정보를 Authorization server에 넘긴다.\n2. Access Token을 Client에 전달한다.\n\n#### Device Code Grant\n장치 코드 부여 유형은 브라우저가 없거나 입력이 제한된 장치에서 사용됩니다.\n\n#### Refresh Token Grant\n기존에 저장해둔 리프러시 토큰이 존재할 때 엑세스토큰 재발급 받을 필요가 있을 때 사용한다. 그리고 기존 액세스는 토큰이 만료된다.\n\n\n\n참고 사이트\n\n* [Naver D2](http://d2.naver.com/helloworld/24942)\n* [OAuth.net](https://OAuth.net/core/1.0/)\n* [Showerbugs](https://showerbugs.github.io/2017-11-16/OAuth-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C)\n* [OAuth 2.0 Servers](https://www.OAuth.com/OAuth2-servers/differences-between-OAuth-1-2/)\n* [이수홍](https://brunch.co.kr/@sbcoba/4)\n* [Authorization Code Flow](https://developer.accela.com/docs/construct-authCodeFlow.html)\n* [OX Wiki](https://ox.gluu.org/doku.php?id=oxauth:implicitgrant)\n","source":"_posts/2018-02-24-OAuth.md","raw":"---\ntitle: OAuth란?\ncatalog: true\ndate: 2018-02-24\nsubtitle:\nheader-img:\ntags:\n- ETC\n- OAuth\n\n---\n\n## OAuth1 란\nOAuth는 Open Authorization, Open Authentication 뜻하는 것으로 애플리케이션(페이스북,구글,트위터)(Service Provider)의 유저의 비밀번호를 Third party앱에 제공 없이 인증,인가를 할 수 있는 오픈 스탠다드 프로토콜이다. OAuth 인증을 통해 애플리케이션 API를 유저대신에 접근할 수 있는 권한을 얻을 수 있다. OAuth가 사용되기 전에는 외부 사이트와 인증기반의 데이터를 연동할 때  인증방식의 표준이 없었기 때문에 기존의 기본인증인 아이디와 비밀번호를 사용하였는데, 이는 보안상 취약한 구조였다. 유저의 비밀번호가 노출될 가망성이 크기 때문이다. 그렇기 때문에 이 문제를 보안하기 위해 OAuth의 인증은 API를 제공하는 서버에서 진행하고, 유저가 인증되었다는 Access Token을 발급하였다. 그 발급된 Access token으로 Third party(Consumer)애플리케이션에서는 Service Provider의 API를 안전하고 쉽게 사용할 수 있게 되었다.\n\n\n### 동작 방식\n먼저 OAuth의 동작 방식을 알기 위해서는 아래의 개념을 알고 있어야 한다.\n#### OAuth의 개념\n먼저 OAuth의는 아래와 같은 개념을 가지고있다.\n| 용어               | 설명                                                                                                                   |\n| ------------------ | ---------------------------------------------------------------------------------------------------------------------- |\n| User               | Service Provider에 계정을 가지고 있으면서, Consumer앱을 이용하려는 사용자                                              |\n| Service Provider   | OAuth를 사용하는 Open API를 제공하는 서비스 (facebook,google등)                                                        |\n| Protected Resource | Service Provider로부터 제공되어지는 API 자원들                                                                         |\n| Consumer           | OAuth 인증을 사용해 Service Provider의 기능을 사용하려는 애플리케이션이나 웹 서비스                                    |\n| Consumer Key       | Consumer가 Service Provider에게 자신을 식별하는 데 사용하는키                                                          |\n| Consumer Secret    | Consumer Key의 소유권을 확립하기 위해 Consumer가 사용하는 Secret                                                       |\n| Request Token      | Consumer가 Service Provider에게 접근 권한을 인증받기 위해 사용하는 값. 인증이 완료된 후에는 Access Token으로 교환한다. |\n| Access Token       | 인증 후 Consumer가 Service Provider의 자원에 접근하기 위한 키를 포함한 값                                              |\n| Token Secret       | 주어진 토큰의 소유권을 인증하기 위해 소비자가 사용하는 Secret                                                          |\n\n#### OAuth의 WorkFlow\n다음은  OAuth의 1.0의 WorkFlow이다.\n![](https://i.imgur.com/7T48KvR.png)\n\n\n위 WorkFlow 흐름은 간단하게 이렇다.\n1. 그림에는 없지만 가장 먼저 Consumer는 Service Provider로부터 Client key와 Secret을 발급 받아야한다. 이것은 Service Provider에 API를 사용할것을 등록하는것과 동시에 Service Provider가 Consmer를 식별할 수 있게 해준다.\n2. 그림에 A 처럼 Request Token을 요청할 때 Consumer 정보, Signature 정보를 포함하여 Request token을 요청을하고 B의 흐름처럼 Request token을 발급받는다.\n3. Request Token값을 받은후 Consumer는 C처럼 User를 Service Provider에 인증 사이트로 다이렉트시키고, 유저는 그곳에서 Service Provider에 유저임을 인증하게 된다.\n4. 그러면 Consumer는 D의 정보처럼 해당 유저가 인증이되면 OAuth_token와 OAuth_verifier를 넘겨준다.\n5. 그이후에 Consumer는 OAuth_token와 OAuth_verifier받았다면 E의 흐름처럼 다시 서명을 만들어 Access Token을 요청하게 된다.\n6. 그리고 Service Provider는 받은 토큰과 서명들이 인증이 되었으면 Access Token을 F의 정보 처럼 넘기게된다.\n7. 그리고 그 Access Token 및 서명정보를 통해 Service Provider에 Protected Resource에 접근할 수 있게 된다.\n\n아래는 Consumer의 요청시 매개변수의 종류에 대한 설명이다.\n\n##### Request Token 발급 매개변수\nRequest Token 발급 요청 시 사용하는 매개변수는 다음 표와 같다.\n| 매개변수               | 설명                                                                                                                                                                                           |\n| ---------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| OAuth_callback         | Service Provider가 인증을 완료한 후 리다이렉트할 Consumer의 웹 주소. 만약 Consumer가 웹 애플리케이션이 아니라 리다이렉트할 주소가 없다면 소문자로 'oob'(Out Of Band라는 뜻)를 값으로 사용한다. |\n| OAuth_consumer_key    |Consumer를 구별하는 키 값. Service Provider는 이 키 값으로 Consumer를 구분한다. |                                                                                                                                                                                                |\n| OAuth_nonce  |Consumer에서 임시로 생성한 임의의 문자열. OAuth_timestamp의 값이 같은 요청에서는 유일한 값이어야 한다. 이는 악의적인 목적으로 계속 요청을 보내는 것을 막기 위해서이다.          |                                                                                                                                                                                                |\n| OAuth_signature |OAuth 인증 정보를 암호화하고 인코딩하여 서명 값. OAuth 인증 정보는 매개변수 중에서 OAuth_signature를 제외한 나머지 매개변수와 HTTP 요청 방식을 문자열로 조합한 값이다. 암화 방식은 OAuth_signature_method에 정의된다.       |                                                                                                                                                                                                |\n| OAuth_signature_method |OAuth_signature를 암호화하는 방법. HMAC-SHA1, HMAC-MD5 등을 사용할 수 있다. |                                                                                                                                                                                                |\n| OAuth_timestamp |요청을 생성한 시점의 타임스탬프. 1970년1월 1일 00시 00분 00초 이후의 시간을 초로 환산한 초 단위의 누적 시간이다.       |                                                                                                                                                                                                |\n| OAuth_version   |\tOAuth 사용 버전. 1.0a는 1.0이라고 명시하면 된다.      |                                                                                                                    \n##### Request Token Signature 생성\n\nOAuth 1.0에서 Service Provider에게 요청을 할려면 매번 전자 서명을 만들어서 보내야한다. 아래는 전자서명을 만드는 순서이다.\n\n1. 요청 매개변수를 모두 모은다.\nOAuth_signature를 제외하고 'OAuth_'로 시작하는 OAuth 관련 매개변수를 모은다. 모든 매개변수를 사전순으로 정렬하고 각각의 키(key)와 값(value)에 URL 인코딩(rfc3986)을 적용한다. URL 인코딩을 실시한 결과를 = 형태로 나열하고 각 쌍 사이에는 &을 넣는다. 이렇게 나온 결과 전체에 또 URL 인코딩을 적용한다.\n\n2. 매개변수를 정규화(Normalize)한다.\n모든 매개변수를 사전순으로 정렬하고 각각의 키(key)와 값(value)에 URL 인코딩(rfc3986)을 적용한다. URL 인코딩을 실시한 결과를 = 형태로 나열하고 각 쌍 사이에는 &을 넣는다. 이렇게 나온 결과 전체에 또 URL 인코딩을 적용한다.\n\n3. Signature Base String을 만든다.\nHTTP method 명(GET 또는 POST), Consumer가 호출한 HTTP URL 주소(매개변수 제외), 정규화한 매개변수를 '&'를 사용해 결합한다. 즉 '[GET|POST] + & + [URL 문자열로 매개변수는 제외] + & + [정규화한 매개변수]' 형태가 된다.\n\n4. 키 생성\n3번 과정까지 거쳐 생성한 문자열을 암호화한다. 암호화할 때 Consumer Secret Key를 사용한다. Consumer Secret Key는 Consumer가 Service Provider에 사용 등록을 할 때 발급받은 값이다. HMAC-SHA1 등의 암호화 방법을 이용하여 최종적인 OAuth_signature를 생성한다.\n\n\n##### Access Token 매개변수\n다음은 Access Token 발급을 요청할 때 사용하는 매개변수 표이다.\n\n| 매개변수               | 설명 |\n| ---------------------- | ---- |\n| OAuth_consumer_key     | Consumer를 구별하는 키 값. Service Provider는 이 키 값으로 Consumer를 구분한다.     |\n| OAuth_nonce            | Consumer에서 임시로 생성한 임의의 문자열. OAuth_timestamp의 값이 같은 요청에서는 유일한 값이어야 한다. 이는 악의적인 목적으로 계속 요청을 보내는 것을 막기 위해서이다.     |\n| OAuth_signature        |OAuth 인증 정보를 암호화하고 인코딩하여 서명 값. OAuth 인증 정보는 매개변수 중에서 OAuth_signature를 제외한 나머지 매개변수와 HTTP 요청 방식을 문자열로 조합한 값이다. 암화 방식은 OAuth_signature_method에 정의된다.      |\n| OAuth_signature_method | OAuth_signature를 암호화하는 방법. HMAC-SHA1, HMAC-MD5 등을 사용할 수 있다.     |\n| OAuth_timestamp        | 요청을 생성한 시점의 타임스탬프. 1970년1월 1일 00시 00분 00초 이후의 시간을 초로 환산한 초 단위의 누적 시간이다.     |\n| OAuth_version          |  OAuth 사용 버전    |\n| OAuth_verifier         | Request Token 요청 시 OAuth_callback으로 전달받은 OAuth_verifier 값     |\n| OAuth_token            | Request Token 요청 시 OAuth_callback으로 전달받은 OAuth_token 값     |\n\n\n##### API호출을 위한 매개변수\n다음은 Access Token을 사용해 API를 호출할 때 사용하는 매개변수는 다음 표이다.\n| 매개변수               | 설명 |\n| ---------------------- | ---- |\n| OAuth_consumer_key     | Consumer를 구별하는 키 값. Service Provider는 이 키 값으로 Consumer를 구분한다.     |\n| OAuth_nonce            | Consumer에서 임시로 생성한 임의의 문자열. OAuth_timestamp의 값이 같은 요청에서는 유일한 값이어야 한다. 이는 악의적인 목적으로 계속 요청을 보내는 것을 막기 위해서이다.     |\n| OAuth_signature        | OAuth 인증 정보를 암호화하고 인코딩하여 서명 값. OAuth 인증 정보는 매개변수 중에서 OAuth_signature를 제외한 나머지 매개변수와 HTTP 요청 방식을 문자열로 조합한 값이다. 암화 방식은 OAuth_signature_method에 정의된다.     |\n| OAuth_signature_method | OAuth_signature를 암호화하는 방법. HMAC-SHA1, HMAC-MD5 등을 사용할 수 있다.     |\n| OAuth_timestamp        |요청을 생성한 시점의 타임스탬프. 1970년1월 1일 00시 00분 00초 이후의 시간을 초로 환산한 초 단위의 누적 시간이다.      |\n| OAuth_version          | OAuth 버전     |\n| OAuth_token                       | OAuth_callback으로 전달받은 OAuth_token     |\n\n\n## OAuth2란\nOAuth의2는 OAuth의1의 유저의 인증플로우, 전반적인 목적만 공유하고 OAuth의1.0을 새로 작성한것이다. OAuth의1.0과 OAuth의2.0의 차이는 앱 애플리케이션, 웹 애플리케이션, 데스크탑 애플리케이션등의 인증방식을 강화하고 Consumer에 개발 간소화를 중심으로 개발 되었다.\n\n### OAuth의1.0 과 OAuth의2.0차이점\n아래는 OAuth 1.0 에서 OAuth2.0 차이점은 일단 인증 절차 간소화 됨으로써 개발자들이 구현하기 더쉬워졌고, 기존에 사용하던 용어도 바뀌면서 Authorizaiton server와 Resource서버의 분리가 명시적으로 되었다. 또한 다양한 인증 방식을 지원하게 됐다. 아래는 1.0과 2.0의 차이점을 나열한것이다.\n#### 인증 절차 간소화\n* 기능의 단순화, 기능과 규모의 확장성 등을 지원하기 위해 만들어 졌다.\n* 기존의 OAuth1.0은 디지털 서명 기반이었지만 OAuth2.0의 암호화는 https에 맡김으로써 복잡한 디지털 서명에관한 로직을 요구하지 않기때문에 구현 자체가 개발자입장에서 쉬워짐.\n\n#### 용어 변경\n* Resource Owner : 사용자 (1.0 User해당)\n* Resource Server : REST API 서버 (1.0 Protected Resource)\n* Authorization Server : 인증서버 (API 서버와 같을 수도 있음)(1.0 Service Provider)\n* Client : 써드파티 어플리케이션 (1.0 Service Provider 해당)\n\n#### Resource Server와 Authorization Server서버의 분리\n* 커다란 서비스는 인증 서버를 분리하거나 다중화 할 수 있어야 함.\n* Authorization Server의 역할을 명확히 함.\n\n#### 다양한 인증 방식(Grant_type)\n* Authorization Code Grant\n* Implicit Grant\n* Resource Owner Password Credentials Grant\n* Client Credentials Grant\n* Device Code Grant\n* Refresh Token Grant\n\n### 인증 종류\nOAuth 2.0의 인증종류는 6가지 입니다. 아래는 각각의 인증방식의 flow와 간단한 설명입니다.\n\n#### Authorization Code Grant\n일반적인 웹사이트에서 소셜로그인과 같은 인증을 받을 때 가장 많이 쓰는 방식으로 기본적으로 지원하고 있는 방식이다. 아래는 Authorization Code Grant type 으로 Access Token을 얻어오는 시퀀스 다이어그램이다.\n![](https://i.imgur.com/xaKCz9E.png)\n1. 먼저 클라이언트가 Redirect URL을 포함하여 Authorization server 인증 요청을 한다.\n2. AuthorizationServer는 유저에게 로그인창을 제공하여 유저를 인증하게 된다.\n3. AuthorizationServer는 Authorization code를 클라이언트에게 제공해준다.\n4. Client는 코드를 Authorization server에 Access Token을 요청한다.\n5. Authorization 서버는 클라이언트에게 Access token을 발급해준다.\n6. 그 Access token을 이용하여 Resource server에 자원을 접근할 수 있게 된다.\n7. 그이후에 토큰이 만료된다면 refresh token을 이용하여 토큰을 재발급 받을 수 있다.\n\n#### Implicit Grant\nPublic Client인 브라우저 기반의 애플리케이션(Javascript application)이나 모바일 애플리케이션에서 바로 Resource Server에 접근하여 사용할 수 있는 방식이다.\n![](https://i.imgur.com/DayLoth.png)\n1. 클라이언트는 Authorization server에 인증을 요청한다.\n2. 유저는 Authorization server를 통해 인증한다.\n3. Authorization server는 Access token을 포함하여 클라이언트의 Redirect url을 호출한다.\n4. 클라이언트는 해당 Access token이 유효한지 Authorization server에 인증요청한다.\n5. 인증서버는 그 토큰이 유효하다면 토큰의 만기시간과함께 리턴해준다.\n6. 클라이언트는 Resource server에 접근할 수 있게된다.\n\n\n#### Resource Owner Password Credentials Grant\nClient에 아이디/패스워드를 받아 아이디/패스워드로 직접 access token을 받아오는 방식이다. Client가 신용이 없을 때에는 사용하기에 위험하다는 단점이 있다. 클라이언트가 확실한 신용이 보장될 때 사용할 수 있는 방식이다.\n![](https://i.imgur.com/FVv86QT.png)\n1. User가 Id와 Password를 입력한다\n2. 클라이언트는 유저의 id와 password와 클라이언트 정보를 넘긴다.\n3. Authorization sever는 Access token을 넘긴다.\n\n\n#### Client Credentials Grant\n애플리케이션이 Confidential Client일 때 id와 secret을 가지고 인증하는 방식이다.\n![](https://i.imgur.com/TMXAjvo.png)\n1. 클라이언트 정보를 Authorization server에 넘긴다.\n2. Access Token을 Client에 전달한다.\n\n#### Device Code Grant\n장치 코드 부여 유형은 브라우저가 없거나 입력이 제한된 장치에서 사용됩니다.\n\n#### Refresh Token Grant\n기존에 저장해둔 리프러시 토큰이 존재할 때 엑세스토큰 재발급 받을 필요가 있을 때 사용한다. 그리고 기존 액세스는 토큰이 만료된다.\n\n\n\n참고 사이트\n\n* [Naver D2](http://d2.naver.com/helloworld/24942)\n* [OAuth.net](https://OAuth.net/core/1.0/)\n* [Showerbugs](https://showerbugs.github.io/2017-11-16/OAuth-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C)\n* [OAuth 2.0 Servers](https://www.OAuth.com/OAuth2-servers/differences-between-OAuth-1-2/)\n* [이수홍](https://brunch.co.kr/@sbcoba/4)\n* [Authorization Code Flow](https://developer.accela.com/docs/construct-authCodeFlow.html)\n* [OX Wiki](https://ox.gluu.org/doku.php?id=oxauth:implicitgrant)\n","slug":"2018-02-24-OAuth","published":1,"updated":"2018-06-20T16:05:18.355Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27ei003rjjpem3ebl4n4","content":"<h2><span id=\"oauth1-란\">OAuth1 란</span></h2>\n<p>OAuth는 Open Authorization, Open Authentication 뜻하는 것으로 애플리케이션(페이스북,구글,트위터)(Service Provider)의 유저의 비밀번호를 Third party앱에 제공 없이 인증,인가를 할 수 있는 오픈 스탠다드 프로토콜이다. OAuth 인증을 통해 애플리케이션 API를 유저대신에 접근할 수 있는 권한을 얻을 수 있다. OAuth가 사용되기 전에는 외부 사이트와 인증기반의 데이터를 연동할 때  인증방식의 표준이 없었기 때문에 기존의 기본인증인 아이디와 비밀번호를 사용하였는데, 이는 보안상 취약한 구조였다. 유저의 비밀번호가 노출될 가망성이 크기 때문이다. 그렇기 때문에 이 문제를 보안하기 위해 OAuth의 인증은 API를 제공하는 서버에서 진행하고, 유저가 인증되었다는 Access Token을 발급하였다. 그 발급된 Access token으로 Third party(Consumer)애플리케이션에서는 Service Provider의 API를 안전하고 쉽게 사용할 수 있게 되었다.</p>\n<h3><span id=\"동작-방식\">동작 방식</span></h3>\n<p>먼저 OAuth의 동작 방식을 알기 위해서는 아래의 개념을 알고 있어야 한다.</p>\n<h4><span id=\"oauth의-개념\">OAuth의 개념</span></h4>\n<p>먼저 OAuth의는 아래와 같은 개념을 가지고있다.</p>\n<table>\n<thead>\n<tr>\n<th>용어</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>User</td>\n<td>Service Provider에 계정을 가지고 있으면서, Consumer앱을 이용하려는 사용자</td>\n</tr>\n<tr>\n<td>Service Provider</td>\n<td>OAuth를 사용하는 Open API를 제공하는 서비스 (facebook,google등)</td>\n</tr>\n<tr>\n<td>Protected Resource</td>\n<td>Service Provider로부터 제공되어지는 API 자원들</td>\n</tr>\n<tr>\n<td>Consumer</td>\n<td>OAuth 인증을 사용해 Service Provider의 기능을 사용하려는 애플리케이션이나 웹 서비스</td>\n</tr>\n<tr>\n<td>Consumer Key</td>\n<td>Consumer가 Service Provider에게 자신을 식별하는 데 사용하는키</td>\n</tr>\n<tr>\n<td>Consumer Secret</td>\n<td>Consumer Key의 소유권을 확립하기 위해 Consumer가 사용하는 Secret</td>\n</tr>\n<tr>\n<td>Request Token</td>\n<td>Consumer가 Service Provider에게 접근 권한을 인증받기 위해 사용하는 값. 인증이 완료된 후에는 Access Token으로 교환한다.</td>\n</tr>\n<tr>\n<td>Access Token</td>\n<td>인증 후 Consumer가 Service Provider의 자원에 접근하기 위한 키를 포함한 값</td>\n</tr>\n<tr>\n<td>Token Secret</td>\n<td>주어진 토큰의 소유권을 인증하기 위해 소비자가 사용하는 Secret</td>\n</tr>\n</tbody>\n</table>\n<h4><span id=\"oauth의-workflow\">OAuth의 WorkFlow</span></h4>\n<p>다음은  OAuth의 1.0의 WorkFlow이다.<br>\n<img src=\"https://i.imgur.com/7T48KvR.png\" alt=\"\"></p>\n<p>위 WorkFlow 흐름은 간단하게 이렇다.</p>\n<ol>\n<li>그림에는 없지만 가장 먼저 Consumer는 Service Provider로부터 Client key와 Secret을 발급 받아야한다. 이것은 Service Provider에 API를 사용할것을 등록하는것과 동시에 Service Provider가 Consmer를 식별할 수 있게 해준다.</li>\n<li>그림에 A 처럼 Request Token을 요청할 때 Consumer 정보, Signature 정보를 포함하여 Request token을 요청을하고 B의 흐름처럼 Request token을 발급받는다.</li>\n<li>Request Token값을 받은후 Consumer는 C처럼 User를 Service Provider에 인증 사이트로 다이렉트시키고, 유저는 그곳에서 Service Provider에 유저임을 인증하게 된다.</li>\n<li>그러면 Consumer는 D의 정보처럼 해당 유저가 인증이되면 OAuth_token와 OAuth_verifier를 넘겨준다.</li>\n<li>그이후에 Consumer는 OAuth_token와 OAuth_verifier받았다면 E의 흐름처럼 다시 서명을 만들어 Access Token을 요청하게 된다.</li>\n<li>그리고 Service Provider는 받은 토큰과 서명들이 인증이 되었으면 Access Token을 F의 정보 처럼 넘기게된다.</li>\n<li>그리고 그 Access Token 및 서명정보를 통해 Service Provider에 Protected Resource에 접근할 수 있게 된다.</li>\n</ol>\n<p>아래는 Consumer의 요청시 매개변수의 종류에 대한 설명이다.</p>\n<h5><span id=\"request-token-발급-매개변수\">Request Token 발급 매개변수</span></h5>\n<p>Request Token 발급 요청 시 사용하는 매개변수는 다음 표와 같다.</p>\n<table>\n<thead>\n<tr>\n<th>매개변수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OAuth_callback</td>\n<td>Service Provider가 인증을 완료한 후 리다이렉트할 Consumer의 웹 주소. 만약 Consumer가 웹 애플리케이션이 아니라 리다이렉트할 주소가 없다면 소문자로 ‘oob’(Out Of Band라는 뜻)를 값으로 사용한다.</td>\n</tr>\n<tr>\n<td>OAuth_consumer_key</td>\n<td>Consumer를 구별하는 키 값. Service Provider는 이 키 값으로 Consumer를 구분한다.</td>\n</tr>\n<tr>\n<td>OAuth_nonce</td>\n<td>Consumer에서 임시로 생성한 임의의 문자열. OAuth_timestamp의 값이 같은 요청에서는 유일한 값이어야 한다. 이는 악의적인 목적으로 계속 요청을 보내는 것을 막기 위해서이다.</td>\n</tr>\n<tr>\n<td>OAuth_signature</td>\n<td>OAuth 인증 정보를 암호화하고 인코딩하여 서명 값. OAuth 인증 정보는 매개변수 중에서 OAuth_signature를 제외한 나머지 매개변수와 HTTP 요청 방식을 문자열로 조합한 값이다. 암화 방식은 OAuth_signature_method에 정의된다.</td>\n</tr>\n<tr>\n<td>OAuth_signature_method</td>\n<td>OAuth_signature를 암호화하는 방법. HMAC-SHA1, HMAC-MD5 등을 사용할 수 있다.</td>\n</tr>\n<tr>\n<td>OAuth_timestamp</td>\n<td>요청을 생성한 시점의 타임스탬프. 1970년1월 1일 00시 00분 00초 이후의 시간을 초로 환산한 초 단위의 누적 시간이다.</td>\n</tr>\n<tr>\n<td>OAuth_version</td>\n<td>OAuth 사용 버전. 1.0a는 1.0이라고 명시하면 된다.</td>\n</tr>\n</tbody>\n</table>\n<h5><span id=\"request-token-signature-생성\">Request Token Signature 생성</span></h5>\n<p>OAuth 1.0에서 Service Provider에게 요청을 할려면 매번 전자 서명을 만들어서 보내야한다. 아래는 전자서명을 만드는 순서이다.</p>\n<ol>\n<li>\n<p>요청 매개변수를 모두 모은다.<br>\nOAuth_signature를 제외하고 'OAuth_'로 시작하는 OAuth 관련 매개변수를 모은다. 모든 매개변수를 사전순으로 정렬하고 각각의 키(key)와 값(value)에 URL 인코딩(rfc3986)을 적용한다. URL 인코딩을 실시한 결과를 = 형태로 나열하고 각 쌍 사이에는 &amp;을 넣는다. 이렇게 나온 결과 전체에 또 URL 인코딩을 적용한다.</p>\n</li>\n<li>\n<p>매개변수를 정규화(Normalize)한다.<br>\n모든 매개변수를 사전순으로 정렬하고 각각의 키(key)와 값(value)에 URL 인코딩(rfc3986)을 적용한다. URL 인코딩을 실시한 결과를 = 형태로 나열하고 각 쌍 사이에는 &amp;을 넣는다. 이렇게 나온 결과 전체에 또 URL 인코딩을 적용한다.</p>\n</li>\n<li>\n<p>Signature Base String을 만든다.<br>\nHTTP method 명(GET 또는 POST), Consumer가 호출한 HTTP URL 주소(매개변수 제외), 정규화한 매개변수를 '&amp;'를 사용해 결합한다. 즉 ‘[GET|POST] + &amp; + [URL 문자열로 매개변수는 제외] + &amp; + [정규화한 매개변수]’ 형태가 된다.</p>\n</li>\n<li>\n<p>키 생성<br>\n3번 과정까지 거쳐 생성한 문자열을 암호화한다. 암호화할 때 Consumer Secret Key를 사용한다. Consumer Secret Key는 Consumer가 Service Provider에 사용 등록을 할 때 발급받은 값이다. HMAC-SHA1 등의 암호화 방법을 이용하여 최종적인 OAuth_signature를 생성한다.</p>\n</li>\n</ol>\n<h5><span id=\"access-token-매개변수\">Access Token 매개변수</span></h5>\n<p>다음은 Access Token 발급을 요청할 때 사용하는 매개변수 표이다.</p>\n<table>\n<thead>\n<tr>\n<th>매개변수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OAuth_consumer_key</td>\n<td>Consumer를 구별하는 키 값. Service Provider는 이 키 값으로 Consumer를 구분한다.</td>\n</tr>\n<tr>\n<td>OAuth_nonce</td>\n<td>Consumer에서 임시로 생성한 임의의 문자열. OAuth_timestamp의 값이 같은 요청에서는 유일한 값이어야 한다. 이는 악의적인 목적으로 계속 요청을 보내는 것을 막기 위해서이다.</td>\n</tr>\n<tr>\n<td>OAuth_signature</td>\n<td>OAuth 인증 정보를 암호화하고 인코딩하여 서명 값. OAuth 인증 정보는 매개변수 중에서 OAuth_signature를 제외한 나머지 매개변수와 HTTP 요청 방식을 문자열로 조합한 값이다. 암화 방식은 OAuth_signature_method에 정의된다.</td>\n</tr>\n<tr>\n<td>OAuth_signature_method</td>\n<td>OAuth_signature를 암호화하는 방법. HMAC-SHA1, HMAC-MD5 등을 사용할 수 있다.</td>\n</tr>\n<tr>\n<td>OAuth_timestamp</td>\n<td>요청을 생성한 시점의 타임스탬프. 1970년1월 1일 00시 00분 00초 이후의 시간을 초로 환산한 초 단위의 누적 시간이다.</td>\n</tr>\n<tr>\n<td>OAuth_version</td>\n<td>OAuth 사용 버전</td>\n</tr>\n<tr>\n<td>OAuth_verifier</td>\n<td>Request Token 요청 시 OAuth_callback으로 전달받은 OAuth_verifier 값</td>\n</tr>\n<tr>\n<td>OAuth_token</td>\n<td>Request Token 요청 시 OAuth_callback으로 전달받은 OAuth_token 값</td>\n</tr>\n</tbody>\n</table>\n<h5><span id=\"api호출을-위한-매개변수\">API호출을 위한 매개변수</span></h5>\n<p>다음은 Access Token을 사용해 API를 호출할 때 사용하는 매개변수는 다음 표이다.</p>\n<table>\n<thead>\n<tr>\n<th>매개변수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OAuth_consumer_key</td>\n<td>Consumer를 구별하는 키 값. Service Provider는 이 키 값으로 Consumer를 구분한다.</td>\n</tr>\n<tr>\n<td>OAuth_nonce</td>\n<td>Consumer에서 임시로 생성한 임의의 문자열. OAuth_timestamp의 값이 같은 요청에서는 유일한 값이어야 한다. 이는 악의적인 목적으로 계속 요청을 보내는 것을 막기 위해서이다.</td>\n</tr>\n<tr>\n<td>OAuth_signature</td>\n<td>OAuth 인증 정보를 암호화하고 인코딩하여 서명 값. OAuth 인증 정보는 매개변수 중에서 OAuth_signature를 제외한 나머지 매개변수와 HTTP 요청 방식을 문자열로 조합한 값이다. 암화 방식은 OAuth_signature_method에 정의된다.</td>\n</tr>\n<tr>\n<td>OAuth_signature_method</td>\n<td>OAuth_signature를 암호화하는 방법. HMAC-SHA1, HMAC-MD5 등을 사용할 수 있다.</td>\n</tr>\n<tr>\n<td>OAuth_timestamp</td>\n<td>요청을 생성한 시점의 타임스탬프. 1970년1월 1일 00시 00분 00초 이후의 시간을 초로 환산한 초 단위의 누적 시간이다.</td>\n</tr>\n<tr>\n<td>OAuth_version</td>\n<td>OAuth 버전</td>\n</tr>\n<tr>\n<td>OAuth_token</td>\n<td>OAuth_callback으로 전달받은 OAuth_token</td>\n</tr>\n</tbody>\n</table>\n<h2><span id=\"oauth2란\">OAuth2란</span></h2>\n<p>OAuth의2는 OAuth의1의 유저의 인증플로우, 전반적인 목적만 공유하고 OAuth의1.0을 새로 작성한것이다. OAuth의1.0과 OAuth의2.0의 차이는 앱 애플리케이션, 웹 애플리케이션, 데스크탑 애플리케이션등의 인증방식을 강화하고 Consumer에 개발 간소화를 중심으로 개발 되었다.</p>\n<h3><span id=\"oauth의10-과-oauth의20차이점\">OAuth의1.0 과 OAuth의2.0차이점</span></h3>\n<p>아래는 OAuth 1.0 에서 OAuth2.0 차이점은 일단 인증 절차 간소화 됨으로써 개발자들이 구현하기 더쉬워졌고, 기존에 사용하던 용어도 바뀌면서 Authorizaiton server와 Resource서버의 분리가 명시적으로 되었다. 또한 다양한 인증 방식을 지원하게 됐다. 아래는 1.0과 2.0의 차이점을 나열한것이다.</p>\n<h4><span id=\"인증-절차-간소화\">인증 절차 간소화</span></h4>\n<ul>\n<li>기능의 단순화, 기능과 규모의 확장성 등을 지원하기 위해 만들어 졌다.</li>\n<li>기존의 OAuth1.0은 디지털 서명 기반이었지만 OAuth2.0의 암호화는 https에 맡김으로써 복잡한 디지털 서명에관한 로직을 요구하지 않기때문에 구현 자체가 개발자입장에서 쉬워짐.</li>\n</ul>\n<h4><span id=\"용어-변경\">용어 변경</span></h4>\n<ul>\n<li>Resource Owner : 사용자 (1.0 User해당)</li>\n<li>Resource Server : REST API 서버 (1.0 Protected Resource)</li>\n<li>Authorization Server : 인증서버 (API 서버와 같을 수도 있음)(1.0 Service Provider)</li>\n<li>Client : 써드파티 어플리케이션 (1.0 Service Provider 해당)</li>\n</ul>\n<h4><span id=\"resource-server와-authorization-server서버의-분리\">Resource Server와 Authorization Server서버의 분리</span></h4>\n<ul>\n<li>커다란 서비스는 인증 서버를 분리하거나 다중화 할 수 있어야 함.</li>\n<li>Authorization Server의 역할을 명확히 함.</li>\n</ul>\n<h4><span id=\"다양한-인증-방식grant_type\">다양한 인증 방식(Grant_type)</span></h4>\n<ul>\n<li>Authorization Code Grant</li>\n<li>Implicit Grant</li>\n<li>Resource Owner Password Credentials Grant</li>\n<li>Client Credentials Grant</li>\n<li>Device Code Grant</li>\n<li>Refresh Token Grant</li>\n</ul>\n<h3><span id=\"인증-종류\">인증 종류</span></h3>\n<p>OAuth 2.0의 인증종류는 6가지 입니다. 아래는 각각의 인증방식의 flow와 간단한 설명입니다.</p>\n<h4><span id=\"authorization-code-grant\">Authorization Code Grant</span></h4>\n<p>일반적인 웹사이트에서 소셜로그인과 같은 인증을 받을 때 가장 많이 쓰는 방식으로 기본적으로 지원하고 있는 방식이다. 아래는 Authorization Code Grant type 으로 Access Token을 얻어오는 시퀀스 다이어그램이다.<br>\n<img src=\"https://i.imgur.com/xaKCz9E.png\" alt=\"\"></p>\n<ol>\n<li>먼저 클라이언트가 Redirect URL을 포함하여 Authorization server 인증 요청을 한다.</li>\n<li>AuthorizationServer는 유저에게 로그인창을 제공하여 유저를 인증하게 된다.</li>\n<li>AuthorizationServer는 Authorization code를 클라이언트에게 제공해준다.</li>\n<li>Client는 코드를 Authorization server에 Access Token을 요청한다.</li>\n<li>Authorization 서버는 클라이언트에게 Access token을 발급해준다.</li>\n<li>그 Access token을 이용하여 Resource server에 자원을 접근할 수 있게 된다.</li>\n<li>그이후에 토큰이 만료된다면 refresh token을 이용하여 토큰을 재발급 받을 수 있다.</li>\n</ol>\n<h4><span id=\"implicit-grant\">Implicit Grant</span></h4>\n<p>Public Client인 브라우저 기반의 애플리케이션(Javascript application)이나 모바일 애플리케이션에서 바로 Resource Server에 접근하여 사용할 수 있는 방식이다.<br>\n<img src=\"https://i.imgur.com/DayLoth.png\" alt=\"\"></p>\n<ol>\n<li>클라이언트는 Authorization server에 인증을 요청한다.</li>\n<li>유저는 Authorization server를 통해 인증한다.</li>\n<li>Authorization server는 Access token을 포함하여 클라이언트의 Redirect url을 호출한다.</li>\n<li>클라이언트는 해당 Access token이 유효한지 Authorization server에 인증요청한다.</li>\n<li>인증서버는 그 토큰이 유효하다면 토큰의 만기시간과함께 리턴해준다.</li>\n<li>클라이언트는 Resource server에 접근할 수 있게된다.</li>\n</ol>\n<h4><span id=\"resource-owner-password-credentials-grant\">Resource Owner Password Credentials Grant</span></h4>\n<p>Client에 아이디/패스워드를 받아 아이디/패스워드로 직접 access token을 받아오는 방식이다. Client가 신용이 없을 때에는 사용하기에 위험하다는 단점이 있다. 클라이언트가 확실한 신용이 보장될 때 사용할 수 있는 방식이다.<br>\n<img src=\"https://i.imgur.com/FVv86QT.png\" alt=\"\"></p>\n<ol>\n<li>User가 Id와 Password를 입력한다</li>\n<li>클라이언트는 유저의 id와 password와 클라이언트 정보를 넘긴다.</li>\n<li>Authorization sever는 Access token을 넘긴다.</li>\n</ol>\n<h4><span id=\"client-credentials-grant\">Client Credentials Grant</span></h4>\n<p>애플리케이션이 Confidential Client일 때 id와 secret을 가지고 인증하는 방식이다.<br>\n<img src=\"https://i.imgur.com/TMXAjvo.png\" alt=\"\"></p>\n<ol>\n<li>클라이언트 정보를 Authorization server에 넘긴다.</li>\n<li>Access Token을 Client에 전달한다.</li>\n</ol>\n<h4><span id=\"device-code-grant\">Device Code Grant</span></h4>\n<p>장치 코드 부여 유형은 브라우저가 없거나 입력이 제한된 장치에서 사용됩니다.</p>\n<h4><span id=\"refresh-token-grant\">Refresh Token Grant</span></h4>\n<p>기존에 저장해둔 리프러시 토큰이 존재할 때 엑세스토큰 재발급 받을 필요가 있을 때 사용한다. 그리고 기존 액세스는 토큰이 만료된다.</p>\n<p>참고 사이트</p>\n<ul>\n<li><a href=\"http://d2.naver.com/helloworld/24942\" target=\"_blank\" rel=\"noopener\">Naver D2</a></li>\n<li><a href=\"https://OAuth.net/core/1.0/\" target=\"_blank\" rel=\"noopener\">OAuth.net</a></li>\n<li><a href=\"https://showerbugs.github.io/2017-11-16/OAuth-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C\" target=\"_blank\" rel=\"noopener\">Showerbugs</a></li>\n<li><a href=\"https://www.OAuth.com/OAuth2-servers/differences-between-OAuth-1-2/\" target=\"_blank\" rel=\"noopener\">OAuth 2.0 Servers</a></li>\n<li><a href=\"https://brunch.co.kr/@sbcoba/4\" target=\"_blank\" rel=\"noopener\">이수홍</a></li>\n<li><a href=\"https://developer.accela.com/docs/construct-authCodeFlow.html\" target=\"_blank\" rel=\"noopener\">Authorization Code Flow</a></li>\n<li><a href=\"https://ox.gluu.org/doku.php?id=oxauth:implicitgrant\" target=\"_blank\" rel=\"noopener\">OX Wiki</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>OAuth1 란</h2>\n<p>OAuth는 Open Authorization, Open Authentication 뜻하는 것으로 애플리케이션(페이스북,구글,트위터)(Service Provider)의 유저의 비밀번호를 Third party앱에 제공 없이 인증,인가를 할 수 있는 오픈 스탠다드 프로토콜이다. OAuth 인증을 통해 애플리케이션 API를 유저대신에 접근할 수 있는 권한을 얻을 수 있다. OAuth가 사용되기 전에는 외부 사이트와 인증기반의 데이터를 연동할 때  인증방식의 표준이 없었기 때문에 기존의 기본인증인 아이디와 비밀번호를 사용하였는데, 이는 보안상 취약한 구조였다. 유저의 비밀번호가 노출될 가망성이 크기 때문이다. 그렇기 때문에 이 문제를 보안하기 위해 OAuth의 인증은 API를 제공하는 서버에서 진행하고, 유저가 인증되었다는 Access Token을 발급하였다. 그 발급된 Access token으로 Third party(Consumer)애플리케이션에서는 Service Provider의 API를 안전하고 쉽게 사용할 수 있게 되었다.</p>\n<h3>동작 방식</h3>\n<p>먼저 OAuth의 동작 방식을 알기 위해서는 아래의 개념을 알고 있어야 한다.</p>\n<h4>OAuth의 개념</h4>\n<p>먼저 OAuth의는 아래와 같은 개념을 가지고있다.</p>\n<table>\n<thead>\n<tr>\n<th>용어</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>User</td>\n<td>Service Provider에 계정을 가지고 있으면서, Consumer앱을 이용하려는 사용자</td>\n</tr>\n<tr>\n<td>Service Provider</td>\n<td>OAuth를 사용하는 Open API를 제공하는 서비스 (facebook,google등)</td>\n</tr>\n<tr>\n<td>Protected Resource</td>\n<td>Service Provider로부터 제공되어지는 API 자원들</td>\n</tr>\n<tr>\n<td>Consumer</td>\n<td>OAuth 인증을 사용해 Service Provider의 기능을 사용하려는 애플리케이션이나 웹 서비스</td>\n</tr>\n<tr>\n<td>Consumer Key</td>\n<td>Consumer가 Service Provider에게 자신을 식별하는 데 사용하는키</td>\n</tr>\n<tr>\n<td>Consumer Secret</td>\n<td>Consumer Key의 소유권을 확립하기 위해 Consumer가 사용하는 Secret</td>\n</tr>\n<tr>\n<td>Request Token</td>\n<td>Consumer가 Service Provider에게 접근 권한을 인증받기 위해 사용하는 값. 인증이 완료된 후에는 Access Token으로 교환한다.</td>\n</tr>\n<tr>\n<td>Access Token</td>\n<td>인증 후 Consumer가 Service Provider의 자원에 접근하기 위한 키를 포함한 값</td>\n</tr>\n<tr>\n<td>Token Secret</td>\n<td>주어진 토큰의 소유권을 인증하기 위해 소비자가 사용하는 Secret</td>\n</tr>\n</tbody>\n</table>\n<h4>OAuth의 WorkFlow</h4>\n<p>다음은  OAuth의 1.0의 WorkFlow이다.<br>\n<img src=\"https://i.imgur.com/7T48KvR.png\" alt=\"\"></p>\n<p>위 WorkFlow 흐름은 간단하게 이렇다.</p>\n<ol>\n<li>그림에는 없지만 가장 먼저 Consumer는 Service Provider로부터 Client key와 Secret을 발급 받아야한다. 이것은 Service Provider에 API를 사용할것을 등록하는것과 동시에 Service Provider가 Consmer를 식별할 수 있게 해준다.</li>\n<li>그림에 A 처럼 Request Token을 요청할 때 Consumer 정보, Signature 정보를 포함하여 Request token을 요청을하고 B의 흐름처럼 Request token을 발급받는다.</li>\n<li>Request Token값을 받은후 Consumer는 C처럼 User를 Service Provider에 인증 사이트로 다이렉트시키고, 유저는 그곳에서 Service Provider에 유저임을 인증하게 된다.</li>\n<li>그러면 Consumer는 D의 정보처럼 해당 유저가 인증이되면 OAuth_token와 OAuth_verifier를 넘겨준다.</li>\n<li>그이후에 Consumer는 OAuth_token와 OAuth_verifier받았다면 E의 흐름처럼 다시 서명을 만들어 Access Token을 요청하게 된다.</li>\n<li>그리고 Service Provider는 받은 토큰과 서명들이 인증이 되었으면 Access Token을 F의 정보 처럼 넘기게된다.</li>\n<li>그리고 그 Access Token 및 서명정보를 통해 Service Provider에 Protected Resource에 접근할 수 있게 된다.</li>\n</ol>\n<p>아래는 Consumer의 요청시 매개변수의 종류에 대한 설명이다.</p>\n<h5>Request Token 발급 매개변수</h5>\n<p>Request Token 발급 요청 시 사용하는 매개변수는 다음 표와 같다.</p>\n<table>\n<thead>\n<tr>\n<th>매개변수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OAuth_callback</td>\n<td>Service Provider가 인증을 완료한 후 리다이렉트할 Consumer의 웹 주소. 만약 Consumer가 웹 애플리케이션이 아니라 리다이렉트할 주소가 없다면 소문자로 ‘oob’(Out Of Band라는 뜻)를 값으로 사용한다.</td>\n</tr>\n<tr>\n<td>OAuth_consumer_key</td>\n<td>Consumer를 구별하는 키 값. Service Provider는 이 키 값으로 Consumer를 구분한다.</td>\n</tr>\n<tr>\n<td>OAuth_nonce</td>\n<td>Consumer에서 임시로 생성한 임의의 문자열. OAuth_timestamp의 값이 같은 요청에서는 유일한 값이어야 한다. 이는 악의적인 목적으로 계속 요청을 보내는 것을 막기 위해서이다.</td>\n</tr>\n<tr>\n<td>OAuth_signature</td>\n<td>OAuth 인증 정보를 암호화하고 인코딩하여 서명 값. OAuth 인증 정보는 매개변수 중에서 OAuth_signature를 제외한 나머지 매개변수와 HTTP 요청 방식을 문자열로 조합한 값이다. 암화 방식은 OAuth_signature_method에 정의된다.</td>\n</tr>\n<tr>\n<td>OAuth_signature_method</td>\n<td>OAuth_signature를 암호화하는 방법. HMAC-SHA1, HMAC-MD5 등을 사용할 수 있다.</td>\n</tr>\n<tr>\n<td>OAuth_timestamp</td>\n<td>요청을 생성한 시점의 타임스탬프. 1970년1월 1일 00시 00분 00초 이후의 시간을 초로 환산한 초 단위의 누적 시간이다.</td>\n</tr>\n<tr>\n<td>OAuth_version</td>\n<td>OAuth 사용 버전. 1.0a는 1.0이라고 명시하면 된다.</td>\n</tr>\n</tbody>\n</table>\n<h5>Request Token Signature 생성</h5>\n<p>OAuth 1.0에서 Service Provider에게 요청을 할려면 매번 전자 서명을 만들어서 보내야한다. 아래는 전자서명을 만드는 순서이다.</p>\n<ol>\n<li>\n<p>요청 매개변수를 모두 모은다.<br>\nOAuth_signature를 제외하고 'OAuth_'로 시작하는 OAuth 관련 매개변수를 모은다. 모든 매개변수를 사전순으로 정렬하고 각각의 키(key)와 값(value)에 URL 인코딩(rfc3986)을 적용한다. URL 인코딩을 실시한 결과를 = 형태로 나열하고 각 쌍 사이에는 &amp;을 넣는다. 이렇게 나온 결과 전체에 또 URL 인코딩을 적용한다.</p>\n</li>\n<li>\n<p>매개변수를 정규화(Normalize)한다.<br>\n모든 매개변수를 사전순으로 정렬하고 각각의 키(key)와 값(value)에 URL 인코딩(rfc3986)을 적용한다. URL 인코딩을 실시한 결과를 = 형태로 나열하고 각 쌍 사이에는 &amp;을 넣는다. 이렇게 나온 결과 전체에 또 URL 인코딩을 적용한다.</p>\n</li>\n<li>\n<p>Signature Base String을 만든다.<br>\nHTTP method 명(GET 또는 POST), Consumer가 호출한 HTTP URL 주소(매개변수 제외), 정규화한 매개변수를 '&amp;'를 사용해 결합한다. 즉 ‘[GET|POST] + &amp; + [URL 문자열로 매개변수는 제외] + &amp; + [정규화한 매개변수]’ 형태가 된다.</p>\n</li>\n<li>\n<p>키 생성<br>\n3번 과정까지 거쳐 생성한 문자열을 암호화한다. 암호화할 때 Consumer Secret Key를 사용한다. Consumer Secret Key는 Consumer가 Service Provider에 사용 등록을 할 때 발급받은 값이다. HMAC-SHA1 등의 암호화 방법을 이용하여 최종적인 OAuth_signature를 생성한다.</p>\n</li>\n</ol>\n<h5>Access Token 매개변수</h5>\n<p>다음은 Access Token 발급을 요청할 때 사용하는 매개변수 표이다.</p>\n<table>\n<thead>\n<tr>\n<th>매개변수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OAuth_consumer_key</td>\n<td>Consumer를 구별하는 키 값. Service Provider는 이 키 값으로 Consumer를 구분한다.</td>\n</tr>\n<tr>\n<td>OAuth_nonce</td>\n<td>Consumer에서 임시로 생성한 임의의 문자열. OAuth_timestamp의 값이 같은 요청에서는 유일한 값이어야 한다. 이는 악의적인 목적으로 계속 요청을 보내는 것을 막기 위해서이다.</td>\n</tr>\n<tr>\n<td>OAuth_signature</td>\n<td>OAuth 인증 정보를 암호화하고 인코딩하여 서명 값. OAuth 인증 정보는 매개변수 중에서 OAuth_signature를 제외한 나머지 매개변수와 HTTP 요청 방식을 문자열로 조합한 값이다. 암화 방식은 OAuth_signature_method에 정의된다.</td>\n</tr>\n<tr>\n<td>OAuth_signature_method</td>\n<td>OAuth_signature를 암호화하는 방법. HMAC-SHA1, HMAC-MD5 등을 사용할 수 있다.</td>\n</tr>\n<tr>\n<td>OAuth_timestamp</td>\n<td>요청을 생성한 시점의 타임스탬프. 1970년1월 1일 00시 00분 00초 이후의 시간을 초로 환산한 초 단위의 누적 시간이다.</td>\n</tr>\n<tr>\n<td>OAuth_version</td>\n<td>OAuth 사용 버전</td>\n</tr>\n<tr>\n<td>OAuth_verifier</td>\n<td>Request Token 요청 시 OAuth_callback으로 전달받은 OAuth_verifier 값</td>\n</tr>\n<tr>\n<td>OAuth_token</td>\n<td>Request Token 요청 시 OAuth_callback으로 전달받은 OAuth_token 값</td>\n</tr>\n</tbody>\n</table>\n<h5>API호출을 위한 매개변수</h5>\n<p>다음은 Access Token을 사용해 API를 호출할 때 사용하는 매개변수는 다음 표이다.</p>\n<table>\n<thead>\n<tr>\n<th>매개변수</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>OAuth_consumer_key</td>\n<td>Consumer를 구별하는 키 값. Service Provider는 이 키 값으로 Consumer를 구분한다.</td>\n</tr>\n<tr>\n<td>OAuth_nonce</td>\n<td>Consumer에서 임시로 생성한 임의의 문자열. OAuth_timestamp의 값이 같은 요청에서는 유일한 값이어야 한다. 이는 악의적인 목적으로 계속 요청을 보내는 것을 막기 위해서이다.</td>\n</tr>\n<tr>\n<td>OAuth_signature</td>\n<td>OAuth 인증 정보를 암호화하고 인코딩하여 서명 값. OAuth 인증 정보는 매개변수 중에서 OAuth_signature를 제외한 나머지 매개변수와 HTTP 요청 방식을 문자열로 조합한 값이다. 암화 방식은 OAuth_signature_method에 정의된다.</td>\n</tr>\n<tr>\n<td>OAuth_signature_method</td>\n<td>OAuth_signature를 암호화하는 방법. HMAC-SHA1, HMAC-MD5 등을 사용할 수 있다.</td>\n</tr>\n<tr>\n<td>OAuth_timestamp</td>\n<td>요청을 생성한 시점의 타임스탬프. 1970년1월 1일 00시 00분 00초 이후의 시간을 초로 환산한 초 단위의 누적 시간이다.</td>\n</tr>\n<tr>\n<td>OAuth_version</td>\n<td>OAuth 버전</td>\n</tr>\n<tr>\n<td>OAuth_token</td>\n<td>OAuth_callback으로 전달받은 OAuth_token</td>\n</tr>\n</tbody>\n</table>\n<h2>OAuth2란</h2>\n<p>OAuth의2는 OAuth의1의 유저의 인증플로우, 전반적인 목적만 공유하고 OAuth의1.0을 새로 작성한것이다. OAuth의1.0과 OAuth의2.0의 차이는 앱 애플리케이션, 웹 애플리케이션, 데스크탑 애플리케이션등의 인증방식을 강화하고 Consumer에 개발 간소화를 중심으로 개발 되었다.</p>\n<h3>OAuth의1.0 과 OAuth의2.0차이점</h3>\n<p>아래는 OAuth 1.0 에서 OAuth2.0 차이점은 일단 인증 절차 간소화 됨으로써 개발자들이 구현하기 더쉬워졌고, 기존에 사용하던 용어도 바뀌면서 Authorizaiton server와 Resource서버의 분리가 명시적으로 되었다. 또한 다양한 인증 방식을 지원하게 됐다. 아래는 1.0과 2.0의 차이점을 나열한것이다.</p>\n<h4>인증 절차 간소화</h4>\n<ul>\n<li>기능의 단순화, 기능과 규모의 확장성 등을 지원하기 위해 만들어 졌다.</li>\n<li>기존의 OAuth1.0은 디지털 서명 기반이었지만 OAuth2.0의 암호화는 https에 맡김으로써 복잡한 디지털 서명에관한 로직을 요구하지 않기때문에 구현 자체가 개발자입장에서 쉬워짐.</li>\n</ul>\n<h4>용어 변경</h4>\n<ul>\n<li>Resource Owner : 사용자 (1.0 User해당)</li>\n<li>Resource Server : REST API 서버 (1.0 Protected Resource)</li>\n<li>Authorization Server : 인증서버 (API 서버와 같을 수도 있음)(1.0 Service Provider)</li>\n<li>Client : 써드파티 어플리케이션 (1.0 Service Provider 해당)</li>\n</ul>\n<h4>Resource Server와 Authorization Server서버의 분리</h4>\n<ul>\n<li>커다란 서비스는 인증 서버를 분리하거나 다중화 할 수 있어야 함.</li>\n<li>Authorization Server의 역할을 명확히 함.</li>\n</ul>\n<h4>다양한 인증 방식(Grant_type)</h4>\n<ul>\n<li>Authorization Code Grant</li>\n<li>Implicit Grant</li>\n<li>Resource Owner Password Credentials Grant</li>\n<li>Client Credentials Grant</li>\n<li>Device Code Grant</li>\n<li>Refresh Token Grant</li>\n</ul>\n<h3>인증 종류</h3>\n<p>OAuth 2.0의 인증종류는 6가지 입니다. 아래는 각각의 인증방식의 flow와 간단한 설명입니다.</p>\n<h4>Authorization Code Grant</h4>\n<p>일반적인 웹사이트에서 소셜로그인과 같은 인증을 받을 때 가장 많이 쓰는 방식으로 기본적으로 지원하고 있는 방식이다. 아래는 Authorization Code Grant type 으로 Access Token을 얻어오는 시퀀스 다이어그램이다.<br>\n<img src=\"https://i.imgur.com/xaKCz9E.png\" alt=\"\"></p>\n<ol>\n<li>먼저 클라이언트가 Redirect URL을 포함하여 Authorization server 인증 요청을 한다.</li>\n<li>AuthorizationServer는 유저에게 로그인창을 제공하여 유저를 인증하게 된다.</li>\n<li>AuthorizationServer는 Authorization code를 클라이언트에게 제공해준다.</li>\n<li>Client는 코드를 Authorization server에 Access Token을 요청한다.</li>\n<li>Authorization 서버는 클라이언트에게 Access token을 발급해준다.</li>\n<li>그 Access token을 이용하여 Resource server에 자원을 접근할 수 있게 된다.</li>\n<li>그이후에 토큰이 만료된다면 refresh token을 이용하여 토큰을 재발급 받을 수 있다.</li>\n</ol>\n<h4>Implicit Grant</h4>\n<p>Public Client인 브라우저 기반의 애플리케이션(Javascript application)이나 모바일 애플리케이션에서 바로 Resource Server에 접근하여 사용할 수 있는 방식이다.<br>\n<img src=\"https://i.imgur.com/DayLoth.png\" alt=\"\"></p>\n<ol>\n<li>클라이언트는 Authorization server에 인증을 요청한다.</li>\n<li>유저는 Authorization server를 통해 인증한다.</li>\n<li>Authorization server는 Access token을 포함하여 클라이언트의 Redirect url을 호출한다.</li>\n<li>클라이언트는 해당 Access token이 유효한지 Authorization server에 인증요청한다.</li>\n<li>인증서버는 그 토큰이 유효하다면 토큰의 만기시간과함께 리턴해준다.</li>\n<li>클라이언트는 Resource server에 접근할 수 있게된다.</li>\n</ol>\n<h4>Resource Owner Password Credentials Grant</h4>\n<p>Client에 아이디/패스워드를 받아 아이디/패스워드로 직접 access token을 받아오는 방식이다. Client가 신용이 없을 때에는 사용하기에 위험하다는 단점이 있다. 클라이언트가 확실한 신용이 보장될 때 사용할 수 있는 방식이다.<br>\n<img src=\"https://i.imgur.com/FVv86QT.png\" alt=\"\"></p>\n<ol>\n<li>User가 Id와 Password를 입력한다</li>\n<li>클라이언트는 유저의 id와 password와 클라이언트 정보를 넘긴다.</li>\n<li>Authorization sever는 Access token을 넘긴다.</li>\n</ol>\n<h4>Client Credentials Grant</h4>\n<p>애플리케이션이 Confidential Client일 때 id와 secret을 가지고 인증하는 방식이다.<br>\n<img src=\"https://i.imgur.com/TMXAjvo.png\" alt=\"\"></p>\n<ol>\n<li>클라이언트 정보를 Authorization server에 넘긴다.</li>\n<li>Access Token을 Client에 전달한다.</li>\n</ol>\n<h4>Device Code Grant</h4>\n<p>장치 코드 부여 유형은 브라우저가 없거나 입력이 제한된 장치에서 사용됩니다.</p>\n<h4>Refresh Token Grant</h4>\n<p>기존에 저장해둔 리프러시 토큰이 존재할 때 엑세스토큰 재발급 받을 필요가 있을 때 사용한다. 그리고 기존 액세스는 토큰이 만료된다.</p>\n<p>참고 사이트</p>\n<ul>\n<li><a href=\"http://d2.naver.com/helloworld/24942\" target=\"_blank\" rel=\"noopener\">Naver D2</a></li>\n<li><a href=\"https://OAuth.net/core/1.0/\" target=\"_blank\" rel=\"noopener\">OAuth.net</a></li>\n<li><a href=\"https://showerbugs.github.io/2017-11-16/OAuth-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C\" target=\"_blank\" rel=\"noopener\">Showerbugs</a></li>\n<li><a href=\"https://www.OAuth.com/OAuth2-servers/differences-between-OAuth-1-2/\" target=\"_blank\" rel=\"noopener\">OAuth 2.0 Servers</a></li>\n<li><a href=\"https://brunch.co.kr/@sbcoba/4\" target=\"_blank\" rel=\"noopener\">이수홍</a></li>\n<li><a href=\"https://developer.accela.com/docs/construct-authCodeFlow.html\" target=\"_blank\" rel=\"noopener\">Authorization Code Flow</a></li>\n<li><a href=\"https://ox.gluu.org/doku.php?id=oxauth:implicitgrant\" target=\"_blank\" rel=\"noopener\">OX Wiki</a></li>\n</ul>\n"},{"title":"Spring Security OAuth2구현","catalog":true,"date":"2018-03-10T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n## Spring Security OAuth2구현\n\n### OAuth란?\nOAuth는 Open Authorization, Open Authentication 뜻하는 것으로 자신의 애플리케이션 서버의 데이터로 다른 Third party에게 자원을 공유하거나 대신 유저 인증을 처리해줄 수 있는 오픈 표준 프로토콜이다.\n\n### OAuth 실 사용 예\n간단히 OAuth인증에 대해 실 사용 예를 보자면 웹, 앱들을 사용하면서 네이버 로그인, 카카오 로그인, 페이스북 로그인 등을 한 번쯤은 보았을 것이다. 이것이 바로 OAuth인 증 방식 중 하나이다. 네이버 로그인, 카카오 로그인, 페이스북 로그인 등으로 로그인을 하게 되면 그 애플리케이션들로부터 Access_token이라는 값을 받아 써드파티 애플리케이션에게 준다. Access_token이라는 값이 어떻게 보면 유저의 인증 키라고 보면 된다. 물론 유저가 로그인을 실패한다면 Access_token을 받지 못할 것이다. Access_token 을 받았다는 것은 해당 유저가 인증이 되었다는 것을 의미한다. 이러한 기술을 통해서 써드파티 애플리케이션에게 유저를 인증 시킨다. 이것이 OAuth인증이다. 물론 OAuth가 Authentication(인증) 기능만 하는 것은 아니다.\n\nOAuth는 Authorization(인가)에 대한 기능도 있다. Authorization라는 기능(?)을 이용하면 써드파티 앱들은 유저가 선택한 로그인 방식에 애플리케이션의 유저 정보 등을 얻을 수 있다. 이정보를 바탕으로 써드파티 앱들은 유저를 자신의 앱에 가입시킨다. 뿐만 아니라 서드파티 앱들은 유저가 로그인한 애플리케이션의 기능 등을 사용할 수 있다. 이것을 잘 사용하는 로켓펀치라는 구직 사이트가 있다. 이 사이트에 페이스북으로 로그인하기 기능 이용하여 로그인과 함께 친구 정보 제공을 동의하고 my account를 들어가면 내 친구들의 로켓펀치의 등록된 구직 정보들을 볼 수 있다. 이것이 가능한 이유는 아까 받은 Access_token으로 페이스북에게 유저의 정보를 요청할 수 있기 때문이다. 이러한 조회 기능뿐만 아니라 유저의 동의만 얻는다면 페이스북 담벼락에 글 남기기 등의 기능들도 사용할 수 있다. 이런 것들 가능하게 해주는 것이 OAuth 인증이다. OAuth도 버전이 있고, 그 차이점이 있는데 미흡하지만 [OAuth란?](https://minwan1.github.io/2018/02/24/2018-02-24-OAuth/)을 참조하면 될 것 같다.\n\n위와 같은 방법뿐만 아니라 Microservices에 인증 방식으로도 사용된다. 마이크로서비스란 하나의 큰 애플리케이션을 여러개의 작은 애플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처를 말한다. 이 [마이크로서비스 아키텍처, 그것이 뭣이 중헌디?](http://guruble.com/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4microservice-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B7%B8%EA%B2%83%EC%9D%B4-%EB%AD%A3%EC%9D%B4-%EC%A4%91%ED%97%8C%EB%94%94/)글에 마이크로서비스에 대한 내용들이 잘 설명돼 있다. 아무래도 자원들이 각각의 서버에 분리해있다보니 인증이나, 인가를 하나로 적절히 관리하는것이 필요하다. 만약 모놀리틱 아키텍처로 이러한 자원들을 관리하게된다면 상당히 비효율적일 것이다. 각각의 자원 서버마다 필요한 자원의 서비스를 호출하려고하면 인증,인가처리를 해야하기 떄문에 매우 비효율적으로 될것이다. 하지만 OAuth방식을 이용한다면 인증서버를 두고 각각의 자원서비스들의 인증, 인가를 관리한다면 효율적으로 자원 서비스들을 관리할 수 있다.\n\n\n### Spring으로 OAuth2구현\n뭔가 서론이 장황해진 것 같다. 결론을 말씀드리자면 이러한 장점들을 이용하기 위해 OAuth인증 시스템을 구현해 볼 것이다. 구현 방법은 Spring을 이용해서 Spring security의 하위 프로젝트 Spring OAuth를 구현할 것이다. 여기에서 구현하고자하는 방식은 OAuth2방식이고 인증 방식은 Password 방식을 구현할 것이다. OAuth2부터는 다양한 인증 방식을 제공하는데 여기에대한 차이점은 [OAuth란?](https://minwan1.github.io/2018/02/24/2018-02-24-OAuth/)글에서 확인할 수 있다.\n\n#### OAuth2 역할\n먼저 구현전에 OAuth2에 역할에대해 알아보자. OAuth2는 크게 Resource Owner, Authorization Server, Resource Server, Client 4개의 역할로 나누어진다. 먼저 Resource Owner는 유저를 말한다. 이유저는 위에서말한 카카오톡,네이버,구글등에 로그인 할 수 있고 그 해당 애플리케이션의 기능을 이용 가능한 유저를 말한다. Authorization Server는 인증 서버를 말한다. 유저가 OAuth를 통해 로그인한다면 카카오톡,네이버,구글의 유저가 맞는지 확인해주는 서버를 말한다. Resource Server는 카카오톡,네이버,구글의 자원(API)이 있는 서버를 말한다. Client는 써드파티앱들을 말한다. Authorization Server, Resource Server를 이용하는 앱들은 모두 Clinet라고 생각하면 된다.\n\n#### Resource Owner Password Credentials Grant 동작방식\n먼저 구현하려고하는 password 인증 방식이 무엇인지 간단하게 살펴보자. 이방식을 사용하기 위해서는 AuthorizationServer에 Client-id와 secret을 등록해야한다. 그리고 Client가 Resource Owner로부터 아이디/패스워드를 받아 직접 access token을 받아오는 방식이다. 이때 클라이언트는 AccessToken을 얻기 위해 AuthorizationServer에 호출할때 이 Client-id와 secret을 Basic-auth를 해줘야 한다. 하지만 이방식은 Client가 신용이 없을 때에는 사용하기에 위험하다는 단점이 있다. 클라이언트가 확실한 신용이 보장될 때 사용할 수 있는 방식이다.\n![](https://i.imgur.com/7LhjI1L.png)\n동작 순서는 대략 이렇다.\n1. AuthorizationServer에 Client-id와 Secret을 등록한다(그림에는 안나와있음)\n2. User가 Id와 Password를 입력한다\n3. 클라이언트는 유저의 id와 password와 클라이언트 정보를 넘긴다.\n4. Authorization sever는 Access token을 넘긴다.\n5. Client는 token로 자원서버에 접근할 수 있게 된다.\n\n그럼 이제 실제 구현을 해볼것이다.\n\n#### OAuth2 in-memory 방식으로 간단한 구현\nOAuth는 인증서버와 자원 서버를 하나의 애플리케이션에서 구현할 수도 있고, 분리할 수도 있다. 여기에서는 두 개를 하나의 애플리케이션에서 구현할 것이다. Resource Owner, Client 관리는 in-memory를 이용할 것이다. 아래와 같이 application.yml에 Resource Owner를 지정하고, Client를 쉽게 등록할 수 있다.\n```\nsecurity:\n  user:\n    name: user\n    password: test\n  oauth2:\n    client:\n      client-id: foo\n      client-secret: bar\n```\n그다음은 Resource Server, Authorization Server의 설정을 구현할 것이다. @EnableResourceServer, @EnableAuthorizationServer 두개의 어노테이션으로 쉽게 인증서버와 자원서버를 구성할 수 있다.\n```java\n@EnableResourceServer  // API 서버 인증(또는 권한 설정)\n@EnableAuthorizationServer // 자원서버 설정\n@Configuration\npublic class ResourceServerConfigurerAdapterImpl extends ResourceServerConfigurerAdapter {\n\n    @Override\n    public void configure(HttpSecurity http) throws Exception {\n        http.authorizeRequests()\n                .antMatchers(\"/users\").access(\"#oauth2.hasScope('read')\");\n    }\n\n}\n```\n위와 같이 지정을 하게 되면 /users라는 자원에 접근하기 위해서는 access_token이 있어야 접근을 할 수 있다. 자원에 대한 CRUD는 Rest Repositories(도메인만으로 REST API를 자동으로 만들어준다.)를 이용할 것이다.  도메인 구성등에 대한 정보는 [소스](https://github.com/minwan1/spring-security-oauth2-example/blob/example-1/src/main/java/com/example/oauth/user/User.java)을 참조 할 수 있다. 사실 너무 간단해서 도메인이라고 할것도 없다. 이제 실제로 /users를 접근을 할 수 없는지 테스트를 해보자. 테스트는 아래와 같이 junit을 사용할 것이다.\n```java\n@Test\npublic void when_callApi_expect_unauthorized() throws Exception {\n    mockMvc.perform(get(\"/users\")).andExpect(status().isOk());\n}\n```\n테스트 결과는.......\n![](https://i.imgur.com/90IClaN.png)\n그렇다. response 결과는 401이 넘어와 실패했다. access_token없이 접근해서 그렇다. 당연한 결과이다. 위 소스는 isOk에서 isUnauthorized로 수정해주면될 것 같다. 그러면 테스트 결과는 성공일 것이다. 그다음은 토큰을 생성한후 API를 호출해 성공하는 테스트를 작성할 것 이다. 먼저 rest로 토큰을 얻어보자. 이 /oauth/token는 Spring OAuth에서 지정해준 URI이다. 이 URI는 Basic Auth를 사용하여 ClientID와 Secret을 포함하고 바디값으로 grant_type, client_id, username, password, scope를 넘기면 토큰 값을 얻을 수 있다.\n```java\nprivate String obtainAccessToken(String username, String password) throws Exception {\n\n    MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n    params.add(\"grant_type\", \"password\");\n    params.add(\"client_id\", CLIENT_ID); //foo\n    params.add(\"username\", username);\n    params.add(\"password\", password);\n    params.add(\"scope\", SCOPE); //read\n\n    ResultActions result\n            = mockMvc.perform(post(\"/oauth/token\")\n            .params(params)\n            .with(httpBasic(CLIENT_ID, CLIENT_SECRET)) //foo, bar\n            .accept(CONTENT_TYPE)) //\"application/json;charset=UTF-8\"\n            .andExpect(status().isOk())\n            .andExpect(content().contentType(CONTENT_TYPE));//\"application/json;charset=UTF-8\"\n\n    String resultString = result.andReturn().getResponse().getContentAsString();\n\n    JacksonJsonParser jsonParser = new JacksonJsonParser();\n    return jsonParser.parseMap(resultString).get(\"access_token\").toString();\n}\n```\n위와같이 넘기면 access_token값을 얻을 수 있다.\n\n```java\n@Test\npublic void when_callUsers_expect_success() throws Exception {\n    String accessToken =obtainAccessToken(SECURITY_USERNAME,SECURITY_PASSWORD);\n    mockMvc.perform(get(\"/users\")\n            .header(\"Authorization\", \"Bearer \" + accessToken)\n            .accept(CONTENT_TYPE))//\"application/json;charset=UTF-8\"\n            .andExpect(status().isOk())\n            .andExpect(content().contentType(CONTENT_TYPE));//\"application/json;charset=UTF-8\"\n}\n```\n그다음 생성한 토큰을 이용해서 header 값에 access_token을 넣은 후 호출하면 호출에 성공한 모습을 확인할 수 있다. 이것의 전체적인 구현인 토큰 관리, client, user 등록등 In-memory기반에 의하여 구현되었다. 그렇기 때문에 서버가 종료되면 기존에 발급되었던 토큰들이 모두 소멸된다. Product로 사용하기 위해서는 JdbcTokenStore빈을 통해서 토큰 관리, client, user 등록등을 영속화하여 사용해야 한다. in-memory 방식으로 구현한 OAuth소스는 [in-memory 방식을 사용한 OAuth2 구현](https://github.com/minwan1/spring-security-oauth2-example/tree/example-1)에서 확인할 수 있다.\n\n\n#### OAuth2 JdbcTokenStore등을 이용한 데이터 영속화\n이제 Authorization Server, Resource Server을 커스터마이징하여 데이터들의 관리를 영속화할 것이다. 가장먼저 해야할것은 Spring Security Oauth에 맞는 디비에 대한 [스키마 ](https://github.com/spring-projects/spring-security-oauth/blob/master/spring-security-oauth2/src/test/resources/schema.sql)를 만드는것이다. 그 후 TokenStore의 빈을 등록하는것이다. TokenStore 빈을 등록을하게 되면 Token관리, Client관리등을 디비로 할 수 있게된다.\n\n```java\n@Bean\npublic TokenStore JdbcTokenStore(@Qualifier(\"dataSource\") DataSource dataSource) {\n    return new JdbcTokenStore(dataSource);\n}\n```\n\n\n그 다음 Authorization Server, Resource Server를 두개의 클래스로 분리할 것이다. ResourceServerConfigurerAdapter, AuthorizationServerConfigurerAdapter를 상속해서 세부내용을 구현해야 한다. 그래야 좀 더 세부적으로 Authorization Server, Resource Server 컨트롤 가능하다. 아래는 각각의 구현체 구조이다.\n\n\n```java\n@Configuration\n@EnableResourceServer\npublic class ResourceServerConfiguration extends ResourceServerConfigurerAdapter {\n\n        @Override\n      public void configure(ResourceServerSecurityConfigurer resources) {\n\n      }\n      @Override\n      public void configure(HttpSecurity http) throws Exception {\n          // 자원서버 접근권한 설정\n      }\n\n}\n```\n```java\n\n@Configuration\n@EnableAuthorizationServer\npublic class DemoApplication extends AuthorizationServerConfigurerAdapter {\n// ...\n   @Override\n   public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {\n// OAuth2 인증서버 자체의  보안 정보를 설정하는 부분\n   }\n   @Override\n   public void configure(ClientDetailsServiceConfigurer clients) throws Exception {\n// Client 에 대한 정보를  설정하는 부분\n   }\n   @Override\n   public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {\n// OAuth2 서버가 작동하기 위한 Endpoint에 대한 정보를 설정\n   }\n   // ...\n}\n```\n\nAuthorization Server, Resource Server를 분리하게 되면 yml에 등록한 클라이언트는 의미가없어진다. 이유는 AuthorizationServerConfigurerAdapter 클래스를 상속함으로써 오버라이딩이되어 authorizationServer에 대한 정의를 여기에 할것이기 때문이다. 그리고 만약 세부구현체를 구현을안하고 accessToken을 생성하려고하면 clientDetailsService를 정의하라는 에러를 만날것이다. 먼저 테스트를 위해 인메모리 등록을 할 것이다. 만약 inMemory가 아닌 외부 db를 사용하고싶으면 아래의 소스 부분에 inMemory부분을 jdbc 방식으로 바꾸면 된다.\n\n```java\n@EnableResourceServer  // API 서버 인증, 권한 설정\n@Configuration\npublic class AuthorizationServiceConfigurerAdapterImpl extends AuthorizationServerConfigurerAdapter{\n\n    @Override\n    public void configure(ClientDetailsServiceConfigurer clients)\n            throws Exception {\n        clients.inMemory() // 이부분을 jdbc를 쓰면 데이터베이스값을 이용할 수 있다.\n                .withClient(\"foo\")\n                .secret(\"bar\")\n                .authorizedGrantTypes(\n                        \"password\",\"authorization_code\", \"refresh_token\")\n                .scopes(\"read\");\n    }\n\n}\n```\n그런데 이렇게 클라이언트 정보를 정의하고 accessToken을 생성하려고 하면 \"Unsupported grant type: password\"라는 메시지를 만난다. 이 메시지를 해결하기 위해서는 AuthorizationServer에 AuthenticationManager를 제공해야한다. 그래서 아래와같이 소스를 추가해줘야한다.\n\n```java\npublic class AuthorizationServiceConfigurerAdapterImpl extends AuthorizationServerConfigurerAdapter{\n\n    @Autowired\n    private AuthenticationManager authenticationManager;\n\n    @Autowired\n    private TokenStore JdbcTokenStore;\n\n    @Override\n    public void configure(ClientDetailsServiceConfigurer clients)\n            throws Exception {\n        clients.inMemory()\n                .withClient(\"foo\")\n                .secret(\"bar\")\n                .authorizedGrantTypes(\n                        \"password\",\"authorization_code\", \"refresh_token\")\n                .scopes(\"read\");\n    }\n\n    @Override\n    public void configure(\n            AuthorizationServerEndpointsConfigurer endpoints)\n            throws Exception {\n\n        endpoints\n                .tokenStore(JdbcTokenStore)\n                .authenticationManager(authenticationManager);\n    }\n\n}\n```\n\n위와 같이 추가되면 이제 토큰은 inMemory가 아닌 DB에 저장이 된다. 그리고 \"Unsupported grant type: password\"에대한 에러도 사라지고 AccessToken이 생성 될것이다. 만약 클라이언트 관리도 디비에서 하려면 아래와 같이 변경해주면 된다.\n```java\n@Override\n    public void configure(ClientDetailsServiceConfigurer clients)\n            throws Exception {\n        clients.jdbc(dataSource);\n    }\n```\n그다음 oauth_client_details 테이블의 아래와같이 클라이언트 정보를 추가해줘야 한다.\n```sql\nINSERT INTO PUBLIC.OAUTH_CLIENT_DETAILS (CLIENT_ID, RESOURCE_IDS, CLIENT_SECRET, SCOPE, AUTHORIZED_GRANT_TYPES, WEB_SERVER_REDIRECT_URI, AUTHORITIES, ACCESS_TOKEN_VALIDITY, REFRESH_TOKEN_VALIDITY, ADDITIONAL_INFORMATION, AUTOAPPROVE) VALUES ('foo', '', 'bar', 'read', 'password,authorization_code,refresh_token', '', '', null, null, '{}', '');\n```\n그리고 위와 같이 Client에 관한 데이터를 Insert해주면 된다. 그렇게 되면 DB에서 클라이언 정보를 관리할 수 있게 된다.\n\n#### Authorization Server, Resource Server 애플리케이션 분리\n\n지금은 하나의 어플리케이션에 Authorization Server, Resource Server를 구현했다. 만약 다른 어플리케이션에 다른 데이터베이스를 바라보고 Authorization Server, Resource Server를 구성했다면 HTTP 통신을 통해 토큰을 확인해야한다. 그럴려면 먼저 인증서버에서 accessToken이 유효한지 확인할 수 있는 URL이 있어야 한다. 하지만 이것은 스프링에서 아래와 같이 설정해준다면 기본적으로 기능을 제공해준다.\n\n```java\n@Override\npublic void configure(\n  AuthorizationServerSecurityConfigurer oauthServer)\n  throws Exception {\n    oauthServer\n      .tokenKeyAccess(\"permitAll()\")\n      .checkTokenAccess(\"isAuthenticated()\");\n      // Token 정보를 API(/oauth/check_token)를 활성화 시킨다. ( 기본은 denyAll )\n}\n\n```\n그리고 자원 서버에서도 다른 클라이언트가 접근한다면 token이 유효한지 인증서버를 통해 체크를 해줘야 한다. 이 설정 또한 쉽게 아래와 같이 URL만 등록해주면 된다. 아래는 YML, 빈을 통해 등록하는 방식을 나열했다.\n**YML등록방법**\n// OAuth2 서버에서 기본적으로 Token정보를 받아오는 URL\n```\nsecurity.resource.token-info-uri:url주소/oauth/check_token\n```\n**빈등록방법**\n```java\n@Primary\n@Bean\npublic RemoteTokenServices tokenService() {\n    RemoteTokenServices tokenService = new RemoteTokenServices();\n    tokenService.setCheckTokenEndpointUrl(\n      \"http://localhost:8080/spring-security-oauth-server/oauth/check_token\");\n    tokenService.setClientId(\"foo\");\n    tokenService.setClientSecret(\"bar\");\n    return tokenService;\n}\n```\n위와 같이 등록하면 자원서버는 등록된 URL로 accessToken이 유효한지 체크를 할것이다.\n\n### 마무리 하며...\n스프링을 통해 OAuth2를 간단하게 구현해봤다. 첫 부분에는 토큰 관리, 클라이언트 등록 등 In-Memory를 통해 간단하게 OAuth2 구현했고, 중간 부분부터는 인증서버와 자원 서버의 클래스를 분리했다. 또한 토큰 관리, 클라이언트 등록 등을 InMemmory로 관리했었는데 이러한 것을 외부 DB 등록을 통해 관리하게 해봤다. OAuth2 인증 방식은 password 인증 방식만 구현해봤는데, 다른 인증 방식을 넣는 것은 어렵지 않다. 인증서버와 자원 서버만 설정되어 있다면 금방 도입할 수 있다. 물론 Product 용으로 개발하는 데까지는 많은 시간이 걸릴 것이다. 요즘 점점 시간이 지나면서 쿠키를 통한 session 방식의 로그인은 없어지고 있는 것 같다. 점점 모바일 환경 등 멀티 디바이스를 지원해야 하므로 웹 하나만을 위한 서버를 만드는 일은 비효율적이기 때문일 것이다. 그래서 많은 서버들이 Token 방식의 로그인 방식으로 옮기고 있는 것 같다. 그중에서도 OAuth2는 많은 인증 방식 등과 인증의 간편함을 가져 인기가 좋은것같다.\n\n이 예제와 관련한 소스는 [JDBC 방식을 사용한 OAuth2 구현](https://github.com/minwan1/spring-security-oauth2-example/tree/example-2)에서 확인할 수 있습니다\n\n참고\n* [OAuth 2 Developers Guide](http://projects.spring.io/spring-security-oauth/docs/oauth2.html)\n* [baeldung](http://www.baeldung.com/oauth-api-testing-with-spring-mvc)\n* [기억보단 기록을](http://jojoldu.tistory.com/234)\n* [이수홍](https://brunch.co.kr/@sbcoba/4)\n\n","source":"_posts/2018-03-11-Spring-OAuth구현.md","raw":"---\ntitle: Spring Security OAuth2구현\ncatalog: true\ndate: 2018-03-11\nsubtitle:\nheader-img:\ntags:\n- Spring\n- Java\n- OAuth\n- ETC\n---\n\n## Spring Security OAuth2구현\n\n### OAuth란?\nOAuth는 Open Authorization, Open Authentication 뜻하는 것으로 자신의 애플리케이션 서버의 데이터로 다른 Third party에게 자원을 공유하거나 대신 유저 인증을 처리해줄 수 있는 오픈 표준 프로토콜이다.\n\n### OAuth 실 사용 예\n간단히 OAuth인증에 대해 실 사용 예를 보자면 웹, 앱들을 사용하면서 네이버 로그인, 카카오 로그인, 페이스북 로그인 등을 한 번쯤은 보았을 것이다. 이것이 바로 OAuth인 증 방식 중 하나이다. 네이버 로그인, 카카오 로그인, 페이스북 로그인 등으로 로그인을 하게 되면 그 애플리케이션들로부터 Access_token이라는 값을 받아 써드파티 애플리케이션에게 준다. Access_token이라는 값이 어떻게 보면 유저의 인증 키라고 보면 된다. 물론 유저가 로그인을 실패한다면 Access_token을 받지 못할 것이다. Access_token 을 받았다는 것은 해당 유저가 인증이 되었다는 것을 의미한다. 이러한 기술을 통해서 써드파티 애플리케이션에게 유저를 인증 시킨다. 이것이 OAuth인증이다. 물론 OAuth가 Authentication(인증) 기능만 하는 것은 아니다.\n\nOAuth는 Authorization(인가)에 대한 기능도 있다. Authorization라는 기능(?)을 이용하면 써드파티 앱들은 유저가 선택한 로그인 방식에 애플리케이션의 유저 정보 등을 얻을 수 있다. 이정보를 바탕으로 써드파티 앱들은 유저를 자신의 앱에 가입시킨다. 뿐만 아니라 서드파티 앱들은 유저가 로그인한 애플리케이션의 기능 등을 사용할 수 있다. 이것을 잘 사용하는 로켓펀치라는 구직 사이트가 있다. 이 사이트에 페이스북으로 로그인하기 기능 이용하여 로그인과 함께 친구 정보 제공을 동의하고 my account를 들어가면 내 친구들의 로켓펀치의 등록된 구직 정보들을 볼 수 있다. 이것이 가능한 이유는 아까 받은 Access_token으로 페이스북에게 유저의 정보를 요청할 수 있기 때문이다. 이러한 조회 기능뿐만 아니라 유저의 동의만 얻는다면 페이스북 담벼락에 글 남기기 등의 기능들도 사용할 수 있다. 이런 것들 가능하게 해주는 것이 OAuth 인증이다. OAuth도 버전이 있고, 그 차이점이 있는데 미흡하지만 [OAuth란?](https://minwan1.github.io/2018/02/24/2018-02-24-OAuth/)을 참조하면 될 것 같다.\n\n위와 같은 방법뿐만 아니라 Microservices에 인증 방식으로도 사용된다. 마이크로서비스란 하나의 큰 애플리케이션을 여러개의 작은 애플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처를 말한다. 이 [마이크로서비스 아키텍처, 그것이 뭣이 중헌디?](http://guruble.com/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4microservice-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B7%B8%EA%B2%83%EC%9D%B4-%EB%AD%A3%EC%9D%B4-%EC%A4%91%ED%97%8C%EB%94%94/)글에 마이크로서비스에 대한 내용들이 잘 설명돼 있다. 아무래도 자원들이 각각의 서버에 분리해있다보니 인증이나, 인가를 하나로 적절히 관리하는것이 필요하다. 만약 모놀리틱 아키텍처로 이러한 자원들을 관리하게된다면 상당히 비효율적일 것이다. 각각의 자원 서버마다 필요한 자원의 서비스를 호출하려고하면 인증,인가처리를 해야하기 떄문에 매우 비효율적으로 될것이다. 하지만 OAuth방식을 이용한다면 인증서버를 두고 각각의 자원서비스들의 인증, 인가를 관리한다면 효율적으로 자원 서비스들을 관리할 수 있다.\n\n\n### Spring으로 OAuth2구현\n뭔가 서론이 장황해진 것 같다. 결론을 말씀드리자면 이러한 장점들을 이용하기 위해 OAuth인증 시스템을 구현해 볼 것이다. 구현 방법은 Spring을 이용해서 Spring security의 하위 프로젝트 Spring OAuth를 구현할 것이다. 여기에서 구현하고자하는 방식은 OAuth2방식이고 인증 방식은 Password 방식을 구현할 것이다. OAuth2부터는 다양한 인증 방식을 제공하는데 여기에대한 차이점은 [OAuth란?](https://minwan1.github.io/2018/02/24/2018-02-24-OAuth/)글에서 확인할 수 있다.\n\n#### OAuth2 역할\n먼저 구현전에 OAuth2에 역할에대해 알아보자. OAuth2는 크게 Resource Owner, Authorization Server, Resource Server, Client 4개의 역할로 나누어진다. 먼저 Resource Owner는 유저를 말한다. 이유저는 위에서말한 카카오톡,네이버,구글등에 로그인 할 수 있고 그 해당 애플리케이션의 기능을 이용 가능한 유저를 말한다. Authorization Server는 인증 서버를 말한다. 유저가 OAuth를 통해 로그인한다면 카카오톡,네이버,구글의 유저가 맞는지 확인해주는 서버를 말한다. Resource Server는 카카오톡,네이버,구글의 자원(API)이 있는 서버를 말한다. Client는 써드파티앱들을 말한다. Authorization Server, Resource Server를 이용하는 앱들은 모두 Clinet라고 생각하면 된다.\n\n#### Resource Owner Password Credentials Grant 동작방식\n먼저 구현하려고하는 password 인증 방식이 무엇인지 간단하게 살펴보자. 이방식을 사용하기 위해서는 AuthorizationServer에 Client-id와 secret을 등록해야한다. 그리고 Client가 Resource Owner로부터 아이디/패스워드를 받아 직접 access token을 받아오는 방식이다. 이때 클라이언트는 AccessToken을 얻기 위해 AuthorizationServer에 호출할때 이 Client-id와 secret을 Basic-auth를 해줘야 한다. 하지만 이방식은 Client가 신용이 없을 때에는 사용하기에 위험하다는 단점이 있다. 클라이언트가 확실한 신용이 보장될 때 사용할 수 있는 방식이다.\n![](https://i.imgur.com/7LhjI1L.png)\n동작 순서는 대략 이렇다.\n1. AuthorizationServer에 Client-id와 Secret을 등록한다(그림에는 안나와있음)\n2. User가 Id와 Password를 입력한다\n3. 클라이언트는 유저의 id와 password와 클라이언트 정보를 넘긴다.\n4. Authorization sever는 Access token을 넘긴다.\n5. Client는 token로 자원서버에 접근할 수 있게 된다.\n\n그럼 이제 실제 구현을 해볼것이다.\n\n#### OAuth2 in-memory 방식으로 간단한 구현\nOAuth는 인증서버와 자원 서버를 하나의 애플리케이션에서 구현할 수도 있고, 분리할 수도 있다. 여기에서는 두 개를 하나의 애플리케이션에서 구현할 것이다. Resource Owner, Client 관리는 in-memory를 이용할 것이다. 아래와 같이 application.yml에 Resource Owner를 지정하고, Client를 쉽게 등록할 수 있다.\n```\nsecurity:\n  user:\n    name: user\n    password: test\n  oauth2:\n    client:\n      client-id: foo\n      client-secret: bar\n```\n그다음은 Resource Server, Authorization Server의 설정을 구현할 것이다. @EnableResourceServer, @EnableAuthorizationServer 두개의 어노테이션으로 쉽게 인증서버와 자원서버를 구성할 수 있다.\n```java\n@EnableResourceServer  // API 서버 인증(또는 권한 설정)\n@EnableAuthorizationServer // 자원서버 설정\n@Configuration\npublic class ResourceServerConfigurerAdapterImpl extends ResourceServerConfigurerAdapter {\n\n    @Override\n    public void configure(HttpSecurity http) throws Exception {\n        http.authorizeRequests()\n                .antMatchers(\"/users\").access(\"#oauth2.hasScope('read')\");\n    }\n\n}\n```\n위와 같이 지정을 하게 되면 /users라는 자원에 접근하기 위해서는 access_token이 있어야 접근을 할 수 있다. 자원에 대한 CRUD는 Rest Repositories(도메인만으로 REST API를 자동으로 만들어준다.)를 이용할 것이다.  도메인 구성등에 대한 정보는 [소스](https://github.com/minwan1/spring-security-oauth2-example/blob/example-1/src/main/java/com/example/oauth/user/User.java)을 참조 할 수 있다. 사실 너무 간단해서 도메인이라고 할것도 없다. 이제 실제로 /users를 접근을 할 수 없는지 테스트를 해보자. 테스트는 아래와 같이 junit을 사용할 것이다.\n```java\n@Test\npublic void when_callApi_expect_unauthorized() throws Exception {\n    mockMvc.perform(get(\"/users\")).andExpect(status().isOk());\n}\n```\n테스트 결과는.......\n![](https://i.imgur.com/90IClaN.png)\n그렇다. response 결과는 401이 넘어와 실패했다. access_token없이 접근해서 그렇다. 당연한 결과이다. 위 소스는 isOk에서 isUnauthorized로 수정해주면될 것 같다. 그러면 테스트 결과는 성공일 것이다. 그다음은 토큰을 생성한후 API를 호출해 성공하는 테스트를 작성할 것 이다. 먼저 rest로 토큰을 얻어보자. 이 /oauth/token는 Spring OAuth에서 지정해준 URI이다. 이 URI는 Basic Auth를 사용하여 ClientID와 Secret을 포함하고 바디값으로 grant_type, client_id, username, password, scope를 넘기면 토큰 값을 얻을 수 있다.\n```java\nprivate String obtainAccessToken(String username, String password) throws Exception {\n\n    MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n    params.add(\"grant_type\", \"password\");\n    params.add(\"client_id\", CLIENT_ID); //foo\n    params.add(\"username\", username);\n    params.add(\"password\", password);\n    params.add(\"scope\", SCOPE); //read\n\n    ResultActions result\n            = mockMvc.perform(post(\"/oauth/token\")\n            .params(params)\n            .with(httpBasic(CLIENT_ID, CLIENT_SECRET)) //foo, bar\n            .accept(CONTENT_TYPE)) //\"application/json;charset=UTF-8\"\n            .andExpect(status().isOk())\n            .andExpect(content().contentType(CONTENT_TYPE));//\"application/json;charset=UTF-8\"\n\n    String resultString = result.andReturn().getResponse().getContentAsString();\n\n    JacksonJsonParser jsonParser = new JacksonJsonParser();\n    return jsonParser.parseMap(resultString).get(\"access_token\").toString();\n}\n```\n위와같이 넘기면 access_token값을 얻을 수 있다.\n\n```java\n@Test\npublic void when_callUsers_expect_success() throws Exception {\n    String accessToken =obtainAccessToken(SECURITY_USERNAME,SECURITY_PASSWORD);\n    mockMvc.perform(get(\"/users\")\n            .header(\"Authorization\", \"Bearer \" + accessToken)\n            .accept(CONTENT_TYPE))//\"application/json;charset=UTF-8\"\n            .andExpect(status().isOk())\n            .andExpect(content().contentType(CONTENT_TYPE));//\"application/json;charset=UTF-8\"\n}\n```\n그다음 생성한 토큰을 이용해서 header 값에 access_token을 넣은 후 호출하면 호출에 성공한 모습을 확인할 수 있다. 이것의 전체적인 구현인 토큰 관리, client, user 등록등 In-memory기반에 의하여 구현되었다. 그렇기 때문에 서버가 종료되면 기존에 발급되었던 토큰들이 모두 소멸된다. Product로 사용하기 위해서는 JdbcTokenStore빈을 통해서 토큰 관리, client, user 등록등을 영속화하여 사용해야 한다. in-memory 방식으로 구현한 OAuth소스는 [in-memory 방식을 사용한 OAuth2 구현](https://github.com/minwan1/spring-security-oauth2-example/tree/example-1)에서 확인할 수 있다.\n\n\n#### OAuth2 JdbcTokenStore등을 이용한 데이터 영속화\n이제 Authorization Server, Resource Server을 커스터마이징하여 데이터들의 관리를 영속화할 것이다. 가장먼저 해야할것은 Spring Security Oauth에 맞는 디비에 대한 [스키마 ](https://github.com/spring-projects/spring-security-oauth/blob/master/spring-security-oauth2/src/test/resources/schema.sql)를 만드는것이다. 그 후 TokenStore의 빈을 등록하는것이다. TokenStore 빈을 등록을하게 되면 Token관리, Client관리등을 디비로 할 수 있게된다.\n\n```java\n@Bean\npublic TokenStore JdbcTokenStore(@Qualifier(\"dataSource\") DataSource dataSource) {\n    return new JdbcTokenStore(dataSource);\n}\n```\n\n\n그 다음 Authorization Server, Resource Server를 두개의 클래스로 분리할 것이다. ResourceServerConfigurerAdapter, AuthorizationServerConfigurerAdapter를 상속해서 세부내용을 구현해야 한다. 그래야 좀 더 세부적으로 Authorization Server, Resource Server 컨트롤 가능하다. 아래는 각각의 구현체 구조이다.\n\n\n```java\n@Configuration\n@EnableResourceServer\npublic class ResourceServerConfiguration extends ResourceServerConfigurerAdapter {\n\n        @Override\n      public void configure(ResourceServerSecurityConfigurer resources) {\n\n      }\n      @Override\n      public void configure(HttpSecurity http) throws Exception {\n          // 자원서버 접근권한 설정\n      }\n\n}\n```\n```java\n\n@Configuration\n@EnableAuthorizationServer\npublic class DemoApplication extends AuthorizationServerConfigurerAdapter {\n// ...\n   @Override\n   public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {\n// OAuth2 인증서버 자체의  보안 정보를 설정하는 부분\n   }\n   @Override\n   public void configure(ClientDetailsServiceConfigurer clients) throws Exception {\n// Client 에 대한 정보를  설정하는 부분\n   }\n   @Override\n   public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {\n// OAuth2 서버가 작동하기 위한 Endpoint에 대한 정보를 설정\n   }\n   // ...\n}\n```\n\nAuthorization Server, Resource Server를 분리하게 되면 yml에 등록한 클라이언트는 의미가없어진다. 이유는 AuthorizationServerConfigurerAdapter 클래스를 상속함으로써 오버라이딩이되어 authorizationServer에 대한 정의를 여기에 할것이기 때문이다. 그리고 만약 세부구현체를 구현을안하고 accessToken을 생성하려고하면 clientDetailsService를 정의하라는 에러를 만날것이다. 먼저 테스트를 위해 인메모리 등록을 할 것이다. 만약 inMemory가 아닌 외부 db를 사용하고싶으면 아래의 소스 부분에 inMemory부분을 jdbc 방식으로 바꾸면 된다.\n\n```java\n@EnableResourceServer  // API 서버 인증, 권한 설정\n@Configuration\npublic class AuthorizationServiceConfigurerAdapterImpl extends AuthorizationServerConfigurerAdapter{\n\n    @Override\n    public void configure(ClientDetailsServiceConfigurer clients)\n            throws Exception {\n        clients.inMemory() // 이부분을 jdbc를 쓰면 데이터베이스값을 이용할 수 있다.\n                .withClient(\"foo\")\n                .secret(\"bar\")\n                .authorizedGrantTypes(\n                        \"password\",\"authorization_code\", \"refresh_token\")\n                .scopes(\"read\");\n    }\n\n}\n```\n그런데 이렇게 클라이언트 정보를 정의하고 accessToken을 생성하려고 하면 \"Unsupported grant type: password\"라는 메시지를 만난다. 이 메시지를 해결하기 위해서는 AuthorizationServer에 AuthenticationManager를 제공해야한다. 그래서 아래와같이 소스를 추가해줘야한다.\n\n```java\npublic class AuthorizationServiceConfigurerAdapterImpl extends AuthorizationServerConfigurerAdapter{\n\n    @Autowired\n    private AuthenticationManager authenticationManager;\n\n    @Autowired\n    private TokenStore JdbcTokenStore;\n\n    @Override\n    public void configure(ClientDetailsServiceConfigurer clients)\n            throws Exception {\n        clients.inMemory()\n                .withClient(\"foo\")\n                .secret(\"bar\")\n                .authorizedGrantTypes(\n                        \"password\",\"authorization_code\", \"refresh_token\")\n                .scopes(\"read\");\n    }\n\n    @Override\n    public void configure(\n            AuthorizationServerEndpointsConfigurer endpoints)\n            throws Exception {\n\n        endpoints\n                .tokenStore(JdbcTokenStore)\n                .authenticationManager(authenticationManager);\n    }\n\n}\n```\n\n위와 같이 추가되면 이제 토큰은 inMemory가 아닌 DB에 저장이 된다. 그리고 \"Unsupported grant type: password\"에대한 에러도 사라지고 AccessToken이 생성 될것이다. 만약 클라이언트 관리도 디비에서 하려면 아래와 같이 변경해주면 된다.\n```java\n@Override\n    public void configure(ClientDetailsServiceConfigurer clients)\n            throws Exception {\n        clients.jdbc(dataSource);\n    }\n```\n그다음 oauth_client_details 테이블의 아래와같이 클라이언트 정보를 추가해줘야 한다.\n```sql\nINSERT INTO PUBLIC.OAUTH_CLIENT_DETAILS (CLIENT_ID, RESOURCE_IDS, CLIENT_SECRET, SCOPE, AUTHORIZED_GRANT_TYPES, WEB_SERVER_REDIRECT_URI, AUTHORITIES, ACCESS_TOKEN_VALIDITY, REFRESH_TOKEN_VALIDITY, ADDITIONAL_INFORMATION, AUTOAPPROVE) VALUES ('foo', '', 'bar', 'read', 'password,authorization_code,refresh_token', '', '', null, null, '{}', '');\n```\n그리고 위와 같이 Client에 관한 데이터를 Insert해주면 된다. 그렇게 되면 DB에서 클라이언 정보를 관리할 수 있게 된다.\n\n#### Authorization Server, Resource Server 애플리케이션 분리\n\n지금은 하나의 어플리케이션에 Authorization Server, Resource Server를 구현했다. 만약 다른 어플리케이션에 다른 데이터베이스를 바라보고 Authorization Server, Resource Server를 구성했다면 HTTP 통신을 통해 토큰을 확인해야한다. 그럴려면 먼저 인증서버에서 accessToken이 유효한지 확인할 수 있는 URL이 있어야 한다. 하지만 이것은 스프링에서 아래와 같이 설정해준다면 기본적으로 기능을 제공해준다.\n\n```java\n@Override\npublic void configure(\n  AuthorizationServerSecurityConfigurer oauthServer)\n  throws Exception {\n    oauthServer\n      .tokenKeyAccess(\"permitAll()\")\n      .checkTokenAccess(\"isAuthenticated()\");\n      // Token 정보를 API(/oauth/check_token)를 활성화 시킨다. ( 기본은 denyAll )\n}\n\n```\n그리고 자원 서버에서도 다른 클라이언트가 접근한다면 token이 유효한지 인증서버를 통해 체크를 해줘야 한다. 이 설정 또한 쉽게 아래와 같이 URL만 등록해주면 된다. 아래는 YML, 빈을 통해 등록하는 방식을 나열했다.\n**YML등록방법**\n// OAuth2 서버에서 기본적으로 Token정보를 받아오는 URL\n```\nsecurity.resource.token-info-uri:url주소/oauth/check_token\n```\n**빈등록방법**\n```java\n@Primary\n@Bean\npublic RemoteTokenServices tokenService() {\n    RemoteTokenServices tokenService = new RemoteTokenServices();\n    tokenService.setCheckTokenEndpointUrl(\n      \"http://localhost:8080/spring-security-oauth-server/oauth/check_token\");\n    tokenService.setClientId(\"foo\");\n    tokenService.setClientSecret(\"bar\");\n    return tokenService;\n}\n```\n위와 같이 등록하면 자원서버는 등록된 URL로 accessToken이 유효한지 체크를 할것이다.\n\n### 마무리 하며...\n스프링을 통해 OAuth2를 간단하게 구현해봤다. 첫 부분에는 토큰 관리, 클라이언트 등록 등 In-Memory를 통해 간단하게 OAuth2 구현했고, 중간 부분부터는 인증서버와 자원 서버의 클래스를 분리했다. 또한 토큰 관리, 클라이언트 등록 등을 InMemmory로 관리했었는데 이러한 것을 외부 DB 등록을 통해 관리하게 해봤다. OAuth2 인증 방식은 password 인증 방식만 구현해봤는데, 다른 인증 방식을 넣는 것은 어렵지 않다. 인증서버와 자원 서버만 설정되어 있다면 금방 도입할 수 있다. 물론 Product 용으로 개발하는 데까지는 많은 시간이 걸릴 것이다. 요즘 점점 시간이 지나면서 쿠키를 통한 session 방식의 로그인은 없어지고 있는 것 같다. 점점 모바일 환경 등 멀티 디바이스를 지원해야 하므로 웹 하나만을 위한 서버를 만드는 일은 비효율적이기 때문일 것이다. 그래서 많은 서버들이 Token 방식의 로그인 방식으로 옮기고 있는 것 같다. 그중에서도 OAuth2는 많은 인증 방식 등과 인증의 간편함을 가져 인기가 좋은것같다.\n\n이 예제와 관련한 소스는 [JDBC 방식을 사용한 OAuth2 구현](https://github.com/minwan1/spring-security-oauth2-example/tree/example-2)에서 확인할 수 있습니다\n\n참고\n* [OAuth 2 Developers Guide](http://projects.spring.io/spring-security-oauth/docs/oauth2.html)\n* [baeldung](http://www.baeldung.com/oauth-api-testing-with-spring-mvc)\n* [기억보단 기록을](http://jojoldu.tistory.com/234)\n* [이수홍](https://brunch.co.kr/@sbcoba/4)\n\n","slug":"2018-03-11-Spring-OAuth구현","published":1,"updated":"2018-07-16T14:19:33.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27ej003sjjpesle38g8k","content":"<h2><span id=\"spring-security-oauth2구현\">Spring Security OAuth2구현</span></h2>\n<h3><span id=\"oauth란\">OAuth란?</span></h3>\n<p>OAuth는 Open Authorization, Open Authentication 뜻하는 것으로 자신의 애플리케이션 서버의 데이터로 다른 Third party에게 자원을 공유하거나 대신 유저 인증을 처리해줄 수 있는 오픈 표준 프로토콜이다.</p>\n<h3><span id=\"oauth-실-사용-예\">OAuth 실 사용 예</span></h3>\n<p>간단히 OAuth인증에 대해 실 사용 예를 보자면 웹, 앱들을 사용하면서 네이버 로그인, 카카오 로그인, 페이스북 로그인 등을 한 번쯤은 보았을 것이다. 이것이 바로 OAuth인 증 방식 중 하나이다. 네이버 로그인, 카카오 로그인, 페이스북 로그인 등으로 로그인을 하게 되면 그 애플리케이션들로부터 Access_token이라는 값을 받아 써드파티 애플리케이션에게 준다. Access_token이라는 값이 어떻게 보면 유저의 인증 키라고 보면 된다. 물론 유저가 로그인을 실패한다면 Access_token을 받지 못할 것이다. Access_token 을 받았다는 것은 해당 유저가 인증이 되었다는 것을 의미한다. 이러한 기술을 통해서 써드파티 애플리케이션에게 유저를 인증 시킨다. 이것이 OAuth인증이다. 물론 OAuth가 Authentication(인증) 기능만 하는 것은 아니다.</p>\n<p>OAuth는 Authorization(인가)에 대한 기능도 있다. Authorization라는 기능(?)을 이용하면 써드파티 앱들은 유저가 선택한 로그인 방식에 애플리케이션의 유저 정보 등을 얻을 수 있다. 이정보를 바탕으로 써드파티 앱들은 유저를 자신의 앱에 가입시킨다. 뿐만 아니라 서드파티 앱들은 유저가 로그인한 애플리케이션의 기능 등을 사용할 수 있다. 이것을 잘 사용하는 로켓펀치라는 구직 사이트가 있다. 이 사이트에 페이스북으로 로그인하기 기능 이용하여 로그인과 함께 친구 정보 제공을 동의하고 my account를 들어가면 내 친구들의 로켓펀치의 등록된 구직 정보들을 볼 수 있다. 이것이 가능한 이유는 아까 받은 Access_token으로 페이스북에게 유저의 정보를 요청할 수 있기 때문이다. 이러한 조회 기능뿐만 아니라 유저의 동의만 얻는다면 페이스북 담벼락에 글 남기기 등의 기능들도 사용할 수 있다. 이런 것들 가능하게 해주는 것이 OAuth 인증이다. OAuth도 버전이 있고, 그 차이점이 있는데 미흡하지만 <a href=\"https://minwan1.github.io/2018/02/24/2018-02-24-OAuth/\">OAuth란?</a>을 참조하면 될 것 같다.</p>\n<p>위와 같은 방법뿐만 아니라 Microservices에 인증 방식으로도 사용된다. 마이크로서비스란 하나의 큰 애플리케이션을 여러개의 작은 애플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처를 말한다. 이 <a href=\"http://guruble.com/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4microservice-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B7%B8%EA%B2%83%EC%9D%B4-%EB%AD%A3%EC%9D%B4-%EC%A4%91%ED%97%8C%EB%94%94/\" target=\"_blank\" rel=\"noopener\">마이크로서비스 아키텍처, 그것이 뭣이 중헌디?</a>글에 마이크로서비스에 대한 내용들이 잘 설명돼 있다. 아무래도 자원들이 각각의 서버에 분리해있다보니 인증이나, 인가를 하나로 적절히 관리하는것이 필요하다. 만약 모놀리틱 아키텍처로 이러한 자원들을 관리하게된다면 상당히 비효율적일 것이다. 각각의 자원 서버마다 필요한 자원의 서비스를 호출하려고하면 인증,인가처리를 해야하기 떄문에 매우 비효율적으로 될것이다. 하지만 OAuth방식을 이용한다면 인증서버를 두고 각각의 자원서비스들의 인증, 인가를 관리한다면 효율적으로 자원 서비스들을 관리할 수 있다.</p>\n<h3><span id=\"spring으로-oauth2구현\">Spring으로 OAuth2구현</span></h3>\n<p>뭔가 서론이 장황해진 것 같다. 결론을 말씀드리자면 이러한 장점들을 이용하기 위해 OAuth인증 시스템을 구현해 볼 것이다. 구현 방법은 Spring을 이용해서 Spring security의 하위 프로젝트 Spring OAuth를 구현할 것이다. 여기에서 구현하고자하는 방식은 OAuth2방식이고 인증 방식은 Password 방식을 구현할 것이다. OAuth2부터는 다양한 인증 방식을 제공하는데 여기에대한 차이점은 <a href=\"https://minwan1.github.io/2018/02/24/2018-02-24-OAuth/\">OAuth란?</a>글에서 확인할 수 있다.</p>\n<h4><span id=\"oauth2-역할\">OAuth2 역할</span></h4>\n<p>먼저 구현전에 OAuth2에 역할에대해 알아보자. OAuth2는 크게 Resource Owner, Authorization Server, Resource Server, Client 4개의 역할로 나누어진다. 먼저 Resource Owner는 유저를 말한다. 이유저는 위에서말한 카카오톡,네이버,구글등에 로그인 할 수 있고 그 해당 애플리케이션의 기능을 이용 가능한 유저를 말한다. Authorization Server는 인증 서버를 말한다. 유저가 OAuth를 통해 로그인한다면 카카오톡,네이버,구글의 유저가 맞는지 확인해주는 서버를 말한다. Resource Server는 카카오톡,네이버,구글의 자원(API)이 있는 서버를 말한다. Client는 써드파티앱들을 말한다. Authorization Server, Resource Server를 이용하는 앱들은 모두 Clinet라고 생각하면 된다.</p>\n<h4><span id=\"resource-owner-password-credentials-grant-동작방식\">Resource Owner Password Credentials Grant 동작방식</span></h4>\n<p>먼저 구현하려고하는 password 인증 방식이 무엇인지 간단하게 살펴보자. 이방식을 사용하기 위해서는 AuthorizationServer에 Client-id와 secret을 등록해야한다. 그리고 Client가 Resource Owner로부터 아이디/패스워드를 받아 직접 access token을 받아오는 방식이다. 이때 클라이언트는 AccessToken을 얻기 위해 AuthorizationServer에 호출할때 이 Client-id와 secret을 Basic-auth를 해줘야 한다. 하지만 이방식은 Client가 신용이 없을 때에는 사용하기에 위험하다는 단점이 있다. 클라이언트가 확실한 신용이 보장될 때 사용할 수 있는 방식이다.<br>\n<img src=\"https://i.imgur.com/7LhjI1L.png\" alt=\"\"><br>\n동작 순서는 대략 이렇다.</p>\n<ol>\n<li>AuthorizationServer에 Client-id와 Secret을 등록한다(그림에는 안나와있음)</li>\n<li>User가 Id와 Password를 입력한다</li>\n<li>클라이언트는 유저의 id와 password와 클라이언트 정보를 넘긴다.</li>\n<li>Authorization sever는 Access token을 넘긴다.</li>\n<li>Client는 token로 자원서버에 접근할 수 있게 된다.</li>\n</ol>\n<p>그럼 이제 실제 구현을 해볼것이다.</p>\n<h4><span id=\"oauth2-in-memory-방식으로-간단한-구현\">OAuth2 in-memory 방식으로 간단한 구현</span></h4>\n<p>OAuth는 인증서버와 자원 서버를 하나의 애플리케이션에서 구현할 수도 있고, 분리할 수도 있다. 여기에서는 두 개를 하나의 애플리케이션에서 구현할 것이다. Resource Owner, Client 관리는 in-memory를 이용할 것이다. 아래와 같이 application.yml에 Resource Owner를 지정하고, Client를 쉽게 등록할 수 있다.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">security:</span><br><span class=\"line\">  user:</span><br><span class=\"line\">    name: user</span><br><span class=\"line\">    password: test</span><br><span class=\"line\">  oauth2:</span><br><span class=\"line\">    client:</span><br><span class=\"line\">      client-id: foo</span><br><span class=\"line\">      client-secret: bar</span><br></pre></td></tr></table></figure>\n<p>그다음은 Resource Server, Authorization Server의 설정을 구현할 것이다. @EnableResourceServer, @EnableAuthorizationServer 두개의 어노테이션으로 쉽게 인증서버와 자원서버를 구성할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableResourceServer</span>  <span class=\"comment\">// API 서버 인증(또는 권한 설정)</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAuthorizationServer</span> <span class=\"comment\">// 자원서버 설정</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResourceServerConfigurerAdapterImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(HttpSecurity http)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        http.authorizeRequests()</span><br><span class=\"line\">                .antMatchers(<span class=\"string\">\"/users\"</span>).access(<span class=\"string\">\"#oauth2.hasScope('read')\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위와 같이 지정을 하게 되면 /users라는 자원에 접근하기 위해서는 access_token이 있어야 접근을 할 수 있다. 자원에 대한 CRUD는 Rest Repositories(도메인만으로 REST API를 자동으로 만들어준다.)를 이용할 것이다.  도메인 구성등에 대한 정보는 <a href=\"https://github.com/minwan1/spring-security-oauth2-example/blob/example-1/src/main/java/com/example/oauth/user/User.java\" target=\"_blank\" rel=\"noopener\">소스</a>을 참조 할 수 있다. 사실 너무 간단해서 도메인이라고 할것도 없다. 이제 실제로 /users를 접근을 할 수 없는지 테스트를 해보자. 테스트는 아래와 같이 junit을 사용할 것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">when_callApi_expect_unauthorized</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    mockMvc.perform(get(<span class=\"string\">\"/users\"</span>)).andExpect(status().isOk());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>테스트 결과는…<br>\n<img src=\"https://i.imgur.com/90IClaN.png\" alt=\"\"><br>\n그렇다. response 결과는 401이 넘어와 실패했다. access_token없이 접근해서 그렇다. 당연한 결과이다. 위 소스는 isOk에서 isUnauthorized로 수정해주면될 것 같다. 그러면 테스트 결과는 성공일 것이다. 그다음은 토큰을 생성한후 API를 호출해 성공하는 테스트를 작성할 것 이다. 먼저 rest로 토큰을 얻어보자. 이 /oauth/token는 Spring OAuth에서 지정해준 URI이다. 이 URI는 Basic Auth를 사용하여 ClientID와 Secret을 포함하고 바디값으로 grant_type, client_id, username, password, scope를 넘기면 토큰 값을 얻을 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">obtainAccessToken</span><span class=\"params\">(String username, String password)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    MultiValueMap&lt;String, String&gt; params = <span class=\"keyword\">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class=\"line\">    params.add(<span class=\"string\">\"grant_type\"</span>, <span class=\"string\">\"password\"</span>);</span><br><span class=\"line\">    params.add(<span class=\"string\">\"client_id\"</span>, CLIENT_ID); <span class=\"comment\">//foo</span></span><br><span class=\"line\">    params.add(<span class=\"string\">\"username\"</span>, username);</span><br><span class=\"line\">    params.add(<span class=\"string\">\"password\"</span>, password);</span><br><span class=\"line\">    params.add(<span class=\"string\">\"scope\"</span>, SCOPE); <span class=\"comment\">//read</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ResultActions result</span><br><span class=\"line\">            = mockMvc.perform(post(<span class=\"string\">\"/oauth/token\"</span>)</span><br><span class=\"line\">            .params(params)</span><br><span class=\"line\">            .with(httpBasic(CLIENT_ID, CLIENT_SECRET)) <span class=\"comment\">//foo, bar</span></span><br><span class=\"line\">            .accept(CONTENT_TYPE)) <span class=\"comment\">//\"application/json;charset=UTF-8\"</span></span><br><span class=\"line\">            .andExpect(status().isOk())</span><br><span class=\"line\">            .andExpect(content().contentType(CONTENT_TYPE));<span class=\"comment\">//\"application/json;charset=UTF-8\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    String resultString = result.andReturn().getResponse().getContentAsString();</span><br><span class=\"line\"></span><br><span class=\"line\">    JacksonJsonParser jsonParser = <span class=\"keyword\">new</span> JacksonJsonParser();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> jsonParser.parseMap(resultString).get(<span class=\"string\">\"access_token\"</span>).toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위와같이 넘기면 access_token값을 얻을 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">when_callUsers_expect_success</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    String accessToken =obtainAccessToken(SECURITY_USERNAME,SECURITY_PASSWORD);</span><br><span class=\"line\">    mockMvc.perform(get(<span class=\"string\">\"/users\"</span>)</span><br><span class=\"line\">            .header(<span class=\"string\">\"Authorization\"</span>, <span class=\"string\">\"Bearer \"</span> + accessToken)</span><br><span class=\"line\">            .accept(CONTENT_TYPE))<span class=\"comment\">//\"application/json;charset=UTF-8\"</span></span><br><span class=\"line\">            .andExpect(status().isOk())</span><br><span class=\"line\">            .andExpect(content().contentType(CONTENT_TYPE));<span class=\"comment\">//\"application/json;charset=UTF-8\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그다음 생성한 토큰을 이용해서 header 값에 access_token을 넣은 후 호출하면 호출에 성공한 모습을 확인할 수 있다. 이것의 전체적인 구현인 토큰 관리, client, user 등록등 In-memory기반에 의하여 구현되었다. 그렇기 때문에 서버가 종료되면 기존에 발급되었던 토큰들이 모두 소멸된다. Product로 사용하기 위해서는 JdbcTokenStore빈을 통해서 토큰 관리, client, user 등록등을 영속화하여 사용해야 한다. in-memory 방식으로 구현한 OAuth소스는 <a href=\"https://github.com/minwan1/spring-security-oauth2-example/tree/example-1\" target=\"_blank\" rel=\"noopener\">in-memory 방식을 사용한 OAuth2 구현</a>에서 확인할 수 있다.</p>\n<h4><span id=\"oauth2-jdbctokenstore등을-이용한-데이터-영속화\">OAuth2 JdbcTokenStore등을 이용한 데이터 영속화</span></h4>\n<p>이제 Authorization Server, Resource Server을 커스터마이징하여 데이터들의 관리를 영속화할 것이다. 가장먼저 해야할것은 Spring Security Oauth에 맞는 디비에 대한 <a href=\"https://github.com/spring-projects/spring-security-oauth/blob/master/spring-security-oauth2/src/test/resources/schema.sql\" target=\"_blank\" rel=\"noopener\">스키마 </a>를 만드는것이다. 그 후 TokenStore의 빈을 등록하는것이다. TokenStore 빈을 등록을하게 되면 Token관리, Client관리등을 디비로 할 수 있게된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> TokenStore <span class=\"title\">JdbcTokenStore</span><span class=\"params\">(@Qualifier(<span class=\"string\">\"dataSource\"</span>)</span> DataSource dataSource) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JdbcTokenStore(dataSource);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그 다음 Authorization Server, Resource Server를 두개의 클래스로 분리할 것이다. ResourceServerConfigurerAdapter, AuthorizationServerConfigurerAdapter를 상속해서 세부내용을 구현해야 한다. 그래야 좀 더 세부적으로 Authorization Server, Resource Server 컨트롤 가능하다. 아래는 각각의 구현체 구조이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableResourceServer</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResourceServerConfiguration</span> <span class=\"keyword\">extends</span> <span class=\"title\">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(ResourceServerSecurityConfigurer resources)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(HttpSecurity http)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 자원서버 접근권한 설정</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAuthorizationServer</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(AuthorizationServerSecurityConfigurer security)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// OAuth2 인증서버 자체의  보안 정보를 설정하는 부분</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(ClientDetailsServiceConfigurer clients)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// Client 에 대한 정보를  설정하는 부분</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// OAuth2 서버가 작동하기 위한 Endpoint에 대한 정보를 설정</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Authorization Server, Resource Server를 분리하게 되면 yml에 등록한 클라이언트는 의미가없어진다. 이유는 AuthorizationServerConfigurerAdapter 클래스를 상속함으로써 오버라이딩이되어 authorizationServer에 대한 정의를 여기에 할것이기 때문이다. 그리고 만약 세부구현체를 구현을안하고 accessToken을 생성하려고하면 clientDetailsService를 정의하라는 에러를 만날것이다. 먼저 테스트를 위해 인메모리 등록을 할 것이다. 만약 inMemory가 아닌 외부 db를 사용하고싶으면 아래의 소스 부분에 inMemory부분을 jdbc 방식으로 바꾸면 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableResourceServer</span>  <span class=\"comment\">// API 서버 인증, 권한 설정</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthorizationServiceConfigurerAdapterImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">AuthorizationServerConfigurerAdapter</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(ClientDetailsServiceConfigurer clients)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        clients.inMemory() <span class=\"comment\">// 이부분을 jdbc를 쓰면 데이터베이스값을 이용할 수 있다.</span></span><br><span class=\"line\">                .withClient(<span class=\"string\">\"foo\"</span>)</span><br><span class=\"line\">                .secret(<span class=\"string\">\"bar\"</span>)</span><br><span class=\"line\">                .authorizedGrantTypes(</span><br><span class=\"line\">                        <span class=\"string\">\"password\"</span>,<span class=\"string\">\"authorization_code\"</span>, <span class=\"string\">\"refresh_token\"</span>)</span><br><span class=\"line\">                .scopes(<span class=\"string\">\"read\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그런데 이렇게 클라이언트 정보를 정의하고 accessToken을 생성하려고 하면 &quot;Unsupported grant type: password&quot;라는 메시지를 만난다. 이 메시지를 해결하기 위해서는 AuthorizationServer에 AuthenticationManager를 제공해야한다. 그래서 아래와같이 소스를 추가해줘야한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthorizationServiceConfigurerAdapterImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">AuthorizationServerConfigurerAdapter</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AuthenticationManager authenticationManager;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TokenStore JdbcTokenStore;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(ClientDetailsServiceConfigurer clients)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        clients.inMemory()</span><br><span class=\"line\">                .withClient(<span class=\"string\">\"foo\"</span>)</span><br><span class=\"line\">                .secret(<span class=\"string\">\"bar\"</span>)</span><br><span class=\"line\">                .authorizedGrantTypes(</span><br><span class=\"line\">                        <span class=\"string\">\"password\"</span>,<span class=\"string\">\"authorization_code\"</span>, <span class=\"string\">\"refresh_token\"</span>)</span><br><span class=\"line\">                .scopes(<span class=\"string\">\"read\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            AuthorizationServerEndpointsConfigurer endpoints)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        endpoints</span><br><span class=\"line\">                .tokenStore(JdbcTokenStore)</span><br><span class=\"line\">                .authenticationManager(authenticationManager);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위와 같이 추가되면 이제 토큰은 inMemory가 아닌 DB에 저장이 된다. 그리고 &quot;Unsupported grant type: password&quot;에대한 에러도 사라지고 AccessToken이 생성 될것이다. 만약 클라이언트 관리도 디비에서 하려면 아래와 같이 변경해주면 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(ClientDetailsServiceConfigurer clients)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        clients.jdbc(dataSource);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>그다음 oauth_client_details 테이블의 아래와같이 클라이언트 정보를 추가해줘야 한다.</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> PUBLIC.OAUTH_CLIENT_DETAILS (CLIENT_ID, RESOURCE_IDS, CLIENT_SECRET, <span class=\"keyword\">SCOPE</span>, AUTHORIZED_GRANT_TYPES, WEB_SERVER_REDIRECT_URI, AUTHORITIES, ACCESS_TOKEN_VALIDITY, REFRESH_TOKEN_VALIDITY, ADDITIONAL_INFORMATION, AUTOAPPROVE) <span class=\"keyword\">VALUES</span> (<span class=\"string\">'foo'</span>, <span class=\"string\">''</span>, <span class=\"string\">'bar'</span>, <span class=\"string\">'read'</span>, <span class=\"string\">'password,authorization_code,refresh_token'</span>, <span class=\"string\">''</span>, <span class=\"string\">''</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"string\">'&#123;&#125;'</span>, <span class=\"string\">''</span>);</span><br></pre></td></tr></table></figure>\n<p>그리고 위와 같이 Client에 관한 데이터를 Insert해주면 된다. 그렇게 되면 DB에서 클라이언 정보를 관리할 수 있게 된다.</p>\n<h4><span id=\"authorization-server-resource-server-애플리케이션-분리\">Authorization Server, Resource Server 애플리케이션 분리</span></h4>\n<p>지금은 하나의 어플리케이션에 Authorization Server, Resource Server를 구현했다. 만약 다른 어플리케이션에 다른 데이터베이스를 바라보고 Authorization Server, Resource Server를 구성했다면 HTTP 통신을 통해 토큰을 확인해야한다. 그럴려면 먼저 인증서버에서 accessToken이 유효한지 확인할 수 있는 URL이 있어야 한다. 하지만 이것은 스프링에서 아래와 같이 설정해준다면 기본적으로 기능을 제공해준다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  AuthorizationServerSecurityConfigurer oauthServer)</span></span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    oauthServer</span><br><span class=\"line\">      .tokenKeyAccess(<span class=\"string\">\"permitAll()\"</span>)</span><br><span class=\"line\">      .checkTokenAccess(<span class=\"string\">\"isAuthenticated()\"</span>);</span><br><span class=\"line\">      <span class=\"comment\">// Token 정보를 API(/oauth/check_token)를 활성화 시킨다. ( 기본은 denyAll )</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그리고 자원 서버에서도 다른 클라이언트가 접근한다면 token이 유효한지 인증서버를 통해 체크를 해줘야 한다. 이 설정 또한 쉽게 아래와 같이 URL만 등록해주면 된다. 아래는 YML, 빈을 통해 등록하는 방식을 나열했다.<br>\n<strong>YML등록방법</strong><br>\n// OAuth2 서버에서 기본적으로 Token정보를 받아오는 URL</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">security.resource.token-info-uri:url주소/oauth/check_token</span><br></pre></td></tr></table></figure>\n<p><strong>빈등록방법</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Primary</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RemoteTokenServices <span class=\"title\">tokenService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    RemoteTokenServices tokenService = <span class=\"keyword\">new</span> RemoteTokenServices();</span><br><span class=\"line\">    tokenService.setCheckTokenEndpointUrl(</span><br><span class=\"line\">      <span class=\"string\">\"http://localhost:8080/spring-security-oauth-server/oauth/check_token\"</span>);</span><br><span class=\"line\">    tokenService.setClientId(<span class=\"string\">\"foo\"</span>);</span><br><span class=\"line\">    tokenService.setClientSecret(<span class=\"string\">\"bar\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tokenService;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위와 같이 등록하면 자원서버는 등록된 URL로 accessToken이 유효한지 체크를 할것이다.</p>\n<h3><span id=\"마무리-하며\">마무리 하며…</span></h3>\n<p>스프링을 통해 OAuth2를 간단하게 구현해봤다. 첫 부분에는 토큰 관리, 클라이언트 등록 등 In-Memory를 통해 간단하게 OAuth2 구현했고, 중간 부분부터는 인증서버와 자원 서버의 클래스를 분리했다. 또한 토큰 관리, 클라이언트 등록 등을 InMemmory로 관리했었는데 이러한 것을 외부 DB 등록을 통해 관리하게 해봤다. OAuth2 인증 방식은 password 인증 방식만 구현해봤는데, 다른 인증 방식을 넣는 것은 어렵지 않다. 인증서버와 자원 서버만 설정되어 있다면 금방 도입할 수 있다. 물론 Product 용으로 개발하는 데까지는 많은 시간이 걸릴 것이다. 요즘 점점 시간이 지나면서 쿠키를 통한 session 방식의 로그인은 없어지고 있는 것 같다. 점점 모바일 환경 등 멀티 디바이스를 지원해야 하므로 웹 하나만을 위한 서버를 만드는 일은 비효율적이기 때문일 것이다. 그래서 많은 서버들이 Token 방식의 로그인 방식으로 옮기고 있는 것 같다. 그중에서도 OAuth2는 많은 인증 방식 등과 인증의 간편함을 가져 인기가 좋은것같다.</p>\n<p>이 예제와 관련한 소스는 <a href=\"https://github.com/minwan1/spring-security-oauth2-example/tree/example-2\" target=\"_blank\" rel=\"noopener\">JDBC 방식을 사용한 OAuth2 구현</a>에서 확인할 수 있습니다</p>\n<p>참고</p>\n<ul>\n<li><a href=\"http://projects.spring.io/spring-security-oauth/docs/oauth2.html\" target=\"_blank\" rel=\"noopener\">OAuth 2 Developers Guide</a></li>\n<li><a href=\"http://www.baeldung.com/oauth-api-testing-with-spring-mvc\" target=\"_blank\" rel=\"noopener\">baeldung</a></li>\n<li><a href=\"http://jojoldu.tistory.com/234\" target=\"_blank\" rel=\"noopener\">기억보단 기록을</a></li>\n<li><a href=\"https://brunch.co.kr/@sbcoba/4\" target=\"_blank\" rel=\"noopener\">이수홍</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>Spring Security OAuth2구현</h2>\n<h3>OAuth란?</h3>\n<p>OAuth는 Open Authorization, Open Authentication 뜻하는 것으로 자신의 애플리케이션 서버의 데이터로 다른 Third party에게 자원을 공유하거나 대신 유저 인증을 처리해줄 수 있는 오픈 표준 프로토콜이다.</p>\n<h3>OAuth 실 사용 예</h3>\n<p>간단히 OAuth인증에 대해 실 사용 예를 보자면 웹, 앱들을 사용하면서 네이버 로그인, 카카오 로그인, 페이스북 로그인 등을 한 번쯤은 보았을 것이다. 이것이 바로 OAuth인 증 방식 중 하나이다. 네이버 로그인, 카카오 로그인, 페이스북 로그인 등으로 로그인을 하게 되면 그 애플리케이션들로부터 Access_token이라는 값을 받아 써드파티 애플리케이션에게 준다. Access_token이라는 값이 어떻게 보면 유저의 인증 키라고 보면 된다. 물론 유저가 로그인을 실패한다면 Access_token을 받지 못할 것이다. Access_token 을 받았다는 것은 해당 유저가 인증이 되었다는 것을 의미한다. 이러한 기술을 통해서 써드파티 애플리케이션에게 유저를 인증 시킨다. 이것이 OAuth인증이다. 물론 OAuth가 Authentication(인증) 기능만 하는 것은 아니다.</p>\n<p>OAuth는 Authorization(인가)에 대한 기능도 있다. Authorization라는 기능(?)을 이용하면 써드파티 앱들은 유저가 선택한 로그인 방식에 애플리케이션의 유저 정보 등을 얻을 수 있다. 이정보를 바탕으로 써드파티 앱들은 유저를 자신의 앱에 가입시킨다. 뿐만 아니라 서드파티 앱들은 유저가 로그인한 애플리케이션의 기능 등을 사용할 수 있다. 이것을 잘 사용하는 로켓펀치라는 구직 사이트가 있다. 이 사이트에 페이스북으로 로그인하기 기능 이용하여 로그인과 함께 친구 정보 제공을 동의하고 my account를 들어가면 내 친구들의 로켓펀치의 등록된 구직 정보들을 볼 수 있다. 이것이 가능한 이유는 아까 받은 Access_token으로 페이스북에게 유저의 정보를 요청할 수 있기 때문이다. 이러한 조회 기능뿐만 아니라 유저의 동의만 얻는다면 페이스북 담벼락에 글 남기기 등의 기능들도 사용할 수 있다. 이런 것들 가능하게 해주는 것이 OAuth 인증이다. OAuth도 버전이 있고, 그 차이점이 있는데 미흡하지만 <a href=\"https://minwan1.github.io/2018/02/24/2018-02-24-OAuth/\">OAuth란?</a>을 참조하면 될 것 같다.</p>\n<p>위와 같은 방법뿐만 아니라 Microservices에 인증 방식으로도 사용된다. 마이크로서비스란 하나의 큰 애플리케이션을 여러개의 작은 애플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처를 말한다. 이 <a href=\"http://guruble.com/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4microservice-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B7%B8%EA%B2%83%EC%9D%B4-%EB%AD%A3%EC%9D%B4-%EC%A4%91%ED%97%8C%EB%94%94/\" target=\"_blank\" rel=\"noopener\">마이크로서비스 아키텍처, 그것이 뭣이 중헌디?</a>글에 마이크로서비스에 대한 내용들이 잘 설명돼 있다. 아무래도 자원들이 각각의 서버에 분리해있다보니 인증이나, 인가를 하나로 적절히 관리하는것이 필요하다. 만약 모놀리틱 아키텍처로 이러한 자원들을 관리하게된다면 상당히 비효율적일 것이다. 각각의 자원 서버마다 필요한 자원의 서비스를 호출하려고하면 인증,인가처리를 해야하기 떄문에 매우 비효율적으로 될것이다. 하지만 OAuth방식을 이용한다면 인증서버를 두고 각각의 자원서비스들의 인증, 인가를 관리한다면 효율적으로 자원 서비스들을 관리할 수 있다.</p>\n<h3>Spring으로 OAuth2구현</h3>\n<p>뭔가 서론이 장황해진 것 같다. 결론을 말씀드리자면 이러한 장점들을 이용하기 위해 OAuth인증 시스템을 구현해 볼 것이다. 구현 방법은 Spring을 이용해서 Spring security의 하위 프로젝트 Spring OAuth를 구현할 것이다. 여기에서 구현하고자하는 방식은 OAuth2방식이고 인증 방식은 Password 방식을 구현할 것이다. OAuth2부터는 다양한 인증 방식을 제공하는데 여기에대한 차이점은 <a href=\"https://minwan1.github.io/2018/02/24/2018-02-24-OAuth/\">OAuth란?</a>글에서 확인할 수 있다.</p>\n<h4>OAuth2 역할</h4>\n<p>먼저 구현전에 OAuth2에 역할에대해 알아보자. OAuth2는 크게 Resource Owner, Authorization Server, Resource Server, Client 4개의 역할로 나누어진다. 먼저 Resource Owner는 유저를 말한다. 이유저는 위에서말한 카카오톡,네이버,구글등에 로그인 할 수 있고 그 해당 애플리케이션의 기능을 이용 가능한 유저를 말한다. Authorization Server는 인증 서버를 말한다. 유저가 OAuth를 통해 로그인한다면 카카오톡,네이버,구글의 유저가 맞는지 확인해주는 서버를 말한다. Resource Server는 카카오톡,네이버,구글의 자원(API)이 있는 서버를 말한다. Client는 써드파티앱들을 말한다. Authorization Server, Resource Server를 이용하는 앱들은 모두 Clinet라고 생각하면 된다.</p>\n<h4>Resource Owner Password Credentials Grant 동작방식</h4>\n<p>먼저 구현하려고하는 password 인증 방식이 무엇인지 간단하게 살펴보자. 이방식을 사용하기 위해서는 AuthorizationServer에 Client-id와 secret을 등록해야한다. 그리고 Client가 Resource Owner로부터 아이디/패스워드를 받아 직접 access token을 받아오는 방식이다. 이때 클라이언트는 AccessToken을 얻기 위해 AuthorizationServer에 호출할때 이 Client-id와 secret을 Basic-auth를 해줘야 한다. 하지만 이방식은 Client가 신용이 없을 때에는 사용하기에 위험하다는 단점이 있다. 클라이언트가 확실한 신용이 보장될 때 사용할 수 있는 방식이다.<br>\n<img src=\"https://i.imgur.com/7LhjI1L.png\" alt=\"\"><br>\n동작 순서는 대략 이렇다.</p>\n<ol>\n<li>AuthorizationServer에 Client-id와 Secret을 등록한다(그림에는 안나와있음)</li>\n<li>User가 Id와 Password를 입력한다</li>\n<li>클라이언트는 유저의 id와 password와 클라이언트 정보를 넘긴다.</li>\n<li>Authorization sever는 Access token을 넘긴다.</li>\n<li>Client는 token로 자원서버에 접근할 수 있게 된다.</li>\n</ol>\n<p>그럼 이제 실제 구현을 해볼것이다.</p>\n<h4>OAuth2 in-memory 방식으로 간단한 구현</h4>\n<p>OAuth는 인증서버와 자원 서버를 하나의 애플리케이션에서 구현할 수도 있고, 분리할 수도 있다. 여기에서는 두 개를 하나의 애플리케이션에서 구현할 것이다. Resource Owner, Client 관리는 in-memory를 이용할 것이다. 아래와 같이 application.yml에 Resource Owner를 지정하고, Client를 쉽게 등록할 수 있다.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">security:</span><br><span class=\"line\">  user:</span><br><span class=\"line\">    name: user</span><br><span class=\"line\">    password: test</span><br><span class=\"line\">  oauth2:</span><br><span class=\"line\">    client:</span><br><span class=\"line\">      client-id: foo</span><br><span class=\"line\">      client-secret: bar</span><br></pre></td></tr></table></figure>\n<p>그다음은 Resource Server, Authorization Server의 설정을 구현할 것이다. @EnableResourceServer, @EnableAuthorizationServer 두개의 어노테이션으로 쉽게 인증서버와 자원서버를 구성할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableResourceServer</span>  <span class=\"comment\">// API 서버 인증(또는 권한 설정)</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAuthorizationServer</span> <span class=\"comment\">// 자원서버 설정</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResourceServerConfigurerAdapterImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(HttpSecurity http)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        http.authorizeRequests()</span><br><span class=\"line\">                .antMatchers(<span class=\"string\">\"/users\"</span>).access(<span class=\"string\">\"#oauth2.hasScope('read')\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위와 같이 지정을 하게 되면 /users라는 자원에 접근하기 위해서는 access_token이 있어야 접근을 할 수 있다. 자원에 대한 CRUD는 Rest Repositories(도메인만으로 REST API를 자동으로 만들어준다.)를 이용할 것이다.  도메인 구성등에 대한 정보는 <a href=\"https://github.com/minwan1/spring-security-oauth2-example/blob/example-1/src/main/java/com/example/oauth/user/User.java\" target=\"_blank\" rel=\"noopener\">소스</a>을 참조 할 수 있다. 사실 너무 간단해서 도메인이라고 할것도 없다. 이제 실제로 /users를 접근을 할 수 없는지 테스트를 해보자. 테스트는 아래와 같이 junit을 사용할 것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">when_callApi_expect_unauthorized</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    mockMvc.perform(get(<span class=\"string\">\"/users\"</span>)).andExpect(status().isOk());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>테스트 결과는…<br>\n<img src=\"https://i.imgur.com/90IClaN.png\" alt=\"\"><br>\n그렇다. response 결과는 401이 넘어와 실패했다. access_token없이 접근해서 그렇다. 당연한 결과이다. 위 소스는 isOk에서 isUnauthorized로 수정해주면될 것 같다. 그러면 테스트 결과는 성공일 것이다. 그다음은 토큰을 생성한후 API를 호출해 성공하는 테스트를 작성할 것 이다. 먼저 rest로 토큰을 얻어보자. 이 /oauth/token는 Spring OAuth에서 지정해준 URI이다. 이 URI는 Basic Auth를 사용하여 ClientID와 Secret을 포함하고 바디값으로 grant_type, client_id, username, password, scope를 넘기면 토큰 값을 얻을 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">obtainAccessToken</span><span class=\"params\">(String username, String password)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    MultiValueMap&lt;String, String&gt; params = <span class=\"keyword\">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class=\"line\">    params.add(<span class=\"string\">\"grant_type\"</span>, <span class=\"string\">\"password\"</span>);</span><br><span class=\"line\">    params.add(<span class=\"string\">\"client_id\"</span>, CLIENT_ID); <span class=\"comment\">//foo</span></span><br><span class=\"line\">    params.add(<span class=\"string\">\"username\"</span>, username);</span><br><span class=\"line\">    params.add(<span class=\"string\">\"password\"</span>, password);</span><br><span class=\"line\">    params.add(<span class=\"string\">\"scope\"</span>, SCOPE); <span class=\"comment\">//read</span></span><br><span class=\"line\"></span><br><span class=\"line\">    ResultActions result</span><br><span class=\"line\">            = mockMvc.perform(post(<span class=\"string\">\"/oauth/token\"</span>)</span><br><span class=\"line\">            .params(params)</span><br><span class=\"line\">            .with(httpBasic(CLIENT_ID, CLIENT_SECRET)) <span class=\"comment\">//foo, bar</span></span><br><span class=\"line\">            .accept(CONTENT_TYPE)) <span class=\"comment\">//\"application/json;charset=UTF-8\"</span></span><br><span class=\"line\">            .andExpect(status().isOk())</span><br><span class=\"line\">            .andExpect(content().contentType(CONTENT_TYPE));<span class=\"comment\">//\"application/json;charset=UTF-8\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    String resultString = result.andReturn().getResponse().getContentAsString();</span><br><span class=\"line\"></span><br><span class=\"line\">    JacksonJsonParser jsonParser = <span class=\"keyword\">new</span> JacksonJsonParser();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> jsonParser.parseMap(resultString).get(<span class=\"string\">\"access_token\"</span>).toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위와같이 넘기면 access_token값을 얻을 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">when_callUsers_expect_success</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    String accessToken =obtainAccessToken(SECURITY_USERNAME,SECURITY_PASSWORD);</span><br><span class=\"line\">    mockMvc.perform(get(<span class=\"string\">\"/users\"</span>)</span><br><span class=\"line\">            .header(<span class=\"string\">\"Authorization\"</span>, <span class=\"string\">\"Bearer \"</span> + accessToken)</span><br><span class=\"line\">            .accept(CONTENT_TYPE))<span class=\"comment\">//\"application/json;charset=UTF-8\"</span></span><br><span class=\"line\">            .andExpect(status().isOk())</span><br><span class=\"line\">            .andExpect(content().contentType(CONTENT_TYPE));<span class=\"comment\">//\"application/json;charset=UTF-8\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그다음 생성한 토큰을 이용해서 header 값에 access_token을 넣은 후 호출하면 호출에 성공한 모습을 확인할 수 있다. 이것의 전체적인 구현인 토큰 관리, client, user 등록등 In-memory기반에 의하여 구현되었다. 그렇기 때문에 서버가 종료되면 기존에 발급되었던 토큰들이 모두 소멸된다. Product로 사용하기 위해서는 JdbcTokenStore빈을 통해서 토큰 관리, client, user 등록등을 영속화하여 사용해야 한다. in-memory 방식으로 구현한 OAuth소스는 <a href=\"https://github.com/minwan1/spring-security-oauth2-example/tree/example-1\" target=\"_blank\" rel=\"noopener\">in-memory 방식을 사용한 OAuth2 구현</a>에서 확인할 수 있다.</p>\n<h4>OAuth2 JdbcTokenStore등을 이용한 데이터 영속화</h4>\n<p>이제 Authorization Server, Resource Server을 커스터마이징하여 데이터들의 관리를 영속화할 것이다. 가장먼저 해야할것은 Spring Security Oauth에 맞는 디비에 대한 <a href=\"https://github.com/spring-projects/spring-security-oauth/blob/master/spring-security-oauth2/src/test/resources/schema.sql\" target=\"_blank\" rel=\"noopener\">스키마 </a>를 만드는것이다. 그 후 TokenStore의 빈을 등록하는것이다. TokenStore 빈을 등록을하게 되면 Token관리, Client관리등을 디비로 할 수 있게된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> TokenStore <span class=\"title\">JdbcTokenStore</span><span class=\"params\">(@Qualifier(<span class=\"string\">\"dataSource\"</span>)</span> DataSource dataSource) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JdbcTokenStore(dataSource);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그 다음 Authorization Server, Resource Server를 두개의 클래스로 분리할 것이다. ResourceServerConfigurerAdapter, AuthorizationServerConfigurerAdapter를 상속해서 세부내용을 구현해야 한다. 그래야 좀 더 세부적으로 Authorization Server, Resource Server 컨트롤 가능하다. 아래는 각각의 구현체 구조이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableResourceServer</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ResourceServerConfiguration</span> <span class=\"keyword\">extends</span> <span class=\"title\">ResourceServerConfigurerAdapter</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(ResourceServerSecurityConfigurer resources)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"meta\">@Override</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(HttpSecurity http)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">// 자원서버 접근권한 설정</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@EnableAuthorizationServer</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoApplication</span> <span class=\"keyword\">extends</span> <span class=\"title\">AuthorizationServerConfigurerAdapter</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(AuthorizationServerSecurityConfigurer security)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// OAuth2 인증서버 자체의  보안 정보를 설정하는 부분</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(ClientDetailsServiceConfigurer clients)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// Client 에 대한 정보를  설정하는 부분</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"meta\">@Override</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// OAuth2 서버가 작동하기 위한 Endpoint에 대한 정보를 설정</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Authorization Server, Resource Server를 분리하게 되면 yml에 등록한 클라이언트는 의미가없어진다. 이유는 AuthorizationServerConfigurerAdapter 클래스를 상속함으로써 오버라이딩이되어 authorizationServer에 대한 정의를 여기에 할것이기 때문이다. 그리고 만약 세부구현체를 구현을안하고 accessToken을 생성하려고하면 clientDetailsService를 정의하라는 에러를 만날것이다. 먼저 테스트를 위해 인메모리 등록을 할 것이다. 만약 inMemory가 아닌 외부 db를 사용하고싶으면 아래의 소스 부분에 inMemory부분을 jdbc 방식으로 바꾸면 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@EnableResourceServer</span>  <span class=\"comment\">// API 서버 인증, 권한 설정</span></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthorizationServiceConfigurerAdapterImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">AuthorizationServerConfigurerAdapter</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(ClientDetailsServiceConfigurer clients)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        clients.inMemory() <span class=\"comment\">// 이부분을 jdbc를 쓰면 데이터베이스값을 이용할 수 있다.</span></span><br><span class=\"line\">                .withClient(<span class=\"string\">\"foo\"</span>)</span><br><span class=\"line\">                .secret(<span class=\"string\">\"bar\"</span>)</span><br><span class=\"line\">                .authorizedGrantTypes(</span><br><span class=\"line\">                        <span class=\"string\">\"password\"</span>,<span class=\"string\">\"authorization_code\"</span>, <span class=\"string\">\"refresh_token\"</span>)</span><br><span class=\"line\">                .scopes(<span class=\"string\">\"read\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그런데 이렇게 클라이언트 정보를 정의하고 accessToken을 생성하려고 하면 &quot;Unsupported grant type: password&quot;라는 메시지를 만난다. 이 메시지를 해결하기 위해서는 AuthorizationServer에 AuthenticationManager를 제공해야한다. 그래서 아래와같이 소스를 추가해줘야한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthorizationServiceConfigurerAdapterImpl</span> <span class=\"keyword\">extends</span> <span class=\"title\">AuthorizationServerConfigurerAdapter</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AuthenticationManager authenticationManager;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TokenStore JdbcTokenStore;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(ClientDetailsServiceConfigurer clients)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        clients.inMemory()</span><br><span class=\"line\">                .withClient(<span class=\"string\">\"foo\"</span>)</span><br><span class=\"line\">                .secret(<span class=\"string\">\"bar\"</span>)</span><br><span class=\"line\">                .authorizedGrantTypes(</span><br><span class=\"line\">                        <span class=\"string\">\"password\"</span>,<span class=\"string\">\"authorization_code\"</span>, <span class=\"string\">\"refresh_token\"</span>)</span><br><span class=\"line\">                .scopes(<span class=\"string\">\"read\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">            AuthorizationServerEndpointsConfigurer endpoints)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        endpoints</span><br><span class=\"line\">                .tokenStore(JdbcTokenStore)</span><br><span class=\"line\">                .authenticationManager(authenticationManager);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위와 같이 추가되면 이제 토큰은 inMemory가 아닌 DB에 저장이 된다. 그리고 &quot;Unsupported grant type: password&quot;에대한 에러도 사라지고 AccessToken이 생성 될것이다. 만약 클라이언트 관리도 디비에서 하려면 아래와 같이 변경해주면 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(ClientDetailsServiceConfigurer clients)</span></span></span><br><span class=\"line\"><span class=\"function\">            <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        clients.jdbc(dataSource);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>그다음 oauth_client_details 테이블의 아래와같이 클라이언트 정보를 추가해줘야 한다.</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> PUBLIC.OAUTH_CLIENT_DETAILS (CLIENT_ID, RESOURCE_IDS, CLIENT_SECRET, <span class=\"keyword\">SCOPE</span>, AUTHORIZED_GRANT_TYPES, WEB_SERVER_REDIRECT_URI, AUTHORITIES, ACCESS_TOKEN_VALIDITY, REFRESH_TOKEN_VALIDITY, ADDITIONAL_INFORMATION, AUTOAPPROVE) <span class=\"keyword\">VALUES</span> (<span class=\"string\">'foo'</span>, <span class=\"string\">''</span>, <span class=\"string\">'bar'</span>, <span class=\"string\">'read'</span>, <span class=\"string\">'password,authorization_code,refresh_token'</span>, <span class=\"string\">''</span>, <span class=\"string\">''</span>, <span class=\"literal\">null</span>, <span class=\"literal\">null</span>, <span class=\"string\">'&#123;&#125;'</span>, <span class=\"string\">''</span>);</span><br></pre></td></tr></table></figure>\n<p>그리고 위와 같이 Client에 관한 데이터를 Insert해주면 된다. 그렇게 되면 DB에서 클라이언 정보를 관리할 수 있게 된다.</p>\n<h4>Authorization Server, Resource Server 애플리케이션 분리</h4>\n<p>지금은 하나의 어플리케이션에 Authorization Server, Resource Server를 구현했다. 만약 다른 어플리케이션에 다른 데이터베이스를 바라보고 Authorization Server, Resource Server를 구성했다면 HTTP 통신을 통해 토큰을 확인해야한다. 그럴려면 먼저 인증서버에서 accessToken이 유효한지 확인할 수 있는 URL이 있어야 한다. 하지만 이것은 스프링에서 아래와 같이 설정해준다면 기본적으로 기능을 제공해준다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">configure</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  AuthorizationServerSecurityConfigurer oauthServer)</span></span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    oauthServer</span><br><span class=\"line\">      .tokenKeyAccess(<span class=\"string\">\"permitAll()\"</span>)</span><br><span class=\"line\">      .checkTokenAccess(<span class=\"string\">\"isAuthenticated()\"</span>);</span><br><span class=\"line\">      <span class=\"comment\">// Token 정보를 API(/oauth/check_token)를 활성화 시킨다. ( 기본은 denyAll )</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그리고 자원 서버에서도 다른 클라이언트가 접근한다면 token이 유효한지 인증서버를 통해 체크를 해줘야 한다. 이 설정 또한 쉽게 아래와 같이 URL만 등록해주면 된다. 아래는 YML, 빈을 통해 등록하는 방식을 나열했다.<br>\n<strong>YML등록방법</strong><br>\n// OAuth2 서버에서 기본적으로 Token정보를 받아오는 URL</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">security.resource.token-info-uri:url주소/oauth/check_token</span><br></pre></td></tr></table></figure>\n<p><strong>빈등록방법</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Primary</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> RemoteTokenServices <span class=\"title\">tokenService</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    RemoteTokenServices tokenService = <span class=\"keyword\">new</span> RemoteTokenServices();</span><br><span class=\"line\">    tokenService.setCheckTokenEndpointUrl(</span><br><span class=\"line\">      <span class=\"string\">\"http://localhost:8080/spring-security-oauth-server/oauth/check_token\"</span>);</span><br><span class=\"line\">    tokenService.setClientId(<span class=\"string\">\"foo\"</span>);</span><br><span class=\"line\">    tokenService.setClientSecret(<span class=\"string\">\"bar\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tokenService;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위와 같이 등록하면 자원서버는 등록된 URL로 accessToken이 유효한지 체크를 할것이다.</p>\n<h3>마무리 하며…</h3>\n<p>스프링을 통해 OAuth2를 간단하게 구현해봤다. 첫 부분에는 토큰 관리, 클라이언트 등록 등 In-Memory를 통해 간단하게 OAuth2 구현했고, 중간 부분부터는 인증서버와 자원 서버의 클래스를 분리했다. 또한 토큰 관리, 클라이언트 등록 등을 InMemmory로 관리했었는데 이러한 것을 외부 DB 등록을 통해 관리하게 해봤다. OAuth2 인증 방식은 password 인증 방식만 구현해봤는데, 다른 인증 방식을 넣는 것은 어렵지 않다. 인증서버와 자원 서버만 설정되어 있다면 금방 도입할 수 있다. 물론 Product 용으로 개발하는 데까지는 많은 시간이 걸릴 것이다. 요즘 점점 시간이 지나면서 쿠키를 통한 session 방식의 로그인은 없어지고 있는 것 같다. 점점 모바일 환경 등 멀티 디바이스를 지원해야 하므로 웹 하나만을 위한 서버를 만드는 일은 비효율적이기 때문일 것이다. 그래서 많은 서버들이 Token 방식의 로그인 방식으로 옮기고 있는 것 같다. 그중에서도 OAuth2는 많은 인증 방식 등과 인증의 간편함을 가져 인기가 좋은것같다.</p>\n<p>이 예제와 관련한 소스는 <a href=\"https://github.com/minwan1/spring-security-oauth2-example/tree/example-2\" target=\"_blank\" rel=\"noopener\">JDBC 방식을 사용한 OAuth2 구현</a>에서 확인할 수 있습니다</p>\n<p>참고</p>\n<ul>\n<li><a href=\"http://projects.spring.io/spring-security-oauth/docs/oauth2.html\" target=\"_blank\" rel=\"noopener\">OAuth 2 Developers Guide</a></li>\n<li><a href=\"http://www.baeldung.com/oauth-api-testing-with-spring-mvc\" target=\"_blank\" rel=\"noopener\">baeldung</a></li>\n<li><a href=\"http://jojoldu.tistory.com/234\" target=\"_blank\" rel=\"noopener\">기억보단 기록을</a></li>\n<li><a href=\"https://brunch.co.kr/@sbcoba/4\" target=\"_blank\" rel=\"noopener\">이수홍</a></li>\n</ul>\n"},{"title":"온라인 서점 API 만들기로 살펴보는 Spring Boot OOP 4","catalog":true,"date":"2018-07-31T15:00:00.000Z","subtitle":"회원가입 Service 만들기 - 응용영역 효율적으로 관리하기 (Part1)","header-img":null,"_content":"\n# Step-04 회원가입 Service 만들기 : 응용영역 효율적으로 관리하기 - Part1\n\n# 응용 영역(서비스)\n\n이 단계에서는 회원가입 기능을 구현하면서 `응용 영역`을 어떻게 하면 응집력 있고, 변경에 유연한 코드를 작성할지에 대해 알아볼 것입니다. 크게 아래와 같은 주제로 `응용영역`을 효율적으로 관리하는 방법에 대해 알아보겠습니다. (**소프트웨어에서 변경이 유연하고, 확장가능한 코드는 아주 핵심적인 부분입니다.**)\n\n* 서비스크기\n* 요구사항 정리 및 초난감 회원가입 Service 구현\n* 캡슐화\n\n# 1. 서비스크기\n\n드디어 회원가입을 하기 위한 signUp 서비스를 구현할 차례입니다. 먼저 회원가입 서비스 기능을 구현하기 전에 회원가입 서비스를 어느 정도의 서비스 크기로 가져갈지 생각해야합니다.\n\n\n## 도메인의 모든 기능을 한클래스에서 구현하는 방법\n먼저 책이나 일반적으로 많이 사용하는 방법인 도메인의 모든 기능을 한 클래스에 서비스에서 구현하는 방법이 있습니다.\n\n```java\n// MemberService.Class\n\n@Autowired\nprivate MemberRepository memberRepository;\n// 유저에관한 부가적인 기능을 만들기위한 수 많은 의존성 주입들\n...\n\n\npublic Member signUp(final MemberSignupRequest request){ // 회원가입을 위한 member정보\n    //비지니스로직\n}\n// 유저에 관한 기능들\n\n```\n\n**장점** :\n* 하나의 클래스에 도메인과 관련된 모든 기능들이 모여 있다.\n* 1인터페이스, 1구현체로 가져가게 되면 모든 Member의 기능들이 인터페이스에 명세되는 장점 있을 수 있다.\n\n**단점** :\n* 한 클래스에 너무 많은 기능들이 모여있어, Member 관한 모든 private 함수들이 뒤섞여 소스 분석이 힘들다.\n* 관련 없는 너무 많은 의존성들이 하나에 클래스에 주입된다.\n* 한 클래스 모든 테스트코드를 작성해야 하기 때문에 테스트 코드를 관리하기 힘들다.\n* 결국 추상화되기 위해서는 특정 기능의 서비스로 분리될 수밖에 없다.\n* SOLID 원칙을 준수하기 위해서는 결국 메서드를 분리해낼 수밖에 없다.(이 부분은 후에 좀 더 세부적으로 설명하겠습니다.)\n\n\n## 구분되는 기능별로 서비스 클래스를 구현하는방법\n그리고 다른 방법은 유저 도메인의 구분되는 기능별로 서비스 클래스를 구현하는 방법이 있습니다.\n```java\n@Service // 어노테이션을 붙이면 스프링에서 ComponentScan을 통해서 스프링 컨테이너에 자동으로 빈을등록해줌.\n@AllArgsConstructor // 모든 필드 변수에 대해 생성자를 만들어줌으로 모든멤버필드에 스프링 빈이 주입이 되어진다.\npublic class MemberSignUpService {\n\n    //회원가입에 필요한 의존성만 주입됨\n    private final MemberRepository memberRepository;\n    private final MemberHelperService memberHelperService;\n\n    public Member signUp(final MemberSignupRequest request){\n        //회원가입 로직\n    }\n\n}\n````\n**장점** :\n* 유지 보수를 할 때 구분되는 기능별로 클래스가 나누어져 있기 때문에 해당 비즈니스로직에만 신경 쓸 수 있다.\n* 해당 기능에 맞는 필요한 의존성만 주입할 수 있다.\n* 테스트 코드 작성하기가 쉽다.\n* 해당 기능을 추상화하려고 해도 이미 하나의 타입으로 뽑아져있기 때문에 추상화하기가 쉽다.\n\n**단점** :\n* 클래스가 많아진다.(단점일까... 처음엔 단점이라고 생각했는데 요즘들어 그렇게 단점은 아니라고 생각합니다.)\n\n\n### 구분되는 기능별로 서비스 클래스를 구현하는방법 선택 이유\n\n아래와 같은 이유로 `도메인의 모든 기능을 한 클래스 서비스`에서 구현하는 방법이 가지는 단점 때문에 `구분되는 기능별로 서비스` 클래스를 구현하는 방법을 선택해서 구현할 것입니다.\n\n1. **테스트코드들을 구분하기 어려워진다.**\n\n한 클래스에 너무 많은 기능들이 있기 때문에 이것을 한 클래스에 테스트 코드를 작성하게 되면 테스트를 구분하기가 어려워집니다. 물론 테스트 클래스만 여러 개로 나눌 수 있지만 이 또한 어떤 테스트 클래스에 어떤 테스트가 작성되었는지 찾기가 어렵습니다.\n만약 `구분되는 기능별로 서비스 클래스를 구현하는 방법`으로 작성했다면 테스트 코드 또한 기능별로 나누어져 있기 때문에 쉽게 테스트 코드를 찾고 관리할 수 있습니다.\n\n2. **너무 많은 public 함수들과 private 함수들이 뒤엉켜 소스분석하기가 어렵고, 한클래스에 너무많은 의존성 주입이 된다.**\n\n너무 많은 public 함수들과 private 함수들이 뒤엉켜 소스 분석하기가 어려워집니다. 만약 `구분되는 기능별로 서비스 클래스를 구현하는 방법`으로 구현한다면 public 함수 그리고 private 함수가 모두 해당 기능에 관련 있는 함수들입니다. 뿐만 아니라 한 클래스에 너무 많은 의존성 주입이 되는 것을 막을 수 있습니다.\n\n3. **결국 추상화되어지기 위해서는 특정 기능의 서비스로 분리될수밖에 없다.**\n\n예를 들어 회원 패스워드 변경 기능, admin에 의한 패스워드 변경 기능이 있다고 해보겠습니다. 좀 더 자세히 설명하면 회원이 패스워드를 변경하기 위해서는 자신의 패스워드를 인증해야 하고 Admin은 별다른 인증 없이 회원의 패스워드를 변경할 수 있습니다. 물론 if 문으로 어드민인지 확인하고 처리할 수 있지만 계속해서 다른 역할들이 추가 될 수 있습니다. 그렇게 되면 패스워드 변경을 추상화해서 관리하는 것이 효율적일 것입니다.\n\n하지만 여기에서 MemberService 자체를 추상화시키면 패스워드 변경을 제외한 나머지 기능들은 추상화가 되지 않을 것입니다. 이것은 ISP 위반입니다.(ISP에 대해서 나중에 좀 더 자세히 알아보겠습니다.) 결국 패스워드 변경을 추상화하기 위해 `도메인의 모든 기능을 한 클래스`에서 구현하는 방법의 MemberService.class에서 분리해서 별도의 클래스로 분리하고 인터페이스를 만들어야 합니다. 반면 `구분되는 기능별로 서비스 클래스`를 구현하는 방법 기능은 이미 클래스로 분리돼 있기 때문에 쉽게 유저 패스워드 변경이라는 인터페이스에 녹아들 수 있습니다.\n\n# 2. 요구사항 정리 및 초난감 회원가입 Service 구현\n\n## 요구사항 정리의 필요성\n\n서비스 영역을 구현할 때 중요한 것은 요구 사항을 받고 요구 사항을 정리하는 것입니다. 요구 사항이 간단해 보여도 정리해야 하는데 그 이유는 아래와 같습니다.\n\n* 간단한 작업 같지만 간단하지 않을 수 있습니다. 막상 요구 사항을 정리하다 보면 생각했던 것보다 작업량이 많을 수 있고 또 미쳐 생각하지 못한 곳에 영향을 주는 작업일 수 있기 때문입니다.\n* 간단하다고 생각하고 정리하지 않고 바로 개발을 하게 되면 놓치는 부분이 발생합니다.\n* 객체의 책임들을 나눌 수 있는 좋은 명세가 될 수 있습니다.\n\n\n다음은 회원가입 기능을 구현하기 위한 요구 사항입니다.(실제 구현에서는 모바일 인증코드는 없을 예정입니다. 몇 가지 예제를 설명하기 위해 예제에만 넣었습니다.)\n\n**회원가입 요구사항**\n\n1. 유저를 가입시키는 기능을 구현한다.\n2. 가입을 하려면 모바일 인증을 해야 한다.\n3. 중복된 이메일은 회원을 가입할 수 없다.\n\n## 초난감 회원가입 서비스 구현\n\n```java\n\n@Service\n@AllArgsConstructor\npublic class MemberSignUpService {\n\n    private final MemberRepository memberRepository;\n    private final CodeVerificationService codeVerificationService;\n\n    public Member signUp(final MemberSignupRequest request){\n\n        final Member duplicator = memberRepository.findByEmail(email);\n        if(duplicator != null) throw new MemberDuplicationException();\n\n        final CodeVerification codeVerification = codeVerificationService.findByMobile(request.getMobile()); // 유저가 있는지 여부를 확인할 수 있는데 인증코드 정보 객체\n\n        if(codeVerification.getAuthCode().equals(request.getAuthCode))){\n            Member member = request.toMember();//성공\n            memberRepository.save(member);\n            return member;\n        }else{\n            throw new MobileAuthenticationCodeFaildException();\n        }\n    }\n}\n\n```\n\n위 소스의 흐름은 이렇습니다.\n1. 먼저 이메일이 중복되었는지 Email로 멤버를 조회하여 멤버의 존재 여부를 확인합니다.\n2. 유저가 모바일 인증한 정보의 객체를 가져옵니다.\n3. 유저의 모바일 정보가 인증되었는지 확인을 합니다.\n4. 성공했다면 회원가입을 시킵니다.\n\n\n\n다음 소스는 회원가입 기능을 하는 데는 문제가 없는 소스입니다. 하지만 코드의 가독성도 떨어지고, 응집력이 떨어지고, 변경에 아주 취약한 소스입니다. 그 이유는 클래스의 역할 분담이 제대로 되지 않았고, 객체의 캡슐화가 되지 않았기 때문입니다.\n\n여기에서 말하는 역할 분담은 책임을 의미합니다. 책임을 알아보기 전에 먼저 캡슐화에 대해 알아보겠습니다.\n\n# 3. 캡슐화\n\n객체지향은 기본적으로 캡슐화를 통해 한 곳의 변화가 다른 곳에 미치는 영향을 최소화하여 변경의 유연함을 가질 수 있게 합니다. 캡슐화를 통해 응용영역을 좀 더 변경에 유연하게 만들 수 있습니다.\n\n> - 캡슐화는 객체가 내부적으로 기능을 어떻게 구현하는지를 감추는것이다. 이를 통해 내부적 변경의 유연함을 주고 코드의 응집력을 높여주는 기법이다.\n\n### 회원가입 예제코드의 문제점\n캡슐화가 안되어있다는 게 무슨 말인지 먼저 알아보겠습니다. 예를 들어 패스워드 변경 기능을 위해서는 codeVerificationService에 의존하고 뿐만 아니라 다른 곳곳에서도 codeVerificationService를 사용하고 있다고 해보겠습니다. 그런데 회사 보안 정책 강화로 인증코드를 체크할 때 만료시간 체크 기능을 추가하라는 요구 사항이 들어왔습니다.\n\n이렇게 되면 애플리케이션 전체에 모바일 인증을 하는 소스를 아래와 같이 인증코드 체크, 만료 여부 체크 기능을 할 수 있는 로직으로 변경해야 합니다.\n\n```java\n//PasswordChangeService\npublic void changePassword(final String mobile, final String authCode, final String password){\n    CodeVerification CodeVerification = codeVerificationService.findByMobile(mobile);\n    if(codeVerification.getAuthenticationCode.eqauls(authCode) && codeVerification.getExpireDate() < 현재시간){\n        //성공\n    }else{\n        //실패\n    }\n}\n\n```\n\n만약 한 곳이라도 실수로 변경하지 않는다면 버그로 이어지게 됩니다. 운 좋게 버그 없이 이 문제를 해결하였다고 생각해보겠습니다. 그런데 갑자기 회사에서 사용자 UX를 생각해서 만료 체크 기능을 없애고 다시 원래 로직으로 변경하라는 요구를 했습니다. 이렇게 되면 다시 전방위로 소스를 수정해야 합니다. 문제는 그 사이에 모바일 인증코드가 다른 곳에 더 추가돼 있을 수 있습니다. 이렇게 되면 소스를 변경하는 과정에서 더욱더 버그가 날 확률이 커집니다. 단지 인증코드 정책 하나가 변경하는것인데 엄청난 리소스가 필요하고 전방위적으로 버그 리스크를 가져야합니다.\n\n이러한 문제는 getter에 오용과 데이터 중심적인 사고로 인해 발생하는 문제입니다. 만약 좀 더 객체지향적인 프로그래밍을 생각했었으면 이러한 문제를 만들지 않고 CodeVerification 객체 자체에 인증처리에 관한 캡슐화된 기능을 제공했었을 것입니다.\n\n\n## CodeVerification 객체 캡슐화하기\n위에 각각의 서비스들에서 최종적으로 하고 싶은 것은 CodeVerification 객체를 통해 인증코드가 인증될 수 있는 인증코드인지 확인하는 것입니다. 내부적인 로직은 알 필요가 없습니다. 이 내용을 바탕으로 CodeVerification 객체에 verify라는 캡슐화된 메서드를 추가할 것입니다.\n\n```java\npublic class CodeVerification{\n    ... //인증객체 다른 변수\n\n    private Timestamp expireDate;\n    private String authCode; // 어떤시스템으로부터발급되어진 인증코드\n\n    private boolean isExpired(){\n        //expire check logic\n    }\n\n    private boolean isValidAuthCode(final String authCode){\n      //auth code check logic\n    }\n\n    public void verify(final String authCode){ // 클라언트로부터 입력될수있는 인증코드\n\n        // 인증코드가 만료되거나 인증코드가 맞지않으면 Exception\n\n    }\n}\n\n```\n\n이제 모든 서비스 영역들은 더 이상 모바일 인증 정책에 대해 알 필요 없이 CodeVerification에 캡슐화된 verify() 함수만 사용하면 됩니다. 예를 들어 위에서 작성한 패스워드 변경 서비스는 아래와 같이 사용할 수 있을 것입니다.\n\n```java\n\n//PasswordChangeService\npublic void changePassword(final PasswordChangeRequest request){\n    CodeVerification CodeVerification = codeVerificationService.findByMobile(request.getMobile());\n    codeVerification.verify(request.getAuthCode);\n    //패스워드 변경로직\n}\n\n\n```\n이제 회사에서 인증 코드에 정책이 변경된다고 해도 쉽게 그 변경에 대응할 수 있습니다. CodeVerification 객체에서만 캡슐화된 verify() 로직을 변경하면 되기 때문입니다. 객체의 캡슐화를 통해 코드의 응집력을 높이고 변경에 유연한 코드를 얻게 되었습니다.\n\n\n## Tell, don't ask\n\n`Tell, don't ask`는 객체지향 및 캡슐화를 잘 표현하는 문장 같습니다. 응용영역에서 특별한 경우를 제외하고는 객체한테 묻지 말고 시키는 것이 코드의 응집력을 높입니다. 그렇지 않으면 위와 같이 변경하기 어려운 코드가 만들어지기 때문입니다.\n\n위의 `초난감 회원가입 서비스` 같은 문제를 만들지 않기 위해 항상 비즈니스로 직을 작성하면서 getter를 오용하여 데이터 중심적인 비즈니스 로직을 작성하고 있는지를 의심해봐야 합니다.\n\n또한 객체지향적인 프로그래밍을 하기 위해서 항상 자신이 객체한테 묻고 있는지, 시키고 있는지를 생각하면서 개발해야 합니다. 그래야 좀 더 객체지향적 프로그래밍을 할 수 있기 때문입니다. (물론 비즈니스 로직이 엄청 커지거나, 공통으로 처리되지 않는 로직으로 인한 서비스 로직에서 비즈니 스로직을 작성해야 할 때도 있습니다.)\n\n\n# 마치며\n\n이장에서 응용 영역을 효율적으로 관리하기 위해 `구분되는 기능별로 클래스`를 구현하는 방법을 선택하여 `초난감 회원가입서비스`를 구현했습니다. 하지만 완성된 `초난감 회원가입 서비스`는 변경에 취약하고 응집력이 떨어지는 코드였습니다. 이렇게 변경에 취약한 이유는 많은 이유가 있겠지만 가장 기본적인 캡슐화가 되어 있지 않았습니다. 캡슐화를 통해 코드의 응집력을 높이고 변경에 유연한 코드로 변경하는 작업을 했습니다.\n\n하지만 `초난감 회원가입 서비스`는 캡슐화의 문제도 문제이지만 기능의 역할 분담이 제대로 되지 않은 문제가 더 큽니다. 이 말은 책임이 적절하게 분리되지 않았다는 것을 의미합니다. 이러한 문제는 다음 part에서 좀 더 세부적으로 알아보겠습니다.\n","source":"_posts/2018-07-26-spring-book-4.md","raw":"---\ntitle: 온라인 서점 API 만들기로 살펴보는 Spring Boot OOP 4\ncatalog: true\ndate: 2018-08-01\nsubtitle: 회원가입 Service 만들기 - 응용영역 효율적으로 관리하기 (Part1)\nheader-img:\ntags:\n- Java\n- Spring\n- 온라인 서점 API 만들기로 살펴보는 Spring Boot OOP\n\n\n---\n\n# Step-04 회원가입 Service 만들기 : 응용영역 효율적으로 관리하기 - Part1\n\n# 응용 영역(서비스)\n\n이 단계에서는 회원가입 기능을 구현하면서 `응용 영역`을 어떻게 하면 응집력 있고, 변경에 유연한 코드를 작성할지에 대해 알아볼 것입니다. 크게 아래와 같은 주제로 `응용영역`을 효율적으로 관리하는 방법에 대해 알아보겠습니다. (**소프트웨어에서 변경이 유연하고, 확장가능한 코드는 아주 핵심적인 부분입니다.**)\n\n* 서비스크기\n* 요구사항 정리 및 초난감 회원가입 Service 구현\n* 캡슐화\n\n# 1. 서비스크기\n\n드디어 회원가입을 하기 위한 signUp 서비스를 구현할 차례입니다. 먼저 회원가입 서비스 기능을 구현하기 전에 회원가입 서비스를 어느 정도의 서비스 크기로 가져갈지 생각해야합니다.\n\n\n## 도메인의 모든 기능을 한클래스에서 구현하는 방법\n먼저 책이나 일반적으로 많이 사용하는 방법인 도메인의 모든 기능을 한 클래스에 서비스에서 구현하는 방법이 있습니다.\n\n```java\n// MemberService.Class\n\n@Autowired\nprivate MemberRepository memberRepository;\n// 유저에관한 부가적인 기능을 만들기위한 수 많은 의존성 주입들\n...\n\n\npublic Member signUp(final MemberSignupRequest request){ // 회원가입을 위한 member정보\n    //비지니스로직\n}\n// 유저에 관한 기능들\n\n```\n\n**장점** :\n* 하나의 클래스에 도메인과 관련된 모든 기능들이 모여 있다.\n* 1인터페이스, 1구현체로 가져가게 되면 모든 Member의 기능들이 인터페이스에 명세되는 장점 있을 수 있다.\n\n**단점** :\n* 한 클래스에 너무 많은 기능들이 모여있어, Member 관한 모든 private 함수들이 뒤섞여 소스 분석이 힘들다.\n* 관련 없는 너무 많은 의존성들이 하나에 클래스에 주입된다.\n* 한 클래스 모든 테스트코드를 작성해야 하기 때문에 테스트 코드를 관리하기 힘들다.\n* 결국 추상화되기 위해서는 특정 기능의 서비스로 분리될 수밖에 없다.\n* SOLID 원칙을 준수하기 위해서는 결국 메서드를 분리해낼 수밖에 없다.(이 부분은 후에 좀 더 세부적으로 설명하겠습니다.)\n\n\n## 구분되는 기능별로 서비스 클래스를 구현하는방법\n그리고 다른 방법은 유저 도메인의 구분되는 기능별로 서비스 클래스를 구현하는 방법이 있습니다.\n```java\n@Service // 어노테이션을 붙이면 스프링에서 ComponentScan을 통해서 스프링 컨테이너에 자동으로 빈을등록해줌.\n@AllArgsConstructor // 모든 필드 변수에 대해 생성자를 만들어줌으로 모든멤버필드에 스프링 빈이 주입이 되어진다.\npublic class MemberSignUpService {\n\n    //회원가입에 필요한 의존성만 주입됨\n    private final MemberRepository memberRepository;\n    private final MemberHelperService memberHelperService;\n\n    public Member signUp(final MemberSignupRequest request){\n        //회원가입 로직\n    }\n\n}\n````\n**장점** :\n* 유지 보수를 할 때 구분되는 기능별로 클래스가 나누어져 있기 때문에 해당 비즈니스로직에만 신경 쓸 수 있다.\n* 해당 기능에 맞는 필요한 의존성만 주입할 수 있다.\n* 테스트 코드 작성하기가 쉽다.\n* 해당 기능을 추상화하려고 해도 이미 하나의 타입으로 뽑아져있기 때문에 추상화하기가 쉽다.\n\n**단점** :\n* 클래스가 많아진다.(단점일까... 처음엔 단점이라고 생각했는데 요즘들어 그렇게 단점은 아니라고 생각합니다.)\n\n\n### 구분되는 기능별로 서비스 클래스를 구현하는방법 선택 이유\n\n아래와 같은 이유로 `도메인의 모든 기능을 한 클래스 서비스`에서 구현하는 방법이 가지는 단점 때문에 `구분되는 기능별로 서비스` 클래스를 구현하는 방법을 선택해서 구현할 것입니다.\n\n1. **테스트코드들을 구분하기 어려워진다.**\n\n한 클래스에 너무 많은 기능들이 있기 때문에 이것을 한 클래스에 테스트 코드를 작성하게 되면 테스트를 구분하기가 어려워집니다. 물론 테스트 클래스만 여러 개로 나눌 수 있지만 이 또한 어떤 테스트 클래스에 어떤 테스트가 작성되었는지 찾기가 어렵습니다.\n만약 `구분되는 기능별로 서비스 클래스를 구현하는 방법`으로 작성했다면 테스트 코드 또한 기능별로 나누어져 있기 때문에 쉽게 테스트 코드를 찾고 관리할 수 있습니다.\n\n2. **너무 많은 public 함수들과 private 함수들이 뒤엉켜 소스분석하기가 어렵고, 한클래스에 너무많은 의존성 주입이 된다.**\n\n너무 많은 public 함수들과 private 함수들이 뒤엉켜 소스 분석하기가 어려워집니다. 만약 `구분되는 기능별로 서비스 클래스를 구현하는 방법`으로 구현한다면 public 함수 그리고 private 함수가 모두 해당 기능에 관련 있는 함수들입니다. 뿐만 아니라 한 클래스에 너무 많은 의존성 주입이 되는 것을 막을 수 있습니다.\n\n3. **결국 추상화되어지기 위해서는 특정 기능의 서비스로 분리될수밖에 없다.**\n\n예를 들어 회원 패스워드 변경 기능, admin에 의한 패스워드 변경 기능이 있다고 해보겠습니다. 좀 더 자세히 설명하면 회원이 패스워드를 변경하기 위해서는 자신의 패스워드를 인증해야 하고 Admin은 별다른 인증 없이 회원의 패스워드를 변경할 수 있습니다. 물론 if 문으로 어드민인지 확인하고 처리할 수 있지만 계속해서 다른 역할들이 추가 될 수 있습니다. 그렇게 되면 패스워드 변경을 추상화해서 관리하는 것이 효율적일 것입니다.\n\n하지만 여기에서 MemberService 자체를 추상화시키면 패스워드 변경을 제외한 나머지 기능들은 추상화가 되지 않을 것입니다. 이것은 ISP 위반입니다.(ISP에 대해서 나중에 좀 더 자세히 알아보겠습니다.) 결국 패스워드 변경을 추상화하기 위해 `도메인의 모든 기능을 한 클래스`에서 구현하는 방법의 MemberService.class에서 분리해서 별도의 클래스로 분리하고 인터페이스를 만들어야 합니다. 반면 `구분되는 기능별로 서비스 클래스`를 구현하는 방법 기능은 이미 클래스로 분리돼 있기 때문에 쉽게 유저 패스워드 변경이라는 인터페이스에 녹아들 수 있습니다.\n\n# 2. 요구사항 정리 및 초난감 회원가입 Service 구현\n\n## 요구사항 정리의 필요성\n\n서비스 영역을 구현할 때 중요한 것은 요구 사항을 받고 요구 사항을 정리하는 것입니다. 요구 사항이 간단해 보여도 정리해야 하는데 그 이유는 아래와 같습니다.\n\n* 간단한 작업 같지만 간단하지 않을 수 있습니다. 막상 요구 사항을 정리하다 보면 생각했던 것보다 작업량이 많을 수 있고 또 미쳐 생각하지 못한 곳에 영향을 주는 작업일 수 있기 때문입니다.\n* 간단하다고 생각하고 정리하지 않고 바로 개발을 하게 되면 놓치는 부분이 발생합니다.\n* 객체의 책임들을 나눌 수 있는 좋은 명세가 될 수 있습니다.\n\n\n다음은 회원가입 기능을 구현하기 위한 요구 사항입니다.(실제 구현에서는 모바일 인증코드는 없을 예정입니다. 몇 가지 예제를 설명하기 위해 예제에만 넣었습니다.)\n\n**회원가입 요구사항**\n\n1. 유저를 가입시키는 기능을 구현한다.\n2. 가입을 하려면 모바일 인증을 해야 한다.\n3. 중복된 이메일은 회원을 가입할 수 없다.\n\n## 초난감 회원가입 서비스 구현\n\n```java\n\n@Service\n@AllArgsConstructor\npublic class MemberSignUpService {\n\n    private final MemberRepository memberRepository;\n    private final CodeVerificationService codeVerificationService;\n\n    public Member signUp(final MemberSignupRequest request){\n\n        final Member duplicator = memberRepository.findByEmail(email);\n        if(duplicator != null) throw new MemberDuplicationException();\n\n        final CodeVerification codeVerification = codeVerificationService.findByMobile(request.getMobile()); // 유저가 있는지 여부를 확인할 수 있는데 인증코드 정보 객체\n\n        if(codeVerification.getAuthCode().equals(request.getAuthCode))){\n            Member member = request.toMember();//성공\n            memberRepository.save(member);\n            return member;\n        }else{\n            throw new MobileAuthenticationCodeFaildException();\n        }\n    }\n}\n\n```\n\n위 소스의 흐름은 이렇습니다.\n1. 먼저 이메일이 중복되었는지 Email로 멤버를 조회하여 멤버의 존재 여부를 확인합니다.\n2. 유저가 모바일 인증한 정보의 객체를 가져옵니다.\n3. 유저의 모바일 정보가 인증되었는지 확인을 합니다.\n4. 성공했다면 회원가입을 시킵니다.\n\n\n\n다음 소스는 회원가입 기능을 하는 데는 문제가 없는 소스입니다. 하지만 코드의 가독성도 떨어지고, 응집력이 떨어지고, 변경에 아주 취약한 소스입니다. 그 이유는 클래스의 역할 분담이 제대로 되지 않았고, 객체의 캡슐화가 되지 않았기 때문입니다.\n\n여기에서 말하는 역할 분담은 책임을 의미합니다. 책임을 알아보기 전에 먼저 캡슐화에 대해 알아보겠습니다.\n\n# 3. 캡슐화\n\n객체지향은 기본적으로 캡슐화를 통해 한 곳의 변화가 다른 곳에 미치는 영향을 최소화하여 변경의 유연함을 가질 수 있게 합니다. 캡슐화를 통해 응용영역을 좀 더 변경에 유연하게 만들 수 있습니다.\n\n> - 캡슐화는 객체가 내부적으로 기능을 어떻게 구현하는지를 감추는것이다. 이를 통해 내부적 변경의 유연함을 주고 코드의 응집력을 높여주는 기법이다.\n\n### 회원가입 예제코드의 문제점\n캡슐화가 안되어있다는 게 무슨 말인지 먼저 알아보겠습니다. 예를 들어 패스워드 변경 기능을 위해서는 codeVerificationService에 의존하고 뿐만 아니라 다른 곳곳에서도 codeVerificationService를 사용하고 있다고 해보겠습니다. 그런데 회사 보안 정책 강화로 인증코드를 체크할 때 만료시간 체크 기능을 추가하라는 요구 사항이 들어왔습니다.\n\n이렇게 되면 애플리케이션 전체에 모바일 인증을 하는 소스를 아래와 같이 인증코드 체크, 만료 여부 체크 기능을 할 수 있는 로직으로 변경해야 합니다.\n\n```java\n//PasswordChangeService\npublic void changePassword(final String mobile, final String authCode, final String password){\n    CodeVerification CodeVerification = codeVerificationService.findByMobile(mobile);\n    if(codeVerification.getAuthenticationCode.eqauls(authCode) && codeVerification.getExpireDate() < 현재시간){\n        //성공\n    }else{\n        //실패\n    }\n}\n\n```\n\n만약 한 곳이라도 실수로 변경하지 않는다면 버그로 이어지게 됩니다. 운 좋게 버그 없이 이 문제를 해결하였다고 생각해보겠습니다. 그런데 갑자기 회사에서 사용자 UX를 생각해서 만료 체크 기능을 없애고 다시 원래 로직으로 변경하라는 요구를 했습니다. 이렇게 되면 다시 전방위로 소스를 수정해야 합니다. 문제는 그 사이에 모바일 인증코드가 다른 곳에 더 추가돼 있을 수 있습니다. 이렇게 되면 소스를 변경하는 과정에서 더욱더 버그가 날 확률이 커집니다. 단지 인증코드 정책 하나가 변경하는것인데 엄청난 리소스가 필요하고 전방위적으로 버그 리스크를 가져야합니다.\n\n이러한 문제는 getter에 오용과 데이터 중심적인 사고로 인해 발생하는 문제입니다. 만약 좀 더 객체지향적인 프로그래밍을 생각했었으면 이러한 문제를 만들지 않고 CodeVerification 객체 자체에 인증처리에 관한 캡슐화된 기능을 제공했었을 것입니다.\n\n\n## CodeVerification 객체 캡슐화하기\n위에 각각의 서비스들에서 최종적으로 하고 싶은 것은 CodeVerification 객체를 통해 인증코드가 인증될 수 있는 인증코드인지 확인하는 것입니다. 내부적인 로직은 알 필요가 없습니다. 이 내용을 바탕으로 CodeVerification 객체에 verify라는 캡슐화된 메서드를 추가할 것입니다.\n\n```java\npublic class CodeVerification{\n    ... //인증객체 다른 변수\n\n    private Timestamp expireDate;\n    private String authCode; // 어떤시스템으로부터발급되어진 인증코드\n\n    private boolean isExpired(){\n        //expire check logic\n    }\n\n    private boolean isValidAuthCode(final String authCode){\n      //auth code check logic\n    }\n\n    public void verify(final String authCode){ // 클라언트로부터 입력될수있는 인증코드\n\n        // 인증코드가 만료되거나 인증코드가 맞지않으면 Exception\n\n    }\n}\n\n```\n\n이제 모든 서비스 영역들은 더 이상 모바일 인증 정책에 대해 알 필요 없이 CodeVerification에 캡슐화된 verify() 함수만 사용하면 됩니다. 예를 들어 위에서 작성한 패스워드 변경 서비스는 아래와 같이 사용할 수 있을 것입니다.\n\n```java\n\n//PasswordChangeService\npublic void changePassword(final PasswordChangeRequest request){\n    CodeVerification CodeVerification = codeVerificationService.findByMobile(request.getMobile());\n    codeVerification.verify(request.getAuthCode);\n    //패스워드 변경로직\n}\n\n\n```\n이제 회사에서 인증 코드에 정책이 변경된다고 해도 쉽게 그 변경에 대응할 수 있습니다. CodeVerification 객체에서만 캡슐화된 verify() 로직을 변경하면 되기 때문입니다. 객체의 캡슐화를 통해 코드의 응집력을 높이고 변경에 유연한 코드를 얻게 되었습니다.\n\n\n## Tell, don't ask\n\n`Tell, don't ask`는 객체지향 및 캡슐화를 잘 표현하는 문장 같습니다. 응용영역에서 특별한 경우를 제외하고는 객체한테 묻지 말고 시키는 것이 코드의 응집력을 높입니다. 그렇지 않으면 위와 같이 변경하기 어려운 코드가 만들어지기 때문입니다.\n\n위의 `초난감 회원가입 서비스` 같은 문제를 만들지 않기 위해 항상 비즈니스로 직을 작성하면서 getter를 오용하여 데이터 중심적인 비즈니스 로직을 작성하고 있는지를 의심해봐야 합니다.\n\n또한 객체지향적인 프로그래밍을 하기 위해서 항상 자신이 객체한테 묻고 있는지, 시키고 있는지를 생각하면서 개발해야 합니다. 그래야 좀 더 객체지향적 프로그래밍을 할 수 있기 때문입니다. (물론 비즈니스 로직이 엄청 커지거나, 공통으로 처리되지 않는 로직으로 인한 서비스 로직에서 비즈니 스로직을 작성해야 할 때도 있습니다.)\n\n\n# 마치며\n\n이장에서 응용 영역을 효율적으로 관리하기 위해 `구분되는 기능별로 클래스`를 구현하는 방법을 선택하여 `초난감 회원가입서비스`를 구현했습니다. 하지만 완성된 `초난감 회원가입 서비스`는 변경에 취약하고 응집력이 떨어지는 코드였습니다. 이렇게 변경에 취약한 이유는 많은 이유가 있겠지만 가장 기본적인 캡슐화가 되어 있지 않았습니다. 캡슐화를 통해 코드의 응집력을 높이고 변경에 유연한 코드로 변경하는 작업을 했습니다.\n\n하지만 `초난감 회원가입 서비스`는 캡슐화의 문제도 문제이지만 기능의 역할 분담이 제대로 되지 않은 문제가 더 큽니다. 이 말은 책임이 적절하게 분리되지 않았다는 것을 의미합니다. 이러한 문제는 다음 part에서 좀 더 세부적으로 알아보겠습니다.\n","slug":"2018-07-26-spring-book-4","published":1,"updated":"2018-08-01T14:22:58.587Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27el003ujjpeyngeigjw","content":"<h1><span id=\"step-04-회원가입-service-만들기-응용영역-효율적으로-관리하기-part1\">Step-04 회원가입 Service 만들기 : 응용영역 효율적으로 관리하기 - Part1</span></h1>\n<h1><span id=\"응용-영역서비스\">응용 영역(서비스)</span></h1>\n<p>이 단계에서는 회원가입 기능을 구현하면서 <code>응용 영역</code>을 어떻게 하면 응집력 있고, 변경에 유연한 코드를 작성할지에 대해 알아볼 것입니다. 크게 아래와 같은 주제로 <code>응용영역</code>을 효율적으로 관리하는 방법에 대해 알아보겠습니다. (<strong>소프트웨어에서 변경이 유연하고, 확장가능한 코드는 아주 핵심적인 부분입니다.</strong>)</p>\n<ul>\n<li>서비스크기</li>\n<li>요구사항 정리 및 초난감 회원가입 Service 구현</li>\n<li>캡슐화</li>\n</ul>\n<h1><span id=\"1-서비스크기\">1. 서비스크기</span></h1>\n<p>드디어 회원가입을 하기 위한 signUp 서비스를 구현할 차례입니다. 먼저 회원가입 서비스 기능을 구현하기 전에 회원가입 서비스를 어느 정도의 서비스 크기로 가져갈지 생각해야합니다.</p>\n<h2><span id=\"도메인의-모든-기능을-한클래스에서-구현하는-방법\">도메인의 모든 기능을 한클래스에서 구현하는 방법</span></h2>\n<p>먼저 책이나 일반적으로 많이 사용하는 방법인 도메인의 모든 기능을 한 클래스에 서비스에서 구현하는 방법이 있습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MemberService.Class</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> MemberRepository memberRepository;</span><br><span class=\"line\"><span class=\"comment\">// 유저에관한 부가적인 기능을 만들기위한 수 많은 의존성 주입들</span></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Member <span class=\"title\">signUp</span><span class=\"params\">(<span class=\"keyword\">final</span> MemberSignupRequest request)</span></span>&#123; <span class=\"comment\">// 회원가입을 위한 member정보</span></span><br><span class=\"line\">    <span class=\"comment\">//비지니스로직</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 유저에 관한 기능들</span></span><br></pre></td></tr></table></figure>\n<p><strong>장점</strong> :</p>\n<ul>\n<li>하나의 클래스에 도메인과 관련된 모든 기능들이 모여 있다.</li>\n<li>1인터페이스, 1구현체로 가져가게 되면 모든 Member의 기능들이 인터페이스에 명세되는 장점 있을 수 있다.</li>\n</ul>\n<p><strong>단점</strong> :</p>\n<ul>\n<li>한 클래스에 너무 많은 기능들이 모여있어, Member 관한 모든 private 함수들이 뒤섞여 소스 분석이 힘들다.</li>\n<li>관련 없는 너무 많은 의존성들이 하나에 클래스에 주입된다.</li>\n<li>한 클래스 모든 테스트코드를 작성해야 하기 때문에 테스트 코드를 관리하기 힘들다.</li>\n<li>결국 추상화되기 위해서는 특정 기능의 서비스로 분리될 수밖에 없다.</li>\n<li>SOLID 원칙을 준수하기 위해서는 결국 메서드를 분리해낼 수밖에 없다.(이 부분은 후에 좀 더 세부적으로 설명하겠습니다.)</li>\n</ul>\n<h2><span id=\"구분되는-기능별로-서비스-클래스를-구현하는방법\">구분되는 기능별로 서비스 클래스를 구현하는방법</span></h2>\n<p>그리고 다른 방법은 유저 도메인의 구분되는 기능별로 서비스 클래스를 구현하는 방법이 있습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span> <span class=\"comment\">// 어노테이션을 붙이면 스프링에서 ComponentScan을 통해서 스프링 컨테이너에 자동으로 빈을등록해줌.</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span> <span class=\"comment\">// 모든 필드 변수에 대해 생성자를 만들어줌으로 모든멤버필드에 스프링 빈이 주입이 되어진다.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MemberSignUpService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//회원가입에 필요한 의존성만 주입됨</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MemberRepository memberRepository;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MemberHelperService memberHelperService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Member <span class=\"title\">signUp</span><span class=\"params\">(<span class=\"keyword\">final</span> MemberSignupRequest request)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//회원가입 로직</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure>\n<p><strong>장점</strong> :</p>\n<ul>\n<li>유지 보수를 할 때 구분되는 기능별로 클래스가 나누어져 있기 때문에 해당 비즈니스로직에만 신경 쓸 수 있다.</li>\n<li>해당 기능에 맞는 필요한 의존성만 주입할 수 있다.</li>\n<li>테스트 코드 작성하기가 쉽다.</li>\n<li>해당 기능을 추상화하려고 해도 이미 하나의 타입으로 뽑아져있기 때문에 추상화하기가 쉽다.</li>\n</ul>\n<p><strong>단점</strong> :</p>\n<ul>\n<li>클래스가 많아진다.(단점일까… 처음엔 단점이라고 생각했는데 요즘들어 그렇게 단점은 아니라고 생각합니다.)</li>\n</ul>\n<h3><span id=\"구분되는-기능별로-서비스-클래스를-구현하는방법-선택-이유\">구분되는 기능별로 서비스 클래스를 구현하는방법 선택 이유</span></h3>\n<p>아래와 같은 이유로 <code>도메인의 모든 기능을 한 클래스 서비스</code>에서 구현하는 방법이 가지는 단점 때문에 <code>구분되는 기능별로 서비스</code> 클래스를 구현하는 방법을 선택해서 구현할 것입니다.</p>\n<ol>\n<li><strong>테스트코드들을 구분하기 어려워진다.</strong></li>\n</ol>\n<p>한 클래스에 너무 많은 기능들이 있기 때문에 이것을 한 클래스에 테스트 코드를 작성하게 되면 테스트를 구분하기가 어려워집니다. 물론 테스트 클래스만 여러 개로 나눌 수 있지만 이 또한 어떤 테스트 클래스에 어떤 테스트가 작성되었는지 찾기가 어렵습니다.<br>\n만약 <code>구분되는 기능별로 서비스 클래스를 구현하는 방법</code>으로 작성했다면 테스트 코드 또한 기능별로 나누어져 있기 때문에 쉽게 테스트 코드를 찾고 관리할 수 있습니다.</p>\n<ol start=\"2\">\n<li><strong>너무 많은 public 함수들과 private 함수들이 뒤엉켜 소스분석하기가 어렵고, 한클래스에 너무많은 의존성 주입이 된다.</strong></li>\n</ol>\n<p>너무 많은 public 함수들과 private 함수들이 뒤엉켜 소스 분석하기가 어려워집니다. 만약 <code>구분되는 기능별로 서비스 클래스를 구현하는 방법</code>으로 구현한다면 public 함수 그리고 private 함수가 모두 해당 기능에 관련 있는 함수들입니다. 뿐만 아니라 한 클래스에 너무 많은 의존성 주입이 되는 것을 막을 수 있습니다.</p>\n<ol start=\"3\">\n<li><strong>결국 추상화되어지기 위해서는 특정 기능의 서비스로 분리될수밖에 없다.</strong></li>\n</ol>\n<p>예를 들어 회원 패스워드 변경 기능, admin에 의한 패스워드 변경 기능이 있다고 해보겠습니다. 좀 더 자세히 설명하면 회원이 패스워드를 변경하기 위해서는 자신의 패스워드를 인증해야 하고 Admin은 별다른 인증 없이 회원의 패스워드를 변경할 수 있습니다. 물론 if 문으로 어드민인지 확인하고 처리할 수 있지만 계속해서 다른 역할들이 추가 될 수 있습니다. 그렇게 되면 패스워드 변경을 추상화해서 관리하는 것이 효율적일 것입니다.</p>\n<p>하지만 여기에서 MemberService 자체를 추상화시키면 패스워드 변경을 제외한 나머지 기능들은 추상화가 되지 않을 것입니다. 이것은 ISP 위반입니다.(ISP에 대해서 나중에 좀 더 자세히 알아보겠습니다.) 결국 패스워드 변경을 추상화하기 위해 <code>도메인의 모든 기능을 한 클래스</code>에서 구현하는 방법의 MemberService.class에서 분리해서 별도의 클래스로 분리하고 인터페이스를 만들어야 합니다. 반면 <code>구분되는 기능별로 서비스 클래스</code>를 구현하는 방법 기능은 이미 클래스로 분리돼 있기 때문에 쉽게 유저 패스워드 변경이라는 인터페이스에 녹아들 수 있습니다.</p>\n<h1><span id=\"2-요구사항-정리-및-초난감-회원가입-service-구현\">2. 요구사항 정리 및 초난감 회원가입 Service 구현</span></h1>\n<h2><span id=\"요구사항-정리의-필요성\">요구사항 정리의 필요성</span></h2>\n<p>서비스 영역을 구현할 때 중요한 것은 요구 사항을 받고 요구 사항을 정리하는 것입니다. 요구 사항이 간단해 보여도 정리해야 하는데 그 이유는 아래와 같습니다.</p>\n<ul>\n<li>간단한 작업 같지만 간단하지 않을 수 있습니다. 막상 요구 사항을 정리하다 보면 생각했던 것보다 작업량이 많을 수 있고 또 미쳐 생각하지 못한 곳에 영향을 주는 작업일 수 있기 때문입니다.</li>\n<li>간단하다고 생각하고 정리하지 않고 바로 개발을 하게 되면 놓치는 부분이 발생합니다.</li>\n<li>객체의 책임들을 나눌 수 있는 좋은 명세가 될 수 있습니다.</li>\n</ul>\n<p>다음은 회원가입 기능을 구현하기 위한 요구 사항입니다.(실제 구현에서는 모바일 인증코드는 없을 예정입니다. 몇 가지 예제를 설명하기 위해 예제에만 넣었습니다.)</p>\n<p><strong>회원가입 요구사항</strong></p>\n<ol>\n<li>유저를 가입시키는 기능을 구현한다.</li>\n<li>가입을 하려면 모바일 인증을 해야 한다.</li>\n<li>중복된 이메일은 회원을 가입할 수 없다.</li>\n</ol>\n<h2><span id=\"초난감-회원가입-서비스-구현\">초난감 회원가입 서비스 구현</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MemberSignUpService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MemberRepository memberRepository;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CodeVerificationService codeVerificationService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Member <span class=\"title\">signUp</span><span class=\"params\">(<span class=\"keyword\">final</span> MemberSignupRequest request)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Member duplicator = memberRepository.findByEmail(email);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(duplicator != <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MemberDuplicationException();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> CodeVerification codeVerification = codeVerificationService.findByMobile(request.getMobile()); <span class=\"comment\">// 유저가 있는지 여부를 확인할 수 있는데 인증코드 정보 객체</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(codeVerification.getAuthCode().equals(request.getAuthCode)))&#123;</span><br><span class=\"line\">            Member member = request.toMember();<span class=\"comment\">//성공</span></span><br><span class=\"line\">            memberRepository.save(member);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> member;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MobileAuthenticationCodeFaildException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위 소스의 흐름은 이렇습니다.</p>\n<ol>\n<li>먼저 이메일이 중복되었는지 Email로 멤버를 조회하여 멤버의 존재 여부를 확인합니다.</li>\n<li>유저가 모바일 인증한 정보의 객체를 가져옵니다.</li>\n<li>유저의 모바일 정보가 인증되었는지 확인을 합니다.</li>\n<li>성공했다면 회원가입을 시킵니다.</li>\n</ol>\n<p>다음 소스는 회원가입 기능을 하는 데는 문제가 없는 소스입니다. 하지만 코드의 가독성도 떨어지고, 응집력이 떨어지고, 변경에 아주 취약한 소스입니다. 그 이유는 클래스의 역할 분담이 제대로 되지 않았고, 객체의 캡슐화가 되지 않았기 때문입니다.</p>\n<p>여기에서 말하는 역할 분담은 책임을 의미합니다. 책임을 알아보기 전에 먼저 캡슐화에 대해 알아보겠습니다.</p>\n<h1><span id=\"3-캡슐화\">3. 캡슐화</span></h1>\n<p>객체지향은 기본적으로 캡슐화를 통해 한 곳의 변화가 다른 곳에 미치는 영향을 최소화하여 변경의 유연함을 가질 수 있게 합니다. 캡슐화를 통해 응용영역을 좀 더 변경에 유연하게 만들 수 있습니다.</p>\n<blockquote>\n<ul>\n<li>캡슐화는 객체가 내부적으로 기능을 어떻게 구현하는지를 감추는것이다. 이를 통해 내부적 변경의 유연함을 주고 코드의 응집력을 높여주는 기법이다.</li>\n</ul>\n</blockquote>\n<h3><span id=\"회원가입-예제코드의-문제점\">회원가입 예제코드의 문제점</span></h3>\n<p>캡슐화가 안되어있다는 게 무슨 말인지 먼저 알아보겠습니다. 예를 들어 패스워드 변경 기능을 위해서는 codeVerificationService에 의존하고 뿐만 아니라 다른 곳곳에서도 codeVerificationService를 사용하고 있다고 해보겠습니다. 그런데 회사 보안 정책 강화로 인증코드를 체크할 때 만료시간 체크 기능을 추가하라는 요구 사항이 들어왔습니다.</p>\n<p>이렇게 되면 애플리케이션 전체에 모바일 인증을 하는 소스를 아래와 같이 인증코드 체크, 만료 여부 체크 기능을 할 수 있는 로직으로 변경해야 합니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//PasswordChangeService</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">changePassword</span><span class=\"params\">(<span class=\"keyword\">final</span> String mobile, <span class=\"keyword\">final</span> String authCode, <span class=\"keyword\">final</span> String password)</span></span>&#123;</span><br><span class=\"line\">    CodeVerification CodeVerification = codeVerificationService.findByMobile(mobile);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(codeVerification.getAuthenticationCode.eqauls(authCode) &amp;&amp; codeVerification.getExpireDate() &lt; 현재시간)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//성공</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//실패</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>만약 한 곳이라도 실수로 변경하지 않는다면 버그로 이어지게 됩니다. 운 좋게 버그 없이 이 문제를 해결하였다고 생각해보겠습니다. 그런데 갑자기 회사에서 사용자 UX를 생각해서 만료 체크 기능을 없애고 다시 원래 로직으로 변경하라는 요구를 했습니다. 이렇게 되면 다시 전방위로 소스를 수정해야 합니다. 문제는 그 사이에 모바일 인증코드가 다른 곳에 더 추가돼 있을 수 있습니다. 이렇게 되면 소스를 변경하는 과정에서 더욱더 버그가 날 확률이 커집니다. 단지 인증코드 정책 하나가 변경하는것인데 엄청난 리소스가 필요하고 전방위적으로 버그 리스크를 가져야합니다.</p>\n<p>이러한 문제는 getter에 오용과 데이터 중심적인 사고로 인해 발생하는 문제입니다. 만약 좀 더 객체지향적인 프로그래밍을 생각했었으면 이러한 문제를 만들지 않고 CodeVerification 객체 자체에 인증처리에 관한 캡슐화된 기능을 제공했었을 것입니다.</p>\n<h2><span id=\"codeverification-객체-캡슐화하기\">CodeVerification 객체 캡슐화하기</span></h2>\n<p>위에 각각의 서비스들에서 최종적으로 하고 싶은 것은 CodeVerification 객체를 통해 인증코드가 인증될 수 있는 인증코드인지 확인하는 것입니다. 내부적인 로직은 알 필요가 없습니다. 이 내용을 바탕으로 CodeVerification 객체에 verify라는 캡슐화된 메서드를 추가할 것입니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CodeVerification</span></span>&#123;</span><br><span class=\"line\">    ... <span class=\"comment\">//인증객체 다른 변수</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Timestamp expireDate;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String authCode; <span class=\"comment\">// 어떤시스템으로부터발급되어진 인증코드</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isExpired</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//expire check logic</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValidAuthCode</span><span class=\"params\">(<span class=\"keyword\">final</span> String authCode)</span></span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//auth code check logic</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">verify</span><span class=\"params\">(<span class=\"keyword\">final</span> String authCode)</span></span>&#123; <span class=\"comment\">// 클라언트로부터 입력될수있는 인증코드</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 인증코드가 만료되거나 인증코드가 맞지않으면 Exception</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이제 모든 서비스 영역들은 더 이상 모바일 인증 정책에 대해 알 필요 없이 CodeVerification에 캡슐화된 verify() 함수만 사용하면 됩니다. 예를 들어 위에서 작성한 패스워드 변경 서비스는 아래와 같이 사용할 수 있을 것입니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//PasswordChangeService</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">changePassword</span><span class=\"params\">(<span class=\"keyword\">final</span> PasswordChangeRequest request)</span></span>&#123;</span><br><span class=\"line\">    CodeVerification CodeVerification = codeVerificationService.findByMobile(request.getMobile());</span><br><span class=\"line\">    codeVerification.verify(request.getAuthCode);</span><br><span class=\"line\">    <span class=\"comment\">//패스워드 변경로직</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이제 회사에서 인증 코드에 정책이 변경된다고 해도 쉽게 그 변경에 대응할 수 있습니다. CodeVerification 객체에서만 캡슐화된 verify() 로직을 변경하면 되기 때문입니다. 객체의 캡슐화를 통해 코드의 응집력을 높이고 변경에 유연한 코드를 얻게 되었습니다.</p>\n<h2><span id=\"tell-dont-ask\">Tell, don’t ask</span></h2>\n<p><code>Tell, don't ask</code>는 객체지향 및 캡슐화를 잘 표현하는 문장 같습니다. 응용영역에서 특별한 경우를 제외하고는 객체한테 묻지 말고 시키는 것이 코드의 응집력을 높입니다. 그렇지 않으면 위와 같이 변경하기 어려운 코드가 만들어지기 때문입니다.</p>\n<p>위의 <code>초난감 회원가입 서비스</code> 같은 문제를 만들지 않기 위해 항상 비즈니스로 직을 작성하면서 getter를 오용하여 데이터 중심적인 비즈니스 로직을 작성하고 있는지를 의심해봐야 합니다.</p>\n<p>또한 객체지향적인 프로그래밍을 하기 위해서 항상 자신이 객체한테 묻고 있는지, 시키고 있는지를 생각하면서 개발해야 합니다. 그래야 좀 더 객체지향적 프로그래밍을 할 수 있기 때문입니다. (물론 비즈니스 로직이 엄청 커지거나, 공통으로 처리되지 않는 로직으로 인한 서비스 로직에서 비즈니 스로직을 작성해야 할 때도 있습니다.)</p>\n<h1><span id=\"마치며\">마치며</span></h1>\n<p>이장에서 응용 영역을 효율적으로 관리하기 위해 <code>구분되는 기능별로 클래스</code>를 구현하는 방법을 선택하여 <code>초난감 회원가입서비스</code>를 구현했습니다. 하지만 완성된 <code>초난감 회원가입 서비스</code>는 변경에 취약하고 응집력이 떨어지는 코드였습니다. 이렇게 변경에 취약한 이유는 많은 이유가 있겠지만 가장 기본적인 캡슐화가 되어 있지 않았습니다. 캡슐화를 통해 코드의 응집력을 높이고 변경에 유연한 코드로 변경하는 작업을 했습니다.</p>\n<p>하지만 <code>초난감 회원가입 서비스</code>는 캡슐화의 문제도 문제이지만 기능의 역할 분담이 제대로 되지 않은 문제가 더 큽니다. 이 말은 책임이 적절하게 분리되지 않았다는 것을 의미합니다. 이러한 문제는 다음 part에서 좀 더 세부적으로 알아보겠습니다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>Step-04 회원가입 Service 만들기 : 응용영역 효율적으로 관리하기 - Part1</h1>\n<h1>응용 영역(서비스)</h1>\n<p>이 단계에서는 회원가입 기능을 구현하면서 <code>응용 영역</code>을 어떻게 하면 응집력 있고, 변경에 유연한 코드를 작성할지에 대해 알아볼 것입니다. 크게 아래와 같은 주제로 <code>응용영역</code>을 효율적으로 관리하는 방법에 대해 알아보겠습니다. (<strong>소프트웨어에서 변경이 유연하고, 확장가능한 코드는 아주 핵심적인 부분입니다.</strong>)</p>\n<ul>\n<li>서비스크기</li>\n<li>요구사항 정리 및 초난감 회원가입 Service 구현</li>\n<li>캡슐화</li>\n</ul>\n<h1>1. 서비스크기</h1>\n<p>드디어 회원가입을 하기 위한 signUp 서비스를 구현할 차례입니다. 먼저 회원가입 서비스 기능을 구현하기 전에 회원가입 서비스를 어느 정도의 서비스 크기로 가져갈지 생각해야합니다.</p>\n<h2>도메인의 모든 기능을 한클래스에서 구현하는 방법</h2>\n<p>먼저 책이나 일반적으로 많이 사용하는 방법인 도메인의 모든 기능을 한 클래스에 서비스에서 구현하는 방법이 있습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// MemberService.Class</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> MemberRepository memberRepository;</span><br><span class=\"line\"><span class=\"comment\">// 유저에관한 부가적인 기능을 만들기위한 수 많은 의존성 주입들</span></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Member <span class=\"title\">signUp</span><span class=\"params\">(<span class=\"keyword\">final</span> MemberSignupRequest request)</span></span>&#123; <span class=\"comment\">// 회원가입을 위한 member정보</span></span><br><span class=\"line\">    <span class=\"comment\">//비지니스로직</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 유저에 관한 기능들</span></span><br></pre></td></tr></table></figure>\n<p><strong>장점</strong> :</p>\n<ul>\n<li>하나의 클래스에 도메인과 관련된 모든 기능들이 모여 있다.</li>\n<li>1인터페이스, 1구현체로 가져가게 되면 모든 Member의 기능들이 인터페이스에 명세되는 장점 있을 수 있다.</li>\n</ul>\n<p><strong>단점</strong> :</p>\n<ul>\n<li>한 클래스에 너무 많은 기능들이 모여있어, Member 관한 모든 private 함수들이 뒤섞여 소스 분석이 힘들다.</li>\n<li>관련 없는 너무 많은 의존성들이 하나에 클래스에 주입된다.</li>\n<li>한 클래스 모든 테스트코드를 작성해야 하기 때문에 테스트 코드를 관리하기 힘들다.</li>\n<li>결국 추상화되기 위해서는 특정 기능의 서비스로 분리될 수밖에 없다.</li>\n<li>SOLID 원칙을 준수하기 위해서는 결국 메서드를 분리해낼 수밖에 없다.(이 부분은 후에 좀 더 세부적으로 설명하겠습니다.)</li>\n</ul>\n<h2>구분되는 기능별로 서비스 클래스를 구현하는방법</h2>\n<p>그리고 다른 방법은 유저 도메인의 구분되는 기능별로 서비스 클래스를 구현하는 방법이 있습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span> <span class=\"comment\">// 어노테이션을 붙이면 스프링에서 ComponentScan을 통해서 스프링 컨테이너에 자동으로 빈을등록해줌.</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span> <span class=\"comment\">// 모든 필드 변수에 대해 생성자를 만들어줌으로 모든멤버필드에 스프링 빈이 주입이 되어진다.</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MemberSignUpService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//회원가입에 필요한 의존성만 주입됨</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MemberRepository memberRepository;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MemberHelperService memberHelperService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Member <span class=\"title\">signUp</span><span class=\"params\">(<span class=\"keyword\">final</span> MemberSignupRequest request)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//회원가입 로직</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure>\n<p><strong>장점</strong> :</p>\n<ul>\n<li>유지 보수를 할 때 구분되는 기능별로 클래스가 나누어져 있기 때문에 해당 비즈니스로직에만 신경 쓸 수 있다.</li>\n<li>해당 기능에 맞는 필요한 의존성만 주입할 수 있다.</li>\n<li>테스트 코드 작성하기가 쉽다.</li>\n<li>해당 기능을 추상화하려고 해도 이미 하나의 타입으로 뽑아져있기 때문에 추상화하기가 쉽다.</li>\n</ul>\n<p><strong>단점</strong> :</p>\n<ul>\n<li>클래스가 많아진다.(단점일까… 처음엔 단점이라고 생각했는데 요즘들어 그렇게 단점은 아니라고 생각합니다.)</li>\n</ul>\n<h3>구분되는 기능별로 서비스 클래스를 구현하는방법 선택 이유</h3>\n<p>아래와 같은 이유로 <code>도메인의 모든 기능을 한 클래스 서비스</code>에서 구현하는 방법이 가지는 단점 때문에 <code>구분되는 기능별로 서비스</code> 클래스를 구현하는 방법을 선택해서 구현할 것입니다.</p>\n<ol>\n<li><strong>테스트코드들을 구분하기 어려워진다.</strong></li>\n</ol>\n<p>한 클래스에 너무 많은 기능들이 있기 때문에 이것을 한 클래스에 테스트 코드를 작성하게 되면 테스트를 구분하기가 어려워집니다. 물론 테스트 클래스만 여러 개로 나눌 수 있지만 이 또한 어떤 테스트 클래스에 어떤 테스트가 작성되었는지 찾기가 어렵습니다.<br>\n만약 <code>구분되는 기능별로 서비스 클래스를 구현하는 방법</code>으로 작성했다면 테스트 코드 또한 기능별로 나누어져 있기 때문에 쉽게 테스트 코드를 찾고 관리할 수 있습니다.</p>\n<ol start=\"2\">\n<li><strong>너무 많은 public 함수들과 private 함수들이 뒤엉켜 소스분석하기가 어렵고, 한클래스에 너무많은 의존성 주입이 된다.</strong></li>\n</ol>\n<p>너무 많은 public 함수들과 private 함수들이 뒤엉켜 소스 분석하기가 어려워집니다. 만약 <code>구분되는 기능별로 서비스 클래스를 구현하는 방법</code>으로 구현한다면 public 함수 그리고 private 함수가 모두 해당 기능에 관련 있는 함수들입니다. 뿐만 아니라 한 클래스에 너무 많은 의존성 주입이 되는 것을 막을 수 있습니다.</p>\n<ol start=\"3\">\n<li><strong>결국 추상화되어지기 위해서는 특정 기능의 서비스로 분리될수밖에 없다.</strong></li>\n</ol>\n<p>예를 들어 회원 패스워드 변경 기능, admin에 의한 패스워드 변경 기능이 있다고 해보겠습니다. 좀 더 자세히 설명하면 회원이 패스워드를 변경하기 위해서는 자신의 패스워드를 인증해야 하고 Admin은 별다른 인증 없이 회원의 패스워드를 변경할 수 있습니다. 물론 if 문으로 어드민인지 확인하고 처리할 수 있지만 계속해서 다른 역할들이 추가 될 수 있습니다. 그렇게 되면 패스워드 변경을 추상화해서 관리하는 것이 효율적일 것입니다.</p>\n<p>하지만 여기에서 MemberService 자체를 추상화시키면 패스워드 변경을 제외한 나머지 기능들은 추상화가 되지 않을 것입니다. 이것은 ISP 위반입니다.(ISP에 대해서 나중에 좀 더 자세히 알아보겠습니다.) 결국 패스워드 변경을 추상화하기 위해 <code>도메인의 모든 기능을 한 클래스</code>에서 구현하는 방법의 MemberService.class에서 분리해서 별도의 클래스로 분리하고 인터페이스를 만들어야 합니다. 반면 <code>구분되는 기능별로 서비스 클래스</code>를 구현하는 방법 기능은 이미 클래스로 분리돼 있기 때문에 쉽게 유저 패스워드 변경이라는 인터페이스에 녹아들 수 있습니다.</p>\n<h1>2. 요구사항 정리 및 초난감 회원가입 Service 구현</h1>\n<h2>요구사항 정리의 필요성</h2>\n<p>서비스 영역을 구현할 때 중요한 것은 요구 사항을 받고 요구 사항을 정리하는 것입니다. 요구 사항이 간단해 보여도 정리해야 하는데 그 이유는 아래와 같습니다.</p>\n<ul>\n<li>간단한 작업 같지만 간단하지 않을 수 있습니다. 막상 요구 사항을 정리하다 보면 생각했던 것보다 작업량이 많을 수 있고 또 미쳐 생각하지 못한 곳에 영향을 주는 작업일 수 있기 때문입니다.</li>\n<li>간단하다고 생각하고 정리하지 않고 바로 개발을 하게 되면 놓치는 부분이 발생합니다.</li>\n<li>객체의 책임들을 나눌 수 있는 좋은 명세가 될 수 있습니다.</li>\n</ul>\n<p>다음은 회원가입 기능을 구현하기 위한 요구 사항입니다.(실제 구현에서는 모바일 인증코드는 없을 예정입니다. 몇 가지 예제를 설명하기 위해 예제에만 넣었습니다.)</p>\n<p><strong>회원가입 요구사항</strong></p>\n<ol>\n<li>유저를 가입시키는 기능을 구현한다.</li>\n<li>가입을 하려면 모바일 인증을 해야 한다.</li>\n<li>중복된 이메일은 회원을 가입할 수 없다.</li>\n</ol>\n<h2>초난감 회원가입 서비스 구현</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"meta\">@AllArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MemberSignUpService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> MemberRepository memberRepository;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CodeVerificationService codeVerificationService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Member <span class=\"title\">signUp</span><span class=\"params\">(<span class=\"keyword\">final</span> MemberSignupRequest request)</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> Member duplicator = memberRepository.findByEmail(email);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(duplicator != <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MemberDuplicationException();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> CodeVerification codeVerification = codeVerificationService.findByMobile(request.getMobile()); <span class=\"comment\">// 유저가 있는지 여부를 확인할 수 있는데 인증코드 정보 객체</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(codeVerification.getAuthCode().equals(request.getAuthCode)))&#123;</span><br><span class=\"line\">            Member member = request.toMember();<span class=\"comment\">//성공</span></span><br><span class=\"line\">            memberRepository.save(member);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> member;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> MobileAuthenticationCodeFaildException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위 소스의 흐름은 이렇습니다.</p>\n<ol>\n<li>먼저 이메일이 중복되었는지 Email로 멤버를 조회하여 멤버의 존재 여부를 확인합니다.</li>\n<li>유저가 모바일 인증한 정보의 객체를 가져옵니다.</li>\n<li>유저의 모바일 정보가 인증되었는지 확인을 합니다.</li>\n<li>성공했다면 회원가입을 시킵니다.</li>\n</ol>\n<p>다음 소스는 회원가입 기능을 하는 데는 문제가 없는 소스입니다. 하지만 코드의 가독성도 떨어지고, 응집력이 떨어지고, 변경에 아주 취약한 소스입니다. 그 이유는 클래스의 역할 분담이 제대로 되지 않았고, 객체의 캡슐화가 되지 않았기 때문입니다.</p>\n<p>여기에서 말하는 역할 분담은 책임을 의미합니다. 책임을 알아보기 전에 먼저 캡슐화에 대해 알아보겠습니다.</p>\n<h1>3. 캡슐화</h1>\n<p>객체지향은 기본적으로 캡슐화를 통해 한 곳의 변화가 다른 곳에 미치는 영향을 최소화하여 변경의 유연함을 가질 수 있게 합니다. 캡슐화를 통해 응용영역을 좀 더 변경에 유연하게 만들 수 있습니다.</p>\n<blockquote>\n<ul>\n<li>캡슐화는 객체가 내부적으로 기능을 어떻게 구현하는지를 감추는것이다. 이를 통해 내부적 변경의 유연함을 주고 코드의 응집력을 높여주는 기법이다.</li>\n</ul>\n</blockquote>\n<h3>회원가입 예제코드의 문제점</h3>\n<p>캡슐화가 안되어있다는 게 무슨 말인지 먼저 알아보겠습니다. 예를 들어 패스워드 변경 기능을 위해서는 codeVerificationService에 의존하고 뿐만 아니라 다른 곳곳에서도 codeVerificationService를 사용하고 있다고 해보겠습니다. 그런데 회사 보안 정책 강화로 인증코드를 체크할 때 만료시간 체크 기능을 추가하라는 요구 사항이 들어왔습니다.</p>\n<p>이렇게 되면 애플리케이션 전체에 모바일 인증을 하는 소스를 아래와 같이 인증코드 체크, 만료 여부 체크 기능을 할 수 있는 로직으로 변경해야 합니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//PasswordChangeService</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">changePassword</span><span class=\"params\">(<span class=\"keyword\">final</span> String mobile, <span class=\"keyword\">final</span> String authCode, <span class=\"keyword\">final</span> String password)</span></span>&#123;</span><br><span class=\"line\">    CodeVerification CodeVerification = codeVerificationService.findByMobile(mobile);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(codeVerification.getAuthenticationCode.eqauls(authCode) &amp;&amp; codeVerification.getExpireDate() &lt; 현재시간)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//성공</span></span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//실패</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>만약 한 곳이라도 실수로 변경하지 않는다면 버그로 이어지게 됩니다. 운 좋게 버그 없이 이 문제를 해결하였다고 생각해보겠습니다. 그런데 갑자기 회사에서 사용자 UX를 생각해서 만료 체크 기능을 없애고 다시 원래 로직으로 변경하라는 요구를 했습니다. 이렇게 되면 다시 전방위로 소스를 수정해야 합니다. 문제는 그 사이에 모바일 인증코드가 다른 곳에 더 추가돼 있을 수 있습니다. 이렇게 되면 소스를 변경하는 과정에서 더욱더 버그가 날 확률이 커집니다. 단지 인증코드 정책 하나가 변경하는것인데 엄청난 리소스가 필요하고 전방위적으로 버그 리스크를 가져야합니다.</p>\n<p>이러한 문제는 getter에 오용과 데이터 중심적인 사고로 인해 발생하는 문제입니다. 만약 좀 더 객체지향적인 프로그래밍을 생각했었으면 이러한 문제를 만들지 않고 CodeVerification 객체 자체에 인증처리에 관한 캡슐화된 기능을 제공했었을 것입니다.</p>\n<h2>CodeVerification 객체 캡슐화하기</h2>\n<p>위에 각각의 서비스들에서 최종적으로 하고 싶은 것은 CodeVerification 객체를 통해 인증코드가 인증될 수 있는 인증코드인지 확인하는 것입니다. 내부적인 로직은 알 필요가 없습니다. 이 내용을 바탕으로 CodeVerification 객체에 verify라는 캡슐화된 메서드를 추가할 것입니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CodeVerification</span></span>&#123;</span><br><span class=\"line\">    ... <span class=\"comment\">//인증객체 다른 변수</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Timestamp expireDate;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String authCode; <span class=\"comment\">// 어떤시스템으로부터발급되어진 인증코드</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isExpired</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//expire check logic</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValidAuthCode</span><span class=\"params\">(<span class=\"keyword\">final</span> String authCode)</span></span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//auth code check logic</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">verify</span><span class=\"params\">(<span class=\"keyword\">final</span> String authCode)</span></span>&#123; <span class=\"comment\">// 클라언트로부터 입력될수있는 인증코드</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 인증코드가 만료되거나 인증코드가 맞지않으면 Exception</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이제 모든 서비스 영역들은 더 이상 모바일 인증 정책에 대해 알 필요 없이 CodeVerification에 캡슐화된 verify() 함수만 사용하면 됩니다. 예를 들어 위에서 작성한 패스워드 변경 서비스는 아래와 같이 사용할 수 있을 것입니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//PasswordChangeService</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">changePassword</span><span class=\"params\">(<span class=\"keyword\">final</span> PasswordChangeRequest request)</span></span>&#123;</span><br><span class=\"line\">    CodeVerification CodeVerification = codeVerificationService.findByMobile(request.getMobile());</span><br><span class=\"line\">    codeVerification.verify(request.getAuthCode);</span><br><span class=\"line\">    <span class=\"comment\">//패스워드 변경로직</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이제 회사에서 인증 코드에 정책이 변경된다고 해도 쉽게 그 변경에 대응할 수 있습니다. CodeVerification 객체에서만 캡슐화된 verify() 로직을 변경하면 되기 때문입니다. 객체의 캡슐화를 통해 코드의 응집력을 높이고 변경에 유연한 코드를 얻게 되었습니다.</p>\n<h2>Tell, don’t ask</h2>\n<p><code>Tell, don't ask</code>는 객체지향 및 캡슐화를 잘 표현하는 문장 같습니다. 응용영역에서 특별한 경우를 제외하고는 객체한테 묻지 말고 시키는 것이 코드의 응집력을 높입니다. 그렇지 않으면 위와 같이 변경하기 어려운 코드가 만들어지기 때문입니다.</p>\n<p>위의 <code>초난감 회원가입 서비스</code> 같은 문제를 만들지 않기 위해 항상 비즈니스로 직을 작성하면서 getter를 오용하여 데이터 중심적인 비즈니스 로직을 작성하고 있는지를 의심해봐야 합니다.</p>\n<p>또한 객체지향적인 프로그래밍을 하기 위해서 항상 자신이 객체한테 묻고 있는지, 시키고 있는지를 생각하면서 개발해야 합니다. 그래야 좀 더 객체지향적 프로그래밍을 할 수 있기 때문입니다. (물론 비즈니스 로직이 엄청 커지거나, 공통으로 처리되지 않는 로직으로 인한 서비스 로직에서 비즈니 스로직을 작성해야 할 때도 있습니다.)</p>\n<h1>마치며</h1>\n<p>이장에서 응용 영역을 효율적으로 관리하기 위해 <code>구분되는 기능별로 클래스</code>를 구현하는 방법을 선택하여 <code>초난감 회원가입서비스</code>를 구현했습니다. 하지만 완성된 <code>초난감 회원가입 서비스</code>는 변경에 취약하고 응집력이 떨어지는 코드였습니다. 이렇게 변경에 취약한 이유는 많은 이유가 있겠지만 가장 기본적인 캡슐화가 되어 있지 않았습니다. 캡슐화를 통해 코드의 응집력을 높이고 변경에 유연한 코드로 변경하는 작업을 했습니다.</p>\n<p>하지만 <code>초난감 회원가입 서비스</code>는 캡슐화의 문제도 문제이지만 기능의 역할 분담이 제대로 되지 않은 문제가 더 큽니다. 이 말은 책임이 적절하게 분리되지 않았다는 것을 의미합니다. 이러한 문제는 다음 part에서 좀 더 세부적으로 알아보겠습니다.</p>\n"},{"title":"온라인 서점 API 만들기로 살펴보는 Spring Boot OOP 6","catalog":true,"date":"2018-08-25T15:00:00.000Z","subtitle":"테스트 코드 작성하기","header-img":null,"_content":"\n# Step-05 : 테스트 코드 작성하기\n\n# 목차\n\n\n- [1. 테스트 코드의 필요성](#1-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1)\n- [2. Test code 작성 방법](#2-test-code-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95)\n    - [Junit](#junit)\n    - [Mockito](#mockito)\n- [3. Unit Test(단위 테스트)](#3-unit-test%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8)\n    - [컨트롤러 테스트(예제)](#%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%98%88%EC%A0%9C)\n    - [서비스 테스트(예제)](#%EC%84%9C%EB%B9%84%EC%8A%A4-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%98%88%EC%A0%9C)\n- [4. Integration Test(통합 테스트)](#4-integration-test%ED%86%B5%ED%95%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8)\n    - [통합테스트 예제](#%ED%86%B5%ED%95%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%98%88%EC%A0%9C)\n        - [@RunWith(SpringRunner.class)](#runwithspringrunnerclass)\n        - [@SpringBootTest](#springboottest)\n        - [MockMvc 사용하기](#mockmvc-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0)\n    - [TDD](#tdd)\n- [5. 마무리하며](#5-%EB%A7%88%EB%AC%B4%EB%A6%AC%ED%95%98%EB%A9%B0)\n\n<!-- /TOC -->\n# 테스트 코드의 필요성\n회원가입 기능을 완성했지만 기능을 테스트하기 위해서는 Postman이나 Swagger로 테스트를 하거나 프론트엔드 화면을 구성해서 테스트를 해야 합니다. 기능 테스트 하나를 해야 하더라도 Postman, Swagger, 프런론 엔드 구성을 해야 한다면 너무 불편할 것입니다. 하지만 테스트코드를 가지고 있다면 아주 간단하게 기능을 테스트해볼 수 있습니다. 이외에도 아래와 같은 장점들이 있습니다.\n\n\n* 단위 테스트로 개발한다면 스프링이 실행될 때까지 기다리지 않아도 되니까 생산성이 올라간다.\n* 테스트 코드가 있기 때문에 리팩토링을 할 때 자신감 있게 리펙토링이 가능해진다.\n* 특정 기능을 리팩토링 한 후 그 기능과 관련된 테스트 코드들이 있으면 사전에 사이드 이펙트들을 방지할 수 있다.\n* 테스트 코드를 작성하다 보면 이상하게 테스트 코드를 작성하기가 어려운 경우가 있는데 이것은 해당 기능 이상의 기능을 하고 있을 수 있다는 것을 의미한다. 이 부분을 개선해 나간다면 Decouple된 시스템을 갖게 된다.\n* 실제 서비스에 배포되기 전에 테스트 코드들을 통해 기능들을 자동 테스트할 수 있다.\n* 테스트 코드를 작성한다면 사전에 생각하지 못한 논리적인 오류들을 생각할 수 있다.\n\n\n\n# Test code 작성 방법\n테스트 코드를 작성하기 위해서는 Junit 테스팅 프레임워크와 Mockito 목 프레임워크를 이용해 테스트 코드를 작성할 것입니다. 테스트 방법은 단위 테스트와 통합 테스트 두 방법으로 나누어 테스트 코드를 작성할 것입니다. \n여기에서 단위 테스트는 퍼블릭 메서드 기능 하나를 기준으로 테스트합니다. 통합 테스트는 컨트롤러 - 서비스 - 리파지토리 영역까지 테스트를 기준으로 테스트합니다. 먼저는 Junit부터 간단히 알아보겠습니다.\n\n## Junit\nJUnit은 테스팅 프레임워크입니다. 외부에 의존 없이 자바 코드만으로 테스트를 가능하게 해주는 프레임워크입니다.\n\n## Mockito\nMockito는 자바에서 테스트를 하기 위해 Mock을 만들어주는 프레임워크입니다. Mockito은 우리가 테스트하는 과정에서 이메일이 나가지 않거나 데이터베이스와 같은 외부 시스템 데이터베이스 연결에 의존하지 않게 해주는 아주 유용한 프레임워크입니다.\n또한 Mockito는 given, when, then 절로 테스트 코드를 좀 더 직관적으로 작성할 수 있습니다. 먼저 Junit과 Mockito를 이용해 단위테스트부터 작성해보겠습니다.\n\n\n# Unit Test(단위 테스트)\n단위 테스트는 테스트하고자 하는 가장 작은 기능 단위로 테스트하는 기법을 말합니다. 단위 테스트 코드를 작성하는 이유는 가장 빠르게 최소 단위의 기능을 간단하게 테스트해볼 수 있고 정확하게 동작하는지 알 수 있습니다.\n\n또한 해당 클래스의 책임또는 기능의 단위를 잡아주는 좋은 기준이 됩니다. 테스트 코드를 작성하다 보면 이상하게 테스트 코드를 작성하기가 어려운 경우가 있습니다. 이것은 해당 기능의 책임 이상의 기능을 하고 있을 가망성이 큽니다. 그렇기 때문에 새로운 디자인을 생각하게 해줍니다.\n\n저는 개인적으로 단위 테스트는 크게 서비스 영역과 컨트롤러 영역 두개로 나눠서 테스트를 합니다. 먼저 컨트롤러 테스트 코드를 작성하겠습니다.\n\n## 컨트롤러 테스트(예제)\n단위 테스트에서는 스프링에 모든 빈들을 올릴 필요가 없습니다. 테스트하고자 하는 빈 만 등록하게 되면 훨씬 더 빠르게 테스트할 수 있습니다. 만약 기능 테스트 하나를 위해서 애플리케이션 빈들을 다 올리게 되면 엄청난 시간 낭비 일 것입니다.\n\n아래 소스는 테스트 코드를 작성하기 위해 설정하는 값에 대한 간단한 설명입니다.\n\n1. @RunWith(MockitoJUnitRunner.class)은 주어진 mock 객체들을 초기화하는 역할을 합니다.\n2. 테스트할 때 필요로 하는 Mock 객체들을 등록해줍니다. \n3. 테스트하고자 하는 클래스에 @InjectMocks을 넣어주면 Mock 객체들이 해당 클래스에 주입됩니다.\n4. 컨트롤러 객체를 전달받아 MockMvc 객체를 생성하며, 다른 스프링 빈을 올릴 필요 없이 해당 컨트롤러만 테스트 가능합니다.\n\n```java\n\n@RunWith(MockitoJUnitRunner.class) //1\npublic class MemberControllerTest {\n\n    @Mock\n    private MemberHelperService memberHelperService;//2\n\n    @InjectMocks\n    private MemberController memberController; //3\n\n    @Before\n    public void setUp() {\n        mockMvc = MockMvcBuilders //4\n                .standaloneSetup(memberController)\n                .build();\n    }\n    ...\n\n}\n```\n\n그리고 다음은 Member 컨틀롤러를 테스트하기 위한 테스트 코드입니다. 개인적으로 테스트하기 위해서 given, when, then을 정하고 순서에 맞게 작성하는 편입니다.\n|구분|설명|\n|-|-|\n|given|목데이터 또는 Request 값들을 설정합니다.|\n|when|실제 테스트 하고자하는 기능을 실행합니다.|\n|then|테스트한 결과값이 의도한값이 맞는지 검증합니다.|\n\n간단하게 아래 테스트 코드를 설명해드리겠습니다.\n\n1. 회원가입을 위해 RequestBody 값을 만든다.\n2. 컨트롤러 쪽에서 memberSignUpService를 호출할 때 Mock 데이터인 request.toMember() 값을 리턴해주는 코드입니다.\n3. 실제 MemberController에 /members POST를 호출하고 결과 값을 받습니다.\n4. 받은 값을 Mapper를 이용해 Member 클래스로 역 직렬화를 합니다.\n5. 리턴 값이 의도한 값이 맞는지 확인합니다.\n\n```java\n\n    private String TEST_EMAIL = \"test@test.com\";\n    private String TEST_PASSWORD = \"password\";\n    private String TEST_FIRST_NAME = \"test\";\n    private String TEST_LAST_NAME = \"test\";\n\n    @Test\n    public void signUpMember_SignupIsSuccess_Member() throws Exception {\n\n        //given\n        final MemberSignupRequest request = buildSignupRequest(TEST_EMAIL, TEST_PASSWORD, TEST_FIRST_NAME, TEST_LAST_NAME); //1\n        given(memberSignUpService.signUp(any())).willReturn(request.toMember()); //2\n\n        //when\n        final String memberAsString = mockMvc.perform(\n                post(\"/members\")\n                        .contentType(MediaType.APPLICATION_JSON)\n                        .content(mapper.writeValueAsString(request)))\n                .andDo(print())\n                .andExpect(status().isCreated())\n                .andReturn()\n                .getResponse()\n                .getContentAsString();//3\n        final Member member = mapper.readValue(memberAsString, Member.class); //4\n\n        //then\n        Assert.assertThat(request.getEmail(), equalTo(member.getEmail())); //5\n        Assert.assertThat(request.getName(), equalTo(member.getName()));\n    }\n\n    private MemberSignupRequest buildSignupRequest(final String email, final String password, final String firstname, final String lastname) {\n        return MemberSignupRequest.builder()\n                .email(new Email(email))\n                .password(new Password(password))\n                .name(new Name(firstname, lastname))\n                .build();\n    }\n\n```\n5번 목록을 보면 굳이 Member 클래스로 역질렬화하여 assertThat로 검증을 할 필요 없이 JsonPath() 기능을 이용해서 검증할 수 있지만 개인적으로는 String으로 테스트 코드들을 관리해야 한다는 점 때문에 클래스로 변경하여 데이터를 검증하는 편입니다.\n\nEmail이나 Name 이 같은 value 인지 체크하기 위해서는 Equals메소드를 재정의 해줘야 합니다. 그래야 같은 벨류값인지 비교를할 수 있습니다. 이러한 이유는 [여기](https://minwan1.github.io/2018/07/03/2018-07-03-equals,hashcode/)를 참조해주시면 감사하겠습니다.\n[Controller Test code](https://github.com/minwan1/online-book-store/blob/master/src/test/java/com/book/member/MemberControllerTest.java)\n\n## 서비스 테스트(예제)\n\n다음은 서비스 코드 단위 테스트 예제입니다. 여기에서는 서비스에 회원가입에 대한 로직만 정확하게 테스트하면 됩니다. 테스트 코드 작성 순서는 다음과 같습니다.\n1. memberSignUpService.signUp() 넘어올 예상되는 파라미터 값을 만듭니다.\n2. Mockito 프레임워크를 이용해 repository를 이용해 저장한 후 디비에서 리턴해줄 값을 작성합니다.\n3. 실제 memberSignUpService.signUp() 호출합니다. \n4. 실제로 memberSignUpService.signUp() 기능이 호출돼서 서비스의 비즈니스 로직이 제대로 진행돼서 memberRepository.save가 호출되었는지 확인합니다.\n5. memberSignUpService.signUp()로 처리된 이메일과 예상되는 이메일이 맞는지 확인합니다.\n\n```java\n    @Test\n    public void signUp_SignUpIsSuccess_Member() {\n\n        //given\n        final MemberSignupRequest request = buildRequest(TEST_EMAIL); //1\n        given(memberRepository.save(any(Member.class))).willReturn(request.toMember()); //2\n\n        //when\n        final Member member = memberSignUpService.signUp(request); //3\n\n        //then \n        Mockito.verify(memberRepository, atLeast(1)).save(any(Member.class)); //4\n        Assert.assertThat(member.getEmail(), is(request.getEmail()));//5\n\n    } \n```\n\n[Service Test code](https://github.com/minwan1/online-book-store/blob/master/src/test/java/com/book/member/service/MemberSignUpServiceTest.java)\n\n# 4. Integration Test(통합 테스트)\n통합 테스트는 단위 테스트보다는 덜 빈번하게 실행되면서 세세한 API 수준의 검증보다는 모듈 단위의 상호 연동이 문제가 없는지 검증하는 것이 주 목적입니다. 위에서 각각의 모듈 별로 단위 테스트를 성공했음에도 이것들을 하나로 결합해서 테스트를 하는 과정에서 테스트가 실패할 수도 있습니다. 예를 들어 데이터베이스 제약조건 등에 문제, 다른 클래스에 의존하고 있는 클래스들이 제대로 연결되었는지 등이 예일 수 있습니다.\n\n## 통합테스트 예제\n다음은 단위 테스트와 다르게 아래의 두 개의 어노테이션을 붙여주셔야 합니다. 위에 단위 테스트는 해당 클래스 하나만 테스트하면 됐지만 통합 테스트 같은 경우 테스트하고자 하는 모듈들이 모두 연결되어 있어야 하기 때문에 애플리케이션에 모든 빈들을 등록해서 테스트합니다.\n\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class MemberControllerIntegrationTest {\n```\n\n### @RunWith(SpringRunner.class)\nSpringJUnit4ClassRunner를 상속받은 SpringRunner 클래스는 SpringBootTest 의 설정돼있는 정보들을 이용해서 스프링 컨테이너를 생성한다. 그리고 Test 클래스에 있는 필드에 있는 변수들에 맞는 클래스를 의존성 주입을 해준다.\n\n### @SpringBootTest\n@SpringBootTest은 프로젝트에 어플리케이션빈들은 등록해주는 역할을 한다. 반드시 위에 @RunWith(SpringRunner.class)과 같이 사용해줘야 한다.\n\n\n### MockMvc 사용하기\n아래의 소스와 같이 단위 테스트와 달리 스프링 웹 애플리케이션을 빈을 주입받고 그것을 기반으로 MockMvc를 만들어줘야 합니다. 이렇게 설정을 하고 실제 API를 호출하게 되면 각 레이어들이 연결된 기능을 테스트해볼 수 있습니다.\n\n```java\n    @Autowired\n    private WebApplicationContext webApplicationContext;\n\n    @Before\n    public void setUp() throws Exception {\n        mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext)\n                .build();\n    }\n```\nMvc 설정을 했으면 이제 실제 테스트 코드를 작성해야 합니다. 순서를 설명해드리면 다음과 같습니다.\n1. 회원가입 API를 호출하면 데이터베이스 회원정보가 insert 될 것 입니다. 하지만 test 코드에서 @Transactional 붙이면 테스트코드 실행 후 insert 됐던 데이터가가 롤백이 됩니다.\n2. 회원가입을 하기 위해 필요한 RequestBody 값을 만든다.\n3. 실제 회원가입 URL을 호출한다.\n4. 결과값을 Member 클래스로 변경한다.\n5. 결과값이 테스트 의도한값이 맞는지 확인한다.\n\n```java\n\n    @Test\n    @Transactional//1\n    public void signUpMember_SignupIsSuccess_Member() throws Exception {\n\n        //given\n        final MemberSignupRequest request = buildSignupRequest(TEST_EMAIL, TEST_PASSWORD, TEST_FIRST_NAME, TEST_LAST_NAME); //2\n\n        //when\n        final String memberAsString = mockMvc.perform(\n                post(\"/members\")\n                        .contentType(MediaType.APPLICATION_JSON)\n                        .content(mapper.writeValueAsString(request)))\n                .andDo(print())\n                .andExpect(status().isCreated())\n                .andReturn()\n                .getResponse()\n                .getContentAsString(); //3\n        final Member member = mapper.readValue(memberAsString, Member.class); //4\n\n        //then\n        Assert.assertThat(request.getEmail(), is(member.getEmail()));//5\n        Assert.assertThat(request.getName(), is(member.getName()));\n    }\n\n    private MemberSignupRequest buildSignupRequest(final String email, final String password, final String firstname, final String lastname) {\n        return MemberSignupRequest.builder()\n                .email(new Email(email))\n                .password(new Password(password))\n                .name(new Name(firstname, lastname))\n                .build();\n    }\n\n```\n\n[Integration Test code](https://github.com/minwan1/online-book-store/blob/master/src/test/java/com/book/member/MemberControllerIntegrationTest.java)\n\n## TDD\nTDD란 테스트 코드를 먼저 작성하고 기능을 구현하고 또 이것을 리팩 토핑 하고 이것을 반복해서 기능을 만드는 개발 방법론을 말합니다. 테스트 주도 개발을 하게 되면 장점은 테스트 코드 하기 좋은 코드를 만들게 된다는 것입니다. 테스트 코드가 작성하기 좋은 코드의 의미는 해당 메서드나 클래스가 하나의 기능 혹은 책임만을 하고 있다는 것을 의미합니다. 이렇듯 테스트 주도 개발을 하게 되면 자연스럽게 Decouple된 객체지향 설계를 할 수 있게 되고 자연스럽게 테스트 코드들을 얻을 수 있습니다. 그렇게 되면 처음에 말했던 테스트 코드의 장점들을 얻게 됩니다.\n\n\n\n\n# 5. 마무리하며\n회원가입에 관련된 테스트 코드들을 완성했습니다. 이제 회원가입의 기능을 테스트를 하기 위해서 Swagger나 프론트엔드 화면이 필요하지 않습니다. 테스트 코드들로 테스트가 가능하기 때문입니다. 또한 테스트 코드는 좋은 문서또는 커뮤니케이션 도구가 될 수 있습니다. 예를 들어 다른 개발자가 SMS 인증 기능이 필요해서 SMS 인증 기능을 만든 개발자한테 기능을 요구했으면 SMS 기능 개발자는 단순 문서나 설명만 해주기보다는 테스트 코드를 준다면 좀 더 효율적으로 커뮤니케이션을 할 수 있을것입니다.\n\n참고\n* [백명석님 강의](https://www.youtube.com/watch?v=60lLSe1phks&list=PLuLb6MC4SOvXCRePHrb4e-EYadjZ9KHyH)","source":"_posts/2018-08-26-spring-book-6.md","raw":"---\ntitle: 온라인 서점 API 만들기로 살펴보는 Spring Boot OOP 6\ncatalog: true\ndate: 2018-08-26\nsubtitle: 테스트 코드 작성하기\nheader-img:\ntags:\n- Java\n- Spring\n- 온라인 서점 API 만들기로 살펴보는 Spring Boot OOP\n\n\n---\n\n# Step-05 : 테스트 코드 작성하기\n\n# 목차\n\n\n- [1. 테스트 코드의 필요성](#1-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1)\n- [2. Test code 작성 방법](#2-test-code-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95)\n    - [Junit](#junit)\n    - [Mockito](#mockito)\n- [3. Unit Test(단위 테스트)](#3-unit-test%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8)\n    - [컨트롤러 테스트(예제)](#%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%98%88%EC%A0%9C)\n    - [서비스 테스트(예제)](#%EC%84%9C%EB%B9%84%EC%8A%A4-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%98%88%EC%A0%9C)\n- [4. Integration Test(통합 테스트)](#4-integration-test%ED%86%B5%ED%95%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8)\n    - [통합테스트 예제](#%ED%86%B5%ED%95%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%98%88%EC%A0%9C)\n        - [@RunWith(SpringRunner.class)](#runwithspringrunnerclass)\n        - [@SpringBootTest](#springboottest)\n        - [MockMvc 사용하기](#mockmvc-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0)\n    - [TDD](#tdd)\n- [5. 마무리하며](#5-%EB%A7%88%EB%AC%B4%EB%A6%AC%ED%95%98%EB%A9%B0)\n\n<!-- /TOC -->\n# 테스트 코드의 필요성\n회원가입 기능을 완성했지만 기능을 테스트하기 위해서는 Postman이나 Swagger로 테스트를 하거나 프론트엔드 화면을 구성해서 테스트를 해야 합니다. 기능 테스트 하나를 해야 하더라도 Postman, Swagger, 프런론 엔드 구성을 해야 한다면 너무 불편할 것입니다. 하지만 테스트코드를 가지고 있다면 아주 간단하게 기능을 테스트해볼 수 있습니다. 이외에도 아래와 같은 장점들이 있습니다.\n\n\n* 단위 테스트로 개발한다면 스프링이 실행될 때까지 기다리지 않아도 되니까 생산성이 올라간다.\n* 테스트 코드가 있기 때문에 리팩토링을 할 때 자신감 있게 리펙토링이 가능해진다.\n* 특정 기능을 리팩토링 한 후 그 기능과 관련된 테스트 코드들이 있으면 사전에 사이드 이펙트들을 방지할 수 있다.\n* 테스트 코드를 작성하다 보면 이상하게 테스트 코드를 작성하기가 어려운 경우가 있는데 이것은 해당 기능 이상의 기능을 하고 있을 수 있다는 것을 의미한다. 이 부분을 개선해 나간다면 Decouple된 시스템을 갖게 된다.\n* 실제 서비스에 배포되기 전에 테스트 코드들을 통해 기능들을 자동 테스트할 수 있다.\n* 테스트 코드를 작성한다면 사전에 생각하지 못한 논리적인 오류들을 생각할 수 있다.\n\n\n\n# Test code 작성 방법\n테스트 코드를 작성하기 위해서는 Junit 테스팅 프레임워크와 Mockito 목 프레임워크를 이용해 테스트 코드를 작성할 것입니다. 테스트 방법은 단위 테스트와 통합 테스트 두 방법으로 나누어 테스트 코드를 작성할 것입니다. \n여기에서 단위 테스트는 퍼블릭 메서드 기능 하나를 기준으로 테스트합니다. 통합 테스트는 컨트롤러 - 서비스 - 리파지토리 영역까지 테스트를 기준으로 테스트합니다. 먼저는 Junit부터 간단히 알아보겠습니다.\n\n## Junit\nJUnit은 테스팅 프레임워크입니다. 외부에 의존 없이 자바 코드만으로 테스트를 가능하게 해주는 프레임워크입니다.\n\n## Mockito\nMockito는 자바에서 테스트를 하기 위해 Mock을 만들어주는 프레임워크입니다. Mockito은 우리가 테스트하는 과정에서 이메일이 나가지 않거나 데이터베이스와 같은 외부 시스템 데이터베이스 연결에 의존하지 않게 해주는 아주 유용한 프레임워크입니다.\n또한 Mockito는 given, when, then 절로 테스트 코드를 좀 더 직관적으로 작성할 수 있습니다. 먼저 Junit과 Mockito를 이용해 단위테스트부터 작성해보겠습니다.\n\n\n# Unit Test(단위 테스트)\n단위 테스트는 테스트하고자 하는 가장 작은 기능 단위로 테스트하는 기법을 말합니다. 단위 테스트 코드를 작성하는 이유는 가장 빠르게 최소 단위의 기능을 간단하게 테스트해볼 수 있고 정확하게 동작하는지 알 수 있습니다.\n\n또한 해당 클래스의 책임또는 기능의 단위를 잡아주는 좋은 기준이 됩니다. 테스트 코드를 작성하다 보면 이상하게 테스트 코드를 작성하기가 어려운 경우가 있습니다. 이것은 해당 기능의 책임 이상의 기능을 하고 있을 가망성이 큽니다. 그렇기 때문에 새로운 디자인을 생각하게 해줍니다.\n\n저는 개인적으로 단위 테스트는 크게 서비스 영역과 컨트롤러 영역 두개로 나눠서 테스트를 합니다. 먼저 컨트롤러 테스트 코드를 작성하겠습니다.\n\n## 컨트롤러 테스트(예제)\n단위 테스트에서는 스프링에 모든 빈들을 올릴 필요가 없습니다. 테스트하고자 하는 빈 만 등록하게 되면 훨씬 더 빠르게 테스트할 수 있습니다. 만약 기능 테스트 하나를 위해서 애플리케이션 빈들을 다 올리게 되면 엄청난 시간 낭비 일 것입니다.\n\n아래 소스는 테스트 코드를 작성하기 위해 설정하는 값에 대한 간단한 설명입니다.\n\n1. @RunWith(MockitoJUnitRunner.class)은 주어진 mock 객체들을 초기화하는 역할을 합니다.\n2. 테스트할 때 필요로 하는 Mock 객체들을 등록해줍니다. \n3. 테스트하고자 하는 클래스에 @InjectMocks을 넣어주면 Mock 객체들이 해당 클래스에 주입됩니다.\n4. 컨트롤러 객체를 전달받아 MockMvc 객체를 생성하며, 다른 스프링 빈을 올릴 필요 없이 해당 컨트롤러만 테스트 가능합니다.\n\n```java\n\n@RunWith(MockitoJUnitRunner.class) //1\npublic class MemberControllerTest {\n\n    @Mock\n    private MemberHelperService memberHelperService;//2\n\n    @InjectMocks\n    private MemberController memberController; //3\n\n    @Before\n    public void setUp() {\n        mockMvc = MockMvcBuilders //4\n                .standaloneSetup(memberController)\n                .build();\n    }\n    ...\n\n}\n```\n\n그리고 다음은 Member 컨틀롤러를 테스트하기 위한 테스트 코드입니다. 개인적으로 테스트하기 위해서 given, when, then을 정하고 순서에 맞게 작성하는 편입니다.\n|구분|설명|\n|-|-|\n|given|목데이터 또는 Request 값들을 설정합니다.|\n|when|실제 테스트 하고자하는 기능을 실행합니다.|\n|then|테스트한 결과값이 의도한값이 맞는지 검증합니다.|\n\n간단하게 아래 테스트 코드를 설명해드리겠습니다.\n\n1. 회원가입을 위해 RequestBody 값을 만든다.\n2. 컨트롤러 쪽에서 memberSignUpService를 호출할 때 Mock 데이터인 request.toMember() 값을 리턴해주는 코드입니다.\n3. 실제 MemberController에 /members POST를 호출하고 결과 값을 받습니다.\n4. 받은 값을 Mapper를 이용해 Member 클래스로 역 직렬화를 합니다.\n5. 리턴 값이 의도한 값이 맞는지 확인합니다.\n\n```java\n\n    private String TEST_EMAIL = \"test@test.com\";\n    private String TEST_PASSWORD = \"password\";\n    private String TEST_FIRST_NAME = \"test\";\n    private String TEST_LAST_NAME = \"test\";\n\n    @Test\n    public void signUpMember_SignupIsSuccess_Member() throws Exception {\n\n        //given\n        final MemberSignupRequest request = buildSignupRequest(TEST_EMAIL, TEST_PASSWORD, TEST_FIRST_NAME, TEST_LAST_NAME); //1\n        given(memberSignUpService.signUp(any())).willReturn(request.toMember()); //2\n\n        //when\n        final String memberAsString = mockMvc.perform(\n                post(\"/members\")\n                        .contentType(MediaType.APPLICATION_JSON)\n                        .content(mapper.writeValueAsString(request)))\n                .andDo(print())\n                .andExpect(status().isCreated())\n                .andReturn()\n                .getResponse()\n                .getContentAsString();//3\n        final Member member = mapper.readValue(memberAsString, Member.class); //4\n\n        //then\n        Assert.assertThat(request.getEmail(), equalTo(member.getEmail())); //5\n        Assert.assertThat(request.getName(), equalTo(member.getName()));\n    }\n\n    private MemberSignupRequest buildSignupRequest(final String email, final String password, final String firstname, final String lastname) {\n        return MemberSignupRequest.builder()\n                .email(new Email(email))\n                .password(new Password(password))\n                .name(new Name(firstname, lastname))\n                .build();\n    }\n\n```\n5번 목록을 보면 굳이 Member 클래스로 역질렬화하여 assertThat로 검증을 할 필요 없이 JsonPath() 기능을 이용해서 검증할 수 있지만 개인적으로는 String으로 테스트 코드들을 관리해야 한다는 점 때문에 클래스로 변경하여 데이터를 검증하는 편입니다.\n\nEmail이나 Name 이 같은 value 인지 체크하기 위해서는 Equals메소드를 재정의 해줘야 합니다. 그래야 같은 벨류값인지 비교를할 수 있습니다. 이러한 이유는 [여기](https://minwan1.github.io/2018/07/03/2018-07-03-equals,hashcode/)를 참조해주시면 감사하겠습니다.\n[Controller Test code](https://github.com/minwan1/online-book-store/blob/master/src/test/java/com/book/member/MemberControllerTest.java)\n\n## 서비스 테스트(예제)\n\n다음은 서비스 코드 단위 테스트 예제입니다. 여기에서는 서비스에 회원가입에 대한 로직만 정확하게 테스트하면 됩니다. 테스트 코드 작성 순서는 다음과 같습니다.\n1. memberSignUpService.signUp() 넘어올 예상되는 파라미터 값을 만듭니다.\n2. Mockito 프레임워크를 이용해 repository를 이용해 저장한 후 디비에서 리턴해줄 값을 작성합니다.\n3. 실제 memberSignUpService.signUp() 호출합니다. \n4. 실제로 memberSignUpService.signUp() 기능이 호출돼서 서비스의 비즈니스 로직이 제대로 진행돼서 memberRepository.save가 호출되었는지 확인합니다.\n5. memberSignUpService.signUp()로 처리된 이메일과 예상되는 이메일이 맞는지 확인합니다.\n\n```java\n    @Test\n    public void signUp_SignUpIsSuccess_Member() {\n\n        //given\n        final MemberSignupRequest request = buildRequest(TEST_EMAIL); //1\n        given(memberRepository.save(any(Member.class))).willReturn(request.toMember()); //2\n\n        //when\n        final Member member = memberSignUpService.signUp(request); //3\n\n        //then \n        Mockito.verify(memberRepository, atLeast(1)).save(any(Member.class)); //4\n        Assert.assertThat(member.getEmail(), is(request.getEmail()));//5\n\n    } \n```\n\n[Service Test code](https://github.com/minwan1/online-book-store/blob/master/src/test/java/com/book/member/service/MemberSignUpServiceTest.java)\n\n# 4. Integration Test(통합 테스트)\n통합 테스트는 단위 테스트보다는 덜 빈번하게 실행되면서 세세한 API 수준의 검증보다는 모듈 단위의 상호 연동이 문제가 없는지 검증하는 것이 주 목적입니다. 위에서 각각의 모듈 별로 단위 테스트를 성공했음에도 이것들을 하나로 결합해서 테스트를 하는 과정에서 테스트가 실패할 수도 있습니다. 예를 들어 데이터베이스 제약조건 등에 문제, 다른 클래스에 의존하고 있는 클래스들이 제대로 연결되었는지 등이 예일 수 있습니다.\n\n## 통합테스트 예제\n다음은 단위 테스트와 다르게 아래의 두 개의 어노테이션을 붙여주셔야 합니다. 위에 단위 테스트는 해당 클래스 하나만 테스트하면 됐지만 통합 테스트 같은 경우 테스트하고자 하는 모듈들이 모두 연결되어 있어야 하기 때문에 애플리케이션에 모든 빈들을 등록해서 테스트합니다.\n\n```java\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class MemberControllerIntegrationTest {\n```\n\n### @RunWith(SpringRunner.class)\nSpringJUnit4ClassRunner를 상속받은 SpringRunner 클래스는 SpringBootTest 의 설정돼있는 정보들을 이용해서 스프링 컨테이너를 생성한다. 그리고 Test 클래스에 있는 필드에 있는 변수들에 맞는 클래스를 의존성 주입을 해준다.\n\n### @SpringBootTest\n@SpringBootTest은 프로젝트에 어플리케이션빈들은 등록해주는 역할을 한다. 반드시 위에 @RunWith(SpringRunner.class)과 같이 사용해줘야 한다.\n\n\n### MockMvc 사용하기\n아래의 소스와 같이 단위 테스트와 달리 스프링 웹 애플리케이션을 빈을 주입받고 그것을 기반으로 MockMvc를 만들어줘야 합니다. 이렇게 설정을 하고 실제 API를 호출하게 되면 각 레이어들이 연결된 기능을 테스트해볼 수 있습니다.\n\n```java\n    @Autowired\n    private WebApplicationContext webApplicationContext;\n\n    @Before\n    public void setUp() throws Exception {\n        mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext)\n                .build();\n    }\n```\nMvc 설정을 했으면 이제 실제 테스트 코드를 작성해야 합니다. 순서를 설명해드리면 다음과 같습니다.\n1. 회원가입 API를 호출하면 데이터베이스 회원정보가 insert 될 것 입니다. 하지만 test 코드에서 @Transactional 붙이면 테스트코드 실행 후 insert 됐던 데이터가가 롤백이 됩니다.\n2. 회원가입을 하기 위해 필요한 RequestBody 값을 만든다.\n3. 실제 회원가입 URL을 호출한다.\n4. 결과값을 Member 클래스로 변경한다.\n5. 결과값이 테스트 의도한값이 맞는지 확인한다.\n\n```java\n\n    @Test\n    @Transactional//1\n    public void signUpMember_SignupIsSuccess_Member() throws Exception {\n\n        //given\n        final MemberSignupRequest request = buildSignupRequest(TEST_EMAIL, TEST_PASSWORD, TEST_FIRST_NAME, TEST_LAST_NAME); //2\n\n        //when\n        final String memberAsString = mockMvc.perform(\n                post(\"/members\")\n                        .contentType(MediaType.APPLICATION_JSON)\n                        .content(mapper.writeValueAsString(request)))\n                .andDo(print())\n                .andExpect(status().isCreated())\n                .andReturn()\n                .getResponse()\n                .getContentAsString(); //3\n        final Member member = mapper.readValue(memberAsString, Member.class); //4\n\n        //then\n        Assert.assertThat(request.getEmail(), is(member.getEmail()));//5\n        Assert.assertThat(request.getName(), is(member.getName()));\n    }\n\n    private MemberSignupRequest buildSignupRequest(final String email, final String password, final String firstname, final String lastname) {\n        return MemberSignupRequest.builder()\n                .email(new Email(email))\n                .password(new Password(password))\n                .name(new Name(firstname, lastname))\n                .build();\n    }\n\n```\n\n[Integration Test code](https://github.com/minwan1/online-book-store/blob/master/src/test/java/com/book/member/MemberControllerIntegrationTest.java)\n\n## TDD\nTDD란 테스트 코드를 먼저 작성하고 기능을 구현하고 또 이것을 리팩 토핑 하고 이것을 반복해서 기능을 만드는 개발 방법론을 말합니다. 테스트 주도 개발을 하게 되면 장점은 테스트 코드 하기 좋은 코드를 만들게 된다는 것입니다. 테스트 코드가 작성하기 좋은 코드의 의미는 해당 메서드나 클래스가 하나의 기능 혹은 책임만을 하고 있다는 것을 의미합니다. 이렇듯 테스트 주도 개발을 하게 되면 자연스럽게 Decouple된 객체지향 설계를 할 수 있게 되고 자연스럽게 테스트 코드들을 얻을 수 있습니다. 그렇게 되면 처음에 말했던 테스트 코드의 장점들을 얻게 됩니다.\n\n\n\n\n# 5. 마무리하며\n회원가입에 관련된 테스트 코드들을 완성했습니다. 이제 회원가입의 기능을 테스트를 하기 위해서 Swagger나 프론트엔드 화면이 필요하지 않습니다. 테스트 코드들로 테스트가 가능하기 때문입니다. 또한 테스트 코드는 좋은 문서또는 커뮤니케이션 도구가 될 수 있습니다. 예를 들어 다른 개발자가 SMS 인증 기능이 필요해서 SMS 인증 기능을 만든 개발자한테 기능을 요구했으면 SMS 기능 개발자는 단순 문서나 설명만 해주기보다는 테스트 코드를 준다면 좀 더 효율적으로 커뮤니케이션을 할 수 있을것입니다.\n\n참고\n* [백명석님 강의](https://www.youtube.com/watch?v=60lLSe1phks&list=PLuLb6MC4SOvXCRePHrb4e-EYadjZ9KHyH)","slug":"2018-08-26-spring-book-6","published":1,"updated":"2018-08-26T14:50:40.425Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27em003vjjpehhl5xbg2","content":"<h1><span id=\"step-05-테스트-코드-작성하기\">Step-05 : 테스트 코드 작성하기</span></h1>\n<h1><span id=\"목차\">목차</span></h1>\n<ul>\n<li><a href=\"#1-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1\">1. 테스트 코드의 필요성</a></li>\n<li><a href=\"#2-test-code-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95\">2. Test code 작성 방법</a>\n<ul>\n<li><a href=\"#junit\">Junit</a></li>\n<li><a href=\"#mockito\">Mockito</a></li>\n</ul>\n</li>\n<li><a href=\"#3-unit-test%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8\">3. Unit Test(단위 테스트)</a>\n<ul>\n<li><a href=\"#%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%98%88%EC%A0%9C\">컨트롤러 테스트(예제)</a></li>\n<li><a href=\"#%EC%84%9C%EB%B9%84%EC%8A%A4-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%98%88%EC%A0%9C\">서비스 테스트(예제)</a></li>\n</ul>\n</li>\n<li><a href=\"#4-integration-test%ED%86%B5%ED%95%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8\">4. Integration Test(통합 테스트)</a>\n<ul>\n<li><a href=\"#%ED%86%B5%ED%95%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%98%88%EC%A0%9C\">통합테스트 예제</a>\n<ul>\n<li><a href=\"#runwithspringrunnerclass\">@RunWith(SpringRunner.class)</a></li>\n<li><a href=\"#springboottest\">@SpringBootTest</a></li>\n<li><a href=\"#mockmvc-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\">MockMvc 사용하기</a></li>\n</ul>\n</li>\n<li><a href=\"#tdd\">TDD</a></li>\n</ul>\n</li>\n<li><a href=\"#5-%EB%A7%88%EB%AC%B4%EB%A6%AC%ED%95%98%EB%A9%B0\">5. 마무리하며</a></li>\n</ul>\n<!-- /TOC -->\n<h1><span id=\"테스트-코드의-필요성\">테스트 코드의 필요성</span></h1>\n<p>회원가입 기능을 완성했지만 기능을 테스트하기 위해서는 Postman이나 Swagger로 테스트를 하거나 프론트엔드 화면을 구성해서 테스트를 해야 합니다. 기능 테스트 하나를 해야 하더라도 Postman, Swagger, 프런론 엔드 구성을 해야 한다면 너무 불편할 것입니다. 하지만 테스트코드를 가지고 있다면 아주 간단하게 기능을 테스트해볼 수 있습니다. 이외에도 아래와 같은 장점들이 있습니다.</p>\n<ul>\n<li>단위 테스트로 개발한다면 스프링이 실행될 때까지 기다리지 않아도 되니까 생산성이 올라간다.</li>\n<li>테스트 코드가 있기 때문에 리팩토링을 할 때 자신감 있게 리펙토링이 가능해진다.</li>\n<li>특정 기능을 리팩토링 한 후 그 기능과 관련된 테스트 코드들이 있으면 사전에 사이드 이펙트들을 방지할 수 있다.</li>\n<li>테스트 코드를 작성하다 보면 이상하게 테스트 코드를 작성하기가 어려운 경우가 있는데 이것은 해당 기능 이상의 기능을 하고 있을 수 있다는 것을 의미한다. 이 부분을 개선해 나간다면 Decouple된 시스템을 갖게 된다.</li>\n<li>실제 서비스에 배포되기 전에 테스트 코드들을 통해 기능들을 자동 테스트할 수 있다.</li>\n<li>테스트 코드를 작성한다면 사전에 생각하지 못한 논리적인 오류들을 생각할 수 있다.</li>\n</ul>\n<h1><span id=\"test-code-작성-방법\">Test code 작성 방법</span></h1>\n<p>테스트 코드를 작성하기 위해서는 Junit 테스팅 프레임워크와 Mockito 목 프레임워크를 이용해 테스트 코드를 작성할 것입니다. 테스트 방법은 단위 테스트와 통합 테스트 두 방법으로 나누어 테스트 코드를 작성할 것입니다.<br>\n여기에서 단위 테스트는 퍼블릭 메서드 기능 하나를 기준으로 테스트합니다. 통합 테스트는 컨트롤러 - 서비스 - 리파지토리 영역까지 테스트를 기준으로 테스트합니다. 먼저는 Junit부터 간단히 알아보겠습니다.</p>\n<h2><span id=\"junit\">Junit</span></h2>\n<p>JUnit은 테스팅 프레임워크입니다. 외부에 의존 없이 자바 코드만으로 테스트를 가능하게 해주는 프레임워크입니다.</p>\n<h2><span id=\"mockito\">Mockito</span></h2>\n<p>Mockito는 자바에서 테스트를 하기 위해 Mock을 만들어주는 프레임워크입니다. Mockito은 우리가 테스트하는 과정에서 이메일이 나가지 않거나 데이터베이스와 같은 외부 시스템 데이터베이스 연결에 의존하지 않게 해주는 아주 유용한 프레임워크입니다.<br>\n또한 Mockito는 given, when, then 절로 테스트 코드를 좀 더 직관적으로 작성할 수 있습니다. 먼저 Junit과 Mockito를 이용해 단위테스트부터 작성해보겠습니다.</p>\n<h1><span id=\"unit-test단위-테스트\">Unit Test(단위 테스트)</span></h1>\n<p>단위 테스트는 테스트하고자 하는 가장 작은 기능 단위로 테스트하는 기법을 말합니다. 단위 테스트 코드를 작성하는 이유는 가장 빠르게 최소 단위의 기능을 간단하게 테스트해볼 수 있고 정확하게 동작하는지 알 수 있습니다.</p>\n<p>또한 해당 클래스의 책임또는 기능의 단위를 잡아주는 좋은 기준이 됩니다. 테스트 코드를 작성하다 보면 이상하게 테스트 코드를 작성하기가 어려운 경우가 있습니다. 이것은 해당 기능의 책임 이상의 기능을 하고 있을 가망성이 큽니다. 그렇기 때문에 새로운 디자인을 생각하게 해줍니다.</p>\n<p>저는 개인적으로 단위 테스트는 크게 서비스 영역과 컨트롤러 영역 두개로 나눠서 테스트를 합니다. 먼저 컨트롤러 테스트 코드를 작성하겠습니다.</p>\n<h2><span id=\"컨트롤러-테스트예제\">컨트롤러 테스트(예제)</span></h2>\n<p>단위 테스트에서는 스프링에 모든 빈들을 올릴 필요가 없습니다. 테스트하고자 하는 빈 만 등록하게 되면 훨씬 더 빠르게 테스트할 수 있습니다. 만약 기능 테스트 하나를 위해서 애플리케이션 빈들을 다 올리게 되면 엄청난 시간 낭비 일 것입니다.</p>\n<p>아래 소스는 테스트 코드를 작성하기 위해 설정하는 값에 대한 간단한 설명입니다.</p>\n<ol>\n<li>@RunWith(MockitoJUnitRunner.class)은 주어진 mock 객체들을 초기화하는 역할을 합니다.</li>\n<li>테스트할 때 필요로 하는 Mock 객체들을 등록해줍니다.</li>\n<li>테스트하고자 하는 클래스에 @InjectMocks을 넣어주면 Mock 객체들이 해당 클래스에 주입됩니다.</li>\n<li>컨트롤러 객체를 전달받아 MockMvc 객체를 생성하며, 다른 스프링 빈을 올릴 필요 없이 해당 컨트롤러만 테스트 가능합니다.</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RunWith</span>(MockitoJUnitRunner.class) <span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MemberControllerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Mock</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MemberHelperService memberHelperService;<span class=\"comment\">//2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@InjectMocks</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MemberController memberController; <span class=\"comment\">//3</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUp</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        mockMvc = MockMvcBuilders <span class=\"comment\">//4</span></span><br><span class=\"line\">                .standaloneSetup(memberController)</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그리고 다음은 Member 컨틀롤러를 테스트하기 위한 테스트 코드입니다. 개인적으로 테스트하기 위해서 given, when, then을 정하고 순서에 맞게 작성하는 편입니다.</p>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>given</td>\n<td>목데이터 또는 Request 값들을 설정합니다.</td>\n</tr>\n<tr>\n<td>when</td>\n<td>실제 테스트 하고자하는 기능을 실행합니다.</td>\n</tr>\n<tr>\n<td>then</td>\n<td>테스트한 결과값이 의도한값이 맞는지 검증합니다.</td>\n</tr>\n</tbody>\n</table>\n<p>간단하게 아래 테스트 코드를 설명해드리겠습니다.</p>\n<ol>\n<li>회원가입을 위해 RequestBody 값을 만든다.</li>\n<li>컨트롤러 쪽에서 memberSignUpService를 호출할 때 Mock 데이터인 request.toMember() 값을 리턴해주는 코드입니다.</li>\n<li>실제 MemberController에 /members POST를 호출하고 결과 값을 받습니다.</li>\n<li>받은 값을 Mapper를 이용해 Member 클래스로 역 직렬화를 합니다.</li>\n<li>리턴 값이 의도한 값이 맞는지 확인합니다.</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> String TEST_EMAIL = <span class=\"string\">\"test@test.com\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> String TEST_PASSWORD = <span class=\"string\">\"password\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> String TEST_FIRST_NAME = <span class=\"string\">\"test\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> String TEST_LAST_NAME = <span class=\"string\">\"test\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">signUpMember_SignupIsSuccess_Member</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//given</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> MemberSignupRequest request = buildSignupRequest(TEST_EMAIL, TEST_PASSWORD, TEST_FIRST_NAME, TEST_LAST_NAME); <span class=\"comment\">//1</span></span><br><span class=\"line\">    given(memberSignUpService.signUp(any())).willReturn(request.toMember()); <span class=\"comment\">//2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//when</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String memberAsString = mockMvc.perform(</span><br><span class=\"line\">            post(<span class=\"string\">\"/members\"</span>)</span><br><span class=\"line\">                    .contentType(MediaType.APPLICATION_JSON)</span><br><span class=\"line\">                    .content(mapper.writeValueAsString(request)))</span><br><span class=\"line\">            .andDo(print())</span><br><span class=\"line\">            .andExpect(status().isCreated())</span><br><span class=\"line\">            .andReturn()</span><br><span class=\"line\">            .getResponse()</span><br><span class=\"line\">            .getContentAsString();<span class=\"comment\">//3</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Member member = mapper.readValue(memberAsString, Member.class); <span class=\"comment\">//4</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//then</span></span><br><span class=\"line\">    Assert.assertThat(request.getEmail(), equalTo(member.getEmail())); <span class=\"comment\">//5</span></span><br><span class=\"line\">    Assert.assertThat(request.getName(), equalTo(member.getName()));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> MemberSignupRequest <span class=\"title\">buildSignupRequest</span><span class=\"params\">(<span class=\"keyword\">final</span> String email, <span class=\"keyword\">final</span> String password, <span class=\"keyword\">final</span> String firstname, <span class=\"keyword\">final</span> String lastname)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MemberSignupRequest.builder()</span><br><span class=\"line\">            .email(<span class=\"keyword\">new</span> Email(email))</span><br><span class=\"line\">            .password(<span class=\"keyword\">new</span> Password(password))</span><br><span class=\"line\">            .name(<span class=\"keyword\">new</span> Name(firstname, lastname))</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>5번 목록을 보면 굳이 Member 클래스로 역질렬화하여 assertThat로 검증을 할 필요 없이 JsonPath() 기능을 이용해서 검증할 수 있지만 개인적으로는 String으로 테스트 코드들을 관리해야 한다는 점 때문에 클래스로 변경하여 데이터를 검증하는 편입니다.</p>\n<p>Email이나 Name 이 같은 value 인지 체크하기 위해서는 Equals메소드를 재정의 해줘야 합니다. 그래야 같은 벨류값인지 비교를할 수 있습니다. 이러한 이유는 <a href=\"https://minwan1.github.io/2018/07/03/2018-07-03-equals,hashcode/\">여기</a>를 참조해주시면 감사하겠습니다.<br>\n<a href=\"https://github.com/minwan1/online-book-store/blob/master/src/test/java/com/book/member/MemberControllerTest.java\" target=\"_blank\" rel=\"noopener\">Controller Test code</a></p>\n<h2><span id=\"서비스-테스트예제\">서비스 테스트(예제)</span></h2>\n<p>다음은 서비스 코드 단위 테스트 예제입니다. 여기에서는 서비스에 회원가입에 대한 로직만 정확하게 테스트하면 됩니다. 테스트 코드 작성 순서는 다음과 같습니다.</p>\n<ol>\n<li>memberSignUpService.signUp() 넘어올 예상되는 파라미터 값을 만듭니다.</li>\n<li>Mockito 프레임워크를 이용해 repository를 이용해 저장한 후 디비에서 리턴해줄 값을 작성합니다.</li>\n<li>실제 memberSignUpService.signUp() 호출합니다.</li>\n<li>실제로 memberSignUpService.signUp() 기능이 호출돼서 서비스의 비즈니스 로직이 제대로 진행돼서 memberRepository.save가 호출되었는지 확인합니다.</li>\n<li>memberSignUpService.signUp()로 처리된 이메일과 예상되는 이메일이 맞는지 확인합니다.</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">signUp_SignUpIsSuccess_Member</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//given</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> MemberSignupRequest request = buildRequest(TEST_EMAIL); <span class=\"comment\">//1</span></span><br><span class=\"line\">    given(memberRepository.save(any(Member.class))).willReturn(request.toMember()); <span class=\"comment\">//2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//when</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Member member = memberSignUpService.signUp(request); <span class=\"comment\">//3</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//then </span></span><br><span class=\"line\">    Mockito.verify(memberRepository, atLeast(<span class=\"number\">1</span>)).save(any(Member.class)); <span class=\"comment\">//4</span></span><br><span class=\"line\">    Assert.assertThat(member.getEmail(), is(request.getEmail()));<span class=\"comment\">//5</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/minwan1/online-book-store/blob/master/src/test/java/com/book/member/service/MemberSignUpServiceTest.java\" target=\"_blank\" rel=\"noopener\">Service Test code</a></p>\n<h1><span id=\"4-integration-test통합-테스트\">4. Integration Test(통합 테스트)</span></h1>\n<p>통합 테스트는 단위 테스트보다는 덜 빈번하게 실행되면서 세세한 API 수준의 검증보다는 모듈 단위의 상호 연동이 문제가 없는지 검증하는 것이 주 목적입니다. 위에서 각각의 모듈 별로 단위 테스트를 성공했음에도 이것들을 하나로 결합해서 테스트를 하는 과정에서 테스트가 실패할 수도 있습니다. 예를 들어 데이터베이스 제약조건 등에 문제, 다른 클래스에 의존하고 있는 클래스들이 제대로 연결되었는지 등이 예일 수 있습니다.</p>\n<h2><span id=\"통합테스트-예제\">통합테스트 예제</span></h2>\n<p>다음은 단위 테스트와 다르게 아래의 두 개의 어노테이션을 붙여주셔야 합니다. 위에 단위 테스트는 해당 클래스 하나만 테스트하면 됐지만 통합 테스트 같은 경우 테스트하고자 하는 모듈들이 모두 연결되어 있어야 하기 때문에 애플리케이션에 모든 빈들을 등록해서 테스트합니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith</span>(SpringRunner.class)</span><br><span class=\"line\"><span class=\"meta\">@SpringBootTest</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MemberControllerIntegrationTest</span> </span>&#123;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"runwithspringrunnerclass\">@RunWith(SpringRunner.class)</span></h3>\n<p>SpringJUnit4ClassRunner를 상속받은 SpringRunner 클래스는 SpringBootTest 의 설정돼있는 정보들을 이용해서 스프링 컨테이너를 생성한다. 그리고 Test 클래스에 있는 필드에 있는 변수들에 맞는 클래스를 의존성 주입을 해준다.</p>\n<h3><span id=\"springboottest\">@SpringBootTest</span></h3>\n<p>@SpringBootTest은 프로젝트에 어플리케이션빈들은 등록해주는 역할을 한다. 반드시 위에 @RunWith(SpringRunner.class)과 같이 사용해줘야 한다.</p>\n<h3><span id=\"mockmvc-사용하기\">MockMvc 사용하기</span></h3>\n<p>아래의 소스와 같이 단위 테스트와 달리 스프링 웹 애플리케이션을 빈을 주입받고 그것을 기반으로 MockMvc를 만들어줘야 합니다. 이렇게 설정을 하고 실제 API를 호출하게 되면 각 레이어들이 연결된 기능을 테스트해볼 수 있습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> WebApplicationContext webApplicationContext;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Before</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUp</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Mvc 설정을 했으면 이제 실제 테스트 코드를 작성해야 합니다. 순서를 설명해드리면 다음과 같습니다.</p>\n<ol>\n<li>회원가입 API를 호출하면 데이터베이스 회원정보가 insert 될 것 입니다. 하지만 test 코드에서 @Transactional 붙이면 테스트코드 실행 후 insert 됐던 데이터가가 롤백이 됩니다.</li>\n<li>회원가입을 하기 위해 필요한 RequestBody 값을 만든다.</li>\n<li>실제 회원가입 URL을 호출한다.</li>\n<li>결과값을 Member 클래스로 변경한다.</li>\n<li>결과값이 테스트 의도한값이 맞는지 확인한다.</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional</span><span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">signUpMember_SignupIsSuccess_Member</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//given</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> MemberSignupRequest request = buildSignupRequest(TEST_EMAIL, TEST_PASSWORD, TEST_FIRST_NAME, TEST_LAST_NAME); <span class=\"comment\">//2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//when</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String memberAsString = mockMvc.perform(</span><br><span class=\"line\">            post(<span class=\"string\">\"/members\"</span>)</span><br><span class=\"line\">                    .contentType(MediaType.APPLICATION_JSON)</span><br><span class=\"line\">                    .content(mapper.writeValueAsString(request)))</span><br><span class=\"line\">            .andDo(print())</span><br><span class=\"line\">            .andExpect(status().isCreated())</span><br><span class=\"line\">            .andReturn()</span><br><span class=\"line\">            .getResponse()</span><br><span class=\"line\">            .getContentAsString(); <span class=\"comment\">//3</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Member member = mapper.readValue(memberAsString, Member.class); <span class=\"comment\">//4</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//then</span></span><br><span class=\"line\">    Assert.assertThat(request.getEmail(), is(member.getEmail()));<span class=\"comment\">//5</span></span><br><span class=\"line\">    Assert.assertThat(request.getName(), is(member.getName()));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> MemberSignupRequest <span class=\"title\">buildSignupRequest</span><span class=\"params\">(<span class=\"keyword\">final</span> String email, <span class=\"keyword\">final</span> String password, <span class=\"keyword\">final</span> String firstname, <span class=\"keyword\">final</span> String lastname)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MemberSignupRequest.builder()</span><br><span class=\"line\">            .email(<span class=\"keyword\">new</span> Email(email))</span><br><span class=\"line\">            .password(<span class=\"keyword\">new</span> Password(password))</span><br><span class=\"line\">            .name(<span class=\"keyword\">new</span> Name(firstname, lastname))</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/minwan1/online-book-store/blob/master/src/test/java/com/book/member/MemberControllerIntegrationTest.java\" target=\"_blank\" rel=\"noopener\">Integration Test code</a></p>\n<h2><span id=\"tdd\">TDD</span></h2>\n<p>TDD란 테스트 코드를 먼저 작성하고 기능을 구현하고 또 이것을 리팩 토핑 하고 이것을 반복해서 기능을 만드는 개발 방법론을 말합니다. 테스트 주도 개발을 하게 되면 장점은 테스트 코드 하기 좋은 코드를 만들게 된다는 것입니다. 테스트 코드가 작성하기 좋은 코드의 의미는 해당 메서드나 클래스가 하나의 기능 혹은 책임만을 하고 있다는 것을 의미합니다. 이렇듯 테스트 주도 개발을 하게 되면 자연스럽게 Decouple된 객체지향 설계를 할 수 있게 되고 자연스럽게 테스트 코드들을 얻을 수 있습니다. 그렇게 되면 처음에 말했던 테스트 코드의 장점들을 얻게 됩니다.</p>\n<h1><span id=\"5-마무리하며\">5. 마무리하며</span></h1>\n<p>회원가입에 관련된 테스트 코드들을 완성했습니다. 이제 회원가입의 기능을 테스트를 하기 위해서 Swagger나 프론트엔드 화면이 필요하지 않습니다. 테스트 코드들로 테스트가 가능하기 때문입니다. 또한 테스트 코드는 좋은 문서또는 커뮤니케이션 도구가 될 수 있습니다. 예를 들어 다른 개발자가 SMS 인증 기능이 필요해서 SMS 인증 기능을 만든 개발자한테 기능을 요구했으면 SMS 기능 개발자는 단순 문서나 설명만 해주기보다는 테스트 코드를 준다면 좀 더 효율적으로 커뮤니케이션을 할 수 있을것입니다.</p>\n<p>참고</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=60lLSe1phks&amp;list=PLuLb6MC4SOvXCRePHrb4e-EYadjZ9KHyH\" target=\"_blank\" rel=\"noopener\">백명석님 강의</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>Step-05 : 테스트 코드 작성하기</h1>\n<h1>목차</h1>\n<ul>\n<li><a href=\"#1-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EC%9D%98-%ED%95%84%EC%9A%94%EC%84%B1\">1. 테스트 코드의 필요성</a></li>\n<li><a href=\"#2-test-code-%EC%9E%91%EC%84%B1-%EB%B0%A9%EB%B2%95\">2. Test code 작성 방법</a>\n<ul>\n<li><a href=\"#junit\">Junit</a></li>\n<li><a href=\"#mockito\">Mockito</a></li>\n</ul>\n</li>\n<li><a href=\"#3-unit-test%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8\">3. Unit Test(단위 테스트)</a>\n<ul>\n<li><a href=\"#%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%98%88%EC%A0%9C\">컨트롤러 테스트(예제)</a></li>\n<li><a href=\"#%EC%84%9C%EB%B9%84%EC%8A%A4-%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%98%88%EC%A0%9C\">서비스 테스트(예제)</a></li>\n</ul>\n</li>\n<li><a href=\"#4-integration-test%ED%86%B5%ED%95%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8\">4. Integration Test(통합 테스트)</a>\n<ul>\n<li><a href=\"#%ED%86%B5%ED%95%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%98%88%EC%A0%9C\">통합테스트 예제</a>\n<ul>\n<li><a href=\"#runwithspringrunnerclass\">@RunWith(SpringRunner.class)</a></li>\n<li><a href=\"#springboottest\">@SpringBootTest</a></li>\n<li><a href=\"#mockmvc-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0\">MockMvc 사용하기</a></li>\n</ul>\n</li>\n<li><a href=\"#tdd\">TDD</a></li>\n</ul>\n</li>\n<li><a href=\"#5-%EB%A7%88%EB%AC%B4%EB%A6%AC%ED%95%98%EB%A9%B0\">5. 마무리하며</a></li>\n</ul>\n<!-- /TOC -->\n<h1>테스트 코드의 필요성</h1>\n<p>회원가입 기능을 완성했지만 기능을 테스트하기 위해서는 Postman이나 Swagger로 테스트를 하거나 프론트엔드 화면을 구성해서 테스트를 해야 합니다. 기능 테스트 하나를 해야 하더라도 Postman, Swagger, 프런론 엔드 구성을 해야 한다면 너무 불편할 것입니다. 하지만 테스트코드를 가지고 있다면 아주 간단하게 기능을 테스트해볼 수 있습니다. 이외에도 아래와 같은 장점들이 있습니다.</p>\n<ul>\n<li>단위 테스트로 개발한다면 스프링이 실행될 때까지 기다리지 않아도 되니까 생산성이 올라간다.</li>\n<li>테스트 코드가 있기 때문에 리팩토링을 할 때 자신감 있게 리펙토링이 가능해진다.</li>\n<li>특정 기능을 리팩토링 한 후 그 기능과 관련된 테스트 코드들이 있으면 사전에 사이드 이펙트들을 방지할 수 있다.</li>\n<li>테스트 코드를 작성하다 보면 이상하게 테스트 코드를 작성하기가 어려운 경우가 있는데 이것은 해당 기능 이상의 기능을 하고 있을 수 있다는 것을 의미한다. 이 부분을 개선해 나간다면 Decouple된 시스템을 갖게 된다.</li>\n<li>실제 서비스에 배포되기 전에 테스트 코드들을 통해 기능들을 자동 테스트할 수 있다.</li>\n<li>테스트 코드를 작성한다면 사전에 생각하지 못한 논리적인 오류들을 생각할 수 있다.</li>\n</ul>\n<h1>Test code 작성 방법</h1>\n<p>테스트 코드를 작성하기 위해서는 Junit 테스팅 프레임워크와 Mockito 목 프레임워크를 이용해 테스트 코드를 작성할 것입니다. 테스트 방법은 단위 테스트와 통합 테스트 두 방법으로 나누어 테스트 코드를 작성할 것입니다.<br>\n여기에서 단위 테스트는 퍼블릭 메서드 기능 하나를 기준으로 테스트합니다. 통합 테스트는 컨트롤러 - 서비스 - 리파지토리 영역까지 테스트를 기준으로 테스트합니다. 먼저는 Junit부터 간단히 알아보겠습니다.</p>\n<h2>Junit</h2>\n<p>JUnit은 테스팅 프레임워크입니다. 외부에 의존 없이 자바 코드만으로 테스트를 가능하게 해주는 프레임워크입니다.</p>\n<h2>Mockito</h2>\n<p>Mockito는 자바에서 테스트를 하기 위해 Mock을 만들어주는 프레임워크입니다. Mockito은 우리가 테스트하는 과정에서 이메일이 나가지 않거나 데이터베이스와 같은 외부 시스템 데이터베이스 연결에 의존하지 않게 해주는 아주 유용한 프레임워크입니다.<br>\n또한 Mockito는 given, when, then 절로 테스트 코드를 좀 더 직관적으로 작성할 수 있습니다. 먼저 Junit과 Mockito를 이용해 단위테스트부터 작성해보겠습니다.</p>\n<h1>Unit Test(단위 테스트)</h1>\n<p>단위 테스트는 테스트하고자 하는 가장 작은 기능 단위로 테스트하는 기법을 말합니다. 단위 테스트 코드를 작성하는 이유는 가장 빠르게 최소 단위의 기능을 간단하게 테스트해볼 수 있고 정확하게 동작하는지 알 수 있습니다.</p>\n<p>또한 해당 클래스의 책임또는 기능의 단위를 잡아주는 좋은 기준이 됩니다. 테스트 코드를 작성하다 보면 이상하게 테스트 코드를 작성하기가 어려운 경우가 있습니다. 이것은 해당 기능의 책임 이상의 기능을 하고 있을 가망성이 큽니다. 그렇기 때문에 새로운 디자인을 생각하게 해줍니다.</p>\n<p>저는 개인적으로 단위 테스트는 크게 서비스 영역과 컨트롤러 영역 두개로 나눠서 테스트를 합니다. 먼저 컨트롤러 테스트 코드를 작성하겠습니다.</p>\n<h2>컨트롤러 테스트(예제)</h2>\n<p>단위 테스트에서는 스프링에 모든 빈들을 올릴 필요가 없습니다. 테스트하고자 하는 빈 만 등록하게 되면 훨씬 더 빠르게 테스트할 수 있습니다. 만약 기능 테스트 하나를 위해서 애플리케이션 빈들을 다 올리게 되면 엄청난 시간 낭비 일 것입니다.</p>\n<p>아래 소스는 테스트 코드를 작성하기 위해 설정하는 값에 대한 간단한 설명입니다.</p>\n<ol>\n<li>@RunWith(MockitoJUnitRunner.class)은 주어진 mock 객체들을 초기화하는 역할을 합니다.</li>\n<li>테스트할 때 필요로 하는 Mock 객체들을 등록해줍니다.</li>\n<li>테스트하고자 하는 클래스에 @InjectMocks을 넣어주면 Mock 객체들이 해당 클래스에 주입됩니다.</li>\n<li>컨트롤러 객체를 전달받아 MockMvc 객체를 생성하며, 다른 스프링 빈을 올릴 필요 없이 해당 컨트롤러만 테스트 가능합니다.</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RunWith</span>(MockitoJUnitRunner.class) <span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MemberControllerTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Mock</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MemberHelperService memberHelperService;<span class=\"comment\">//2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@InjectMocks</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MemberController memberController; <span class=\"comment\">//3</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUp</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        mockMvc = MockMvcBuilders <span class=\"comment\">//4</span></span><br><span class=\"line\">                .standaloneSetup(memberController)</span><br><span class=\"line\">                .build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그리고 다음은 Member 컨틀롤러를 테스트하기 위한 테스트 코드입니다. 개인적으로 테스트하기 위해서 given, when, then을 정하고 순서에 맞게 작성하는 편입니다.</p>\n<table>\n<thead>\n<tr>\n<th>구분</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>given</td>\n<td>목데이터 또는 Request 값들을 설정합니다.</td>\n</tr>\n<tr>\n<td>when</td>\n<td>실제 테스트 하고자하는 기능을 실행합니다.</td>\n</tr>\n<tr>\n<td>then</td>\n<td>테스트한 결과값이 의도한값이 맞는지 검증합니다.</td>\n</tr>\n</tbody>\n</table>\n<p>간단하게 아래 테스트 코드를 설명해드리겠습니다.</p>\n<ol>\n<li>회원가입을 위해 RequestBody 값을 만든다.</li>\n<li>컨트롤러 쪽에서 memberSignUpService를 호출할 때 Mock 데이터인 request.toMember() 값을 리턴해주는 코드입니다.</li>\n<li>실제 MemberController에 /members POST를 호출하고 결과 값을 받습니다.</li>\n<li>받은 값을 Mapper를 이용해 Member 클래스로 역 직렬화를 합니다.</li>\n<li>리턴 값이 의도한 값이 맞는지 확인합니다.</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> String TEST_EMAIL = <span class=\"string\">\"test@test.com\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> String TEST_PASSWORD = <span class=\"string\">\"password\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> String TEST_FIRST_NAME = <span class=\"string\">\"test\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> String TEST_LAST_NAME = <span class=\"string\">\"test\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">signUpMember_SignupIsSuccess_Member</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//given</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> MemberSignupRequest request = buildSignupRequest(TEST_EMAIL, TEST_PASSWORD, TEST_FIRST_NAME, TEST_LAST_NAME); <span class=\"comment\">//1</span></span><br><span class=\"line\">    given(memberSignUpService.signUp(any())).willReturn(request.toMember()); <span class=\"comment\">//2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//when</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String memberAsString = mockMvc.perform(</span><br><span class=\"line\">            post(<span class=\"string\">\"/members\"</span>)</span><br><span class=\"line\">                    .contentType(MediaType.APPLICATION_JSON)</span><br><span class=\"line\">                    .content(mapper.writeValueAsString(request)))</span><br><span class=\"line\">            .andDo(print())</span><br><span class=\"line\">            .andExpect(status().isCreated())</span><br><span class=\"line\">            .andReturn()</span><br><span class=\"line\">            .getResponse()</span><br><span class=\"line\">            .getContentAsString();<span class=\"comment\">//3</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Member member = mapper.readValue(memberAsString, Member.class); <span class=\"comment\">//4</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//then</span></span><br><span class=\"line\">    Assert.assertThat(request.getEmail(), equalTo(member.getEmail())); <span class=\"comment\">//5</span></span><br><span class=\"line\">    Assert.assertThat(request.getName(), equalTo(member.getName()));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> MemberSignupRequest <span class=\"title\">buildSignupRequest</span><span class=\"params\">(<span class=\"keyword\">final</span> String email, <span class=\"keyword\">final</span> String password, <span class=\"keyword\">final</span> String firstname, <span class=\"keyword\">final</span> String lastname)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MemberSignupRequest.builder()</span><br><span class=\"line\">            .email(<span class=\"keyword\">new</span> Email(email))</span><br><span class=\"line\">            .password(<span class=\"keyword\">new</span> Password(password))</span><br><span class=\"line\">            .name(<span class=\"keyword\">new</span> Name(firstname, lastname))</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>5번 목록을 보면 굳이 Member 클래스로 역질렬화하여 assertThat로 검증을 할 필요 없이 JsonPath() 기능을 이용해서 검증할 수 있지만 개인적으로는 String으로 테스트 코드들을 관리해야 한다는 점 때문에 클래스로 변경하여 데이터를 검증하는 편입니다.</p>\n<p>Email이나 Name 이 같은 value 인지 체크하기 위해서는 Equals메소드를 재정의 해줘야 합니다. 그래야 같은 벨류값인지 비교를할 수 있습니다. 이러한 이유는 <a href=\"https://minwan1.github.io/2018/07/03/2018-07-03-equals,hashcode/\">여기</a>를 참조해주시면 감사하겠습니다.<br>\n<a href=\"https://github.com/minwan1/online-book-store/blob/master/src/test/java/com/book/member/MemberControllerTest.java\" target=\"_blank\" rel=\"noopener\">Controller Test code</a></p>\n<h2>서비스 테스트(예제)</h2>\n<p>다음은 서비스 코드 단위 테스트 예제입니다. 여기에서는 서비스에 회원가입에 대한 로직만 정확하게 테스트하면 됩니다. 테스트 코드 작성 순서는 다음과 같습니다.</p>\n<ol>\n<li>memberSignUpService.signUp() 넘어올 예상되는 파라미터 값을 만듭니다.</li>\n<li>Mockito 프레임워크를 이용해 repository를 이용해 저장한 후 디비에서 리턴해줄 값을 작성합니다.</li>\n<li>실제 memberSignUpService.signUp() 호출합니다.</li>\n<li>실제로 memberSignUpService.signUp() 기능이 호출돼서 서비스의 비즈니스 로직이 제대로 진행돼서 memberRepository.save가 호출되었는지 확인합니다.</li>\n<li>memberSignUpService.signUp()로 처리된 이메일과 예상되는 이메일이 맞는지 확인합니다.</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">signUp_SignUpIsSuccess_Member</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//given</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> MemberSignupRequest request = buildRequest(TEST_EMAIL); <span class=\"comment\">//1</span></span><br><span class=\"line\">    given(memberRepository.save(any(Member.class))).willReturn(request.toMember()); <span class=\"comment\">//2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//when</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Member member = memberSignUpService.signUp(request); <span class=\"comment\">//3</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//then </span></span><br><span class=\"line\">    Mockito.verify(memberRepository, atLeast(<span class=\"number\">1</span>)).save(any(Member.class)); <span class=\"comment\">//4</span></span><br><span class=\"line\">    Assert.assertThat(member.getEmail(), is(request.getEmail()));<span class=\"comment\">//5</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/minwan1/online-book-store/blob/master/src/test/java/com/book/member/service/MemberSignUpServiceTest.java\" target=\"_blank\" rel=\"noopener\">Service Test code</a></p>\n<h1>4. Integration Test(통합 테스트)</h1>\n<p>통합 테스트는 단위 테스트보다는 덜 빈번하게 실행되면서 세세한 API 수준의 검증보다는 모듈 단위의 상호 연동이 문제가 없는지 검증하는 것이 주 목적입니다. 위에서 각각의 모듈 별로 단위 테스트를 성공했음에도 이것들을 하나로 결합해서 테스트를 하는 과정에서 테스트가 실패할 수도 있습니다. 예를 들어 데이터베이스 제약조건 등에 문제, 다른 클래스에 의존하고 있는 클래스들이 제대로 연결되었는지 등이 예일 수 있습니다.</p>\n<h2>통합테스트 예제</h2>\n<p>다음은 단위 테스트와 다르게 아래의 두 개의 어노테이션을 붙여주셔야 합니다. 위에 단위 테스트는 해당 클래스 하나만 테스트하면 됐지만 통합 테스트 같은 경우 테스트하고자 하는 모듈들이 모두 연결되어 있어야 하기 때문에 애플리케이션에 모든 빈들을 등록해서 테스트합니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith</span>(SpringRunner.class)</span><br><span class=\"line\"><span class=\"meta\">@SpringBootTest</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MemberControllerIntegrationTest</span> </span>&#123;</span><br></pre></td></tr></table></figure>\n<h3>@RunWith(SpringRunner.class)</h3>\n<p>SpringJUnit4ClassRunner를 상속받은 SpringRunner 클래스는 SpringBootTest 의 설정돼있는 정보들을 이용해서 스프링 컨테이너를 생성한다. 그리고 Test 클래스에 있는 필드에 있는 변수들에 맞는 클래스를 의존성 주입을 해준다.</p>\n<h3>@SpringBootTest</h3>\n<p>@SpringBootTest은 프로젝트에 어플리케이션빈들은 등록해주는 역할을 한다. 반드시 위에 @RunWith(SpringRunner.class)과 같이 사용해줘야 한다.</p>\n<h3>MockMvc 사용하기</h3>\n<p>아래의 소스와 같이 단위 테스트와 달리 스프링 웹 애플리케이션을 빈을 주입받고 그것을 기반으로 MockMvc를 만들어줘야 합니다. 이렇게 설정을 하고 실제 API를 호출하게 되면 각 레이어들이 연결된 기능을 테스트해볼 수 있습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> WebApplicationContext webApplicationContext;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Before</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUp</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Mvc 설정을 했으면 이제 실제 테스트 코드를 작성해야 합니다. 순서를 설명해드리면 다음과 같습니다.</p>\n<ol>\n<li>회원가입 API를 호출하면 데이터베이스 회원정보가 insert 될 것 입니다. 하지만 test 코드에서 @Transactional 붙이면 테스트코드 실행 후 insert 됐던 데이터가가 롤백이 됩니다.</li>\n<li>회원가입을 하기 위해 필요한 RequestBody 값을 만든다.</li>\n<li>실제 회원가입 URL을 호출한다.</li>\n<li>결과값을 Member 클래스로 변경한다.</li>\n<li>결과값이 테스트 의도한값이 맞는지 확인한다.</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional</span><span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">signUpMember_SignupIsSuccess_Member</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//given</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> MemberSignupRequest request = buildSignupRequest(TEST_EMAIL, TEST_PASSWORD, TEST_FIRST_NAME, TEST_LAST_NAME); <span class=\"comment\">//2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//when</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String memberAsString = mockMvc.perform(</span><br><span class=\"line\">            post(<span class=\"string\">\"/members\"</span>)</span><br><span class=\"line\">                    .contentType(MediaType.APPLICATION_JSON)</span><br><span class=\"line\">                    .content(mapper.writeValueAsString(request)))</span><br><span class=\"line\">            .andDo(print())</span><br><span class=\"line\">            .andExpect(status().isCreated())</span><br><span class=\"line\">            .andReturn()</span><br><span class=\"line\">            .getResponse()</span><br><span class=\"line\">            .getContentAsString(); <span class=\"comment\">//3</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Member member = mapper.readValue(memberAsString, Member.class); <span class=\"comment\">//4</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//then</span></span><br><span class=\"line\">    Assert.assertThat(request.getEmail(), is(member.getEmail()));<span class=\"comment\">//5</span></span><br><span class=\"line\">    Assert.assertThat(request.getName(), is(member.getName()));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> MemberSignupRequest <span class=\"title\">buildSignupRequest</span><span class=\"params\">(<span class=\"keyword\">final</span> String email, <span class=\"keyword\">final</span> String password, <span class=\"keyword\">final</span> String firstname, <span class=\"keyword\">final</span> String lastname)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> MemberSignupRequest.builder()</span><br><span class=\"line\">            .email(<span class=\"keyword\">new</span> Email(email))</span><br><span class=\"line\">            .password(<span class=\"keyword\">new</span> Password(password))</span><br><span class=\"line\">            .name(<span class=\"keyword\">new</span> Name(firstname, lastname))</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/minwan1/online-book-store/blob/master/src/test/java/com/book/member/MemberControllerIntegrationTest.java\" target=\"_blank\" rel=\"noopener\">Integration Test code</a></p>\n<h2>TDD</h2>\n<p>TDD란 테스트 코드를 먼저 작성하고 기능을 구현하고 또 이것을 리팩 토핑 하고 이것을 반복해서 기능을 만드는 개발 방법론을 말합니다. 테스트 주도 개발을 하게 되면 장점은 테스트 코드 하기 좋은 코드를 만들게 된다는 것입니다. 테스트 코드가 작성하기 좋은 코드의 의미는 해당 메서드나 클래스가 하나의 기능 혹은 책임만을 하고 있다는 것을 의미합니다. 이렇듯 테스트 주도 개발을 하게 되면 자연스럽게 Decouple된 객체지향 설계를 할 수 있게 되고 자연스럽게 테스트 코드들을 얻을 수 있습니다. 그렇게 되면 처음에 말했던 테스트 코드의 장점들을 얻게 됩니다.</p>\n<h1>5. 마무리하며</h1>\n<p>회원가입에 관련된 테스트 코드들을 완성했습니다. 이제 회원가입의 기능을 테스트를 하기 위해서 Swagger나 프론트엔드 화면이 필요하지 않습니다. 테스트 코드들로 테스트가 가능하기 때문입니다. 또한 테스트 코드는 좋은 문서또는 커뮤니케이션 도구가 될 수 있습니다. 예를 들어 다른 개발자가 SMS 인증 기능이 필요해서 SMS 인증 기능을 만든 개발자한테 기능을 요구했으면 SMS 기능 개발자는 단순 문서나 설명만 해주기보다는 테스트 코드를 준다면 좀 더 효율적으로 커뮤니케이션을 할 수 있을것입니다.</p>\n<p>참고</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=60lLSe1phks&amp;list=PLuLb6MC4SOvXCRePHrb4e-EYadjZ9KHyH\" target=\"_blank\" rel=\"noopener\">백명석님 강의</a></li>\n</ul>\n"},{"title":"OS-2:컴퓨터 시스템 구조란?","catalog":true,"date":"2018-06-22T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n\n## 컴퓨터 시스템 구조\n### 1. 컴퓨터 시스템의 구조\n\n컴퓨터 시스템 구조에 들어가기전에 용어를 먼저 정리해보자.\n\n#### CPU란\n\nCPU는 내부적으로 크게 3가지로 나눌 수 있습니다. 연산을 수행하는 산술논리장치(ALU), 제어 명령을 전달하는 컨트롤 장치(CU), 결과 값을 일시적으로 기억하는 레지스터(Register)가 이에 해당됩니다. 아래 그림은 CPU의 구조를 그림으로 도식화 한 것이다.\n![](https://i.imgur.com/r0MbHY2.png)\n\n#### Memory란\nCPU의 Register의 용량은 매우 작다. 그래서 정보를 저장해 두었다가 필요할 때 읽어 들여 이용할 수 있는 주 기억 장치가 필요하다. 이 주기억장치에는 컴퓨터가 켜지면 운영체제, 사용자 프로그램등이 메모리공간에 올라가게된다. CPU는 주기억장치에서 프로그램들의 명령어등을 읽어와 작업을 수행한다. 주 기억창치로는 ROM, RAM 등이 있음.\n\n#### I/O Device란\n입출력 장치란, 사용자가 원하는 문자나 그림의 데이터를 컴퓨터로 전달하는 하거나 출력하는 장치이다. 입력장치의 종류에는 키보드, 마우스이 있고 출력 장치로는 모니터, 프린터등이 있다.\n\n컴퓨터 시스템은 크게 위 3단어로 구성된다고 볼 수 있다. 아래 그림은 컴퓨터 시스템 구조를 도식화한 것이다.\n\n\n![](https://i.imgur.com/DmnmAGX.png)\n\n간단하게 컴퓨터 시스템 흐름을 설명하면 컴퓨터에 전원이 들어오게 되면 메인메모리에 운영체제가 올라간다. 이때 모든 운영체제 코드가 올라가는게아니라 시스템이 돌아가기위한 핵심적인 부분이 먼저올라가는데 이부분을 커널이라 한다. 이러한 이유는 모든 코드가 메모리에 올리게되면 자원낭비가 심하기 때문이다.\n\n그 이후에 CPU는 메모리의 운영체제 프로그램들을 읽어 운영체제를 실행한다. 운영체제가 시작되고 다른 프로그램들을 실행시키면 마찬가지로 메인메모리에 올라가게 된다. 이때 CPU는 메인메모리에 명령어주소를 레지스터에 저장하는데 이 레지스터이름은 PC레지스터라 한다. 그 이후 각각의 프로그램들은 I/O 디바이스 사용이 필요할 수 있는데 이러한 요청은 운영체제한테 요청을해야한다. 이러한 요청을 시스템콜이라고 한다. 이렇게 프로그램들이 직접 I/O디바이스를 제어하지 않는 이유는 많은 이유가있지만 가장큰 이유는 보안때문이다.\n\n프로그램의 요청을 받은 운영체제는 I/O 디바이스의 컨트롤러에게 데이터 입출력 처리를 요청을 한다. 그리고 I/O 디바이스 컨 틀롤러들은 입출력을 받게 되면 Interrupt를 발생시켜 CPU에게 작업이 완료됐다고 알리게 된다. CPU는 I/O 디바이스에 버퍼에 가서 데이터를 읽어와 메인 메모리에 올려놓게 된다. 이러한 작업이 반복되는 것이 컴퓨터 프로그램의 동작 원리이다. 아래 그림은 좀 더 CPU와 메모리 I/O 디바이스들을 세부 분화한 그림이다.\n\n\n![](https://i.imgur.com/8JAIHTg.png)\n\n### 2. CPU와 I/O연산\n\n위 구조에서 먼저 I/O 디바이스와 CPU 관계를 봐보자. 컴퓨터에 대한 연산은 CPU가 처리한다. 반면 I/O 디바이스들에 대한 연산은 각각의 디바이스 컨트롤러들이 처리한다. 컨트롤러들은 각각의 디바이스들의 CPU 역할을 한다. 이렇기 때문에 둘은 서로 동시에 처리가 가능하다. 그리고 각각의 컨트롤러로부터 들어오고 나오는 데이터들은 로컬 버퍼에서 관리한다. 로컬 버퍼는 램과 같은 역할을 한다.\n\n데이터가 입출력되었는지는 CPU가 처리하는 게 아니라 각각의 컨트롤러들이 연산을 하고 이것을 CPU에게 인터럽트를 발생시켜 보고하는 형태로 처리된다. CPU는 항상 메모리에 명령어를 읽어와 작업을 수행하는데 매 명령어를 읽어오기 전 인터럽트가 발생하였는지 확인하고 인터럽트가 발생했으면 인터럽트를 먼저 처리하고 그 이후에 명령어를 처리한다.\n\n\n#### Device Controller\n각각의 디바이스들을 I/O연산, 제어관리를 하는 역할을 한다.(각각의 디바이스들의 CPU 역할)\n**Device Driver**\n운영체제가 각각의 디바이스를 접근하게 하기위한 인터페이스역할을하는 소프트웨어.\n**펌웨어**\n디바이스가 동작하기위한 소프트웨어\n\n#### Buffer\n각각의 디바이스 컨트롤러들이 명령을 내려 디바이스의 데이터를 읽어오거나 출력할때는 데이터를 저장하는 공간이다. (각각의 디바이스들의 램역할)\n\n\n### 3. 입터럽트의 일반적 기능\n\n그다음 CPU와 각각의 I/O 디바이스 컨트롤러 디바이스들 간에 인터럽트 처리를 확인해 보자. 기본적으로 운영체제에는 인터럽트가 발생했을 때 각각의 인터럽트에 대한 처리가 운영체제 안에 코드로 작성되어 저장되어있다. 이 다양한 인터럽트에 대해 각각의 처리해야 할 업무들을 정의해놓은 것이 인터럽트 처리 루틴이다. CPU는 인터럽트가 발생하면 하던 일을 멈추고 인터럽트가 발생했을 대 수행해야 할 코드영역으로 가서 정의된 작업을 하게 된다. 이때 수행되는 일을 좀 더 자세히 보면 다음과 같다. CPU 가 먼저 로컬 버퍼에 있는 내용을 프로그램 B가 사용할 수 있도록 메모리로 전달하고, 이제 프로그램 B가 CPU를 할당받을 경우 다음 명령어를 수행할 수 있음을 표시해둔다.\n\n인터럽트는 크게 2가지고 인터럽트로 나누어지는데 하드웨어 인터럽트와 소프트웨어 인터럽트가 있다. 하드웨어 인터럽트는 하드웨어가 발생시키고 소프트웨어는 소프트웨어가 인터럽트를 발생시킨다는 차이가 있다. 운영체제는 인터럽트 루틴을 쉽게 찾아가기 위해 인터럽트 벡터를 가지고 있다. 인터럽트 벡터는 인터럽트 종류마다 번호를 정해서, 번호에 따라 처리해야할 코드가 위치한 부분을 포인터로 가리키고 있는 자료구조를 말한다. 실제처리는 인터럽트 루틴에서 이루어진다.\n\n\n#### Interrupt\nCPU는 I/O 디바이스들이 데이터를 입력할때까지 기다리는게 아니라 자신의 일을 계속 처리하고있게 된다. 이때 I/O 디바이스들에게 입력이 이루어지면 각각의 디바이스 컨틀롤러가 인터럽트를 발생시켜 CPU에게 알려준다. 이때 발생시키는 신호를 인터럽트라고 한다.\n\n#### 인터럽트 루틴\n운영체제에는 인터럽트가 발생했을 때 각각의 인터럽트에대한 처리가 운영체제 안에 저장되어있다. 이 다양한 인터럽트에대해 각각의 처리해야할 업무들을 정의 해놓은것이 인터럽트 처리 루틴이다.\n\n#### 인터럽트 벡터\n인터럽트 벡터는 인터럽트 종류마다 번호를 정해서, 번호에 따라 처리해야할 코드가 위치한 부분을 포인터로 가리키고 있는 자료구조를 말한다.\n\n#### System Call\n응용프로그램이 운영체제의 서비스를 받기위해 커널함수를 호출하는것.\n\n#### Timer\n특정 프로그램이 무한루프에 빠져 CPU를 독점하는 경우를 막기위해 존재한다. 만약 특정프로그램이 CPU할당시간을 초과한다면 timer는 인터럽트를 발생시켜 CPU의 권한을 운영체제에게 다시 넘긴다.\n\n#### mode bit\n CPU에서 지금 실행되는 프로그램이 프로그램인지 운영체제인지 구분해주는 역할\n\n#### 스택영역\n실행중인 함수에서 다른 함수를 호출한경우 호출된 함수의 종료후 원래 함수의 실행이던 위치로 돌아오기 위해 복귀 주소를 저장하는 위치이다.\n#### 데이터 영역\n전역변수등 프로그램이 사용하는 각종 데이터가 저장되는 공간이다.\n#### 코드 영역\n프로그래머가 작성한 코드가 기계어 명령형태로 저장되는 영역이다.\n\n#### DMA\nCPU가 각각의 I/O디바이스를 통해 데이터를 읽어 메인메모리에 프로그램에게 전달하게되면 CPU효율이 떨어지기때문에 주변기기의 인터페이스 장치에 제어권을 주어 직접 주기억장치와 데이터를 주고 바는 방식으로 액세스하여 데이터를 전송하는 방법\n\n\n### 4.인터럽트 핸들링\n\n인터럽트 핸들링이란 인터럽트가 발생한 경우에 처리해하는 절차를 의미한다. 인터럽트는 앞에서 말한 대로 발생 시에만 CPU에 의해 운영체제 코드 부분 즉 인터럽트 루틴을 실행한다. 인터럽트가 발생하지 않는다면 CPU는 계속 계속해서 사용자 프로그램의 명령어를 처리할 것이다.\n\nCPU가 사용자 프로그램 처리 중 인터럽트가 발생하면 사용자 프로그램의 현재 수행 중이던 주소와 부가적인 정보를 저장해야 한한다. 왜냐하면 인터럽트가 발생하면 레지스터의 기존 데이터들이 지워지기 때문이다.\n\n운영체제 커널 내에는 현재 시스템 내에서 수행되는 프로그램들을 관리하기 위한 자료 구조인 프로세스 제어 블록(PCB : Process Control Block) 을 두고 있다. 이 자료 구조 중 일부는 인터럽트가 발생했을 때 프로그램의 어느 부분이 수행되던 중이었는지를 저장하기 위한 자료구조로 사용된다.\n\n이 자료구조를 바탕으로 인터럽트가 발생했을 때 인터럽트 처리를 하고 CPU는 다시 원래 프로그램으로 돌아올 수 있다.\n\n#### PCB\n운영체제 커널 내에는 현재 시스템 내에서 수행되는 프로그램들을 관리하기 위한 자료 구조인 프로세스 제어 블록(PCB : Process Control Block) 을 두고 있다. 이 자료 구조중 일부는 인터럽트가 발생했을때 프로그램의 어느부분이 수행되던 중이었는지를 저장하기 위한 자료구조로 사용된다.\n\n### 4.입출력 구조\n\n#### 동기식 입출력\n입출력(I/O)이란 컴퓨터 시스템이 컴퓨터 외부의 주변 장치들과 데이터를 주고받는것을 말한다. 입출력 방식에는 동기식 입출력과 비동기식 입출력이 있다. 동기식 입출력(synchronous I/O)은 입출력 요청후 입출력 작업이 완료된후에야 CPU의 제어권이 그 프로그램에게 다시 넘어갈 수 있는 방식을 말한다. 따라서 동기식 입출력에서는 입출력 연산이 끝날 때까지 CPU는 아무 일을 수행할 수 없다. 기본적으로 CPU의 명령수행속도는 빠른반면 외부 장치에서 데이터를 읽어오는 등의 입출력 연산은 상대적으로 속도가 느리다. 그럼으로 CPU가 입출력 연산을 기다리는것은 비효율적이다. 따라서 일반적으로 프로그램이 입출력을 수행중인 경우 CPU를 다른 프로그램에게 이양해 CPU가 계속쉬지 않고 일할수 있도록 관리한다. 그리고 그 입출력을 수행하고있는 프로그램은 CPU를 할당하더라도 명령을 수행을 못하는데 이것을 **\"봉쇄 상태(blocked state)\"** 로 전환 시킨다고 말한다. 봉쇄 상태의 프로그램에게는 CPU를 할당하지 않고, CPU를 할당하면 곧바로 작업 수행 가능한 프로그램들에게만 CPU를 할당하게 된다.\n\n그러나 여기에서 문제가 하나 발생할 수 있다. 앞서 설명한 것처럼 입출력이 수행중일 때 다른 프로그램에게 CPU를 양도하게 되므로 다수의 입출력 연산이 동시에 요청되거나 처리될 수 있다. 예를들어 A라는 프로그램과 B라는 프로그램이 있다고 가정하자. 이때 두 프로그램은 동시에 하나의 파일에 접근하려고한다. 여기에서 개발자는 A라는 프로그램이 먼저 파일을 수정할것을 예상하고 개발했다고 가정해보자. 하지만 컨트롤러는 이것의 순서를 보장하지 않는다. 이러한 문제점을 해결하기 위해서 **I/O장치** 별로 큐를 두어 요청한 순서대로 처리할 수 있도록 한다. 큐는 아시다시피 FIFO의 구조로 이루어지기 때문에 들어온 순서대로 처리하게 될것이다.\n\n위의 내용을 보면 크게 I/O동기식 입출력은 크게 2가지 구현 방법이 있다.\n**구현방법 1**\n* I/O 끝날 때까지 CPU를 낭비시킴\n* 매시점 하나의 I/O만 일어날 수 있음\n\n**구현방법 2**\n* I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗음\n* I/O처리를 기다리는 줄에 그 프로그램을 줄세움\n* 다른 프로그램에게 CPU를 줌\n\n#### 비동기식 입출력\n비동기식 입출력은 입출력 연산을 요청한 후에 연산이 끝나기를 기다리는 것이 아니라 CPU의 제어권을 입출력 연산을 호출한 그 프로그램에게 곧바로 다시 부여하는 방식을 말한다. 프로그램 중 데이터를 입출력할 때 입출력 결과를 기다려야 하는 경우가 있을 수 있고, 반대로 입출력 결과는 상관없이 다른 일을 수행할 수 있는 기능들이 있을 것이다. 비동기식에서는 입출력 결과에 상관없이 수행할 수 있는 일들을 먼저 처리하고 입출력의 결과가 필요한 프로그램들은 입출력이 완료된 후에 작업을 수행한다.\n\n![](https://i.imgur.com/ykkvu39.png)\n\n위 그림은 동기식 입출력과 비동기식 입출력을 비교해 보여주는 그림이다. 동기식 입출력 같은 경우에는 응답이 돌아올 때까지 입출력을 요청했던 프로그램은 봉쇄 상태가 되고 인터럽트가 발생하면 그때 입출력에 관한 프로그램이 봉쇄 상태가 풀리게 되고 CPU를 할당받을 수 있는 상태가 된다.\n\n반면 비동기식 프로그램은 입출력을 요청한 프로세스에게 곧바로 다시 주어지며, 입출력 연산이 완료되는 것과 무관하게 처리 가능한 작업부터 처리한다. 한편, 비동기식 입출력에서도 입출력 연산이 완료되면 동기식과 마찬가지로 인터럽트를 통해 이를 CPU에게 알려준다. 이러한 구체적인 예를 통해 정리해보면 다음과 같다.\n\n1. 프로그램 A가 실행중에 디스크에서 데이터를 읽어오는 명령을 만나게되면 A는 시스템콜을 발생시킨다.\n2. CPU는 지금까지 프로그램 A의 작업을 멈추고 현재 수행상태를 저장한후에, 인터럽트에 의해 처리 되어야할 커널 루틴으로 이동한다.\n3. 처리 루틴으로 이동하게되면 CPU는 컨트롤러에게 입출력 연산을 요청하게 된다.\n4. 디바이스 컨트롤러는 A가 요청한 데이터를 디스크로부터 읽어와 버퍼에 저장한다.\n5. 읽어오는 동안 프로그램 A는 CPU를 B 프로그램에게 넘겨주게 된다. (이때 A프로그램은 봉쇄상태가 가되고 CPU 명령을 수행하려고해도 수행하지 못함)\n6. 디바이스컨트롤러가 작업이 다 끝나면 하드웨어 인터럽트를 발생시킨다.\n7. 인터럽트가 발생하면 B프로그램을 처리작업을 잠시 미뤄 두고 인터럽트 처리루틴에 가서 인터럽트를 처리한다.\n8. 그럼 인터럽트 처리루틴은 컨틀러에서 데이터를 읽어와 A프로그램에게 올리게되고 A프로그램은 다시 CPU 줄을 기다려야한다.\n9. 그 후 다시 프로그램 B로 돌아가 작업을 수행하게된다.\n\n일반적으로는 동기식 입출력을 사용한다. 이 때 운영체제는 장치별로 입출력 처리를 기다리는 프로세스를 줄세워 관리한다.\n\n### 5. DMA(Direct Memory Access)\n\n일반적으로 I/O 디바이스들이 메인 메모리에 바로 접근할 수 없고 I/O 디바이스들은 인터럽트를 발생시켜 CPU가 I/O 디바이스들의 데이터를 읽어 메인 메모리 프로그램에 올린다. 하지만 CPU는 프로그램의 명령어를 처리하는 것 외에도 항상 각각의 I/O 디바이스들 인터럽트에 대한 처리도 해야 하기 때문에 기존 CPU 작업들을 방해하게 된다.\n\n이러한 비효율성을 극복하기 위해 CPU 대신에 I/O 디바이스들에 인터럽트를 처리할 컨트롤러를 하나 더 둔다. 이것이 바로 DMA 장치이다. DMA가 있음으로 더 이상 CPU는 하던 작업을 멈추고 각종 I/O디바이스들의 인터럽트를 처리할 필요가 없어진다. 단지 DMA Controller에 인터럽트만 처리하게 되면 된다. 이때 DMA는 바이트 단위가 아니라 블록 단위로 데이터를 모아서 CPU에게 인터럽트를 발생시킨다. 이러한 방법으로 CPU의 효율을 높일 수 있다.\n\n* 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해사용\n* CPU의 중재 없이 Device controller가 device의 buffer storage의 내용을 메모리에 block 단위로 직접 전송\n* 바이트 단위가 아니라 block 단위로 인터럽트를 발생시킴\n\n\n### 6. 저장 장치 구조\n\n#### 주기억장치\n컴퓨터 시스템을 구성하는 저장 장치는 주 기억 장치와 보조기억장치다. 주 기억장치는 보통 메모리라고 부르며 전원이 나가면 저장되었던 내용이 모두 사려 저버리는 휘발성(volatile)의 RAM을 매체로 사용하는 경우이다.\n\n#### 보조기억장치\n보조기억장치는 전원이 나가도 저장된 내용을 기억할 수 있는 비휘발성(nonvolatile)의 마그네틱 디스크를 흔히 사용한다. 보조 기억장치는 크게 두가지 부분으로 파일시스템용과 스왑 영역이다.\n**파일 시스템**\n전원이 나가도 유지해야할 정보가있으면 그것을 파일형태로 보조기억장치에 저장한다.\n**스왑 영역**\n메인 메모리의 크기는 한정되어있고, 가격이 비싸다. 그러므로 다수의 프로그램이 메인 메모리에 올라가 동시에 수행될경우 메모리 공간이 부족한경우가 많다. 그렇기 때문에 한번에 모두 메인메모리에 올려놓는게 아니라 프로그램이 돌아가기 위한 핵심적인 부분만 메인 메모리에 올려놓고 나머지는 스왑영역에두고 필요할 때마다 메인 메모리로 불러오게 된다.\n\n\n### 7. 저장 장치의 계층 구조\n\n컴퓨터의 시스템을 구성하는 저장 장치부터 느린 저장 장치까지 단계적인 계층 구조로 이루어진다. 빠른 저장 장치는 단위 공간당 가격이 높기때문에 적은 용량을 사용하며, 느린 저장 장치는 가격이 저렴해 대용량을 사용하는 반면 접근속도가 느리다는 약점이 있다. 아래그림은 이 내용을 그림으로 표현한것이다.\n\n![](https://i.imgur.com/z6a9a8B.png)\n\n상위 저장 장치 계층으로 갈수록 접근 속도가 월등히 빠르지만 용량은 상대적으로 적다. 하지만 당장 필요한 정보만을 선별적으로 저장하게 되면 마치 하위에 있는 큰 용량의 저장 장치를 가지고 있는 것과 비슷한 성능 효과를 낼 수 있다. 예를 들면, 캐시메모리는 레지스터와 메인 메모리 사이에 존재한다. 캐시메모리는 메인 메모리보다 용량이 작다. 그러나 여러 가지 캐슁기법을 이용해 적은 용량의 캐시메모리를 사용해서도 메인 메모리와 같이 큰 용량을 가진 것처럼 효율적으로 관리할 수 있다.\n\n**캐슁 기법** 이란 상대적으로 느린 저장장치에 있는 내용중에 당장 사용되거나 빈번히 사용될 정보를 빠른 저장장치에 선별적으로 저장하여, 두 저장 장치 사이의 속도를 완충 시키는 기법을 의미한다.\n\n### 8. 하드웨어의 보안\n\n일반적으로 사용하는 운영체제는 여러 프로그램이 동시에 실행될 수 있는 다중 프로그래밍 환경에서 실행된다. 그러므로 각 프로그램들이 다른 프로그램의 실행을 방해하거나 프로그램 간에 서로 충돌이 일어날 수 있기 때문에 이러한 문제를 해결하기 위한 각종 보안 기법이 필요하다. 하드웨어적인 보안을 유지하기 위해서 운영체제는 기본적으로 두 가지 모두의 운영을 지원한다. 커널 모드와 사용자 모두가 이에 해당한다.\n\n커널 모드는 운영체제가 CPU의 제어권을 가지고 운영체제 코드를 실행되는 모드로서, 이 모드에서는 모든 종류의 명령을 다 실행할 수 있다. 사용자모드는 일반 사용자 프로그램이 실행되며 제한적인 명령만을 수행할 수 있다.\n\n그러나 중요한 연산을 운영체제만이 수행할 수 있도록 수행버리면 제어가 필요 없게된다. 사용자 프로그램이 CPU를 가지고 있는 동안에는 운영체제가 CPU를 선점할 수 없으므로 사용자 프로그램을 감시할 수 있는 방법이 없게된다. 그러므로 이러한 상황을 방지하기위해 **모드비트** 라는 하드웨어적인 자원이 필요하다.\n\n모드 비트가 0으로 세팅되어 있으면 커널 모드를 의미하고, 모드 비트가 1이면 사용자 모드를 의미한다. CPU는 보안과 관련된 명령을 수행하기 전에는 모드 비트를 조사해 모드 비트가 0으로 세팅된 경우에만 그 명령을 수행한다.\n\nCPU가 운영체제를 점유하고 있을 때 운영체제는 모드 비트를 0으로 사용하다가 사용자 프로그램에게 CPU를 넘길 때에는 모드 비트를 1로 세팅하고 넘기게 된다. 보통 모드 비트가 0이 되는 경우에는 이와 같이 운영체제에게 권한이 넘어가거나 인터럽트가 발생하여 인터럽트 루틴을 처리해야 할 경우이다.\n\n#### 커널모드\n운영체제가 CPU의 제어권을 가지고 운영체제 코드를 실행되는 모드로서, 이 모드에서는 모든 종류의 명령을 다 실행할 수 있다.\n\n#### 사용자 모드\n일반 사용자 프로그램이 실행되며 제한적인 명령만을 수행할 수 있다.\n\n#### 모드비트\n모드비트를 통해 CPU가 운영체제 함수를 호출할 수 있는지 결정하게된다. 모드 비트가 0이면 커널모드를 의미하고 1이면 사용자 모드를 의미한다.\n\n### 9. 메모리 보안\n여러 프로그램이 메모리에 동시에 올라가서 실행되기 때문에 하나의 사용자 프로그램이 다른 사용자 프로그램이나 운영체제가 위치한 메모리 영역을 침범할 수 있기 때문이다. 적어도 인터럽트 벡터와 인터럽트 처리 루틴이 있는 곳은 각별한 보안이 필요하다. 이러한 문제를 해결하기 위해서 두 개의 레지스터를 이용해 현재 접근하려는 메모리가 한 법적인지 체크함으로써 메모리를 보호한다.\n\n이두가지는 기준 레지스터(base register)와 한계 레지스터(limit register)이다. 기준 레지스터는 실행되고 있는 프로그램이 합법적으로 접근이 시작되는 메모리 주소를 보관하고 있고, 한계 레지스터는 해당 프로그램이 기준 레지스터로부터 접근할 수 있는 범위를 저장하고 있다. 사용자 프로그램은 이 두 개의 값의 범위만 접근할 수 있게 된다. 이 범위를 벗어난 접근을 하게 되면 예외 인터럽트가 발생하게 된다.\n\n아래그림은 기준레지스터 한계리지서터의 내용을 표현한 그림이다.\n![](https://i.imgur.com/Q6fK3mt.png)\n\n### 10. CPU의 보호\n\n일반적으로 CPU는 컴퓨터 시스템내에 하나밖에 존재하지 않기 때문에 특정 프로그램이 CPU를 독점해 무한 반복문을 수행하는 등 부적절한 방법으로 CPU를 독점한다면 다른프로그램들 및 운영체제가 CPU를 획득하지 못하게 된다. 이와같이 CPU가 하나의 프로그램의 독점을 막기위해 타이머라는 하드웨어가 존재 한다.\n타이머는 정해진 시간이 지나면 인터럽트를 발생시켜 운영체제에게 CPU의 제어권을 이양시키는 역할을 한다. 타이머는 정해진 시간이지나면 인터럽트를 발생시키는데 이 인터럽트 처리 루틴의 내용은 CPU의 제어권을 CPU에게 넘기는것이다.\n\n### 11. 시스템 콜을 이용한 입출력 수행\n\n사용자 프로그램이 I/O 디바이이스등을 통해 데이터 입출력을 할 수 없다. 보통 이러한 작업은 운영체제를 통해서 해야한다. 운영체제에는 I/O디바이스들에 데이터 입출력명령이 코드로 구현되어 있다. 그래서 보통 사용자 프로그램들은 인터럽트를 발생을 시켜 I/O디바이스등 입출력을하는데 이러한 것을 가리켜 시스템 콜이라고한다. 시스템콜은 소프트웨어적인 인터럽트로서 사용자 프로그램이 시스템콜을 할경우 트랩이 발생해 CPU에 대한 제어권이 운영체제로 넘어간다. 그러면 운영체제는 해당하는 시스템콜을 처리하기위해 처리루틴으로가서 시스템 콜 에 맞는 처리 루틴을 수행한다.\n\n\n참조\n* [운영체제와 정보기술의 원리](http://www.yes24.com/24/goods/2824944)\n","source":"_posts/2018-06-23-운영체제란[OS-2].md","raw":"---\ntitle: OS-2:컴퓨터 시스템 구조란?\ncatalog: true\ndate: 2018-06-23\nsubtitle:\nheader-img:\ntags:\n- ETC\n- O/S\n\n\n\n---\n\n\n## 컴퓨터 시스템 구조\n### 1. 컴퓨터 시스템의 구조\n\n컴퓨터 시스템 구조에 들어가기전에 용어를 먼저 정리해보자.\n\n#### CPU란\n\nCPU는 내부적으로 크게 3가지로 나눌 수 있습니다. 연산을 수행하는 산술논리장치(ALU), 제어 명령을 전달하는 컨트롤 장치(CU), 결과 값을 일시적으로 기억하는 레지스터(Register)가 이에 해당됩니다. 아래 그림은 CPU의 구조를 그림으로 도식화 한 것이다.\n![](https://i.imgur.com/r0MbHY2.png)\n\n#### Memory란\nCPU의 Register의 용량은 매우 작다. 그래서 정보를 저장해 두었다가 필요할 때 읽어 들여 이용할 수 있는 주 기억 장치가 필요하다. 이 주기억장치에는 컴퓨터가 켜지면 운영체제, 사용자 프로그램등이 메모리공간에 올라가게된다. CPU는 주기억장치에서 프로그램들의 명령어등을 읽어와 작업을 수행한다. 주 기억창치로는 ROM, RAM 등이 있음.\n\n#### I/O Device란\n입출력 장치란, 사용자가 원하는 문자나 그림의 데이터를 컴퓨터로 전달하는 하거나 출력하는 장치이다. 입력장치의 종류에는 키보드, 마우스이 있고 출력 장치로는 모니터, 프린터등이 있다.\n\n컴퓨터 시스템은 크게 위 3단어로 구성된다고 볼 수 있다. 아래 그림은 컴퓨터 시스템 구조를 도식화한 것이다.\n\n\n![](https://i.imgur.com/DmnmAGX.png)\n\n간단하게 컴퓨터 시스템 흐름을 설명하면 컴퓨터에 전원이 들어오게 되면 메인메모리에 운영체제가 올라간다. 이때 모든 운영체제 코드가 올라가는게아니라 시스템이 돌아가기위한 핵심적인 부분이 먼저올라가는데 이부분을 커널이라 한다. 이러한 이유는 모든 코드가 메모리에 올리게되면 자원낭비가 심하기 때문이다.\n\n그 이후에 CPU는 메모리의 운영체제 프로그램들을 읽어 운영체제를 실행한다. 운영체제가 시작되고 다른 프로그램들을 실행시키면 마찬가지로 메인메모리에 올라가게 된다. 이때 CPU는 메인메모리에 명령어주소를 레지스터에 저장하는데 이 레지스터이름은 PC레지스터라 한다. 그 이후 각각의 프로그램들은 I/O 디바이스 사용이 필요할 수 있는데 이러한 요청은 운영체제한테 요청을해야한다. 이러한 요청을 시스템콜이라고 한다. 이렇게 프로그램들이 직접 I/O디바이스를 제어하지 않는 이유는 많은 이유가있지만 가장큰 이유는 보안때문이다.\n\n프로그램의 요청을 받은 운영체제는 I/O 디바이스의 컨트롤러에게 데이터 입출력 처리를 요청을 한다. 그리고 I/O 디바이스 컨 틀롤러들은 입출력을 받게 되면 Interrupt를 발생시켜 CPU에게 작업이 완료됐다고 알리게 된다. CPU는 I/O 디바이스에 버퍼에 가서 데이터를 읽어와 메인 메모리에 올려놓게 된다. 이러한 작업이 반복되는 것이 컴퓨터 프로그램의 동작 원리이다. 아래 그림은 좀 더 CPU와 메모리 I/O 디바이스들을 세부 분화한 그림이다.\n\n\n![](https://i.imgur.com/8JAIHTg.png)\n\n### 2. CPU와 I/O연산\n\n위 구조에서 먼저 I/O 디바이스와 CPU 관계를 봐보자. 컴퓨터에 대한 연산은 CPU가 처리한다. 반면 I/O 디바이스들에 대한 연산은 각각의 디바이스 컨트롤러들이 처리한다. 컨트롤러들은 각각의 디바이스들의 CPU 역할을 한다. 이렇기 때문에 둘은 서로 동시에 처리가 가능하다. 그리고 각각의 컨트롤러로부터 들어오고 나오는 데이터들은 로컬 버퍼에서 관리한다. 로컬 버퍼는 램과 같은 역할을 한다.\n\n데이터가 입출력되었는지는 CPU가 처리하는 게 아니라 각각의 컨트롤러들이 연산을 하고 이것을 CPU에게 인터럽트를 발생시켜 보고하는 형태로 처리된다. CPU는 항상 메모리에 명령어를 읽어와 작업을 수행하는데 매 명령어를 읽어오기 전 인터럽트가 발생하였는지 확인하고 인터럽트가 발생했으면 인터럽트를 먼저 처리하고 그 이후에 명령어를 처리한다.\n\n\n#### Device Controller\n각각의 디바이스들을 I/O연산, 제어관리를 하는 역할을 한다.(각각의 디바이스들의 CPU 역할)\n**Device Driver**\n운영체제가 각각의 디바이스를 접근하게 하기위한 인터페이스역할을하는 소프트웨어.\n**펌웨어**\n디바이스가 동작하기위한 소프트웨어\n\n#### Buffer\n각각의 디바이스 컨트롤러들이 명령을 내려 디바이스의 데이터를 읽어오거나 출력할때는 데이터를 저장하는 공간이다. (각각의 디바이스들의 램역할)\n\n\n### 3. 입터럽트의 일반적 기능\n\n그다음 CPU와 각각의 I/O 디바이스 컨트롤러 디바이스들 간에 인터럽트 처리를 확인해 보자. 기본적으로 운영체제에는 인터럽트가 발생했을 때 각각의 인터럽트에 대한 처리가 운영체제 안에 코드로 작성되어 저장되어있다. 이 다양한 인터럽트에 대해 각각의 처리해야 할 업무들을 정의해놓은 것이 인터럽트 처리 루틴이다. CPU는 인터럽트가 발생하면 하던 일을 멈추고 인터럽트가 발생했을 대 수행해야 할 코드영역으로 가서 정의된 작업을 하게 된다. 이때 수행되는 일을 좀 더 자세히 보면 다음과 같다. CPU 가 먼저 로컬 버퍼에 있는 내용을 프로그램 B가 사용할 수 있도록 메모리로 전달하고, 이제 프로그램 B가 CPU를 할당받을 경우 다음 명령어를 수행할 수 있음을 표시해둔다.\n\n인터럽트는 크게 2가지고 인터럽트로 나누어지는데 하드웨어 인터럽트와 소프트웨어 인터럽트가 있다. 하드웨어 인터럽트는 하드웨어가 발생시키고 소프트웨어는 소프트웨어가 인터럽트를 발생시킨다는 차이가 있다. 운영체제는 인터럽트 루틴을 쉽게 찾아가기 위해 인터럽트 벡터를 가지고 있다. 인터럽트 벡터는 인터럽트 종류마다 번호를 정해서, 번호에 따라 처리해야할 코드가 위치한 부분을 포인터로 가리키고 있는 자료구조를 말한다. 실제처리는 인터럽트 루틴에서 이루어진다.\n\n\n#### Interrupt\nCPU는 I/O 디바이스들이 데이터를 입력할때까지 기다리는게 아니라 자신의 일을 계속 처리하고있게 된다. 이때 I/O 디바이스들에게 입력이 이루어지면 각각의 디바이스 컨틀롤러가 인터럽트를 발생시켜 CPU에게 알려준다. 이때 발생시키는 신호를 인터럽트라고 한다.\n\n#### 인터럽트 루틴\n운영체제에는 인터럽트가 발생했을 때 각각의 인터럽트에대한 처리가 운영체제 안에 저장되어있다. 이 다양한 인터럽트에대해 각각의 처리해야할 업무들을 정의 해놓은것이 인터럽트 처리 루틴이다.\n\n#### 인터럽트 벡터\n인터럽트 벡터는 인터럽트 종류마다 번호를 정해서, 번호에 따라 처리해야할 코드가 위치한 부분을 포인터로 가리키고 있는 자료구조를 말한다.\n\n#### System Call\n응용프로그램이 운영체제의 서비스를 받기위해 커널함수를 호출하는것.\n\n#### Timer\n특정 프로그램이 무한루프에 빠져 CPU를 독점하는 경우를 막기위해 존재한다. 만약 특정프로그램이 CPU할당시간을 초과한다면 timer는 인터럽트를 발생시켜 CPU의 권한을 운영체제에게 다시 넘긴다.\n\n#### mode bit\n CPU에서 지금 실행되는 프로그램이 프로그램인지 운영체제인지 구분해주는 역할\n\n#### 스택영역\n실행중인 함수에서 다른 함수를 호출한경우 호출된 함수의 종료후 원래 함수의 실행이던 위치로 돌아오기 위해 복귀 주소를 저장하는 위치이다.\n#### 데이터 영역\n전역변수등 프로그램이 사용하는 각종 데이터가 저장되는 공간이다.\n#### 코드 영역\n프로그래머가 작성한 코드가 기계어 명령형태로 저장되는 영역이다.\n\n#### DMA\nCPU가 각각의 I/O디바이스를 통해 데이터를 읽어 메인메모리에 프로그램에게 전달하게되면 CPU효율이 떨어지기때문에 주변기기의 인터페이스 장치에 제어권을 주어 직접 주기억장치와 데이터를 주고 바는 방식으로 액세스하여 데이터를 전송하는 방법\n\n\n### 4.인터럽트 핸들링\n\n인터럽트 핸들링이란 인터럽트가 발생한 경우에 처리해하는 절차를 의미한다. 인터럽트는 앞에서 말한 대로 발생 시에만 CPU에 의해 운영체제 코드 부분 즉 인터럽트 루틴을 실행한다. 인터럽트가 발생하지 않는다면 CPU는 계속 계속해서 사용자 프로그램의 명령어를 처리할 것이다.\n\nCPU가 사용자 프로그램 처리 중 인터럽트가 발생하면 사용자 프로그램의 현재 수행 중이던 주소와 부가적인 정보를 저장해야 한한다. 왜냐하면 인터럽트가 발생하면 레지스터의 기존 데이터들이 지워지기 때문이다.\n\n운영체제 커널 내에는 현재 시스템 내에서 수행되는 프로그램들을 관리하기 위한 자료 구조인 프로세스 제어 블록(PCB : Process Control Block) 을 두고 있다. 이 자료 구조 중 일부는 인터럽트가 발생했을 때 프로그램의 어느 부분이 수행되던 중이었는지를 저장하기 위한 자료구조로 사용된다.\n\n이 자료구조를 바탕으로 인터럽트가 발생했을 때 인터럽트 처리를 하고 CPU는 다시 원래 프로그램으로 돌아올 수 있다.\n\n#### PCB\n운영체제 커널 내에는 현재 시스템 내에서 수행되는 프로그램들을 관리하기 위한 자료 구조인 프로세스 제어 블록(PCB : Process Control Block) 을 두고 있다. 이 자료 구조중 일부는 인터럽트가 발생했을때 프로그램의 어느부분이 수행되던 중이었는지를 저장하기 위한 자료구조로 사용된다.\n\n### 4.입출력 구조\n\n#### 동기식 입출력\n입출력(I/O)이란 컴퓨터 시스템이 컴퓨터 외부의 주변 장치들과 데이터를 주고받는것을 말한다. 입출력 방식에는 동기식 입출력과 비동기식 입출력이 있다. 동기식 입출력(synchronous I/O)은 입출력 요청후 입출력 작업이 완료된후에야 CPU의 제어권이 그 프로그램에게 다시 넘어갈 수 있는 방식을 말한다. 따라서 동기식 입출력에서는 입출력 연산이 끝날 때까지 CPU는 아무 일을 수행할 수 없다. 기본적으로 CPU의 명령수행속도는 빠른반면 외부 장치에서 데이터를 읽어오는 등의 입출력 연산은 상대적으로 속도가 느리다. 그럼으로 CPU가 입출력 연산을 기다리는것은 비효율적이다. 따라서 일반적으로 프로그램이 입출력을 수행중인 경우 CPU를 다른 프로그램에게 이양해 CPU가 계속쉬지 않고 일할수 있도록 관리한다. 그리고 그 입출력을 수행하고있는 프로그램은 CPU를 할당하더라도 명령을 수행을 못하는데 이것을 **\"봉쇄 상태(blocked state)\"** 로 전환 시킨다고 말한다. 봉쇄 상태의 프로그램에게는 CPU를 할당하지 않고, CPU를 할당하면 곧바로 작업 수행 가능한 프로그램들에게만 CPU를 할당하게 된다.\n\n그러나 여기에서 문제가 하나 발생할 수 있다. 앞서 설명한 것처럼 입출력이 수행중일 때 다른 프로그램에게 CPU를 양도하게 되므로 다수의 입출력 연산이 동시에 요청되거나 처리될 수 있다. 예를들어 A라는 프로그램과 B라는 프로그램이 있다고 가정하자. 이때 두 프로그램은 동시에 하나의 파일에 접근하려고한다. 여기에서 개발자는 A라는 프로그램이 먼저 파일을 수정할것을 예상하고 개발했다고 가정해보자. 하지만 컨트롤러는 이것의 순서를 보장하지 않는다. 이러한 문제점을 해결하기 위해서 **I/O장치** 별로 큐를 두어 요청한 순서대로 처리할 수 있도록 한다. 큐는 아시다시피 FIFO의 구조로 이루어지기 때문에 들어온 순서대로 처리하게 될것이다.\n\n위의 내용을 보면 크게 I/O동기식 입출력은 크게 2가지 구현 방법이 있다.\n**구현방법 1**\n* I/O 끝날 때까지 CPU를 낭비시킴\n* 매시점 하나의 I/O만 일어날 수 있음\n\n**구현방법 2**\n* I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗음\n* I/O처리를 기다리는 줄에 그 프로그램을 줄세움\n* 다른 프로그램에게 CPU를 줌\n\n#### 비동기식 입출력\n비동기식 입출력은 입출력 연산을 요청한 후에 연산이 끝나기를 기다리는 것이 아니라 CPU의 제어권을 입출력 연산을 호출한 그 프로그램에게 곧바로 다시 부여하는 방식을 말한다. 프로그램 중 데이터를 입출력할 때 입출력 결과를 기다려야 하는 경우가 있을 수 있고, 반대로 입출력 결과는 상관없이 다른 일을 수행할 수 있는 기능들이 있을 것이다. 비동기식에서는 입출력 결과에 상관없이 수행할 수 있는 일들을 먼저 처리하고 입출력의 결과가 필요한 프로그램들은 입출력이 완료된 후에 작업을 수행한다.\n\n![](https://i.imgur.com/ykkvu39.png)\n\n위 그림은 동기식 입출력과 비동기식 입출력을 비교해 보여주는 그림이다. 동기식 입출력 같은 경우에는 응답이 돌아올 때까지 입출력을 요청했던 프로그램은 봉쇄 상태가 되고 인터럽트가 발생하면 그때 입출력에 관한 프로그램이 봉쇄 상태가 풀리게 되고 CPU를 할당받을 수 있는 상태가 된다.\n\n반면 비동기식 프로그램은 입출력을 요청한 프로세스에게 곧바로 다시 주어지며, 입출력 연산이 완료되는 것과 무관하게 처리 가능한 작업부터 처리한다. 한편, 비동기식 입출력에서도 입출력 연산이 완료되면 동기식과 마찬가지로 인터럽트를 통해 이를 CPU에게 알려준다. 이러한 구체적인 예를 통해 정리해보면 다음과 같다.\n\n1. 프로그램 A가 실행중에 디스크에서 데이터를 읽어오는 명령을 만나게되면 A는 시스템콜을 발생시킨다.\n2. CPU는 지금까지 프로그램 A의 작업을 멈추고 현재 수행상태를 저장한후에, 인터럽트에 의해 처리 되어야할 커널 루틴으로 이동한다.\n3. 처리 루틴으로 이동하게되면 CPU는 컨트롤러에게 입출력 연산을 요청하게 된다.\n4. 디바이스 컨트롤러는 A가 요청한 데이터를 디스크로부터 읽어와 버퍼에 저장한다.\n5. 읽어오는 동안 프로그램 A는 CPU를 B 프로그램에게 넘겨주게 된다. (이때 A프로그램은 봉쇄상태가 가되고 CPU 명령을 수행하려고해도 수행하지 못함)\n6. 디바이스컨트롤러가 작업이 다 끝나면 하드웨어 인터럽트를 발생시킨다.\n7. 인터럽트가 발생하면 B프로그램을 처리작업을 잠시 미뤄 두고 인터럽트 처리루틴에 가서 인터럽트를 처리한다.\n8. 그럼 인터럽트 처리루틴은 컨틀러에서 데이터를 읽어와 A프로그램에게 올리게되고 A프로그램은 다시 CPU 줄을 기다려야한다.\n9. 그 후 다시 프로그램 B로 돌아가 작업을 수행하게된다.\n\n일반적으로는 동기식 입출력을 사용한다. 이 때 운영체제는 장치별로 입출력 처리를 기다리는 프로세스를 줄세워 관리한다.\n\n### 5. DMA(Direct Memory Access)\n\n일반적으로 I/O 디바이스들이 메인 메모리에 바로 접근할 수 없고 I/O 디바이스들은 인터럽트를 발생시켜 CPU가 I/O 디바이스들의 데이터를 읽어 메인 메모리 프로그램에 올린다. 하지만 CPU는 프로그램의 명령어를 처리하는 것 외에도 항상 각각의 I/O 디바이스들 인터럽트에 대한 처리도 해야 하기 때문에 기존 CPU 작업들을 방해하게 된다.\n\n이러한 비효율성을 극복하기 위해 CPU 대신에 I/O 디바이스들에 인터럽트를 처리할 컨트롤러를 하나 더 둔다. 이것이 바로 DMA 장치이다. DMA가 있음으로 더 이상 CPU는 하던 작업을 멈추고 각종 I/O디바이스들의 인터럽트를 처리할 필요가 없어진다. 단지 DMA Controller에 인터럽트만 처리하게 되면 된다. 이때 DMA는 바이트 단위가 아니라 블록 단위로 데이터를 모아서 CPU에게 인터럽트를 발생시킨다. 이러한 방법으로 CPU의 효율을 높일 수 있다.\n\n* 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해사용\n* CPU의 중재 없이 Device controller가 device의 buffer storage의 내용을 메모리에 block 단위로 직접 전송\n* 바이트 단위가 아니라 block 단위로 인터럽트를 발생시킴\n\n\n### 6. 저장 장치 구조\n\n#### 주기억장치\n컴퓨터 시스템을 구성하는 저장 장치는 주 기억 장치와 보조기억장치다. 주 기억장치는 보통 메모리라고 부르며 전원이 나가면 저장되었던 내용이 모두 사려 저버리는 휘발성(volatile)의 RAM을 매체로 사용하는 경우이다.\n\n#### 보조기억장치\n보조기억장치는 전원이 나가도 저장된 내용을 기억할 수 있는 비휘발성(nonvolatile)의 마그네틱 디스크를 흔히 사용한다. 보조 기억장치는 크게 두가지 부분으로 파일시스템용과 스왑 영역이다.\n**파일 시스템**\n전원이 나가도 유지해야할 정보가있으면 그것을 파일형태로 보조기억장치에 저장한다.\n**스왑 영역**\n메인 메모리의 크기는 한정되어있고, 가격이 비싸다. 그러므로 다수의 프로그램이 메인 메모리에 올라가 동시에 수행될경우 메모리 공간이 부족한경우가 많다. 그렇기 때문에 한번에 모두 메인메모리에 올려놓는게 아니라 프로그램이 돌아가기 위한 핵심적인 부분만 메인 메모리에 올려놓고 나머지는 스왑영역에두고 필요할 때마다 메인 메모리로 불러오게 된다.\n\n\n### 7. 저장 장치의 계층 구조\n\n컴퓨터의 시스템을 구성하는 저장 장치부터 느린 저장 장치까지 단계적인 계층 구조로 이루어진다. 빠른 저장 장치는 단위 공간당 가격이 높기때문에 적은 용량을 사용하며, 느린 저장 장치는 가격이 저렴해 대용량을 사용하는 반면 접근속도가 느리다는 약점이 있다. 아래그림은 이 내용을 그림으로 표현한것이다.\n\n![](https://i.imgur.com/z6a9a8B.png)\n\n상위 저장 장치 계층으로 갈수록 접근 속도가 월등히 빠르지만 용량은 상대적으로 적다. 하지만 당장 필요한 정보만을 선별적으로 저장하게 되면 마치 하위에 있는 큰 용량의 저장 장치를 가지고 있는 것과 비슷한 성능 효과를 낼 수 있다. 예를 들면, 캐시메모리는 레지스터와 메인 메모리 사이에 존재한다. 캐시메모리는 메인 메모리보다 용량이 작다. 그러나 여러 가지 캐슁기법을 이용해 적은 용량의 캐시메모리를 사용해서도 메인 메모리와 같이 큰 용량을 가진 것처럼 효율적으로 관리할 수 있다.\n\n**캐슁 기법** 이란 상대적으로 느린 저장장치에 있는 내용중에 당장 사용되거나 빈번히 사용될 정보를 빠른 저장장치에 선별적으로 저장하여, 두 저장 장치 사이의 속도를 완충 시키는 기법을 의미한다.\n\n### 8. 하드웨어의 보안\n\n일반적으로 사용하는 운영체제는 여러 프로그램이 동시에 실행될 수 있는 다중 프로그래밍 환경에서 실행된다. 그러므로 각 프로그램들이 다른 프로그램의 실행을 방해하거나 프로그램 간에 서로 충돌이 일어날 수 있기 때문에 이러한 문제를 해결하기 위한 각종 보안 기법이 필요하다. 하드웨어적인 보안을 유지하기 위해서 운영체제는 기본적으로 두 가지 모두의 운영을 지원한다. 커널 모드와 사용자 모두가 이에 해당한다.\n\n커널 모드는 운영체제가 CPU의 제어권을 가지고 운영체제 코드를 실행되는 모드로서, 이 모드에서는 모든 종류의 명령을 다 실행할 수 있다. 사용자모드는 일반 사용자 프로그램이 실행되며 제한적인 명령만을 수행할 수 있다.\n\n그러나 중요한 연산을 운영체제만이 수행할 수 있도록 수행버리면 제어가 필요 없게된다. 사용자 프로그램이 CPU를 가지고 있는 동안에는 운영체제가 CPU를 선점할 수 없으므로 사용자 프로그램을 감시할 수 있는 방법이 없게된다. 그러므로 이러한 상황을 방지하기위해 **모드비트** 라는 하드웨어적인 자원이 필요하다.\n\n모드 비트가 0으로 세팅되어 있으면 커널 모드를 의미하고, 모드 비트가 1이면 사용자 모드를 의미한다. CPU는 보안과 관련된 명령을 수행하기 전에는 모드 비트를 조사해 모드 비트가 0으로 세팅된 경우에만 그 명령을 수행한다.\n\nCPU가 운영체제를 점유하고 있을 때 운영체제는 모드 비트를 0으로 사용하다가 사용자 프로그램에게 CPU를 넘길 때에는 모드 비트를 1로 세팅하고 넘기게 된다. 보통 모드 비트가 0이 되는 경우에는 이와 같이 운영체제에게 권한이 넘어가거나 인터럽트가 발생하여 인터럽트 루틴을 처리해야 할 경우이다.\n\n#### 커널모드\n운영체제가 CPU의 제어권을 가지고 운영체제 코드를 실행되는 모드로서, 이 모드에서는 모든 종류의 명령을 다 실행할 수 있다.\n\n#### 사용자 모드\n일반 사용자 프로그램이 실행되며 제한적인 명령만을 수행할 수 있다.\n\n#### 모드비트\n모드비트를 통해 CPU가 운영체제 함수를 호출할 수 있는지 결정하게된다. 모드 비트가 0이면 커널모드를 의미하고 1이면 사용자 모드를 의미한다.\n\n### 9. 메모리 보안\n여러 프로그램이 메모리에 동시에 올라가서 실행되기 때문에 하나의 사용자 프로그램이 다른 사용자 프로그램이나 운영체제가 위치한 메모리 영역을 침범할 수 있기 때문이다. 적어도 인터럽트 벡터와 인터럽트 처리 루틴이 있는 곳은 각별한 보안이 필요하다. 이러한 문제를 해결하기 위해서 두 개의 레지스터를 이용해 현재 접근하려는 메모리가 한 법적인지 체크함으로써 메모리를 보호한다.\n\n이두가지는 기준 레지스터(base register)와 한계 레지스터(limit register)이다. 기준 레지스터는 실행되고 있는 프로그램이 합법적으로 접근이 시작되는 메모리 주소를 보관하고 있고, 한계 레지스터는 해당 프로그램이 기준 레지스터로부터 접근할 수 있는 범위를 저장하고 있다. 사용자 프로그램은 이 두 개의 값의 범위만 접근할 수 있게 된다. 이 범위를 벗어난 접근을 하게 되면 예외 인터럽트가 발생하게 된다.\n\n아래그림은 기준레지스터 한계리지서터의 내용을 표현한 그림이다.\n![](https://i.imgur.com/Q6fK3mt.png)\n\n### 10. CPU의 보호\n\n일반적으로 CPU는 컴퓨터 시스템내에 하나밖에 존재하지 않기 때문에 특정 프로그램이 CPU를 독점해 무한 반복문을 수행하는 등 부적절한 방법으로 CPU를 독점한다면 다른프로그램들 및 운영체제가 CPU를 획득하지 못하게 된다. 이와같이 CPU가 하나의 프로그램의 독점을 막기위해 타이머라는 하드웨어가 존재 한다.\n타이머는 정해진 시간이 지나면 인터럽트를 발생시켜 운영체제에게 CPU의 제어권을 이양시키는 역할을 한다. 타이머는 정해진 시간이지나면 인터럽트를 발생시키는데 이 인터럽트 처리 루틴의 내용은 CPU의 제어권을 CPU에게 넘기는것이다.\n\n### 11. 시스템 콜을 이용한 입출력 수행\n\n사용자 프로그램이 I/O 디바이이스등을 통해 데이터 입출력을 할 수 없다. 보통 이러한 작업은 운영체제를 통해서 해야한다. 운영체제에는 I/O디바이스들에 데이터 입출력명령이 코드로 구현되어 있다. 그래서 보통 사용자 프로그램들은 인터럽트를 발생을 시켜 I/O디바이스등 입출력을하는데 이러한 것을 가리켜 시스템 콜이라고한다. 시스템콜은 소프트웨어적인 인터럽트로서 사용자 프로그램이 시스템콜을 할경우 트랩이 발생해 CPU에 대한 제어권이 운영체제로 넘어간다. 그러면 운영체제는 해당하는 시스템콜을 처리하기위해 처리루틴으로가서 시스템 콜 에 맞는 처리 루틴을 수행한다.\n\n\n참조\n* [운영체제와 정보기술의 원리](http://www.yes24.com/24/goods/2824944)\n","slug":"2018-06-23-운영체제란[OS-2]","published":1,"updated":"2018-06-23T13:40:43.663Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27f00049jjpepcw6g7cc","content":"<h2><span id=\"컴퓨터-시스템-구조\">컴퓨터 시스템 구조</span></h2>\n<h3><span id=\"1-컴퓨터-시스템의-구조\">1. 컴퓨터 시스템의 구조</span></h3>\n<p>컴퓨터 시스템 구조에 들어가기전에 용어를 먼저 정리해보자.</p>\n<h4><span id=\"cpu란\">CPU란</span></h4>\n<p>CPU는 내부적으로 크게 3가지로 나눌 수 있습니다. 연산을 수행하는 산술논리장치(ALU), 제어 명령을 전달하는 컨트롤 장치(CU), 결과 값을 일시적으로 기억하는 레지스터(Register)가 이에 해당됩니다. 아래 그림은 CPU의 구조를 그림으로 도식화 한 것이다.<br>\n<img src=\"https://i.imgur.com/r0MbHY2.png\" alt=\"\"></p>\n<h4><span id=\"memory란\">Memory란</span></h4>\n<p>CPU의 Register의 용량은 매우 작다. 그래서 정보를 저장해 두었다가 필요할 때 읽어 들여 이용할 수 있는 주 기억 장치가 필요하다. 이 주기억장치에는 컴퓨터가 켜지면 운영체제, 사용자 프로그램등이 메모리공간에 올라가게된다. CPU는 주기억장치에서 프로그램들의 명령어등을 읽어와 작업을 수행한다. 주 기억창치로는 ROM, RAM 등이 있음.</p>\n<h4><span id=\"io-device란\">I/O Device란</span></h4>\n<p>입출력 장치란, 사용자가 원하는 문자나 그림의 데이터를 컴퓨터로 전달하는 하거나 출력하는 장치이다. 입력장치의 종류에는 키보드, 마우스이 있고 출력 장치로는 모니터, 프린터등이 있다.</p>\n<p>컴퓨터 시스템은 크게 위 3단어로 구성된다고 볼 수 있다. 아래 그림은 컴퓨터 시스템 구조를 도식화한 것이다.</p>\n<p><img src=\"https://i.imgur.com/DmnmAGX.png\" alt=\"\"></p>\n<p>간단하게 컴퓨터 시스템 흐름을 설명하면 컴퓨터에 전원이 들어오게 되면 메인메모리에 운영체제가 올라간다. 이때 모든 운영체제 코드가 올라가는게아니라 시스템이 돌아가기위한 핵심적인 부분이 먼저올라가는데 이부분을 커널이라 한다. 이러한 이유는 모든 코드가 메모리에 올리게되면 자원낭비가 심하기 때문이다.</p>\n<p>그 이후에 CPU는 메모리의 운영체제 프로그램들을 읽어 운영체제를 실행한다. 운영체제가 시작되고 다른 프로그램들을 실행시키면 마찬가지로 메인메모리에 올라가게 된다. 이때 CPU는 메인메모리에 명령어주소를 레지스터에 저장하는데 이 레지스터이름은 PC레지스터라 한다. 그 이후 각각의 프로그램들은 I/O 디바이스 사용이 필요할 수 있는데 이러한 요청은 운영체제한테 요청을해야한다. 이러한 요청을 시스템콜이라고 한다. 이렇게 프로그램들이 직접 I/O디바이스를 제어하지 않는 이유는 많은 이유가있지만 가장큰 이유는 보안때문이다.</p>\n<p>프로그램의 요청을 받은 운영체제는 I/O 디바이스의 컨트롤러에게 데이터 입출력 처리를 요청을 한다. 그리고 I/O 디바이스 컨 틀롤러들은 입출력을 받게 되면 Interrupt를 발생시켜 CPU에게 작업이 완료됐다고 알리게 된다. CPU는 I/O 디바이스에 버퍼에 가서 데이터를 읽어와 메인 메모리에 올려놓게 된다. 이러한 작업이 반복되는 것이 컴퓨터 프로그램의 동작 원리이다. 아래 그림은 좀 더 CPU와 메모리 I/O 디바이스들을 세부 분화한 그림이다.</p>\n<p><img src=\"https://i.imgur.com/8JAIHTg.png\" alt=\"\"></p>\n<h3><span id=\"2-cpu와-io연산\">2. CPU와 I/O연산</span></h3>\n<p>위 구조에서 먼저 I/O 디바이스와 CPU 관계를 봐보자. 컴퓨터에 대한 연산은 CPU가 처리한다. 반면 I/O 디바이스들에 대한 연산은 각각의 디바이스 컨트롤러들이 처리한다. 컨트롤러들은 각각의 디바이스들의 CPU 역할을 한다. 이렇기 때문에 둘은 서로 동시에 처리가 가능하다. 그리고 각각의 컨트롤러로부터 들어오고 나오는 데이터들은 로컬 버퍼에서 관리한다. 로컬 버퍼는 램과 같은 역할을 한다.</p>\n<p>데이터가 입출력되었는지는 CPU가 처리하는 게 아니라 각각의 컨트롤러들이 연산을 하고 이것을 CPU에게 인터럽트를 발생시켜 보고하는 형태로 처리된다. CPU는 항상 메모리에 명령어를 읽어와 작업을 수행하는데 매 명령어를 읽어오기 전 인터럽트가 발생하였는지 확인하고 인터럽트가 발생했으면 인터럽트를 먼저 처리하고 그 이후에 명령어를 처리한다.</p>\n<h4><span id=\"device-controller\">Device Controller</span></h4>\n<p>각각의 디바이스들을 I/O연산, 제어관리를 하는 역할을 한다.(각각의 디바이스들의 CPU 역할)<br>\n<strong>Device Driver</strong><br>\n운영체제가 각각의 디바이스를 접근하게 하기위한 인터페이스역할을하는 소프트웨어.<br>\n<strong>펌웨어</strong><br>\n디바이스가 동작하기위한 소프트웨어</p>\n<h4><span id=\"buffer\">Buffer</span></h4>\n<p>각각의 디바이스 컨트롤러들이 명령을 내려 디바이스의 데이터를 읽어오거나 출력할때는 데이터를 저장하는 공간이다. (각각의 디바이스들의 램역할)</p>\n<h3><span id=\"3-입터럽트의-일반적-기능\">3. 입터럽트의 일반적 기능</span></h3>\n<p>그다음 CPU와 각각의 I/O 디바이스 컨트롤러 디바이스들 간에 인터럽트 처리를 확인해 보자. 기본적으로 운영체제에는 인터럽트가 발생했을 때 각각의 인터럽트에 대한 처리가 운영체제 안에 코드로 작성되어 저장되어있다. 이 다양한 인터럽트에 대해 각각의 처리해야 할 업무들을 정의해놓은 것이 인터럽트 처리 루틴이다. CPU는 인터럽트가 발생하면 하던 일을 멈추고 인터럽트가 발생했을 대 수행해야 할 코드영역으로 가서 정의된 작업을 하게 된다. 이때 수행되는 일을 좀 더 자세히 보면 다음과 같다. CPU 가 먼저 로컬 버퍼에 있는 내용을 프로그램 B가 사용할 수 있도록 메모리로 전달하고, 이제 프로그램 B가 CPU를 할당받을 경우 다음 명령어를 수행할 수 있음을 표시해둔다.</p>\n<p>인터럽트는 크게 2가지고 인터럽트로 나누어지는데 하드웨어 인터럽트와 소프트웨어 인터럽트가 있다. 하드웨어 인터럽트는 하드웨어가 발생시키고 소프트웨어는 소프트웨어가 인터럽트를 발생시킨다는 차이가 있다. 운영체제는 인터럽트 루틴을 쉽게 찾아가기 위해 인터럽트 벡터를 가지고 있다. 인터럽트 벡터는 인터럽트 종류마다 번호를 정해서, 번호에 따라 처리해야할 코드가 위치한 부분을 포인터로 가리키고 있는 자료구조를 말한다. 실제처리는 인터럽트 루틴에서 이루어진다.</p>\n<h4><span id=\"interrupt\">Interrupt</span></h4>\n<p>CPU는 I/O 디바이스들이 데이터를 입력할때까지 기다리는게 아니라 자신의 일을 계속 처리하고있게 된다. 이때 I/O 디바이스들에게 입력이 이루어지면 각각의 디바이스 컨틀롤러가 인터럽트를 발생시켜 CPU에게 알려준다. 이때 발생시키는 신호를 인터럽트라고 한다.</p>\n<h4><span id=\"인터럽트-루틴\">인터럽트 루틴</span></h4>\n<p>운영체제에는 인터럽트가 발생했을 때 각각의 인터럽트에대한 처리가 운영체제 안에 저장되어있다. 이 다양한 인터럽트에대해 각각의 처리해야할 업무들을 정의 해놓은것이 인터럽트 처리 루틴이다.</p>\n<h4><span id=\"인터럽트-벡터\">인터럽트 벡터</span></h4>\n<p>인터럽트 벡터는 인터럽트 종류마다 번호를 정해서, 번호에 따라 처리해야할 코드가 위치한 부분을 포인터로 가리키고 있는 자료구조를 말한다.</p>\n<h4><span id=\"system-call\">System Call</span></h4>\n<p>응용프로그램이 운영체제의 서비스를 받기위해 커널함수를 호출하는것.</p>\n<h4><span id=\"timer\">Timer</span></h4>\n<p>특정 프로그램이 무한루프에 빠져 CPU를 독점하는 경우를 막기위해 존재한다. 만약 특정프로그램이 CPU할당시간을 초과한다면 timer는 인터럽트를 발생시켜 CPU의 권한을 운영체제에게 다시 넘긴다.</p>\n<h4><span id=\"mode-bit\">mode bit</span></h4>\n<p>CPU에서 지금 실행되는 프로그램이 프로그램인지 운영체제인지 구분해주는 역할</p>\n<h4><span id=\"스택영역\">스택영역</span></h4>\n<p>실행중인 함수에서 다른 함수를 호출한경우 호출된 함수의 종료후 원래 함수의 실행이던 위치로 돌아오기 위해 복귀 주소를 저장하는 위치이다.</p>\n<h4><span id=\"데이터-영역\">데이터 영역</span></h4>\n<p>전역변수등 프로그램이 사용하는 각종 데이터가 저장되는 공간이다.</p>\n<h4><span id=\"코드-영역\">코드 영역</span></h4>\n<p>프로그래머가 작성한 코드가 기계어 명령형태로 저장되는 영역이다.</p>\n<h4><span id=\"dma\">DMA</span></h4>\n<p>CPU가 각각의 I/O디바이스를 통해 데이터를 읽어 메인메모리에 프로그램에게 전달하게되면 CPU효율이 떨어지기때문에 주변기기의 인터페이스 장치에 제어권을 주어 직접 주기억장치와 데이터를 주고 바는 방식으로 액세스하여 데이터를 전송하는 방법</p>\n<h3><span id=\"4인터럽트-핸들링\">4.인터럽트 핸들링</span></h3>\n<p>인터럽트 핸들링이란 인터럽트가 발생한 경우에 처리해하는 절차를 의미한다. 인터럽트는 앞에서 말한 대로 발생 시에만 CPU에 의해 운영체제 코드 부분 즉 인터럽트 루틴을 실행한다. 인터럽트가 발생하지 않는다면 CPU는 계속 계속해서 사용자 프로그램의 명령어를 처리할 것이다.</p>\n<p>CPU가 사용자 프로그램 처리 중 인터럽트가 발생하면 사용자 프로그램의 현재 수행 중이던 주소와 부가적인 정보를 저장해야 한한다. 왜냐하면 인터럽트가 발생하면 레지스터의 기존 데이터들이 지워지기 때문이다.</p>\n<p>운영체제 커널 내에는 현재 시스템 내에서 수행되는 프로그램들을 관리하기 위한 자료 구조인 프로세스 제어 블록(PCB : Process Control Block) 을 두고 있다. 이 자료 구조 중 일부는 인터럽트가 발생했을 때 프로그램의 어느 부분이 수행되던 중이었는지를 저장하기 위한 자료구조로 사용된다.</p>\n<p>이 자료구조를 바탕으로 인터럽트가 발생했을 때 인터럽트 처리를 하고 CPU는 다시 원래 프로그램으로 돌아올 수 있다.</p>\n<h4><span id=\"pcb\">PCB</span></h4>\n<p>운영체제 커널 내에는 현재 시스템 내에서 수행되는 프로그램들을 관리하기 위한 자료 구조인 프로세스 제어 블록(PCB : Process Control Block) 을 두고 있다. 이 자료 구조중 일부는 인터럽트가 발생했을때 프로그램의 어느부분이 수행되던 중이었는지를 저장하기 위한 자료구조로 사용된다.</p>\n<h3><span id=\"4입출력-구조\">4.입출력 구조</span></h3>\n<h4><span id=\"동기식-입출력\">동기식 입출력</span></h4>\n<p>입출력(I/O)이란 컴퓨터 시스템이 컴퓨터 외부의 주변 장치들과 데이터를 주고받는것을 말한다. 입출력 방식에는 동기식 입출력과 비동기식 입출력이 있다. 동기식 입출력(synchronous I/O)은 입출력 요청후 입출력 작업이 완료된후에야 CPU의 제어권이 그 프로그램에게 다시 넘어갈 수 있는 방식을 말한다. 따라서 동기식 입출력에서는 입출력 연산이 끝날 때까지 CPU는 아무 일을 수행할 수 없다. 기본적으로 CPU의 명령수행속도는 빠른반면 외부 장치에서 데이터를 읽어오는 등의 입출력 연산은 상대적으로 속도가 느리다. 그럼으로 CPU가 입출력 연산을 기다리는것은 비효율적이다. 따라서 일반적으로 프로그램이 입출력을 수행중인 경우 CPU를 다른 프로그램에게 이양해 CPU가 계속쉬지 않고 일할수 있도록 관리한다. 그리고 그 입출력을 수행하고있는 프로그램은 CPU를 할당하더라도 명령을 수행을 못하는데 이것을 <strong>“봉쇄 상태(blocked state)”</strong> 로 전환 시킨다고 말한다. 봉쇄 상태의 프로그램에게는 CPU를 할당하지 않고, CPU를 할당하면 곧바로 작업 수행 가능한 프로그램들에게만 CPU를 할당하게 된다.</p>\n<p>그러나 여기에서 문제가 하나 발생할 수 있다. 앞서 설명한 것처럼 입출력이 수행중일 때 다른 프로그램에게 CPU를 양도하게 되므로 다수의 입출력 연산이 동시에 요청되거나 처리될 수 있다. 예를들어 A라는 프로그램과 B라는 프로그램이 있다고 가정하자. 이때 두 프로그램은 동시에 하나의 파일에 접근하려고한다. 여기에서 개발자는 A라는 프로그램이 먼저 파일을 수정할것을 예상하고 개발했다고 가정해보자. 하지만 컨트롤러는 이것의 순서를 보장하지 않는다. 이러한 문제점을 해결하기 위해서 <strong>I/O장치</strong> 별로 큐를 두어 요청한 순서대로 처리할 수 있도록 한다. 큐는 아시다시피 FIFO의 구조로 이루어지기 때문에 들어온 순서대로 처리하게 될것이다.</p>\n<p>위의 내용을 보면 크게 I/O동기식 입출력은 크게 2가지 구현 방법이 있다.<br>\n<strong>구현방법 1</strong></p>\n<ul>\n<li>I/O 끝날 때까지 CPU를 낭비시킴</li>\n<li>매시점 하나의 I/O만 일어날 수 있음</li>\n</ul>\n<p><strong>구현방법 2</strong></p>\n<ul>\n<li>I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗음</li>\n<li>I/O처리를 기다리는 줄에 그 프로그램을 줄세움</li>\n<li>다른 프로그램에게 CPU를 줌</li>\n</ul>\n<h4><span id=\"비동기식-입출력\">비동기식 입출력</span></h4>\n<p>비동기식 입출력은 입출력 연산을 요청한 후에 연산이 끝나기를 기다리는 것이 아니라 CPU의 제어권을 입출력 연산을 호출한 그 프로그램에게 곧바로 다시 부여하는 방식을 말한다. 프로그램 중 데이터를 입출력할 때 입출력 결과를 기다려야 하는 경우가 있을 수 있고, 반대로 입출력 결과는 상관없이 다른 일을 수행할 수 있는 기능들이 있을 것이다. 비동기식에서는 입출력 결과에 상관없이 수행할 수 있는 일들을 먼저 처리하고 입출력의 결과가 필요한 프로그램들은 입출력이 완료된 후에 작업을 수행한다.</p>\n<p><img src=\"https://i.imgur.com/ykkvu39.png\" alt=\"\"></p>\n<p>위 그림은 동기식 입출력과 비동기식 입출력을 비교해 보여주는 그림이다. 동기식 입출력 같은 경우에는 응답이 돌아올 때까지 입출력을 요청했던 프로그램은 봉쇄 상태가 되고 인터럽트가 발생하면 그때 입출력에 관한 프로그램이 봉쇄 상태가 풀리게 되고 CPU를 할당받을 수 있는 상태가 된다.</p>\n<p>반면 비동기식 프로그램은 입출력을 요청한 프로세스에게 곧바로 다시 주어지며, 입출력 연산이 완료되는 것과 무관하게 처리 가능한 작업부터 처리한다. 한편, 비동기식 입출력에서도 입출력 연산이 완료되면 동기식과 마찬가지로 인터럽트를 통해 이를 CPU에게 알려준다. 이러한 구체적인 예를 통해 정리해보면 다음과 같다.</p>\n<ol>\n<li>프로그램 A가 실행중에 디스크에서 데이터를 읽어오는 명령을 만나게되면 A는 시스템콜을 발생시킨다.</li>\n<li>CPU는 지금까지 프로그램 A의 작업을 멈추고 현재 수행상태를 저장한후에, 인터럽트에 의해 처리 되어야할 커널 루틴으로 이동한다.</li>\n<li>처리 루틴으로 이동하게되면 CPU는 컨트롤러에게 입출력 연산을 요청하게 된다.</li>\n<li>디바이스 컨트롤러는 A가 요청한 데이터를 디스크로부터 읽어와 버퍼에 저장한다.</li>\n<li>읽어오는 동안 프로그램 A는 CPU를 B 프로그램에게 넘겨주게 된다. (이때 A프로그램은 봉쇄상태가 가되고 CPU 명령을 수행하려고해도 수행하지 못함)</li>\n<li>디바이스컨트롤러가 작업이 다 끝나면 하드웨어 인터럽트를 발생시킨다.</li>\n<li>인터럽트가 발생하면 B프로그램을 처리작업을 잠시 미뤄 두고 인터럽트 처리루틴에 가서 인터럽트를 처리한다.</li>\n<li>그럼 인터럽트 처리루틴은 컨틀러에서 데이터를 읽어와 A프로그램에게 올리게되고 A프로그램은 다시 CPU 줄을 기다려야한다.</li>\n<li>그 후 다시 프로그램 B로 돌아가 작업을 수행하게된다.</li>\n</ol>\n<p>일반적으로는 동기식 입출력을 사용한다. 이 때 운영체제는 장치별로 입출력 처리를 기다리는 프로세스를 줄세워 관리한다.</p>\n<h3><span id=\"5-dmadirect-memory-access\">5. DMA(Direct Memory Access)</span></h3>\n<p>일반적으로 I/O 디바이스들이 메인 메모리에 바로 접근할 수 없고 I/O 디바이스들은 인터럽트를 발생시켜 CPU가 I/O 디바이스들의 데이터를 읽어 메인 메모리 프로그램에 올린다. 하지만 CPU는 프로그램의 명령어를 처리하는 것 외에도 항상 각각의 I/O 디바이스들 인터럽트에 대한 처리도 해야 하기 때문에 기존 CPU 작업들을 방해하게 된다.</p>\n<p>이러한 비효율성을 극복하기 위해 CPU 대신에 I/O 디바이스들에 인터럽트를 처리할 컨트롤러를 하나 더 둔다. 이것이 바로 DMA 장치이다. DMA가 있음으로 더 이상 CPU는 하던 작업을 멈추고 각종 I/O디바이스들의 인터럽트를 처리할 필요가 없어진다. 단지 DMA Controller에 인터럽트만 처리하게 되면 된다. 이때 DMA는 바이트 단위가 아니라 블록 단위로 데이터를 모아서 CPU에게 인터럽트를 발생시킨다. 이러한 방법으로 CPU의 효율을 높일 수 있다.</p>\n<ul>\n<li>빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해사용</li>\n<li>CPU의 중재 없이 Device controller가 device의 buffer storage의 내용을 메모리에 block 단위로 직접 전송</li>\n<li>바이트 단위가 아니라 block 단위로 인터럽트를 발생시킴</li>\n</ul>\n<h3><span id=\"6-저장-장치-구조\">6. 저장 장치 구조</span></h3>\n<h4><span id=\"주기억장치\">주기억장치</span></h4>\n<p>컴퓨터 시스템을 구성하는 저장 장치는 주 기억 장치와 보조기억장치다. 주 기억장치는 보통 메모리라고 부르며 전원이 나가면 저장되었던 내용이 모두 사려 저버리는 휘발성(volatile)의 RAM을 매체로 사용하는 경우이다.</p>\n<h4><span id=\"보조기억장치\">보조기억장치</span></h4>\n<p>보조기억장치는 전원이 나가도 저장된 내용을 기억할 수 있는 비휘발성(nonvolatile)의 마그네틱 디스크를 흔히 사용한다. 보조 기억장치는 크게 두가지 부분으로 파일시스템용과 스왑 영역이다.<br>\n<strong>파일 시스템</strong><br>\n전원이 나가도 유지해야할 정보가있으면 그것을 파일형태로 보조기억장치에 저장한다.<br>\n<strong>스왑 영역</strong><br>\n메인 메모리의 크기는 한정되어있고, 가격이 비싸다. 그러므로 다수의 프로그램이 메인 메모리에 올라가 동시에 수행될경우 메모리 공간이 부족한경우가 많다. 그렇기 때문에 한번에 모두 메인메모리에 올려놓는게 아니라 프로그램이 돌아가기 위한 핵심적인 부분만 메인 메모리에 올려놓고 나머지는 스왑영역에두고 필요할 때마다 메인 메모리로 불러오게 된다.</p>\n<h3><span id=\"7-저장-장치의-계층-구조\">7. 저장 장치의 계층 구조</span></h3>\n<p>컴퓨터의 시스템을 구성하는 저장 장치부터 느린 저장 장치까지 단계적인 계층 구조로 이루어진다. 빠른 저장 장치는 단위 공간당 가격이 높기때문에 적은 용량을 사용하며, 느린 저장 장치는 가격이 저렴해 대용량을 사용하는 반면 접근속도가 느리다는 약점이 있다. 아래그림은 이 내용을 그림으로 표현한것이다.</p>\n<p><img src=\"https://i.imgur.com/z6a9a8B.png\" alt=\"\"></p>\n<p>상위 저장 장치 계층으로 갈수록 접근 속도가 월등히 빠르지만 용량은 상대적으로 적다. 하지만 당장 필요한 정보만을 선별적으로 저장하게 되면 마치 하위에 있는 큰 용량의 저장 장치를 가지고 있는 것과 비슷한 성능 효과를 낼 수 있다. 예를 들면, 캐시메모리는 레지스터와 메인 메모리 사이에 존재한다. 캐시메모리는 메인 메모리보다 용량이 작다. 그러나 여러 가지 캐슁기법을 이용해 적은 용량의 캐시메모리를 사용해서도 메인 메모리와 같이 큰 용량을 가진 것처럼 효율적으로 관리할 수 있다.</p>\n<p><strong>캐슁 기법</strong> 이란 상대적으로 느린 저장장치에 있는 내용중에 당장 사용되거나 빈번히 사용될 정보를 빠른 저장장치에 선별적으로 저장하여, 두 저장 장치 사이의 속도를 완충 시키는 기법을 의미한다.</p>\n<h3><span id=\"8-하드웨어의-보안\">8. 하드웨어의 보안</span></h3>\n<p>일반적으로 사용하는 운영체제는 여러 프로그램이 동시에 실행될 수 있는 다중 프로그래밍 환경에서 실행된다. 그러므로 각 프로그램들이 다른 프로그램의 실행을 방해하거나 프로그램 간에 서로 충돌이 일어날 수 있기 때문에 이러한 문제를 해결하기 위한 각종 보안 기법이 필요하다. 하드웨어적인 보안을 유지하기 위해서 운영체제는 기본적으로 두 가지 모두의 운영을 지원한다. 커널 모드와 사용자 모두가 이에 해당한다.</p>\n<p>커널 모드는 운영체제가 CPU의 제어권을 가지고 운영체제 코드를 실행되는 모드로서, 이 모드에서는 모든 종류의 명령을 다 실행할 수 있다. 사용자모드는 일반 사용자 프로그램이 실행되며 제한적인 명령만을 수행할 수 있다.</p>\n<p>그러나 중요한 연산을 운영체제만이 수행할 수 있도록 수행버리면 제어가 필요 없게된다. 사용자 프로그램이 CPU를 가지고 있는 동안에는 운영체제가 CPU를 선점할 수 없으므로 사용자 프로그램을 감시할 수 있는 방법이 없게된다. 그러므로 이러한 상황을 방지하기위해 <strong>모드비트</strong> 라는 하드웨어적인 자원이 필요하다.</p>\n<p>모드 비트가 0으로 세팅되어 있으면 커널 모드를 의미하고, 모드 비트가 1이면 사용자 모드를 의미한다. CPU는 보안과 관련된 명령을 수행하기 전에는 모드 비트를 조사해 모드 비트가 0으로 세팅된 경우에만 그 명령을 수행한다.</p>\n<p>CPU가 운영체제를 점유하고 있을 때 운영체제는 모드 비트를 0으로 사용하다가 사용자 프로그램에게 CPU를 넘길 때에는 모드 비트를 1로 세팅하고 넘기게 된다. 보통 모드 비트가 0이 되는 경우에는 이와 같이 운영체제에게 권한이 넘어가거나 인터럽트가 발생하여 인터럽트 루틴을 처리해야 할 경우이다.</p>\n<h4><span id=\"커널모드\">커널모드</span></h4>\n<p>운영체제가 CPU의 제어권을 가지고 운영체제 코드를 실행되는 모드로서, 이 모드에서는 모든 종류의 명령을 다 실행할 수 있다.</p>\n<h4><span id=\"사용자-모드\">사용자 모드</span></h4>\n<p>일반 사용자 프로그램이 실행되며 제한적인 명령만을 수행할 수 있다.</p>\n<h4><span id=\"모드비트\">모드비트</span></h4>\n<p>모드비트를 통해 CPU가 운영체제 함수를 호출할 수 있는지 결정하게된다. 모드 비트가 0이면 커널모드를 의미하고 1이면 사용자 모드를 의미한다.</p>\n<h3><span id=\"9-메모리-보안\">9. 메모리 보안</span></h3>\n<p>여러 프로그램이 메모리에 동시에 올라가서 실행되기 때문에 하나의 사용자 프로그램이 다른 사용자 프로그램이나 운영체제가 위치한 메모리 영역을 침범할 수 있기 때문이다. 적어도 인터럽트 벡터와 인터럽트 처리 루틴이 있는 곳은 각별한 보안이 필요하다. 이러한 문제를 해결하기 위해서 두 개의 레지스터를 이용해 현재 접근하려는 메모리가 한 법적인지 체크함으로써 메모리를 보호한다.</p>\n<p>이두가지는 기준 레지스터(base register)와 한계 레지스터(limit register)이다. 기준 레지스터는 실행되고 있는 프로그램이 합법적으로 접근이 시작되는 메모리 주소를 보관하고 있고, 한계 레지스터는 해당 프로그램이 기준 레지스터로부터 접근할 수 있는 범위를 저장하고 있다. 사용자 프로그램은 이 두 개의 값의 범위만 접근할 수 있게 된다. 이 범위를 벗어난 접근을 하게 되면 예외 인터럽트가 발생하게 된다.</p>\n<p>아래그림은 기준레지스터 한계리지서터의 내용을 표현한 그림이다.<br>\n<img src=\"https://i.imgur.com/Q6fK3mt.png\" alt=\"\"></p>\n<h3><span id=\"10-cpu의-보호\">10. CPU의 보호</span></h3>\n<p>일반적으로 CPU는 컴퓨터 시스템내에 하나밖에 존재하지 않기 때문에 특정 프로그램이 CPU를 독점해 무한 반복문을 수행하는 등 부적절한 방법으로 CPU를 독점한다면 다른프로그램들 및 운영체제가 CPU를 획득하지 못하게 된다. 이와같이 CPU가 하나의 프로그램의 독점을 막기위해 타이머라는 하드웨어가 존재 한다.<br>\n타이머는 정해진 시간이 지나면 인터럽트를 발생시켜 운영체제에게 CPU의 제어권을 이양시키는 역할을 한다. 타이머는 정해진 시간이지나면 인터럽트를 발생시키는데 이 인터럽트 처리 루틴의 내용은 CPU의 제어권을 CPU에게 넘기는것이다.</p>\n<h3><span id=\"11-시스템-콜을-이용한-입출력-수행\">11. 시스템 콜을 이용한 입출력 수행</span></h3>\n<p>사용자 프로그램이 I/O 디바이이스등을 통해 데이터 입출력을 할 수 없다. 보통 이러한 작업은 운영체제를 통해서 해야한다. 운영체제에는 I/O디바이스들에 데이터 입출력명령이 코드로 구현되어 있다. 그래서 보통 사용자 프로그램들은 인터럽트를 발생을 시켜 I/O디바이스등 입출력을하는데 이러한 것을 가리켜 시스템 콜이라고한다. 시스템콜은 소프트웨어적인 인터럽트로서 사용자 프로그램이 시스템콜을 할경우 트랩이 발생해 CPU에 대한 제어권이 운영체제로 넘어간다. 그러면 운영체제는 해당하는 시스템콜을 처리하기위해 처리루틴으로가서 시스템 콜 에 맞는 처리 루틴을 수행한다.</p>\n<p>참조</p>\n<ul>\n<li><a href=\"http://www.yes24.com/24/goods/2824944\" target=\"_blank\" rel=\"noopener\">운영체제와 정보기술의 원리</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>컴퓨터 시스템 구조</h2>\n<h3>1. 컴퓨터 시스템의 구조</h3>\n<p>컴퓨터 시스템 구조에 들어가기전에 용어를 먼저 정리해보자.</p>\n<h4>CPU란</h4>\n<p>CPU는 내부적으로 크게 3가지로 나눌 수 있습니다. 연산을 수행하는 산술논리장치(ALU), 제어 명령을 전달하는 컨트롤 장치(CU), 결과 값을 일시적으로 기억하는 레지스터(Register)가 이에 해당됩니다. 아래 그림은 CPU의 구조를 그림으로 도식화 한 것이다.<br>\n<img src=\"https://i.imgur.com/r0MbHY2.png\" alt=\"\"></p>\n<h4>Memory란</h4>\n<p>CPU의 Register의 용량은 매우 작다. 그래서 정보를 저장해 두었다가 필요할 때 읽어 들여 이용할 수 있는 주 기억 장치가 필요하다. 이 주기억장치에는 컴퓨터가 켜지면 운영체제, 사용자 프로그램등이 메모리공간에 올라가게된다. CPU는 주기억장치에서 프로그램들의 명령어등을 읽어와 작업을 수행한다. 주 기억창치로는 ROM, RAM 등이 있음.</p>\n<h4>I/O Device란</h4>\n<p>입출력 장치란, 사용자가 원하는 문자나 그림의 데이터를 컴퓨터로 전달하는 하거나 출력하는 장치이다. 입력장치의 종류에는 키보드, 마우스이 있고 출력 장치로는 모니터, 프린터등이 있다.</p>\n<p>컴퓨터 시스템은 크게 위 3단어로 구성된다고 볼 수 있다. 아래 그림은 컴퓨터 시스템 구조를 도식화한 것이다.</p>\n<p><img src=\"https://i.imgur.com/DmnmAGX.png\" alt=\"\"></p>\n<p>간단하게 컴퓨터 시스템 흐름을 설명하면 컴퓨터에 전원이 들어오게 되면 메인메모리에 운영체제가 올라간다. 이때 모든 운영체제 코드가 올라가는게아니라 시스템이 돌아가기위한 핵심적인 부분이 먼저올라가는데 이부분을 커널이라 한다. 이러한 이유는 모든 코드가 메모리에 올리게되면 자원낭비가 심하기 때문이다.</p>\n<p>그 이후에 CPU는 메모리의 운영체제 프로그램들을 읽어 운영체제를 실행한다. 운영체제가 시작되고 다른 프로그램들을 실행시키면 마찬가지로 메인메모리에 올라가게 된다. 이때 CPU는 메인메모리에 명령어주소를 레지스터에 저장하는데 이 레지스터이름은 PC레지스터라 한다. 그 이후 각각의 프로그램들은 I/O 디바이스 사용이 필요할 수 있는데 이러한 요청은 운영체제한테 요청을해야한다. 이러한 요청을 시스템콜이라고 한다. 이렇게 프로그램들이 직접 I/O디바이스를 제어하지 않는 이유는 많은 이유가있지만 가장큰 이유는 보안때문이다.</p>\n<p>프로그램의 요청을 받은 운영체제는 I/O 디바이스의 컨트롤러에게 데이터 입출력 처리를 요청을 한다. 그리고 I/O 디바이스 컨 틀롤러들은 입출력을 받게 되면 Interrupt를 발생시켜 CPU에게 작업이 완료됐다고 알리게 된다. CPU는 I/O 디바이스에 버퍼에 가서 데이터를 읽어와 메인 메모리에 올려놓게 된다. 이러한 작업이 반복되는 것이 컴퓨터 프로그램의 동작 원리이다. 아래 그림은 좀 더 CPU와 메모리 I/O 디바이스들을 세부 분화한 그림이다.</p>\n<p><img src=\"https://i.imgur.com/8JAIHTg.png\" alt=\"\"></p>\n<h3>2. CPU와 I/O연산</h3>\n<p>위 구조에서 먼저 I/O 디바이스와 CPU 관계를 봐보자. 컴퓨터에 대한 연산은 CPU가 처리한다. 반면 I/O 디바이스들에 대한 연산은 각각의 디바이스 컨트롤러들이 처리한다. 컨트롤러들은 각각의 디바이스들의 CPU 역할을 한다. 이렇기 때문에 둘은 서로 동시에 처리가 가능하다. 그리고 각각의 컨트롤러로부터 들어오고 나오는 데이터들은 로컬 버퍼에서 관리한다. 로컬 버퍼는 램과 같은 역할을 한다.</p>\n<p>데이터가 입출력되었는지는 CPU가 처리하는 게 아니라 각각의 컨트롤러들이 연산을 하고 이것을 CPU에게 인터럽트를 발생시켜 보고하는 형태로 처리된다. CPU는 항상 메모리에 명령어를 읽어와 작업을 수행하는데 매 명령어를 읽어오기 전 인터럽트가 발생하였는지 확인하고 인터럽트가 발생했으면 인터럽트를 먼저 처리하고 그 이후에 명령어를 처리한다.</p>\n<h4>Device Controller</h4>\n<p>각각의 디바이스들을 I/O연산, 제어관리를 하는 역할을 한다.(각각의 디바이스들의 CPU 역할)<br>\n<strong>Device Driver</strong><br>\n운영체제가 각각의 디바이스를 접근하게 하기위한 인터페이스역할을하는 소프트웨어.<br>\n<strong>펌웨어</strong><br>\n디바이스가 동작하기위한 소프트웨어</p>\n<h4>Buffer</h4>\n<p>각각의 디바이스 컨트롤러들이 명령을 내려 디바이스의 데이터를 읽어오거나 출력할때는 데이터를 저장하는 공간이다. (각각의 디바이스들의 램역할)</p>\n<h3>3. 입터럽트의 일반적 기능</h3>\n<p>그다음 CPU와 각각의 I/O 디바이스 컨트롤러 디바이스들 간에 인터럽트 처리를 확인해 보자. 기본적으로 운영체제에는 인터럽트가 발생했을 때 각각의 인터럽트에 대한 처리가 운영체제 안에 코드로 작성되어 저장되어있다. 이 다양한 인터럽트에 대해 각각의 처리해야 할 업무들을 정의해놓은 것이 인터럽트 처리 루틴이다. CPU는 인터럽트가 발생하면 하던 일을 멈추고 인터럽트가 발생했을 대 수행해야 할 코드영역으로 가서 정의된 작업을 하게 된다. 이때 수행되는 일을 좀 더 자세히 보면 다음과 같다. CPU 가 먼저 로컬 버퍼에 있는 내용을 프로그램 B가 사용할 수 있도록 메모리로 전달하고, 이제 프로그램 B가 CPU를 할당받을 경우 다음 명령어를 수행할 수 있음을 표시해둔다.</p>\n<p>인터럽트는 크게 2가지고 인터럽트로 나누어지는데 하드웨어 인터럽트와 소프트웨어 인터럽트가 있다. 하드웨어 인터럽트는 하드웨어가 발생시키고 소프트웨어는 소프트웨어가 인터럽트를 발생시킨다는 차이가 있다. 운영체제는 인터럽트 루틴을 쉽게 찾아가기 위해 인터럽트 벡터를 가지고 있다. 인터럽트 벡터는 인터럽트 종류마다 번호를 정해서, 번호에 따라 처리해야할 코드가 위치한 부분을 포인터로 가리키고 있는 자료구조를 말한다. 실제처리는 인터럽트 루틴에서 이루어진다.</p>\n<h4>Interrupt</h4>\n<p>CPU는 I/O 디바이스들이 데이터를 입력할때까지 기다리는게 아니라 자신의 일을 계속 처리하고있게 된다. 이때 I/O 디바이스들에게 입력이 이루어지면 각각의 디바이스 컨틀롤러가 인터럽트를 발생시켜 CPU에게 알려준다. 이때 발생시키는 신호를 인터럽트라고 한다.</p>\n<h4>인터럽트 루틴</h4>\n<p>운영체제에는 인터럽트가 발생했을 때 각각의 인터럽트에대한 처리가 운영체제 안에 저장되어있다. 이 다양한 인터럽트에대해 각각의 처리해야할 업무들을 정의 해놓은것이 인터럽트 처리 루틴이다.</p>\n<h4>인터럽트 벡터</h4>\n<p>인터럽트 벡터는 인터럽트 종류마다 번호를 정해서, 번호에 따라 처리해야할 코드가 위치한 부분을 포인터로 가리키고 있는 자료구조를 말한다.</p>\n<h4>System Call</h4>\n<p>응용프로그램이 운영체제의 서비스를 받기위해 커널함수를 호출하는것.</p>\n<h4>Timer</h4>\n<p>특정 프로그램이 무한루프에 빠져 CPU를 독점하는 경우를 막기위해 존재한다. 만약 특정프로그램이 CPU할당시간을 초과한다면 timer는 인터럽트를 발생시켜 CPU의 권한을 운영체제에게 다시 넘긴다.</p>\n<h4>mode bit</h4>\n<p>CPU에서 지금 실행되는 프로그램이 프로그램인지 운영체제인지 구분해주는 역할</p>\n<h4>스택영역</h4>\n<p>실행중인 함수에서 다른 함수를 호출한경우 호출된 함수의 종료후 원래 함수의 실행이던 위치로 돌아오기 위해 복귀 주소를 저장하는 위치이다.</p>\n<h4>데이터 영역</h4>\n<p>전역변수등 프로그램이 사용하는 각종 데이터가 저장되는 공간이다.</p>\n<h4>코드 영역</h4>\n<p>프로그래머가 작성한 코드가 기계어 명령형태로 저장되는 영역이다.</p>\n<h4>DMA</h4>\n<p>CPU가 각각의 I/O디바이스를 통해 데이터를 읽어 메인메모리에 프로그램에게 전달하게되면 CPU효율이 떨어지기때문에 주변기기의 인터페이스 장치에 제어권을 주어 직접 주기억장치와 데이터를 주고 바는 방식으로 액세스하여 데이터를 전송하는 방법</p>\n<h3>4.인터럽트 핸들링</h3>\n<p>인터럽트 핸들링이란 인터럽트가 발생한 경우에 처리해하는 절차를 의미한다. 인터럽트는 앞에서 말한 대로 발생 시에만 CPU에 의해 운영체제 코드 부분 즉 인터럽트 루틴을 실행한다. 인터럽트가 발생하지 않는다면 CPU는 계속 계속해서 사용자 프로그램의 명령어를 처리할 것이다.</p>\n<p>CPU가 사용자 프로그램 처리 중 인터럽트가 발생하면 사용자 프로그램의 현재 수행 중이던 주소와 부가적인 정보를 저장해야 한한다. 왜냐하면 인터럽트가 발생하면 레지스터의 기존 데이터들이 지워지기 때문이다.</p>\n<p>운영체제 커널 내에는 현재 시스템 내에서 수행되는 프로그램들을 관리하기 위한 자료 구조인 프로세스 제어 블록(PCB : Process Control Block) 을 두고 있다. 이 자료 구조 중 일부는 인터럽트가 발생했을 때 프로그램의 어느 부분이 수행되던 중이었는지를 저장하기 위한 자료구조로 사용된다.</p>\n<p>이 자료구조를 바탕으로 인터럽트가 발생했을 때 인터럽트 처리를 하고 CPU는 다시 원래 프로그램으로 돌아올 수 있다.</p>\n<h4>PCB</h4>\n<p>운영체제 커널 내에는 현재 시스템 내에서 수행되는 프로그램들을 관리하기 위한 자료 구조인 프로세스 제어 블록(PCB : Process Control Block) 을 두고 있다. 이 자료 구조중 일부는 인터럽트가 발생했을때 프로그램의 어느부분이 수행되던 중이었는지를 저장하기 위한 자료구조로 사용된다.</p>\n<h3>4.입출력 구조</h3>\n<h4>동기식 입출력</h4>\n<p>입출력(I/O)이란 컴퓨터 시스템이 컴퓨터 외부의 주변 장치들과 데이터를 주고받는것을 말한다. 입출력 방식에는 동기식 입출력과 비동기식 입출력이 있다. 동기식 입출력(synchronous I/O)은 입출력 요청후 입출력 작업이 완료된후에야 CPU의 제어권이 그 프로그램에게 다시 넘어갈 수 있는 방식을 말한다. 따라서 동기식 입출력에서는 입출력 연산이 끝날 때까지 CPU는 아무 일을 수행할 수 없다. 기본적으로 CPU의 명령수행속도는 빠른반면 외부 장치에서 데이터를 읽어오는 등의 입출력 연산은 상대적으로 속도가 느리다. 그럼으로 CPU가 입출력 연산을 기다리는것은 비효율적이다. 따라서 일반적으로 프로그램이 입출력을 수행중인 경우 CPU를 다른 프로그램에게 이양해 CPU가 계속쉬지 않고 일할수 있도록 관리한다. 그리고 그 입출력을 수행하고있는 프로그램은 CPU를 할당하더라도 명령을 수행을 못하는데 이것을 <strong>“봉쇄 상태(blocked state)”</strong> 로 전환 시킨다고 말한다. 봉쇄 상태의 프로그램에게는 CPU를 할당하지 않고, CPU를 할당하면 곧바로 작업 수행 가능한 프로그램들에게만 CPU를 할당하게 된다.</p>\n<p>그러나 여기에서 문제가 하나 발생할 수 있다. 앞서 설명한 것처럼 입출력이 수행중일 때 다른 프로그램에게 CPU를 양도하게 되므로 다수의 입출력 연산이 동시에 요청되거나 처리될 수 있다. 예를들어 A라는 프로그램과 B라는 프로그램이 있다고 가정하자. 이때 두 프로그램은 동시에 하나의 파일에 접근하려고한다. 여기에서 개발자는 A라는 프로그램이 먼저 파일을 수정할것을 예상하고 개발했다고 가정해보자. 하지만 컨트롤러는 이것의 순서를 보장하지 않는다. 이러한 문제점을 해결하기 위해서 <strong>I/O장치</strong> 별로 큐를 두어 요청한 순서대로 처리할 수 있도록 한다. 큐는 아시다시피 FIFO의 구조로 이루어지기 때문에 들어온 순서대로 처리하게 될것이다.</p>\n<p>위의 내용을 보면 크게 I/O동기식 입출력은 크게 2가지 구현 방법이 있다.<br>\n<strong>구현방법 1</strong></p>\n<ul>\n<li>I/O 끝날 때까지 CPU를 낭비시킴</li>\n<li>매시점 하나의 I/O만 일어날 수 있음</li>\n</ul>\n<p><strong>구현방법 2</strong></p>\n<ul>\n<li>I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗음</li>\n<li>I/O처리를 기다리는 줄에 그 프로그램을 줄세움</li>\n<li>다른 프로그램에게 CPU를 줌</li>\n</ul>\n<h4>비동기식 입출력</h4>\n<p>비동기식 입출력은 입출력 연산을 요청한 후에 연산이 끝나기를 기다리는 것이 아니라 CPU의 제어권을 입출력 연산을 호출한 그 프로그램에게 곧바로 다시 부여하는 방식을 말한다. 프로그램 중 데이터를 입출력할 때 입출력 결과를 기다려야 하는 경우가 있을 수 있고, 반대로 입출력 결과는 상관없이 다른 일을 수행할 수 있는 기능들이 있을 것이다. 비동기식에서는 입출력 결과에 상관없이 수행할 수 있는 일들을 먼저 처리하고 입출력의 결과가 필요한 프로그램들은 입출력이 완료된 후에 작업을 수행한다.</p>\n<p><img src=\"https://i.imgur.com/ykkvu39.png\" alt=\"\"></p>\n<p>위 그림은 동기식 입출력과 비동기식 입출력을 비교해 보여주는 그림이다. 동기식 입출력 같은 경우에는 응답이 돌아올 때까지 입출력을 요청했던 프로그램은 봉쇄 상태가 되고 인터럽트가 발생하면 그때 입출력에 관한 프로그램이 봉쇄 상태가 풀리게 되고 CPU를 할당받을 수 있는 상태가 된다.</p>\n<p>반면 비동기식 프로그램은 입출력을 요청한 프로세스에게 곧바로 다시 주어지며, 입출력 연산이 완료되는 것과 무관하게 처리 가능한 작업부터 처리한다. 한편, 비동기식 입출력에서도 입출력 연산이 완료되면 동기식과 마찬가지로 인터럽트를 통해 이를 CPU에게 알려준다. 이러한 구체적인 예를 통해 정리해보면 다음과 같다.</p>\n<ol>\n<li>프로그램 A가 실행중에 디스크에서 데이터를 읽어오는 명령을 만나게되면 A는 시스템콜을 발생시킨다.</li>\n<li>CPU는 지금까지 프로그램 A의 작업을 멈추고 현재 수행상태를 저장한후에, 인터럽트에 의해 처리 되어야할 커널 루틴으로 이동한다.</li>\n<li>처리 루틴으로 이동하게되면 CPU는 컨트롤러에게 입출력 연산을 요청하게 된다.</li>\n<li>디바이스 컨트롤러는 A가 요청한 데이터를 디스크로부터 읽어와 버퍼에 저장한다.</li>\n<li>읽어오는 동안 프로그램 A는 CPU를 B 프로그램에게 넘겨주게 된다. (이때 A프로그램은 봉쇄상태가 가되고 CPU 명령을 수행하려고해도 수행하지 못함)</li>\n<li>디바이스컨트롤러가 작업이 다 끝나면 하드웨어 인터럽트를 발생시킨다.</li>\n<li>인터럽트가 발생하면 B프로그램을 처리작업을 잠시 미뤄 두고 인터럽트 처리루틴에 가서 인터럽트를 처리한다.</li>\n<li>그럼 인터럽트 처리루틴은 컨틀러에서 데이터를 읽어와 A프로그램에게 올리게되고 A프로그램은 다시 CPU 줄을 기다려야한다.</li>\n<li>그 후 다시 프로그램 B로 돌아가 작업을 수행하게된다.</li>\n</ol>\n<p>일반적으로는 동기식 입출력을 사용한다. 이 때 운영체제는 장치별로 입출력 처리를 기다리는 프로세스를 줄세워 관리한다.</p>\n<h3>5. DMA(Direct Memory Access)</h3>\n<p>일반적으로 I/O 디바이스들이 메인 메모리에 바로 접근할 수 없고 I/O 디바이스들은 인터럽트를 발생시켜 CPU가 I/O 디바이스들의 데이터를 읽어 메인 메모리 프로그램에 올린다. 하지만 CPU는 프로그램의 명령어를 처리하는 것 외에도 항상 각각의 I/O 디바이스들 인터럽트에 대한 처리도 해야 하기 때문에 기존 CPU 작업들을 방해하게 된다.</p>\n<p>이러한 비효율성을 극복하기 위해 CPU 대신에 I/O 디바이스들에 인터럽트를 처리할 컨트롤러를 하나 더 둔다. 이것이 바로 DMA 장치이다. DMA가 있음으로 더 이상 CPU는 하던 작업을 멈추고 각종 I/O디바이스들의 인터럽트를 처리할 필요가 없어진다. 단지 DMA Controller에 인터럽트만 처리하게 되면 된다. 이때 DMA는 바이트 단위가 아니라 블록 단위로 데이터를 모아서 CPU에게 인터럽트를 발생시킨다. 이러한 방법으로 CPU의 효율을 높일 수 있다.</p>\n<ul>\n<li>빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해사용</li>\n<li>CPU의 중재 없이 Device controller가 device의 buffer storage의 내용을 메모리에 block 단위로 직접 전송</li>\n<li>바이트 단위가 아니라 block 단위로 인터럽트를 발생시킴</li>\n</ul>\n<h3>6. 저장 장치 구조</h3>\n<h4>주기억장치</h4>\n<p>컴퓨터 시스템을 구성하는 저장 장치는 주 기억 장치와 보조기억장치다. 주 기억장치는 보통 메모리라고 부르며 전원이 나가면 저장되었던 내용이 모두 사려 저버리는 휘발성(volatile)의 RAM을 매체로 사용하는 경우이다.</p>\n<h4>보조기억장치</h4>\n<p>보조기억장치는 전원이 나가도 저장된 내용을 기억할 수 있는 비휘발성(nonvolatile)의 마그네틱 디스크를 흔히 사용한다. 보조 기억장치는 크게 두가지 부분으로 파일시스템용과 스왑 영역이다.<br>\n<strong>파일 시스템</strong><br>\n전원이 나가도 유지해야할 정보가있으면 그것을 파일형태로 보조기억장치에 저장한다.<br>\n<strong>스왑 영역</strong><br>\n메인 메모리의 크기는 한정되어있고, 가격이 비싸다. 그러므로 다수의 프로그램이 메인 메모리에 올라가 동시에 수행될경우 메모리 공간이 부족한경우가 많다. 그렇기 때문에 한번에 모두 메인메모리에 올려놓는게 아니라 프로그램이 돌아가기 위한 핵심적인 부분만 메인 메모리에 올려놓고 나머지는 스왑영역에두고 필요할 때마다 메인 메모리로 불러오게 된다.</p>\n<h3>7. 저장 장치의 계층 구조</h3>\n<p>컴퓨터의 시스템을 구성하는 저장 장치부터 느린 저장 장치까지 단계적인 계층 구조로 이루어진다. 빠른 저장 장치는 단위 공간당 가격이 높기때문에 적은 용량을 사용하며, 느린 저장 장치는 가격이 저렴해 대용량을 사용하는 반면 접근속도가 느리다는 약점이 있다. 아래그림은 이 내용을 그림으로 표현한것이다.</p>\n<p><img src=\"https://i.imgur.com/z6a9a8B.png\" alt=\"\"></p>\n<p>상위 저장 장치 계층으로 갈수록 접근 속도가 월등히 빠르지만 용량은 상대적으로 적다. 하지만 당장 필요한 정보만을 선별적으로 저장하게 되면 마치 하위에 있는 큰 용량의 저장 장치를 가지고 있는 것과 비슷한 성능 효과를 낼 수 있다. 예를 들면, 캐시메모리는 레지스터와 메인 메모리 사이에 존재한다. 캐시메모리는 메인 메모리보다 용량이 작다. 그러나 여러 가지 캐슁기법을 이용해 적은 용량의 캐시메모리를 사용해서도 메인 메모리와 같이 큰 용량을 가진 것처럼 효율적으로 관리할 수 있다.</p>\n<p><strong>캐슁 기법</strong> 이란 상대적으로 느린 저장장치에 있는 내용중에 당장 사용되거나 빈번히 사용될 정보를 빠른 저장장치에 선별적으로 저장하여, 두 저장 장치 사이의 속도를 완충 시키는 기법을 의미한다.</p>\n<h3>8. 하드웨어의 보안</h3>\n<p>일반적으로 사용하는 운영체제는 여러 프로그램이 동시에 실행될 수 있는 다중 프로그래밍 환경에서 실행된다. 그러므로 각 프로그램들이 다른 프로그램의 실행을 방해하거나 프로그램 간에 서로 충돌이 일어날 수 있기 때문에 이러한 문제를 해결하기 위한 각종 보안 기법이 필요하다. 하드웨어적인 보안을 유지하기 위해서 운영체제는 기본적으로 두 가지 모두의 운영을 지원한다. 커널 모드와 사용자 모두가 이에 해당한다.</p>\n<p>커널 모드는 운영체제가 CPU의 제어권을 가지고 운영체제 코드를 실행되는 모드로서, 이 모드에서는 모든 종류의 명령을 다 실행할 수 있다. 사용자모드는 일반 사용자 프로그램이 실행되며 제한적인 명령만을 수행할 수 있다.</p>\n<p>그러나 중요한 연산을 운영체제만이 수행할 수 있도록 수행버리면 제어가 필요 없게된다. 사용자 프로그램이 CPU를 가지고 있는 동안에는 운영체제가 CPU를 선점할 수 없으므로 사용자 프로그램을 감시할 수 있는 방법이 없게된다. 그러므로 이러한 상황을 방지하기위해 <strong>모드비트</strong> 라는 하드웨어적인 자원이 필요하다.</p>\n<p>모드 비트가 0으로 세팅되어 있으면 커널 모드를 의미하고, 모드 비트가 1이면 사용자 모드를 의미한다. CPU는 보안과 관련된 명령을 수행하기 전에는 모드 비트를 조사해 모드 비트가 0으로 세팅된 경우에만 그 명령을 수행한다.</p>\n<p>CPU가 운영체제를 점유하고 있을 때 운영체제는 모드 비트를 0으로 사용하다가 사용자 프로그램에게 CPU를 넘길 때에는 모드 비트를 1로 세팅하고 넘기게 된다. 보통 모드 비트가 0이 되는 경우에는 이와 같이 운영체제에게 권한이 넘어가거나 인터럽트가 발생하여 인터럽트 루틴을 처리해야 할 경우이다.</p>\n<h4>커널모드</h4>\n<p>운영체제가 CPU의 제어권을 가지고 운영체제 코드를 실행되는 모드로서, 이 모드에서는 모든 종류의 명령을 다 실행할 수 있다.</p>\n<h4>사용자 모드</h4>\n<p>일반 사용자 프로그램이 실행되며 제한적인 명령만을 수행할 수 있다.</p>\n<h4>모드비트</h4>\n<p>모드비트를 통해 CPU가 운영체제 함수를 호출할 수 있는지 결정하게된다. 모드 비트가 0이면 커널모드를 의미하고 1이면 사용자 모드를 의미한다.</p>\n<h3>9. 메모리 보안</h3>\n<p>여러 프로그램이 메모리에 동시에 올라가서 실행되기 때문에 하나의 사용자 프로그램이 다른 사용자 프로그램이나 운영체제가 위치한 메모리 영역을 침범할 수 있기 때문이다. 적어도 인터럽트 벡터와 인터럽트 처리 루틴이 있는 곳은 각별한 보안이 필요하다. 이러한 문제를 해결하기 위해서 두 개의 레지스터를 이용해 현재 접근하려는 메모리가 한 법적인지 체크함으로써 메모리를 보호한다.</p>\n<p>이두가지는 기준 레지스터(base register)와 한계 레지스터(limit register)이다. 기준 레지스터는 실행되고 있는 프로그램이 합법적으로 접근이 시작되는 메모리 주소를 보관하고 있고, 한계 레지스터는 해당 프로그램이 기준 레지스터로부터 접근할 수 있는 범위를 저장하고 있다. 사용자 프로그램은 이 두 개의 값의 범위만 접근할 수 있게 된다. 이 범위를 벗어난 접근을 하게 되면 예외 인터럽트가 발생하게 된다.</p>\n<p>아래그림은 기준레지스터 한계리지서터의 내용을 표현한 그림이다.<br>\n<img src=\"https://i.imgur.com/Q6fK3mt.png\" alt=\"\"></p>\n<h3>10. CPU의 보호</h3>\n<p>일반적으로 CPU는 컴퓨터 시스템내에 하나밖에 존재하지 않기 때문에 특정 프로그램이 CPU를 독점해 무한 반복문을 수행하는 등 부적절한 방법으로 CPU를 독점한다면 다른프로그램들 및 운영체제가 CPU를 획득하지 못하게 된다. 이와같이 CPU가 하나의 프로그램의 독점을 막기위해 타이머라는 하드웨어가 존재 한다.<br>\n타이머는 정해진 시간이 지나면 인터럽트를 발생시켜 운영체제에게 CPU의 제어권을 이양시키는 역할을 한다. 타이머는 정해진 시간이지나면 인터럽트를 발생시키는데 이 인터럽트 처리 루틴의 내용은 CPU의 제어권을 CPU에게 넘기는것이다.</p>\n<h3>11. 시스템 콜을 이용한 입출력 수행</h3>\n<p>사용자 프로그램이 I/O 디바이이스등을 통해 데이터 입출력을 할 수 없다. 보통 이러한 작업은 운영체제를 통해서 해야한다. 운영체제에는 I/O디바이스들에 데이터 입출력명령이 코드로 구현되어 있다. 그래서 보통 사용자 프로그램들은 인터럽트를 발생을 시켜 I/O디바이스등 입출력을하는데 이러한 것을 가리켜 시스템 콜이라고한다. 시스템콜은 소프트웨어적인 인터럽트로서 사용자 프로그램이 시스템콜을 할경우 트랩이 발생해 CPU에 대한 제어권이 운영체제로 넘어간다. 그러면 운영체제는 해당하는 시스템콜을 처리하기위해 처리루틴으로가서 시스템 콜 에 맞는 처리 루틴을 수행한다.</p>\n<p>참조</p>\n<ul>\n<li><a href=\"http://www.yes24.com/24/goods/2824944\" target=\"_blank\" rel=\"noopener\">운영체제와 정보기술의 원리</a></li>\n</ul>\n"},{"title":"Java Collection framework","catalog":true,"date":"2018-07-02T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n\n## 시작하며\n컬렉션에 대한 내용을 정리하게 된 계기는 먼저 자바 Collection 만의 API 기능을 효율적으로 사용하기 위해서이다. 다음은 자료구조를 적극적으로 활용하기 위해서이다. 자료구조를 이용하면 훨씬 효율적으로 데이터들을 관리할 수 있고 심지어 코드의 가독성 또한 좋아지기 때문이다. 가독성이 안 좋아지고 복잡함을 증가시키는 IF 문을 피하는 코드를 만드는 것은 아주 효율적인 코딩이라고 생각한다.\n\n예를 들어, List에 있는 이메일들을 중복 검사한다고 했을 때 단순하게 생각하면 List를 Email 숫자만큼 loop를 돌려 Email을 중복 검사하는 방법이 있을 수 있다. 하지만 HashSet, TreeSet을 이용하면 중복된 값이 저장이 되지 않기 때문에 좀 더 효율적으로 데이터를 관리하고, 소스코드를 깔끔하게 관리할 수 있다.\n\n또한 다른 예를 들면 여러 개의 이메일에서 특정 이메일을 검색한다고 했을 때 TreeSet 자료구조를 이용하면 트리구조로 데이터가 저장되기 때문에 검색 기능 또한 뛰어나다. 반면 List 같은 경우에는 loop로 하나하나 노드를 검색해서 해당 이메일이 나올 때까지 검색을 해야 하기 때문에 효율적이지 않다. 그러므로 자바에서 효율적인 코딩을 하기 위해서는 Collection 프레임워크를 자세히 알아두는 것은 좋다고 생각한다.\n\n아래의 내용은 '[이것이 자바다](https://book.naver.com/bookdb/book_detail.nhn?bid=8589375)' 를 보고 컬렉션에 대한 내용을 정리한것이다.\n\n## 컬렉션 프레임워크\n\n애플리케이션을 개발하다 보면 다수의 객체를 저장해야 하는 경우가 많이 발생한다. 예를 들어 Product 객체를 10개를 저장해야 한다. 어떻게 하면 효율적으로 저장할 수 있을까. 먼저 가장 간단한 배열을 확인해보자.\n\n```java\n//길이 10인 배열생성\nProduct[] array = new Product[10];\n\n//객체추가\narray[0] = new Product(\"Model1\");\narray[1] = new Product(\"Model2\");\n\n//객체 검색\nProduct model1 = array[0];\nProduct model2 = array[1];\n\n//객체 삭제\narray[0] = null;\narray[1] = null;\n\n```\n\n배열은 쉽게 생성하고 사용할 수 있지만, 저장할 수 있는 객체수가 배열을 생성할 때 결정되기 때문에 불특정 다수의 객체를 저장하기에는 문제가 있다. 물론 배열의 길이를 크게 생성하면 되지만, 이것은 좋은 방법이 아니다. 또 다른 문제는 배열의 객체를 삭제했을 때 해당 인덱스가 비게 되면 아래와 같이 중간중간에 객체가 없는 배열이 된다. 이렇게 되면 객체를 어디에 저장해야 할지 배열 인덱스 하나하나 검색 후 비어있는 공간에 객체를 저장해야 한다.\n\n```java\n[1][2][3][4][5][6]\n O  O  X  O  X  O\n```\n\n자바는 배열의 이러한 문제점을 해결하고, 널리 알려져 있는 자료구조(Data Structre)를 바탕으로 객체들을 효율적으로 추가, 삭제, 검색할수 있도록 Java.util 패키지에 컬렉션과 관련된 인터페이스와 클래스들을 포함시켜 놓았다. 이들을 총칭해서 컬렉션 프레임워크라 한다.\n\n**컬렉션** 이란 사전적 의미로 요소를 수집해서 저장하는 것을 의미하는데, 자바 컬렉션은 객체를 수집해서 저장하는 역할을 한다. 자바 컬렉션 프레임워크는 몇 가지 인터페이스를 통해서 다양한 컬렉션 클래스를 이용할 수 있도록 한다. 컬렉션 프레임워크의 주요 인터페이스로는 List, Set, Map이 있다. 이 인터페이스들은 컬렉션을 사용하는 방법을 정의하는 것인데, 다음은 인터페이스로 사용 가능한 컬렉션 클래스를 보여준다.\n\n![](https://i.imgur.com/JmO4zX2.png)\n\nList와 Set은 객체 추가, 삭제 검색하는 방법에 많은 공통점이 있기 때문에 이 인터페이스들의 공통된 메소드들만 모아 Collection 인터페이스로 정의해 두고 있다. Map은 키와 값을 하나의 쌍으로 묶어서 관리하는 구조로 되어있어 List및 Set과는 사용방법이 완전히 다르다.\n\n| 인터페이스 분류          | 특징                              | 구현클래스                                 |\n| ----------------- | ------------------------------- | ------------------------------------- |\n| Collection (List) | - 순서룰유지하고저장<br>- 중복 저장 가능       | ArrayList, Vector, LinkedList         |\n| Collection (Set)  | - 순서를 유지 않고 저장 <br> - 중복 저장 안됨  | HashSet, TreeSet                      |\n| Map               | - 키와 값의 쌍으로 저장 <br> - 키는 중복 안 됨 | HashMap,Hashtable,TreeMap, Properties |\n\n\n\n\n### List 컬렉션\n\nList 컬렉션은 객체를 일렬로 늘어놓은 구조를 가지고 있다. 객체를 인덱스로 관리하기 때문에 객체를 저장하면 자동 인덱스가 부여되고 인덱스로 객체를 검색, 삭제할 수 있는 기능을 제공한다.  List 컬렉션에는 ArrayList, Vector, LinkedList 등이 있는데 다음은 List 컬렉션에서 공통적으로 사용 가능한 List 인터페이스의 메소드들이다. 인덱스로 객체를 관리하기 때문에 인덱스를 매게 값으로 갖눈 메소드가 많다.\n\n**객체 추가**\n\n| 메소드              | 설명                         |\n| ---------------- | -------------------------- |\n| boolean add(E e) | 주어진 객체를 맨 끝에 추가            |\n| void add(E e)    | 주어진 인덱스에 객체를 추가            |\n| set add(E e)     | 주어진 인덱스에 저장된 객체를 주어진 객체로바꿈 |\n\n\n**객체 검색**\n\n| 메소드                        | 설명                  |\n| -------------------------- | ------------------- |\n| boolean contains(Object o) | 주어진 객체가 저장되어 있는지 여부 |\n| E get(int index)           | 주어진 인덱스에 객체를 리턴     |\n| isEmpty()                  | 컬렉션이 비어있는지 검사       |\n| int size()                 | 저장되어 있는 전체 객체 수를 리턴 |\n\n **객체 삭제**\n\n| 메소드                      | 설명                  |\n| ------------------------ | ------------------- |\n| void clean()             | 저장된 모든 객체를 삭제       |\n| E remove(int index)      | 주어진 인덱스에 저장된 객체를 삭제 |\n| boolean remove(Object o) | 주어진 객체를 삭제          |\n\n\n#### ArrayList\nArrayList는 List 인터페이스의 구현 클래스로, ArrayList에 객체를 추가하면 객체가 인덱스로 관리된다. 일반배열과 ArrayList는 인덱스로 객체를 관리한다는 점에서는 유사하지만, 큰차이점을 가지고 있다. 배열은 생성할 때 크기가 고정되고, 사용중에 크기를 변경할 수 없지만, ArrayList는 저장 용량을 초과한 객체들이 들어오면 자동적으로 저장용량이 늘어난다. 다음은 ArrayList 객체의 내부 구조를 보여준다.\n\n![](https://i.imgur.com/M08M97l.png)\n\n검사버튼 삭제버튼 초기에 ArrayList를 선언하면 10개의 객체를 저장할 수 있는 List가 선언이 된다. 만약 초기부터 용량을 크게 선언하고 싶다면 아래와 같이 선언하면 된다.\n\n```java\nList<String> list = new ArrayList<String>(30);\n```\n\nArrayList에 객체를 저장하면 인덱스 0 부터 차례대로 저장된다. ArrayList에서 특정 인덱스의 객체를 제거하면 바로 뒤 인덱스부터 마지막 인덱스까지 모두 앞으로 1씩 당겨진다. 마찬가지로 특정 인덱스에 객체를 삽입하면 해당 인덱스부터 마지막 인덱스까지 모두 1씩 밀려난다. 다음은 4번 인덱스가 제거되었을 때 5번 인덱스부터 모두 앞으로 1씩 당겨지는 모습을 보여준다.\n\n![](https://i.imgur.com/nhg1zDA.png)\n\n위와같이 List안에서 노드가삭제가되면 앞으로 하나하나 다 밀려나야한다. 따라서 빈번한 객체 삭제와 삽입이 일어나나는 곳에서는 ArrayList를 사용하지 않고 삽입삭제에 용이한 LinkedList를 사용하는것이 좋다. 그러나 인덱스 검색이나 마지막 노드추가에서는 ArrayList가 더 좋은 성능을 발휘한다.\n\n다음예제는 ArrayList에 String 객체를 추가, 검색, 삭제하는방법의 간단한 예제이다.\n\n**예제**\n\n* [String 객체를 저장하는 ArrayList](https://github.com/minwan1/blog-example/tree/master/java-basis-example/src/collection/list/arraylist)\n\n#### Vector\nVector는 ArrayList와 동일한 내부 구조를 가지고 있다. Vector를 생성하기 위해서는 지정할 객체 타입을 타입 파라미터로 표기하고 기본 생성자를 호출하면 된다.\n\n```java\nList<E> list = new Vector<E>();\n```\nArrayList와 다른점은 Vector는 동기화된 메소드로 구성되어 있기 때문에 멀티 스레드가 동시에 이 메소드들을 실행할 수 없고, 하나의 스레드가 실행을 완료해야만 다른 스레드가 실행할 수 있다. 그래서 멀티 스레드 환경에서 안전하게 객체를 추가, 삭제할 수 있다.\n\n다음은 Vector를 이용해서 객체를 추가, 삭제, 검색하는 예제이다.\n\n**예제**\n\n* [객체 저장, 삭제](https://github.com/minwan1/blog-example/tree/master/java-basis-example/src/collection/list/vector)\n\n#### LinkedList\nLinkedList는 List 구현 클래스이므로 ArrayList와 사용방법은 똑같지만 내부 구조는 완전 다르다. ArrayList는 내부 배열 객체를 저장해서 인덱스로 관리하지만, LinkedList는 인접 참조를 링크해서 체인처럼 관리한다.\n\n![](https://i.imgur.com/09ZGkA7.png)\n\nLinkedList에서 특정 인덱스의 객체를 제거하면 앞뒤 링크만 변경되고 나머지 링크는 변경되지 않는다. 특정 인덱스에 객체를 삽입할 때에도 마찬가지다. 그렇기 때문에 빈번한 객체를 삭제할 때는 LinkedList가 성능이 좋다. 왜냐 중간에서 하나 삭제를 하더라도 앞뒤의 노드만 연결해주면 되기 때문이다.\nLinkedList는 생성하기 위해서는 저장할 객체 타입 파라미터(E)에 표기하고 기본 생성자로 호출하면 된다. 기본적으로 LinkedList는 처음 생성될 때에는 어떤한 링크도 만들어지지 않기 때문에 내부적으로 비어있다. 아래와 같이 생성할 수 있겠다.\n\n```java\nList<E> list = new LinkedList<E>();\n```\n다음 예제는 ArrayList와 LinkedList에 10000개의 객체를 삽입하는데 걸릴시간을 측정하는 예제이다. 누가 더 많은 시간이 걸리는지에 대한 예제이다.\n\n**예제**\n\n[ArrayList와 LinkedList의 실행 성능 비교](https://github.com/minwan1/blog-example/tree/master/java-basis-example/src/collection/list/linkedlist)\n\n### Set 컬렉션\nList 컬렉션은 저장 순서를 유지하지만, Set 컬렉션은 저장 순서가 유지되지 않는다. 또한 객체를 중복해서 저장할 수 없다. 하나의 null만 저장할 수 있다. Set 컬렉션은 수학의 집합에 비유될 수 있다. 집합은 순서와 상관없고 중복이 허용되지 않기 때문이다.\n\nSet 컬렉션에는 HashSet, LinkedHashSet, TreeSet등이 있는데, 다음은 Set 컬렉션에 공통적으로 사용 가능한 Set 인터페이스의 메소드들이다.\n\n![](https://i.imgur.com/ZByMxEo.png)\nSet 컬렉션은 인덱스로 객체를 검색해서 가져오는 메소드가 없다. 대신 전체 객체를 대상으로 한번씩 반복해서 가져오는 반복자(Iterator)를 제공한다. 반복자는 Iterator 인터페이스를 구현한 객체를 말하는데, itorator() 메소드를 호출하면 얻을 수 있다.\n\n\n```java\nSet<String> set = ...;\nIterator<String> iterator = set.iterator();\n```\n\n다음은 Iterator 인터페이스에 선언된 메소드들이다.\n\n| 리턴 타입   | 메소드명      | 설명                                      |\n| ------- | --------- | --------------------------------------- |\n| boolean | hasNext() | 가져올 객체가 있으면 true를 리턴하고 없으면 false를 리턴한다. |\n| E       | next()    | 컬렉션에서 하나의 객체를 가져온다                      |\n| void    | remove()  | Set 컬렉션에서 객체를 제거한다.                     |\n\nIterator에서 하나의 객체를 가져올 때는 next() 메소드를 사용한다. next() 메소드를 사용하기전에 먼저 가져올 객체가 있는지 확인하는것이 좋다. hasNext() 메소드는 가져올 객체가 있으면 true를 리턴하고 더이상 가져올 객체가 없으면 false를 리턴한다. 따라서 true가 리턴될때 next() 메소드를 사용해야한다. 다음은 Set을 이용한 루핑 방법이다.\n\n방법 1. Iterator를 사용한벙법\n```java\nSet<String> set = ...;\nIterator<String> iterator = set.iterator();\nwhile(iterator.hasNext()){ // has가 다음 객체가있는지 체크해주니까 있는 만큼 루핑된다.\n  String str = iterator.next();\n}\n```\n방법 2. For문 사용\n```java\nfor(String str : set){ // 저장된 객체수만큼 루핑한다.\n\n}\n```\n\n\n#### HashSet\nHashSet은 Set 인터페이스의 구현클래스이다. HashSet을 생성하기 위해서는 다음과 같이 기본생성자를 호출하면 된다.\n\n```java\nSet<E> set = new HashSet<E>();\n```\n\nHashSet은 Set의 성격대로 순서상관없이 저장되고, 중복 저장되지 않는다. HashSet이 판단하는 동일한 객체란 꼭 같은 인스턴스를 뜻하지 않는다. HashSet은 객체를 저장하기전에 먼저 객체의 HashCode()메소드를 호출해서 해시코드를 얻는다. 그리고 이미 저장되어 있는 객체의 hashCode() 메소드를 호출해서 해시코드를 얻어낸다. 그리고 이미저장되어 있는 객체들의 해시코드와 비교 한다. 만약 equals()메소드로 두 객체를 비교해서 true가 나오면 동일한 객체로 판단하고 중복 저장을 하지 않는다.\n\n![](https://i.imgur.com/re05jjk.png)\n\n문자열을 HashSet에 저장할 경우, 깊은 문자열을 갖는 String 객체는 동등한 객체로 간주되고 다른 문자열을 갖는 String 객체는 다른 객체로 간주되는데, 그 이유는 String 클래스가 hashCode()와 equals() 메소드를 재정의해서 같은 문자열일 경우 hashCode()의 리턴값을 같게, equals()의 리턴값은 true가 나오도록 오버라이딩이 되있기 때문이다. 물론 자신이 정의 한 클래스에도 똑같이 적용할 수 있다.\n\n예를 들어 Member 클래스를 정의했다고 가정하자. 이 MemberClass에는 인스턴스가 달라도 이름과 나이가 동일하다면 동등 객체라고 equals()와 hashCode를 정의했다고 치자. 그리고 아래와 같이 Set에 객체를 넣는다고 해보자.\n\n```java\nSet<Member> set = new HashSet<Member>();\nset.add(new Member(\"홍길동\", 30));\nset.add(new Member(\"홍길동\", 30));\nSystem.out.println(\"총 객체수 : \" + set.size()); 저장된 객체 수 얻기 // 사이즈 1\n\n```\n위와같이 Set에 이름과 나이가 같은 객체를 두개 넣더라도 실제적으로 set에는 1개의 객체만 들어가게 된다.\n\n다음은 HashSet을 이용해 앞에서 간단한 Hashse에대한 기능을 확인하는 예제이다.\n\n* [String 객체를 중복없이 저장하는 HashSet](https://github.com/minwan1/blog-example/tree/master/java-basis-example/src/collection/set)\n* [Member 객체를 정보없이 저장하는 HashSet](https://github.com/minwan1/blog-example/tree/master/java-basis-example/src/collection/set)\n\n### Map 컬렉션\nMap 컬렉션은 키(Key)와 값(value으로 구성된 Entry 객체를 저장하는 구조를 가지고 있다. 여기서 키와 값은 모두 객체이다. 키는 중복 저장될 수 없지만 값은 중복 저장될 수 있다. 키값이 중복되어 저장된다면 먼저 저장된 값은 저장되지 않는다.\n![](https://i.imgur.com/TI9n5UB.png)\n\nMap 컬렉션에는 HashMap, Hashtable, LinkedHashMap, Properties, TreeMap 등이 있다. 다음은 Map컬렉션에서 공통적으로 사용가능한 Map 인터페이스의 메소드들이다. 키로 객체들을 관리하기때문에 키를 매개값으로 갖는 메소드가 많다.\n![](https://i.imgur.com/zCuSUsB.png)\n\nMap에서는 키를 알고 싶다면 get() 메소 도로 객체를 얻어낼 수 있다. 하지만 맵 안에 데이터를 하나하나 얻어 내고 싶다면 두 가지 방법이 있다. 먼저 아래는 Key를 Set 타입으로 뽑아서 하나하나 Iterator 시켜 그 key 값으로 value를 얻는 방법이 있을 수 있다.\n\n```java\nMap<String, String> map = new HashMap<>();\n\nfinal Set<String> strings = map.keySet();\nfinal Iterator<String> iterator = strings.iterator();\nwhile(iterator.hasNext()){\n    String key = iterator.next();\n    String value = map.get(key);\n}\n```\n\n두 번째 방법은 entrySet을 통해 Entry객체를 Set타입으로 뽑아서 key와 value를 동시에 얻는 방법이 있을 수 있다.\n\n```java\nMap<String, String> map = new HashMap<>();\n\nfinal Set<Map.Entry<String, String>> entries = map.entrySet();\nfinal Iterator<Map.Entry<String, String>> iterator = entries.iterator();\nwhile(iterator.hasNext()){\n    final Map.Entry<String, String> mapEntry = iterator.next();\n    mapEntry.getKey();\n    mapEntry.getValue()\n}\n```\n\n#### HashMap\nHashMap의 키로 사용할 객체는 HashCode와 equals()메소드를 재정의해서 동등객체가 될조건을 정해야한다. 동등 객체, 즉 동일한 키가 될 조건은 hashCode()의 리턴값이 같아야하고, equals()메소드가 true를 리턴해야한다. 동등 객체, 즉 동일한 키가 될 조건은 hashCoDE()의 리턴값이 같아야하고 equals()메소드가 true를 리턴해야 한다.\n\n주로 키 타입으로 String을 많이사용하는데 String은 글자가 다르면 hashCode, equals 메소드가 다르도록 재정의가 되있기때문에 키로 적합하다. 해쉬맵은 아래와같이 키타입과 value 타입을 파라미터로 주고 기본 생성자로 선언할 수 있다.\n\n```java\nMap<K, V> map = new HashMap<K, V>();\n```\n\n**예제**\n\n* [이름을 키로 점수를 값으로 저장하기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/map/hashmap/HashMapExample1.java)\n* [학번과 이름이 동일한 경우 같은 키로 인식](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/map/hashmap/HashMapExample2.java)\n\n#### Hashtable\nHashtable은 HashMap과 동일한 내부구조를 가진다. HashMap과 차이점은 Hashtable은 동기화된(synchronized)메소드로 구성되어 있기때문에 멀티스레드가 동시에 이 메소드들을 실행할 수 는 없고, 하나의 스레드가 실행을 완료해야만 다른 스레드를 실행할 수 있다.\n\n다음은 Hash테이블을 이용해 키보드로 아이디와 비밀번호를 입력받아서 패스워드 인증 기능을 구현하는 예제이다.\n\n**예제**\n\n* [아이디와 비밀번호 검사하기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/map/hashtable/HashtableExample.java)\n\n#### Properties\nProperties는 Hashtable의 하위 클래스이기 때문에 HashTable의 모든 특징을 그대로 가지고 있다. Hashtable은 키와 값을 다양한 타입으로 지정이 가능한데 비해 Properties는 키와 값을 String 타입으로 제한한 컬렉션이다. Properties는 애플리케이션의 옵션정보, 데이터베이스 연결 정보 그리고 국제화(다국어) 정보가 저장된 프로퍼티(~.properties) 파일을 읽을 때 주로 사용한다.\n\n프로퍼티 파일은 키와 값이 = 기호로 연결되어 있는 텍스트 파일로 ISO 8859-1문자셋으로 저장된다. 이 문자셋으로 직접 표현할 수 없는 한글은 유니코드로 변환되어 저장된다.\n\n\n### 검색 기능을 강화시킨 컬렉션\n컬렉션 프레임워크는 검색 기능을 강화시킨 TreeSet과 TreeMap을 제공하고 있다. 이름에서 알 수 있듯이 TreeSet은 Set 컬렉션이고, TreeMap은 Map 컬렉션이다. 이 컬렉션들은 이진 트리를 이용해서 계층적(Tree 구조)를 가지면서 객체를 저장한다.\n\n#### 이진 트린 구조\n이진 트리는 여러 개의 노드가 트리 형태로 이루어진 연결된 구조로, 루트 노드라고 불리는 하나의 노드에서부터 시작해서 각 노드에 최대 2개의 노드를 연결할 수 있는 구조를 가지고 있다.\n\n![](https://i.imgur.com/SnTiRL0.png)\n\n위 아래로 연결된 두 노드를 부모 - 자식 관계에 있다고 하며 위의 노드를 부모 노드, 아래 노드를 자식 노드라고 한다. 하나의 노드는 최대 2개의 자식 노드와 연결될 수 있다. 이진 트리는 부모 노드의 값보다 작은 노드는 왼쪽에 위치시키고, 부모 노드의 값보다 큰 노드는 오른쪽에 위치시킨다. 예를 들어 6,3,9,2,5의 순서로 값을 저장하면 다음과 같은 순서로 진행된다.\n\n![](https://i.imgur.com/vmcODcJ.png)\n\n작은값은 왼쪽에, 큰값은 오른쪽에 저장한다. 숫자가 아닌 문자가 저장할경우네느 문자의 유니코드 값으로 비교한다. 이진 트리가 범위 검색을 쉽게할 수 있는 이유는 아래와 같이 값들이 정렬되어 있어 그룹핑이 쉽기 때문이다.\n\n![](https://i.imgur.com/dt6exaV.png)\n\n\n#### TreeSet\nTreeSet은 이진 트리를 기반으로 한 Set 컬렉션이다. 하나의 노드는 노드 값인 value와 왼쪽과 자식 노드를 참조하기 위한 두 개의 변수로 구성된다. TreeSet에 객체를 저장하면 자동으로 정렬되는데 부모 값과 비교해서 낮은 것은 왼쪽 자식 노드에, 높은 것은 오른쪽 자식 노드에 저장한다.\n![](https://i.imgur.com/1tD53qf.png)\n\nTreeSet을 생성하기 위해서는 저장할 객체 타입을 파라미터로 표기하고 기본 생성자를 호출하면 된다.\n```java\nTreeSet<E> treeSet = new TreeSet<E>();\n```\n\nSet 인터페이스 타입 변수에 대입해도 되지만 TreeSet클래스 타입으로 대입한 이유는 객체를 찾거나 범위 검색과 관련된 메소드를 사용하기 위해서이다. 다음은 TreeSet이 가지고있는 검색 관련된 메소드들이다.\n\n| 메소드          | 설명                                                   |\n| ------------ | ---------------------------------------------------- |\n| first()      | 제일 낮은 객체를 리턴                                         |\n| last()       | 제일 높은 객체를 리턴                                         |\n| lower(E e)   | 주어진 객체보다 바로 아래 객체를 리턴                                |\n| higher(E e)  | 주어진 객체보다 바로 위 객체를 리턴                                 |\n| floor(E e)   | 주어진 객체와 동등한 객체가 있으면 리턴 . 만약 없다면 주어진 객체의 바로 위의 객체를 리턴 |\n| celling(E e) | 주어진 객체와 동등한 객체가 있으면 리턴, 만약 없다면 주어진 객체의 바로 위의 객체를 리턴  |\n| pollFirst()  | 제일 낮은 객체를 꺼내오고 컬렉션에서 제거함                             |\n| pollLast()   | 제일 높은 객체를 꺼내오고 컬렉션에서 제거함                             |\n\n\n다음은 TreeSet을 이용해 몇가지 기능을 구현해보는 예제이다.\n\n**예제**\n* [TreeSet 특정 객체 찾기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/tree/treeset/TreeSetExample1.java)\n* [TreeSet 객체 정렬하기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/tree/treeset/TreeSetExample2.java)\n* [TreeSet 영어 단어를 정렬하고, 범위 검색해보기 ](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/tree/treeset/TreeSetExample3.java)\n\n#### TreeMap\nTreeMap은 이진 트리를 기반으로 한 Map 컬렉션이다. TreeSet 과의 차이점은 키와 값이 저장된 MapEntry를 저장한다는 점이다. TreeMap에 객체를 저장하면 자동으로 정렬되는데 기본적으로 부모 키값과 비교해서 키값이 낮은 것은 왼쪽 자식 노드에, 키값이 높은 것은 오른쪽 자식 노드에 Map.Entry 객체를 저장한다.\n\n![](https://i.imgur.com/si0KBY0.png)\n\nTreeMap을 생성하기 위해서는 키로 저장할 객체 타입과 값으로 저장할 객체 타입을 타입 파라미터로 주고 기본 생성자를 호출하면 된다.\n```java\nTreeMap<String, Integer> treeMap = new TreeMap<String, Integer>();\n\n```\n| 메소드                 | 설명                                                                    |\n| ------------------- | --------------------------------------------------------------------- |\n| firstEntry()        | 제일 낮은 Map.Entry를 리턴                                                   |\n| lastEntry()         | 제일 높은 Map.Entry를 리턴                                                   |\n| lowerEntry(K key)   | 주어진 키보다 바로 아래 Map.Entry를 리턴                                           |\n| higherEntry(K key)  | 주어진 키보다 바로 위 Map.Entry를 리턴                                            |\n| floorEntry(K key)   | 주어진 키와 동등한 키가 있으면 해당 Map.Entry를 리턴,<br>없다면 주어진 키 바로 아래의 Map.Entry를 리턴 |\n| ceilingEntry(K key) | 주어진 키와 동등한 키가 있으면 해당 Map.Entry를 리턴,<br>없다면 주어진 키 바로 위의 Map.Entry를 리턴  |\n| pollFirstEntry()    | 제일 낮은 Map.Entry를 꺼내오고 컬렉션에서 제거함                                       |\n| pollLastEntry()     | 제일 높은 Map.Entry를 꺼내오고 컬렉션에서 제거함                                       |\n\n다음은 TreeMap 가지고 있는 정렬과 관련된 메소드들이다.\n\n| 리턴 타입             | 메소드                | 설명                                     |\n| ----------------- | ------------------ | -------------------------------------- |\n| NavigableSet<K>   | descendingKeySet() | 내림차순으로 정렬된 키의 NavigableSet을 리턴         |\n| NavigableMap<K,V> | descendingMap()    | 내림차순으로 정렬된 Map.Entry의 NavigableMap을 리턴 |\n\ndescendingMap 메소드를 호출하면 내림차순 NavigableMap타입의 객체를 리턴해주는데 만약 한번 더호출하게되면 오름차순 객체를 리턴한다.\n\n```java\nNavigableMap<K, V> descendingMap = treeMap.descendingMap();\nNavigableMap<K, V> ascendingMap = descendingMap.descendingMap();\n```\n\n| 리턴 타입              | 메소드                                                                    | 설명                                                                                                 |\n| ------------------ | ---------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- |\n| NavigableMap<K, V> | headMap(k toKey, boolean inclusive)                                    | 주어진 키보다 낮은 Map.Entry들을 NavigableMap으로리턴. 주어진 키의 Map.Entry 포함여부는 두번째 매개 값에 따라 달라짐                   |\n| NavigableMap<K, V> | tailMap(k fromKey, boolean inclusive)                                  | 주어진 객체보다 높은 Map.Entry들을 NavigableMap으로 리턴. 주어진 객체 포함여부는 두번째 매개값에서 따라 달라짐                           |\n| NavigableMap<K, V> | subMap(K fromKey, boolean fromInclusive, K tokey, boolean toInclusive) | 시작과 끝으로 주어진 키 사이의 Map.Entry들을 NavigableMap 컬렉션으로 변환. 시작과 끝 키의 Map.Entry 포함여부는 두번째, 네번째 매개값에 따라 달라짐 |\n\n여기에서 간단하게 SubMap()메소드의 사용방법을 간단히 봐보자. subMap()메소드는 네 개의 매개 변수가 있는데, 시작키와 끝키, 그리고 이 키들의 Map.Entry를 포함할지 여부의 boolean값을 받는다. 이것을 기반으로 그 해당 범위내의 Map을 리턴해준다.\n\n다음은 TreeMap 구조를 이용해 몇가지 기능을 구현한 예제이다.\n\n**예제**\n* [TreeMap 특정 Map.Entry 찾기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/tree/treemap/TreeMapExample1.java)\n* [TreeMap 객체 정렬하기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/tree/treemap/TreeMapExample2.java)\n* [TreeMap 키로 정렬하고 범위 검색하기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/tree/treemap/TreeMapExample3.java)\n\n#### Comparable과 Compartor\nTreeSet의 객체와 TreeMap의 키는 저장과 동시에 자동 오름차순으로 정렬되는데, 숫자일 경우 값으로 정렬하고, 문자열일 경우에는 유니코드로 정렬한다. TreeSet과 TreeMap은 이진 트리로 크기를 비교해 트리구조를 구성해야 하기 때문에 java.lang.Comparable 인터페이스를 구현해야 쓸 수 있다. 기본적으로 Wrraper Class들은 Comparable 인터페이스가 구현되어 있어 TreeSet과 TreeMap을 사용할 수 있다.\n\n또한 ArrayList 등의 자료구조를 Collection.sort()함수를 사용할때도 Comparable을 이용해 compareTo()메소드만 구현하게되면 쉽게 Collection프레임워크의 자료구조들을 정렬하여 사용할 수 있다. 쉽게 Coparable을 implements를 하여 compareTo()메소드만 정의해주면 된다. 아래의 설명을 참조하여 compareTo()를 재정의해주면된다.\n\n\n| 리턴타임 | 메소드            | 설명                                                                 |\n| ---- | -------------- | ------------------------------------------------------------------ |\n| int  | compareTo(T o) | 주어진 객체와 같으면 0을리턴 <br> 주어진 객체보다 작으면 음수를 리턴 <br>  주어진 객체보다 크면 양수를 리터 |\n\n\n다음은 나이를 기준으로 Person객체를 오름차순으로 정렬하기 위해 Comparable 인터페이스를 구현한것이다. 나이가 적을 경우는 -1을 동일한경우는 0을 클경우는 1을 리턴하도록하여 compareTo() 메소드를 재정의하여 treeSet을 이용하여 유저를 출력하였다. \n\n다음은 **Comparable 예제**이다.\n\n* [Comparable 예제](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/ComparableExample.java)\n\n위에서 말했듯이 TreeSet, TreeMap을 사용할 때의 키가 Comparable을 구현하고 있지 않을 경우에는 저장하는 순간 ClassCastException이 발생한다. 이진 트리를 구성하기 위해서는 값 비교는 필 수이다. 그렇다면 객체에 Comparable 구현체를 구현하는 방법 말고 정렬하는 방법은 없을까... 그 방법은 Comparator 인터페이스다. 그런데 결국에는 둘 다 비슷한 방법이라고 생각한다. 어쨌든 예제를 간단하게 한번 봐보자.\n\n```java\nTreeSet<E> treeSet = new TreeSet<E>(new AscendingComparator());\n\nTreeMap<K,V> treeMap = new TreeMap<K, V> (new DescendingComparator());\n```\n\n정렬자는 Comparator 인터페이스를 구현한 객체를 말하는데, Comparator 인터페이스는 다음과 같이 메소드가 정의되어 있다.\n\n| 리턴 타입 | 메소드                 | 설명                                                                            |\n| ----- | ------------------- | ----------------------------------------------------------------------------- |\n| int   | compare(T o1, T o2) | o1과 o2가 동등하다면 0을리턴<br> o2이 o2보다 앞에 오게하면 음수를 리턴 <br> o1이 o2보다 뒤에 오게 하려면 양수를 리턴 |\n\n다음은 Comparator를 이용하여 과일 객체를 내림차순으로 정렬시키는 **예제**이다.\n* [Compartor 예제](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/ComparatorExample.java)\n\n### LIFO와 FIFO 컬렉션\n\n후입 선출(LIFO : Last In First Out)은 나중에 넣은 객체가 먼저 빠져 나가는 자료구조를 말한다. 반대로 선입 선출(FIFO : First In First Out)은 먼저 넣은 객체가 먼저 빠져나가는 구조를 말한다. 컬렉션 프레임워크에는 LIFO 자료구조를 제공하는 스택(Stack) 클래스와 FIFO 자료구조를 제공하는 (Queue) 인터페이스를 제공하고 있다. 다음은 스택과 큐의 구조를 보여준다.\n![](https://i.imgur.com/QJcADSn.png)\n\n스택을 응용한 대표적인 예가 프로그램들의 함수를 저장하는 공간인 스택공간일 수 가 있다. 스택 메모리에 저장된 변수는 나중에 저장된것부터 저장된다. 큐를 응용한 대표적인 예가 스레드풀의 작업이다. 작업 큐는 먼저 들어온 작업부터 처리한다.\n\n#### Stack\n\nStack 클래스는 LIFO 자료구조를 구현한 클래스이다. 다음은 Stack 클래스의 주요 메소드들이다.\n\n\n| 리턴 타입 | 메소드          | 설명                                   |\n| ----- | ------------ | ------------------------------------ |\n| E     | push(E item) | 주어진 객체를 스택에 넣는다.                     |\n| E     | peek()       | 스택의 맨 위 객체를 가져온다. 객체를 스택에서 제거하지 않는다. |\n| E     | pop()        | 스택의 맨 위 객체를 가져온다. 객체를 스택에서 제거한다.     |\n\nStack을 사용하기위해서는 아래와같이 스택을 생성할때 타입파라미터를 넘기고 기본생성자를 호출하면 된다.\n```java\nStack<E> stack = new Stack<E>();\n```\n\n다음은 택시에서 많이 볼 수 있는 동전케이스를 스택 클래스로 구현한 예제이다. 먼저 넣은 동전은 제일밑에 깔리고 나중에 넣은 동전이 위에 쌓이기 때문에 Stack에서 동전을 빼면 마지막에 넣은 동전이 먼저나오는 예제이다.\n* [Stack 예제](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/stack/StackExample.java)\n\n#### Queue\n\nQueue인터페이스는 FIFO자료구조에서 사용되는 메소드를 정의하고 있다. 다음은 Queue 인터페이스에 정의되어 있는 메소드를 보여준다\n\n\n| 리턴 타입| 메소드 | 설명 |\n| -------- | -------- | -------- |\n| boolean       | offer(E e)       | 주어진 객체를 넣는다.       |\n| E       | peek()       | 객체 하나를 가져온다. 객체를 큐에서 제거하지 않는다.       |\n| E       | poll()       | 객체 하나를 가져온다. 객체를 큐에서 제거한다.       |\n\n\nQueue 인터페이스를 구현한 대표적인 클래스는 LinkedList이다. LinkedList는 List인터페이스를 구현했기 때문에 List 컬렉션이기도 하다. 다음 코드는 LinkedList 객체를 Queue 인터페이스 타입으로 변환한것이다.\n```java\nQueue<E> queue = new LinkedList<E>();\n```\n다음은 Queue를 이용해서 간단한 메시지 큐를 구현한 예제이다. 먼저 넣은 메시지가 반대쪽으로 먼저 나오기 때문에 넣은 순서대로 메시지가 처리 되는 예제이다.\n* [Queue 예제](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/queue/QueueExample.java)\n\n\n참고 \n* [이것이 자바다](https://book.naver.com/bookdb/book_detail.nhn?bid=8589375)","source":"_posts/2018-07-03-collection.md","raw":"---\ntitle: Java Collection framework\ncatalog: true\ndate: 2018-07-03\nsubtitle:\nheader-img:\ntags:\n- Java\n\n\n---\n\n\n## 시작하며\n컬렉션에 대한 내용을 정리하게 된 계기는 먼저 자바 Collection 만의 API 기능을 효율적으로 사용하기 위해서이다. 다음은 자료구조를 적극적으로 활용하기 위해서이다. 자료구조를 이용하면 훨씬 효율적으로 데이터들을 관리할 수 있고 심지어 코드의 가독성 또한 좋아지기 때문이다. 가독성이 안 좋아지고 복잡함을 증가시키는 IF 문을 피하는 코드를 만드는 것은 아주 효율적인 코딩이라고 생각한다.\n\n예를 들어, List에 있는 이메일들을 중복 검사한다고 했을 때 단순하게 생각하면 List를 Email 숫자만큼 loop를 돌려 Email을 중복 검사하는 방법이 있을 수 있다. 하지만 HashSet, TreeSet을 이용하면 중복된 값이 저장이 되지 않기 때문에 좀 더 효율적으로 데이터를 관리하고, 소스코드를 깔끔하게 관리할 수 있다.\n\n또한 다른 예를 들면 여러 개의 이메일에서 특정 이메일을 검색한다고 했을 때 TreeSet 자료구조를 이용하면 트리구조로 데이터가 저장되기 때문에 검색 기능 또한 뛰어나다. 반면 List 같은 경우에는 loop로 하나하나 노드를 검색해서 해당 이메일이 나올 때까지 검색을 해야 하기 때문에 효율적이지 않다. 그러므로 자바에서 효율적인 코딩을 하기 위해서는 Collection 프레임워크를 자세히 알아두는 것은 좋다고 생각한다.\n\n아래의 내용은 '[이것이 자바다](https://book.naver.com/bookdb/book_detail.nhn?bid=8589375)' 를 보고 컬렉션에 대한 내용을 정리한것이다.\n\n## 컬렉션 프레임워크\n\n애플리케이션을 개발하다 보면 다수의 객체를 저장해야 하는 경우가 많이 발생한다. 예를 들어 Product 객체를 10개를 저장해야 한다. 어떻게 하면 효율적으로 저장할 수 있을까. 먼저 가장 간단한 배열을 확인해보자.\n\n```java\n//길이 10인 배열생성\nProduct[] array = new Product[10];\n\n//객체추가\narray[0] = new Product(\"Model1\");\narray[1] = new Product(\"Model2\");\n\n//객체 검색\nProduct model1 = array[0];\nProduct model2 = array[1];\n\n//객체 삭제\narray[0] = null;\narray[1] = null;\n\n```\n\n배열은 쉽게 생성하고 사용할 수 있지만, 저장할 수 있는 객체수가 배열을 생성할 때 결정되기 때문에 불특정 다수의 객체를 저장하기에는 문제가 있다. 물론 배열의 길이를 크게 생성하면 되지만, 이것은 좋은 방법이 아니다. 또 다른 문제는 배열의 객체를 삭제했을 때 해당 인덱스가 비게 되면 아래와 같이 중간중간에 객체가 없는 배열이 된다. 이렇게 되면 객체를 어디에 저장해야 할지 배열 인덱스 하나하나 검색 후 비어있는 공간에 객체를 저장해야 한다.\n\n```java\n[1][2][3][4][5][6]\n O  O  X  O  X  O\n```\n\n자바는 배열의 이러한 문제점을 해결하고, 널리 알려져 있는 자료구조(Data Structre)를 바탕으로 객체들을 효율적으로 추가, 삭제, 검색할수 있도록 Java.util 패키지에 컬렉션과 관련된 인터페이스와 클래스들을 포함시켜 놓았다. 이들을 총칭해서 컬렉션 프레임워크라 한다.\n\n**컬렉션** 이란 사전적 의미로 요소를 수집해서 저장하는 것을 의미하는데, 자바 컬렉션은 객체를 수집해서 저장하는 역할을 한다. 자바 컬렉션 프레임워크는 몇 가지 인터페이스를 통해서 다양한 컬렉션 클래스를 이용할 수 있도록 한다. 컬렉션 프레임워크의 주요 인터페이스로는 List, Set, Map이 있다. 이 인터페이스들은 컬렉션을 사용하는 방법을 정의하는 것인데, 다음은 인터페이스로 사용 가능한 컬렉션 클래스를 보여준다.\n\n![](https://i.imgur.com/JmO4zX2.png)\n\nList와 Set은 객체 추가, 삭제 검색하는 방법에 많은 공통점이 있기 때문에 이 인터페이스들의 공통된 메소드들만 모아 Collection 인터페이스로 정의해 두고 있다. Map은 키와 값을 하나의 쌍으로 묶어서 관리하는 구조로 되어있어 List및 Set과는 사용방법이 완전히 다르다.\n\n| 인터페이스 분류          | 특징                              | 구현클래스                                 |\n| ----------------- | ------------------------------- | ------------------------------------- |\n| Collection (List) | - 순서룰유지하고저장<br>- 중복 저장 가능       | ArrayList, Vector, LinkedList         |\n| Collection (Set)  | - 순서를 유지 않고 저장 <br> - 중복 저장 안됨  | HashSet, TreeSet                      |\n| Map               | - 키와 값의 쌍으로 저장 <br> - 키는 중복 안 됨 | HashMap,Hashtable,TreeMap, Properties |\n\n\n\n\n### List 컬렉션\n\nList 컬렉션은 객체를 일렬로 늘어놓은 구조를 가지고 있다. 객체를 인덱스로 관리하기 때문에 객체를 저장하면 자동 인덱스가 부여되고 인덱스로 객체를 검색, 삭제할 수 있는 기능을 제공한다.  List 컬렉션에는 ArrayList, Vector, LinkedList 등이 있는데 다음은 List 컬렉션에서 공통적으로 사용 가능한 List 인터페이스의 메소드들이다. 인덱스로 객체를 관리하기 때문에 인덱스를 매게 값으로 갖눈 메소드가 많다.\n\n**객체 추가**\n\n| 메소드              | 설명                         |\n| ---------------- | -------------------------- |\n| boolean add(E e) | 주어진 객체를 맨 끝에 추가            |\n| void add(E e)    | 주어진 인덱스에 객체를 추가            |\n| set add(E e)     | 주어진 인덱스에 저장된 객체를 주어진 객체로바꿈 |\n\n\n**객체 검색**\n\n| 메소드                        | 설명                  |\n| -------------------------- | ------------------- |\n| boolean contains(Object o) | 주어진 객체가 저장되어 있는지 여부 |\n| E get(int index)           | 주어진 인덱스에 객체를 리턴     |\n| isEmpty()                  | 컬렉션이 비어있는지 검사       |\n| int size()                 | 저장되어 있는 전체 객체 수를 리턴 |\n\n **객체 삭제**\n\n| 메소드                      | 설명                  |\n| ------------------------ | ------------------- |\n| void clean()             | 저장된 모든 객체를 삭제       |\n| E remove(int index)      | 주어진 인덱스에 저장된 객체를 삭제 |\n| boolean remove(Object o) | 주어진 객체를 삭제          |\n\n\n#### ArrayList\nArrayList는 List 인터페이스의 구현 클래스로, ArrayList에 객체를 추가하면 객체가 인덱스로 관리된다. 일반배열과 ArrayList는 인덱스로 객체를 관리한다는 점에서는 유사하지만, 큰차이점을 가지고 있다. 배열은 생성할 때 크기가 고정되고, 사용중에 크기를 변경할 수 없지만, ArrayList는 저장 용량을 초과한 객체들이 들어오면 자동적으로 저장용량이 늘어난다. 다음은 ArrayList 객체의 내부 구조를 보여준다.\n\n![](https://i.imgur.com/M08M97l.png)\n\n검사버튼 삭제버튼 초기에 ArrayList를 선언하면 10개의 객체를 저장할 수 있는 List가 선언이 된다. 만약 초기부터 용량을 크게 선언하고 싶다면 아래와 같이 선언하면 된다.\n\n```java\nList<String> list = new ArrayList<String>(30);\n```\n\nArrayList에 객체를 저장하면 인덱스 0 부터 차례대로 저장된다. ArrayList에서 특정 인덱스의 객체를 제거하면 바로 뒤 인덱스부터 마지막 인덱스까지 모두 앞으로 1씩 당겨진다. 마찬가지로 특정 인덱스에 객체를 삽입하면 해당 인덱스부터 마지막 인덱스까지 모두 1씩 밀려난다. 다음은 4번 인덱스가 제거되었을 때 5번 인덱스부터 모두 앞으로 1씩 당겨지는 모습을 보여준다.\n\n![](https://i.imgur.com/nhg1zDA.png)\n\n위와같이 List안에서 노드가삭제가되면 앞으로 하나하나 다 밀려나야한다. 따라서 빈번한 객체 삭제와 삽입이 일어나나는 곳에서는 ArrayList를 사용하지 않고 삽입삭제에 용이한 LinkedList를 사용하는것이 좋다. 그러나 인덱스 검색이나 마지막 노드추가에서는 ArrayList가 더 좋은 성능을 발휘한다.\n\n다음예제는 ArrayList에 String 객체를 추가, 검색, 삭제하는방법의 간단한 예제이다.\n\n**예제**\n\n* [String 객체를 저장하는 ArrayList](https://github.com/minwan1/blog-example/tree/master/java-basis-example/src/collection/list/arraylist)\n\n#### Vector\nVector는 ArrayList와 동일한 내부 구조를 가지고 있다. Vector를 생성하기 위해서는 지정할 객체 타입을 타입 파라미터로 표기하고 기본 생성자를 호출하면 된다.\n\n```java\nList<E> list = new Vector<E>();\n```\nArrayList와 다른점은 Vector는 동기화된 메소드로 구성되어 있기 때문에 멀티 스레드가 동시에 이 메소드들을 실행할 수 없고, 하나의 스레드가 실행을 완료해야만 다른 스레드가 실행할 수 있다. 그래서 멀티 스레드 환경에서 안전하게 객체를 추가, 삭제할 수 있다.\n\n다음은 Vector를 이용해서 객체를 추가, 삭제, 검색하는 예제이다.\n\n**예제**\n\n* [객체 저장, 삭제](https://github.com/minwan1/blog-example/tree/master/java-basis-example/src/collection/list/vector)\n\n#### LinkedList\nLinkedList는 List 구현 클래스이므로 ArrayList와 사용방법은 똑같지만 내부 구조는 완전 다르다. ArrayList는 내부 배열 객체를 저장해서 인덱스로 관리하지만, LinkedList는 인접 참조를 링크해서 체인처럼 관리한다.\n\n![](https://i.imgur.com/09ZGkA7.png)\n\nLinkedList에서 특정 인덱스의 객체를 제거하면 앞뒤 링크만 변경되고 나머지 링크는 변경되지 않는다. 특정 인덱스에 객체를 삽입할 때에도 마찬가지다. 그렇기 때문에 빈번한 객체를 삭제할 때는 LinkedList가 성능이 좋다. 왜냐 중간에서 하나 삭제를 하더라도 앞뒤의 노드만 연결해주면 되기 때문이다.\nLinkedList는 생성하기 위해서는 저장할 객체 타입 파라미터(E)에 표기하고 기본 생성자로 호출하면 된다. 기본적으로 LinkedList는 처음 생성될 때에는 어떤한 링크도 만들어지지 않기 때문에 내부적으로 비어있다. 아래와 같이 생성할 수 있겠다.\n\n```java\nList<E> list = new LinkedList<E>();\n```\n다음 예제는 ArrayList와 LinkedList에 10000개의 객체를 삽입하는데 걸릴시간을 측정하는 예제이다. 누가 더 많은 시간이 걸리는지에 대한 예제이다.\n\n**예제**\n\n[ArrayList와 LinkedList의 실행 성능 비교](https://github.com/minwan1/blog-example/tree/master/java-basis-example/src/collection/list/linkedlist)\n\n### Set 컬렉션\nList 컬렉션은 저장 순서를 유지하지만, Set 컬렉션은 저장 순서가 유지되지 않는다. 또한 객체를 중복해서 저장할 수 없다. 하나의 null만 저장할 수 있다. Set 컬렉션은 수학의 집합에 비유될 수 있다. 집합은 순서와 상관없고 중복이 허용되지 않기 때문이다.\n\nSet 컬렉션에는 HashSet, LinkedHashSet, TreeSet등이 있는데, 다음은 Set 컬렉션에 공통적으로 사용 가능한 Set 인터페이스의 메소드들이다.\n\n![](https://i.imgur.com/ZByMxEo.png)\nSet 컬렉션은 인덱스로 객체를 검색해서 가져오는 메소드가 없다. 대신 전체 객체를 대상으로 한번씩 반복해서 가져오는 반복자(Iterator)를 제공한다. 반복자는 Iterator 인터페이스를 구현한 객체를 말하는데, itorator() 메소드를 호출하면 얻을 수 있다.\n\n\n```java\nSet<String> set = ...;\nIterator<String> iterator = set.iterator();\n```\n\n다음은 Iterator 인터페이스에 선언된 메소드들이다.\n\n| 리턴 타입   | 메소드명      | 설명                                      |\n| ------- | --------- | --------------------------------------- |\n| boolean | hasNext() | 가져올 객체가 있으면 true를 리턴하고 없으면 false를 리턴한다. |\n| E       | next()    | 컬렉션에서 하나의 객체를 가져온다                      |\n| void    | remove()  | Set 컬렉션에서 객체를 제거한다.                     |\n\nIterator에서 하나의 객체를 가져올 때는 next() 메소드를 사용한다. next() 메소드를 사용하기전에 먼저 가져올 객체가 있는지 확인하는것이 좋다. hasNext() 메소드는 가져올 객체가 있으면 true를 리턴하고 더이상 가져올 객체가 없으면 false를 리턴한다. 따라서 true가 리턴될때 next() 메소드를 사용해야한다. 다음은 Set을 이용한 루핑 방법이다.\n\n방법 1. Iterator를 사용한벙법\n```java\nSet<String> set = ...;\nIterator<String> iterator = set.iterator();\nwhile(iterator.hasNext()){ // has가 다음 객체가있는지 체크해주니까 있는 만큼 루핑된다.\n  String str = iterator.next();\n}\n```\n방법 2. For문 사용\n```java\nfor(String str : set){ // 저장된 객체수만큼 루핑한다.\n\n}\n```\n\n\n#### HashSet\nHashSet은 Set 인터페이스의 구현클래스이다. HashSet을 생성하기 위해서는 다음과 같이 기본생성자를 호출하면 된다.\n\n```java\nSet<E> set = new HashSet<E>();\n```\n\nHashSet은 Set의 성격대로 순서상관없이 저장되고, 중복 저장되지 않는다. HashSet이 판단하는 동일한 객체란 꼭 같은 인스턴스를 뜻하지 않는다. HashSet은 객체를 저장하기전에 먼저 객체의 HashCode()메소드를 호출해서 해시코드를 얻는다. 그리고 이미 저장되어 있는 객체의 hashCode() 메소드를 호출해서 해시코드를 얻어낸다. 그리고 이미저장되어 있는 객체들의 해시코드와 비교 한다. 만약 equals()메소드로 두 객체를 비교해서 true가 나오면 동일한 객체로 판단하고 중복 저장을 하지 않는다.\n\n![](https://i.imgur.com/re05jjk.png)\n\n문자열을 HashSet에 저장할 경우, 깊은 문자열을 갖는 String 객체는 동등한 객체로 간주되고 다른 문자열을 갖는 String 객체는 다른 객체로 간주되는데, 그 이유는 String 클래스가 hashCode()와 equals() 메소드를 재정의해서 같은 문자열일 경우 hashCode()의 리턴값을 같게, equals()의 리턴값은 true가 나오도록 오버라이딩이 되있기 때문이다. 물론 자신이 정의 한 클래스에도 똑같이 적용할 수 있다.\n\n예를 들어 Member 클래스를 정의했다고 가정하자. 이 MemberClass에는 인스턴스가 달라도 이름과 나이가 동일하다면 동등 객체라고 equals()와 hashCode를 정의했다고 치자. 그리고 아래와 같이 Set에 객체를 넣는다고 해보자.\n\n```java\nSet<Member> set = new HashSet<Member>();\nset.add(new Member(\"홍길동\", 30));\nset.add(new Member(\"홍길동\", 30));\nSystem.out.println(\"총 객체수 : \" + set.size()); 저장된 객체 수 얻기 // 사이즈 1\n\n```\n위와같이 Set에 이름과 나이가 같은 객체를 두개 넣더라도 실제적으로 set에는 1개의 객체만 들어가게 된다.\n\n다음은 HashSet을 이용해 앞에서 간단한 Hashse에대한 기능을 확인하는 예제이다.\n\n* [String 객체를 중복없이 저장하는 HashSet](https://github.com/minwan1/blog-example/tree/master/java-basis-example/src/collection/set)\n* [Member 객체를 정보없이 저장하는 HashSet](https://github.com/minwan1/blog-example/tree/master/java-basis-example/src/collection/set)\n\n### Map 컬렉션\nMap 컬렉션은 키(Key)와 값(value으로 구성된 Entry 객체를 저장하는 구조를 가지고 있다. 여기서 키와 값은 모두 객체이다. 키는 중복 저장될 수 없지만 값은 중복 저장될 수 있다. 키값이 중복되어 저장된다면 먼저 저장된 값은 저장되지 않는다.\n![](https://i.imgur.com/TI9n5UB.png)\n\nMap 컬렉션에는 HashMap, Hashtable, LinkedHashMap, Properties, TreeMap 등이 있다. 다음은 Map컬렉션에서 공통적으로 사용가능한 Map 인터페이스의 메소드들이다. 키로 객체들을 관리하기때문에 키를 매개값으로 갖는 메소드가 많다.\n![](https://i.imgur.com/zCuSUsB.png)\n\nMap에서는 키를 알고 싶다면 get() 메소 도로 객체를 얻어낼 수 있다. 하지만 맵 안에 데이터를 하나하나 얻어 내고 싶다면 두 가지 방법이 있다. 먼저 아래는 Key를 Set 타입으로 뽑아서 하나하나 Iterator 시켜 그 key 값으로 value를 얻는 방법이 있을 수 있다.\n\n```java\nMap<String, String> map = new HashMap<>();\n\nfinal Set<String> strings = map.keySet();\nfinal Iterator<String> iterator = strings.iterator();\nwhile(iterator.hasNext()){\n    String key = iterator.next();\n    String value = map.get(key);\n}\n```\n\n두 번째 방법은 entrySet을 통해 Entry객체를 Set타입으로 뽑아서 key와 value를 동시에 얻는 방법이 있을 수 있다.\n\n```java\nMap<String, String> map = new HashMap<>();\n\nfinal Set<Map.Entry<String, String>> entries = map.entrySet();\nfinal Iterator<Map.Entry<String, String>> iterator = entries.iterator();\nwhile(iterator.hasNext()){\n    final Map.Entry<String, String> mapEntry = iterator.next();\n    mapEntry.getKey();\n    mapEntry.getValue()\n}\n```\n\n#### HashMap\nHashMap의 키로 사용할 객체는 HashCode와 equals()메소드를 재정의해서 동등객체가 될조건을 정해야한다. 동등 객체, 즉 동일한 키가 될 조건은 hashCode()의 리턴값이 같아야하고, equals()메소드가 true를 리턴해야한다. 동등 객체, 즉 동일한 키가 될 조건은 hashCoDE()의 리턴값이 같아야하고 equals()메소드가 true를 리턴해야 한다.\n\n주로 키 타입으로 String을 많이사용하는데 String은 글자가 다르면 hashCode, equals 메소드가 다르도록 재정의가 되있기때문에 키로 적합하다. 해쉬맵은 아래와같이 키타입과 value 타입을 파라미터로 주고 기본 생성자로 선언할 수 있다.\n\n```java\nMap<K, V> map = new HashMap<K, V>();\n```\n\n**예제**\n\n* [이름을 키로 점수를 값으로 저장하기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/map/hashmap/HashMapExample1.java)\n* [학번과 이름이 동일한 경우 같은 키로 인식](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/map/hashmap/HashMapExample2.java)\n\n#### Hashtable\nHashtable은 HashMap과 동일한 내부구조를 가진다. HashMap과 차이점은 Hashtable은 동기화된(synchronized)메소드로 구성되어 있기때문에 멀티스레드가 동시에 이 메소드들을 실행할 수 는 없고, 하나의 스레드가 실행을 완료해야만 다른 스레드를 실행할 수 있다.\n\n다음은 Hash테이블을 이용해 키보드로 아이디와 비밀번호를 입력받아서 패스워드 인증 기능을 구현하는 예제이다.\n\n**예제**\n\n* [아이디와 비밀번호 검사하기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/map/hashtable/HashtableExample.java)\n\n#### Properties\nProperties는 Hashtable의 하위 클래스이기 때문에 HashTable의 모든 특징을 그대로 가지고 있다. Hashtable은 키와 값을 다양한 타입으로 지정이 가능한데 비해 Properties는 키와 값을 String 타입으로 제한한 컬렉션이다. Properties는 애플리케이션의 옵션정보, 데이터베이스 연결 정보 그리고 국제화(다국어) 정보가 저장된 프로퍼티(~.properties) 파일을 읽을 때 주로 사용한다.\n\n프로퍼티 파일은 키와 값이 = 기호로 연결되어 있는 텍스트 파일로 ISO 8859-1문자셋으로 저장된다. 이 문자셋으로 직접 표현할 수 없는 한글은 유니코드로 변환되어 저장된다.\n\n\n### 검색 기능을 강화시킨 컬렉션\n컬렉션 프레임워크는 검색 기능을 강화시킨 TreeSet과 TreeMap을 제공하고 있다. 이름에서 알 수 있듯이 TreeSet은 Set 컬렉션이고, TreeMap은 Map 컬렉션이다. 이 컬렉션들은 이진 트리를 이용해서 계층적(Tree 구조)를 가지면서 객체를 저장한다.\n\n#### 이진 트린 구조\n이진 트리는 여러 개의 노드가 트리 형태로 이루어진 연결된 구조로, 루트 노드라고 불리는 하나의 노드에서부터 시작해서 각 노드에 최대 2개의 노드를 연결할 수 있는 구조를 가지고 있다.\n\n![](https://i.imgur.com/SnTiRL0.png)\n\n위 아래로 연결된 두 노드를 부모 - 자식 관계에 있다고 하며 위의 노드를 부모 노드, 아래 노드를 자식 노드라고 한다. 하나의 노드는 최대 2개의 자식 노드와 연결될 수 있다. 이진 트리는 부모 노드의 값보다 작은 노드는 왼쪽에 위치시키고, 부모 노드의 값보다 큰 노드는 오른쪽에 위치시킨다. 예를 들어 6,3,9,2,5의 순서로 값을 저장하면 다음과 같은 순서로 진행된다.\n\n![](https://i.imgur.com/vmcODcJ.png)\n\n작은값은 왼쪽에, 큰값은 오른쪽에 저장한다. 숫자가 아닌 문자가 저장할경우네느 문자의 유니코드 값으로 비교한다. 이진 트리가 범위 검색을 쉽게할 수 있는 이유는 아래와 같이 값들이 정렬되어 있어 그룹핑이 쉽기 때문이다.\n\n![](https://i.imgur.com/dt6exaV.png)\n\n\n#### TreeSet\nTreeSet은 이진 트리를 기반으로 한 Set 컬렉션이다. 하나의 노드는 노드 값인 value와 왼쪽과 자식 노드를 참조하기 위한 두 개의 변수로 구성된다. TreeSet에 객체를 저장하면 자동으로 정렬되는데 부모 값과 비교해서 낮은 것은 왼쪽 자식 노드에, 높은 것은 오른쪽 자식 노드에 저장한다.\n![](https://i.imgur.com/1tD53qf.png)\n\nTreeSet을 생성하기 위해서는 저장할 객체 타입을 파라미터로 표기하고 기본 생성자를 호출하면 된다.\n```java\nTreeSet<E> treeSet = new TreeSet<E>();\n```\n\nSet 인터페이스 타입 변수에 대입해도 되지만 TreeSet클래스 타입으로 대입한 이유는 객체를 찾거나 범위 검색과 관련된 메소드를 사용하기 위해서이다. 다음은 TreeSet이 가지고있는 검색 관련된 메소드들이다.\n\n| 메소드          | 설명                                                   |\n| ------------ | ---------------------------------------------------- |\n| first()      | 제일 낮은 객체를 리턴                                         |\n| last()       | 제일 높은 객체를 리턴                                         |\n| lower(E e)   | 주어진 객체보다 바로 아래 객체를 리턴                                |\n| higher(E e)  | 주어진 객체보다 바로 위 객체를 리턴                                 |\n| floor(E e)   | 주어진 객체와 동등한 객체가 있으면 리턴 . 만약 없다면 주어진 객체의 바로 위의 객체를 리턴 |\n| celling(E e) | 주어진 객체와 동등한 객체가 있으면 리턴, 만약 없다면 주어진 객체의 바로 위의 객체를 리턴  |\n| pollFirst()  | 제일 낮은 객체를 꺼내오고 컬렉션에서 제거함                             |\n| pollLast()   | 제일 높은 객체를 꺼내오고 컬렉션에서 제거함                             |\n\n\n다음은 TreeSet을 이용해 몇가지 기능을 구현해보는 예제이다.\n\n**예제**\n* [TreeSet 특정 객체 찾기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/tree/treeset/TreeSetExample1.java)\n* [TreeSet 객체 정렬하기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/tree/treeset/TreeSetExample2.java)\n* [TreeSet 영어 단어를 정렬하고, 범위 검색해보기 ](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/tree/treeset/TreeSetExample3.java)\n\n#### TreeMap\nTreeMap은 이진 트리를 기반으로 한 Map 컬렉션이다. TreeSet 과의 차이점은 키와 값이 저장된 MapEntry를 저장한다는 점이다. TreeMap에 객체를 저장하면 자동으로 정렬되는데 기본적으로 부모 키값과 비교해서 키값이 낮은 것은 왼쪽 자식 노드에, 키값이 높은 것은 오른쪽 자식 노드에 Map.Entry 객체를 저장한다.\n\n![](https://i.imgur.com/si0KBY0.png)\n\nTreeMap을 생성하기 위해서는 키로 저장할 객체 타입과 값으로 저장할 객체 타입을 타입 파라미터로 주고 기본 생성자를 호출하면 된다.\n```java\nTreeMap<String, Integer> treeMap = new TreeMap<String, Integer>();\n\n```\n| 메소드                 | 설명                                                                    |\n| ------------------- | --------------------------------------------------------------------- |\n| firstEntry()        | 제일 낮은 Map.Entry를 리턴                                                   |\n| lastEntry()         | 제일 높은 Map.Entry를 리턴                                                   |\n| lowerEntry(K key)   | 주어진 키보다 바로 아래 Map.Entry를 리턴                                           |\n| higherEntry(K key)  | 주어진 키보다 바로 위 Map.Entry를 리턴                                            |\n| floorEntry(K key)   | 주어진 키와 동등한 키가 있으면 해당 Map.Entry를 리턴,<br>없다면 주어진 키 바로 아래의 Map.Entry를 리턴 |\n| ceilingEntry(K key) | 주어진 키와 동등한 키가 있으면 해당 Map.Entry를 리턴,<br>없다면 주어진 키 바로 위의 Map.Entry를 리턴  |\n| pollFirstEntry()    | 제일 낮은 Map.Entry를 꺼내오고 컬렉션에서 제거함                                       |\n| pollLastEntry()     | 제일 높은 Map.Entry를 꺼내오고 컬렉션에서 제거함                                       |\n\n다음은 TreeMap 가지고 있는 정렬과 관련된 메소드들이다.\n\n| 리턴 타입             | 메소드                | 설명                                     |\n| ----------------- | ------------------ | -------------------------------------- |\n| NavigableSet<K>   | descendingKeySet() | 내림차순으로 정렬된 키의 NavigableSet을 리턴         |\n| NavigableMap<K,V> | descendingMap()    | 내림차순으로 정렬된 Map.Entry의 NavigableMap을 리턴 |\n\ndescendingMap 메소드를 호출하면 내림차순 NavigableMap타입의 객체를 리턴해주는데 만약 한번 더호출하게되면 오름차순 객체를 리턴한다.\n\n```java\nNavigableMap<K, V> descendingMap = treeMap.descendingMap();\nNavigableMap<K, V> ascendingMap = descendingMap.descendingMap();\n```\n\n| 리턴 타입              | 메소드                                                                    | 설명                                                                                                 |\n| ------------------ | ---------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------- |\n| NavigableMap<K, V> | headMap(k toKey, boolean inclusive)                                    | 주어진 키보다 낮은 Map.Entry들을 NavigableMap으로리턴. 주어진 키의 Map.Entry 포함여부는 두번째 매개 값에 따라 달라짐                   |\n| NavigableMap<K, V> | tailMap(k fromKey, boolean inclusive)                                  | 주어진 객체보다 높은 Map.Entry들을 NavigableMap으로 리턴. 주어진 객체 포함여부는 두번째 매개값에서 따라 달라짐                           |\n| NavigableMap<K, V> | subMap(K fromKey, boolean fromInclusive, K tokey, boolean toInclusive) | 시작과 끝으로 주어진 키 사이의 Map.Entry들을 NavigableMap 컬렉션으로 변환. 시작과 끝 키의 Map.Entry 포함여부는 두번째, 네번째 매개값에 따라 달라짐 |\n\n여기에서 간단하게 SubMap()메소드의 사용방법을 간단히 봐보자. subMap()메소드는 네 개의 매개 변수가 있는데, 시작키와 끝키, 그리고 이 키들의 Map.Entry를 포함할지 여부의 boolean값을 받는다. 이것을 기반으로 그 해당 범위내의 Map을 리턴해준다.\n\n다음은 TreeMap 구조를 이용해 몇가지 기능을 구현한 예제이다.\n\n**예제**\n* [TreeMap 특정 Map.Entry 찾기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/tree/treemap/TreeMapExample1.java)\n* [TreeMap 객체 정렬하기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/tree/treemap/TreeMapExample2.java)\n* [TreeMap 키로 정렬하고 범위 검색하기](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/tree/treemap/TreeMapExample3.java)\n\n#### Comparable과 Compartor\nTreeSet의 객체와 TreeMap의 키는 저장과 동시에 자동 오름차순으로 정렬되는데, 숫자일 경우 값으로 정렬하고, 문자열일 경우에는 유니코드로 정렬한다. TreeSet과 TreeMap은 이진 트리로 크기를 비교해 트리구조를 구성해야 하기 때문에 java.lang.Comparable 인터페이스를 구현해야 쓸 수 있다. 기본적으로 Wrraper Class들은 Comparable 인터페이스가 구현되어 있어 TreeSet과 TreeMap을 사용할 수 있다.\n\n또한 ArrayList 등의 자료구조를 Collection.sort()함수를 사용할때도 Comparable을 이용해 compareTo()메소드만 구현하게되면 쉽게 Collection프레임워크의 자료구조들을 정렬하여 사용할 수 있다. 쉽게 Coparable을 implements를 하여 compareTo()메소드만 정의해주면 된다. 아래의 설명을 참조하여 compareTo()를 재정의해주면된다.\n\n\n| 리턴타임 | 메소드            | 설명                                                                 |\n| ---- | -------------- | ------------------------------------------------------------------ |\n| int  | compareTo(T o) | 주어진 객체와 같으면 0을리턴 <br> 주어진 객체보다 작으면 음수를 리턴 <br>  주어진 객체보다 크면 양수를 리터 |\n\n\n다음은 나이를 기준으로 Person객체를 오름차순으로 정렬하기 위해 Comparable 인터페이스를 구현한것이다. 나이가 적을 경우는 -1을 동일한경우는 0을 클경우는 1을 리턴하도록하여 compareTo() 메소드를 재정의하여 treeSet을 이용하여 유저를 출력하였다. \n\n다음은 **Comparable 예제**이다.\n\n* [Comparable 예제](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/ComparableExample.java)\n\n위에서 말했듯이 TreeSet, TreeMap을 사용할 때의 키가 Comparable을 구현하고 있지 않을 경우에는 저장하는 순간 ClassCastException이 발생한다. 이진 트리를 구성하기 위해서는 값 비교는 필 수이다. 그렇다면 객체에 Comparable 구현체를 구현하는 방법 말고 정렬하는 방법은 없을까... 그 방법은 Comparator 인터페이스다. 그런데 결국에는 둘 다 비슷한 방법이라고 생각한다. 어쨌든 예제를 간단하게 한번 봐보자.\n\n```java\nTreeSet<E> treeSet = new TreeSet<E>(new AscendingComparator());\n\nTreeMap<K,V> treeMap = new TreeMap<K, V> (new DescendingComparator());\n```\n\n정렬자는 Comparator 인터페이스를 구현한 객체를 말하는데, Comparator 인터페이스는 다음과 같이 메소드가 정의되어 있다.\n\n| 리턴 타입 | 메소드                 | 설명                                                                            |\n| ----- | ------------------- | ----------------------------------------------------------------------------- |\n| int   | compare(T o1, T o2) | o1과 o2가 동등하다면 0을리턴<br> o2이 o2보다 앞에 오게하면 음수를 리턴 <br> o1이 o2보다 뒤에 오게 하려면 양수를 리턴 |\n\n다음은 Comparator를 이용하여 과일 객체를 내림차순으로 정렬시키는 **예제**이다.\n* [Compartor 예제](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/ComparatorExample.java)\n\n### LIFO와 FIFO 컬렉션\n\n후입 선출(LIFO : Last In First Out)은 나중에 넣은 객체가 먼저 빠져 나가는 자료구조를 말한다. 반대로 선입 선출(FIFO : First In First Out)은 먼저 넣은 객체가 먼저 빠져나가는 구조를 말한다. 컬렉션 프레임워크에는 LIFO 자료구조를 제공하는 스택(Stack) 클래스와 FIFO 자료구조를 제공하는 (Queue) 인터페이스를 제공하고 있다. 다음은 스택과 큐의 구조를 보여준다.\n![](https://i.imgur.com/QJcADSn.png)\n\n스택을 응용한 대표적인 예가 프로그램들의 함수를 저장하는 공간인 스택공간일 수 가 있다. 스택 메모리에 저장된 변수는 나중에 저장된것부터 저장된다. 큐를 응용한 대표적인 예가 스레드풀의 작업이다. 작업 큐는 먼저 들어온 작업부터 처리한다.\n\n#### Stack\n\nStack 클래스는 LIFO 자료구조를 구현한 클래스이다. 다음은 Stack 클래스의 주요 메소드들이다.\n\n\n| 리턴 타입 | 메소드          | 설명                                   |\n| ----- | ------------ | ------------------------------------ |\n| E     | push(E item) | 주어진 객체를 스택에 넣는다.                     |\n| E     | peek()       | 스택의 맨 위 객체를 가져온다. 객체를 스택에서 제거하지 않는다. |\n| E     | pop()        | 스택의 맨 위 객체를 가져온다. 객체를 스택에서 제거한다.     |\n\nStack을 사용하기위해서는 아래와같이 스택을 생성할때 타입파라미터를 넘기고 기본생성자를 호출하면 된다.\n```java\nStack<E> stack = new Stack<E>();\n```\n\n다음은 택시에서 많이 볼 수 있는 동전케이스를 스택 클래스로 구현한 예제이다. 먼저 넣은 동전은 제일밑에 깔리고 나중에 넣은 동전이 위에 쌓이기 때문에 Stack에서 동전을 빼면 마지막에 넣은 동전이 먼저나오는 예제이다.\n* [Stack 예제](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/stack/StackExample.java)\n\n#### Queue\n\nQueue인터페이스는 FIFO자료구조에서 사용되는 메소드를 정의하고 있다. 다음은 Queue 인터페이스에 정의되어 있는 메소드를 보여준다\n\n\n| 리턴 타입| 메소드 | 설명 |\n| -------- | -------- | -------- |\n| boolean       | offer(E e)       | 주어진 객체를 넣는다.       |\n| E       | peek()       | 객체 하나를 가져온다. 객체를 큐에서 제거하지 않는다.       |\n| E       | poll()       | 객체 하나를 가져온다. 객체를 큐에서 제거한다.       |\n\n\nQueue 인터페이스를 구현한 대표적인 클래스는 LinkedList이다. LinkedList는 List인터페이스를 구현했기 때문에 List 컬렉션이기도 하다. 다음 코드는 LinkedList 객체를 Queue 인터페이스 타입으로 변환한것이다.\n```java\nQueue<E> queue = new LinkedList<E>();\n```\n다음은 Queue를 이용해서 간단한 메시지 큐를 구현한 예제이다. 먼저 넣은 메시지가 반대쪽으로 먼저 나오기 때문에 넣은 순서대로 메시지가 처리 되는 예제이다.\n* [Queue 예제](https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/queue/QueueExample.java)\n\n\n참고 \n* [이것이 자바다](https://book.naver.com/bookdb/book_detail.nhn?bid=8589375)","slug":"2018-07-03-collection","published":1,"updated":"2018-07-03T12:23:21.830Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27f5004cjjpejew0mjkn","content":"<h2><span id=\"시작하며\">시작하며</span></h2>\n<p>컬렉션에 대한 내용을 정리하게 된 계기는 먼저 자바 Collection 만의 API 기능을 효율적으로 사용하기 위해서이다. 다음은 자료구조를 적극적으로 활용하기 위해서이다. 자료구조를 이용하면 훨씬 효율적으로 데이터들을 관리할 수 있고 심지어 코드의 가독성 또한 좋아지기 때문이다. 가독성이 안 좋아지고 복잡함을 증가시키는 IF 문을 피하는 코드를 만드는 것은 아주 효율적인 코딩이라고 생각한다.</p>\n<p>예를 들어, List에 있는 이메일들을 중복 검사한다고 했을 때 단순하게 생각하면 List를 Email 숫자만큼 loop를 돌려 Email을 중복 검사하는 방법이 있을 수 있다. 하지만 HashSet, TreeSet을 이용하면 중복된 값이 저장이 되지 않기 때문에 좀 더 효율적으로 데이터를 관리하고, 소스코드를 깔끔하게 관리할 수 있다.</p>\n<p>또한 다른 예를 들면 여러 개의 이메일에서 특정 이메일을 검색한다고 했을 때 TreeSet 자료구조를 이용하면 트리구조로 데이터가 저장되기 때문에 검색 기능 또한 뛰어나다. 반면 List 같은 경우에는 loop로 하나하나 노드를 검색해서 해당 이메일이 나올 때까지 검색을 해야 하기 때문에 효율적이지 않다. 그러므로 자바에서 효율적인 코딩을 하기 위해서는 Collection 프레임워크를 자세히 알아두는 것은 좋다고 생각한다.</p>\n<p>아래의 내용은 ‘<a href=\"https://book.naver.com/bookdb/book_detail.nhn?bid=8589375\" target=\"_blank\" rel=\"noopener\">이것이 자바다</a>’ 를 보고 컬렉션에 대한 내용을 정리한것이다.</p>\n<h2><span id=\"컬렉션-프레임워크\">컬렉션 프레임워크</span></h2>\n<p>애플리케이션을 개발하다 보면 다수의 객체를 저장해야 하는 경우가 많이 발생한다. 예를 들어 Product 객체를 10개를 저장해야 한다. 어떻게 하면 효율적으로 저장할 수 있을까. 먼저 가장 간단한 배열을 확인해보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//길이 10인 배열생성</span></span><br><span class=\"line\">Product[] array = <span class=\"keyword\">new</span> Product[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//객체추가</span></span><br><span class=\"line\">array[<span class=\"number\">0</span>] = <span class=\"keyword\">new</span> Product(<span class=\"string\">\"Model1\"</span>);</span><br><span class=\"line\">array[<span class=\"number\">1</span>] = <span class=\"keyword\">new</span> Product(<span class=\"string\">\"Model2\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//객체 검색</span></span><br><span class=\"line\">Product model1 = array[<span class=\"number\">0</span>];</span><br><span class=\"line\">Product model2 = array[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//객체 삭제</span></span><br><span class=\"line\">array[<span class=\"number\">0</span>] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">array[<span class=\"number\">1</span>] = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>배열은 쉽게 생성하고 사용할 수 있지만, 저장할 수 있는 객체수가 배열을 생성할 때 결정되기 때문에 불특정 다수의 객체를 저장하기에는 문제가 있다. 물론 배열의 길이를 크게 생성하면 되지만, 이것은 좋은 방법이 아니다. 또 다른 문제는 배열의 객체를 삭제했을 때 해당 인덱스가 비게 되면 아래와 같이 중간중간에 객체가 없는 배열이 된다. 이렇게 되면 객체를 어디에 저장해야 할지 배열 인덱스 하나하나 검색 후 비어있는 공간에 객체를 저장해야 한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>][<span class=\"number\">2</span>][<span class=\"number\">3</span>][<span class=\"number\">4</span>][<span class=\"number\">5</span>][<span class=\"number\">6</span>]</span><br><span class=\"line\"> O  O  X  O  X  O</span><br></pre></td></tr></table></figure>\n<p>자바는 배열의 이러한 문제점을 해결하고, 널리 알려져 있는 자료구조(Data Structre)를 바탕으로 객체들을 효율적으로 추가, 삭제, 검색할수 있도록 Java.util 패키지에 컬렉션과 관련된 인터페이스와 클래스들을 포함시켜 놓았다. 이들을 총칭해서 컬렉션 프레임워크라 한다.</p>\n<p><strong>컬렉션</strong> 이란 사전적 의미로 요소를 수집해서 저장하는 것을 의미하는데, 자바 컬렉션은 객체를 수집해서 저장하는 역할을 한다. 자바 컬렉션 프레임워크는 몇 가지 인터페이스를 통해서 다양한 컬렉션 클래스를 이용할 수 있도록 한다. 컬렉션 프레임워크의 주요 인터페이스로는 List, Set, Map이 있다. 이 인터페이스들은 컬렉션을 사용하는 방법을 정의하는 것인데, 다음은 인터페이스로 사용 가능한 컬렉션 클래스를 보여준다.</p>\n<p><img src=\"https://i.imgur.com/JmO4zX2.png\" alt=\"\"></p>\n<p>List와 Set은 객체 추가, 삭제 검색하는 방법에 많은 공통점이 있기 때문에 이 인터페이스들의 공통된 메소드들만 모아 Collection 인터페이스로 정의해 두고 있다. Map은 키와 값을 하나의 쌍으로 묶어서 관리하는 구조로 되어있어 List및 Set과는 사용방법이 완전히 다르다.</p>\n<table>\n<thead>\n<tr>\n<th>인터페이스 분류</th>\n<th>특징</th>\n<th>구현클래스</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Collection (List)</td>\n<td>- 순서룰유지하고저장<br>- 중복 저장 가능</td>\n<td>ArrayList, Vector, LinkedList</td>\n</tr>\n<tr>\n<td>Collection (Set)</td>\n<td>- 순서를 유지 않고 저장 <br> - 중복 저장 안됨</td>\n<td>HashSet, TreeSet</td>\n</tr>\n<tr>\n<td>Map</td>\n<td>- 키와 값의 쌍으로 저장 <br> - 키는 중복 안 됨</td>\n<td>HashMap,Hashtable,TreeMap, Properties</td>\n</tr>\n</tbody>\n</table>\n<h3><span id=\"list-컬렉션\">List 컬렉션</span></h3>\n<p>List 컬렉션은 객체를 일렬로 늘어놓은 구조를 가지고 있다. 객체를 인덱스로 관리하기 때문에 객체를 저장하면 자동 인덱스가 부여되고 인덱스로 객체를 검색, 삭제할 수 있는 기능을 제공한다.  List 컬렉션에는 ArrayList, Vector, LinkedList 등이 있는데 다음은 List 컬렉션에서 공통적으로 사용 가능한 List 인터페이스의 메소드들이다. 인덱스로 객체를 관리하기 때문에 인덱스를 매게 값으로 갖눈 메소드가 많다.</p>\n<p><strong>객체 추가</strong></p>\n<table>\n<thead>\n<tr>\n<th>메소드</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>boolean add(E e)</td>\n<td>주어진 객체를 맨 끝에 추가</td>\n</tr>\n<tr>\n<td>void add(E e)</td>\n<td>주어진 인덱스에 객체를 추가</td>\n</tr>\n<tr>\n<td>set add(E e)</td>\n<td>주어진 인덱스에 저장된 객체를 주어진 객체로바꿈</td>\n</tr>\n</tbody>\n</table>\n<p><strong>객체 검색</strong></p>\n<table>\n<thead>\n<tr>\n<th>메소드</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>boolean contains(Object o)</td>\n<td>주어진 객체가 저장되어 있는지 여부</td>\n</tr>\n<tr>\n<td>E get(int index)</td>\n<td>주어진 인덱스에 객체를 리턴</td>\n</tr>\n<tr>\n<td>isEmpty()</td>\n<td>컬렉션이 비어있는지 검사</td>\n</tr>\n<tr>\n<td>int size()</td>\n<td>저장되어 있는 전체 객체 수를 리턴</td>\n</tr>\n</tbody>\n</table>\n<p><strong>객체 삭제</strong></p>\n<table>\n<thead>\n<tr>\n<th>메소드</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>void clean()</td>\n<td>저장된 모든 객체를 삭제</td>\n</tr>\n<tr>\n<td>E remove(int index)</td>\n<td>주어진 인덱스에 저장된 객체를 삭제</td>\n</tr>\n<tr>\n<td>boolean remove(Object o)</td>\n<td>주어진 객체를 삭제</td>\n</tr>\n</tbody>\n</table>\n<h4><span id=\"arraylist\">ArrayList</span></h4>\n<p>ArrayList는 List 인터페이스의 구현 클래스로, ArrayList에 객체를 추가하면 객체가 인덱스로 관리된다. 일반배열과 ArrayList는 인덱스로 객체를 관리한다는 점에서는 유사하지만, 큰차이점을 가지고 있다. 배열은 생성할 때 크기가 고정되고, 사용중에 크기를 변경할 수 없지만, ArrayList는 저장 용량을 초과한 객체들이 들어오면 자동적으로 저장용량이 늘어난다. 다음은 ArrayList 객체의 내부 구조를 보여준다.</p>\n<p><img src=\"https://i.imgur.com/M08M97l.png\" alt=\"\"></p>\n<p>검사버튼 삭제버튼 초기에 ArrayList를 선언하면 10개의 객체를 저장할 수 있는 List가 선언이 된다. 만약 초기부터 용량을 크게 선언하고 싶다면 아래와 같이 선언하면 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;(<span class=\"number\">30</span>);</span><br></pre></td></tr></table></figure>\n<p>ArrayList에 객체를 저장하면 인덱스 0 부터 차례대로 저장된다. ArrayList에서 특정 인덱스의 객체를 제거하면 바로 뒤 인덱스부터 마지막 인덱스까지 모두 앞으로 1씩 당겨진다. 마찬가지로 특정 인덱스에 객체를 삽입하면 해당 인덱스부터 마지막 인덱스까지 모두 1씩 밀려난다. 다음은 4번 인덱스가 제거되었을 때 5번 인덱스부터 모두 앞으로 1씩 당겨지는 모습을 보여준다.</p>\n<p><img src=\"https://i.imgur.com/nhg1zDA.png\" alt=\"\"></p>\n<p>위와같이 List안에서 노드가삭제가되면 앞으로 하나하나 다 밀려나야한다. 따라서 빈번한 객체 삭제와 삽입이 일어나나는 곳에서는 ArrayList를 사용하지 않고 삽입삭제에 용이한 LinkedList를 사용하는것이 좋다. 그러나 인덱스 검색이나 마지막 노드추가에서는 ArrayList가 더 좋은 성능을 발휘한다.</p>\n<p>다음예제는 ArrayList에 String 객체를 추가, 검색, 삭제하는방법의 간단한 예제이다.</p>\n<p><strong>예제</strong></p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/tree/master/java-basis-example/src/collection/list/arraylist\" target=\"_blank\" rel=\"noopener\">String 객체를 저장하는 ArrayList</a></li>\n</ul>\n<h4><span id=\"vector\">Vector</span></h4>\n<p>Vector는 ArrayList와 동일한 내부 구조를 가지고 있다. Vector를 생성하기 위해서는 지정할 객체 타입을 타입 파라미터로 표기하고 기본 생성자를 호출하면 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;E&gt; list = <span class=\"keyword\">new</span> Vector&lt;E&gt;();</span><br></pre></td></tr></table></figure>\n<p>ArrayList와 다른점은 Vector는 동기화된 메소드로 구성되어 있기 때문에 멀티 스레드가 동시에 이 메소드들을 실행할 수 없고, 하나의 스레드가 실행을 완료해야만 다른 스레드가 실행할 수 있다. 그래서 멀티 스레드 환경에서 안전하게 객체를 추가, 삭제할 수 있다.</p>\n<p>다음은 Vector를 이용해서 객체를 추가, 삭제, 검색하는 예제이다.</p>\n<p><strong>예제</strong></p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/tree/master/java-basis-example/src/collection/list/vector\" target=\"_blank\" rel=\"noopener\">객체 저장, 삭제</a></li>\n</ul>\n<h4><span id=\"linkedlist\">LinkedList</span></h4>\n<p>LinkedList는 List 구현 클래스이므로 ArrayList와 사용방법은 똑같지만 내부 구조는 완전 다르다. ArrayList는 내부 배열 객체를 저장해서 인덱스로 관리하지만, LinkedList는 인접 참조를 링크해서 체인처럼 관리한다.</p>\n<p><img src=\"https://i.imgur.com/09ZGkA7.png\" alt=\"\"></p>\n<p>LinkedList에서 특정 인덱스의 객체를 제거하면 앞뒤 링크만 변경되고 나머지 링크는 변경되지 않는다. 특정 인덱스에 객체를 삽입할 때에도 마찬가지다. 그렇기 때문에 빈번한 객체를 삭제할 때는 LinkedList가 성능이 좋다. 왜냐 중간에서 하나 삭제를 하더라도 앞뒤의 노드만 연결해주면 되기 때문이다.<br>\nLinkedList는 생성하기 위해서는 저장할 객체 타입 파라미터(E)에 표기하고 기본 생성자로 호출하면 된다. 기본적으로 LinkedList는 처음 생성될 때에는 어떤한 링크도 만들어지지 않기 때문에 내부적으로 비어있다. 아래와 같이 생성할 수 있겠다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;E&gt; list = <span class=\"keyword\">new</span> LinkedList&lt;E&gt;();</span><br></pre></td></tr></table></figure>\n<p>다음 예제는 ArrayList와 LinkedList에 10000개의 객체를 삽입하는데 걸릴시간을 측정하는 예제이다. 누가 더 많은 시간이 걸리는지에 대한 예제이다.</p>\n<p><strong>예제</strong></p>\n<p><a href=\"https://github.com/minwan1/blog-example/tree/master/java-basis-example/src/collection/list/linkedlist\" target=\"_blank\" rel=\"noopener\">ArrayList와 LinkedList의 실행 성능 비교</a></p>\n<h3><span id=\"set-컬렉션\">Set 컬렉션</span></h3>\n<p>List 컬렉션은 저장 순서를 유지하지만, Set 컬렉션은 저장 순서가 유지되지 않는다. 또한 객체를 중복해서 저장할 수 없다. 하나의 null만 저장할 수 있다. Set 컬렉션은 수학의 집합에 비유될 수 있다. 집합은 순서와 상관없고 중복이 허용되지 않기 때문이다.</p>\n<p>Set 컬렉션에는 HashSet, LinkedHashSet, TreeSet등이 있는데, 다음은 Set 컬렉션에 공통적으로 사용 가능한 Set 인터페이스의 메소드들이다.</p>\n<p><img src=\"https://i.imgur.com/ZByMxEo.png\" alt=\"\"><br>\nSet 컬렉션은 인덱스로 객체를 검색해서 가져오는 메소드가 없다. 대신 전체 객체를 대상으로 한번씩 반복해서 가져오는 반복자(Iterator)를 제공한다. 반복자는 Iterator 인터페이스를 구현한 객체를 말하는데, itorator() 메소드를 호출하면 얻을 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Set&lt;String&gt; set = ...;</span><br><span class=\"line\">Iterator&lt;String&gt; iterator = set.iterator();</span><br></pre></td></tr></table></figure>\n<p>다음은 Iterator 인터페이스에 선언된 메소드들이다.</p>\n<table>\n<thead>\n<tr>\n<th>리턴 타입</th>\n<th>메소드명</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>boolean</td>\n<td>hasNext()</td>\n<td>가져올 객체가 있으면 true를 리턴하고 없으면 false를 리턴한다.</td>\n</tr>\n<tr>\n<td>E</td>\n<td>next()</td>\n<td>컬렉션에서 하나의 객체를 가져온다</td>\n</tr>\n<tr>\n<td>void</td>\n<td>remove()</td>\n<td>Set 컬렉션에서 객체를 제거한다.</td>\n</tr>\n</tbody>\n</table>\n<p>Iterator에서 하나의 객체를 가져올 때는 next() 메소드를 사용한다. next() 메소드를 사용하기전에 먼저 가져올 객체가 있는지 확인하는것이 좋다. hasNext() 메소드는 가져올 객체가 있으면 true를 리턴하고 더이상 가져올 객체가 없으면 false를 리턴한다. 따라서 true가 리턴될때 next() 메소드를 사용해야한다. 다음은 Set을 이용한 루핑 방법이다.</p>\n<p>방법 1. Iterator를 사용한벙법</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Set&lt;String&gt; set = ...;</span><br><span class=\"line\">Iterator&lt;String&gt; iterator = set.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(iterator.hasNext())&#123; <span class=\"comment\">// has가 다음 객체가있는지 체크해주니까 있는 만큼 루핑된다.</span></span><br><span class=\"line\">  String str = iterator.next();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>방법 2. For문 사용</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(String str : set)&#123; <span class=\"comment\">// 저장된 객체수만큼 루핑한다.</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4><span id=\"hashset\">HashSet</span></h4>\n<p>HashSet은 Set 인터페이스의 구현클래스이다. HashSet을 생성하기 위해서는 다음과 같이 기본생성자를 호출하면 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Set&lt;E&gt; set = <span class=\"keyword\">new</span> HashSet&lt;E&gt;();</span><br></pre></td></tr></table></figure>\n<p>HashSet은 Set의 성격대로 순서상관없이 저장되고, 중복 저장되지 않는다. HashSet이 판단하는 동일한 객체란 꼭 같은 인스턴스를 뜻하지 않는다. HashSet은 객체를 저장하기전에 먼저 객체의 HashCode()메소드를 호출해서 해시코드를 얻는다. 그리고 이미 저장되어 있는 객체의 hashCode() 메소드를 호출해서 해시코드를 얻어낸다. 그리고 이미저장되어 있는 객체들의 해시코드와 비교 한다. 만약 equals()메소드로 두 객체를 비교해서 true가 나오면 동일한 객체로 판단하고 중복 저장을 하지 않는다.</p>\n<p><img src=\"https://i.imgur.com/re05jjk.png\" alt=\"\"></p>\n<p>문자열을 HashSet에 저장할 경우, 깊은 문자열을 갖는 String 객체는 동등한 객체로 간주되고 다른 문자열을 갖는 String 객체는 다른 객체로 간주되는데, 그 이유는 String 클래스가 hashCode()와 equals() 메소드를 재정의해서 같은 문자열일 경우 hashCode()의 리턴값을 같게, equals()의 리턴값은 true가 나오도록 오버라이딩이 되있기 때문이다. 물론 자신이 정의 한 클래스에도 똑같이 적용할 수 있다.</p>\n<p>예를 들어 Member 클래스를 정의했다고 가정하자. 이 MemberClass에는 인스턴스가 달라도 이름과 나이가 동일하다면 동등 객체라고 equals()와 hashCode를 정의했다고 치자. 그리고 아래와 같이 Set에 객체를 넣는다고 해보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Set&lt;Member&gt; set = <span class=\"keyword\">new</span> HashSet&lt;Member&gt;();</span><br><span class=\"line\">set.add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"홍길동\"</span>, <span class=\"number\">30</span>));</span><br><span class=\"line\">set.add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"홍길동\"</span>, <span class=\"number\">30</span>));</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"총 객체수 : \"</span> + set.size()); 저장된 객체 수 얻기 <span class=\"comment\">// 사이즈 1</span></span><br></pre></td></tr></table></figure>\n<p>위와같이 Set에 이름과 나이가 같은 객체를 두개 넣더라도 실제적으로 set에는 1개의 객체만 들어가게 된다.</p>\n<p>다음은 HashSet을 이용해 앞에서 간단한 Hashse에대한 기능을 확인하는 예제이다.</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/tree/master/java-basis-example/src/collection/set\" target=\"_blank\" rel=\"noopener\">String 객체를 중복없이 저장하는 HashSet</a></li>\n<li><a href=\"https://github.com/minwan1/blog-example/tree/master/java-basis-example/src/collection/set\" target=\"_blank\" rel=\"noopener\">Member 객체를 정보없이 저장하는 HashSet</a></li>\n</ul>\n<h3><span id=\"map-컬렉션\">Map 컬렉션</span></h3>\n<p>Map 컬렉션은 키(Key)와 값(value으로 구성된 Entry 객체를 저장하는 구조를 가지고 있다. 여기서 키와 값은 모두 객체이다. 키는 중복 저장될 수 없지만 값은 중복 저장될 수 있다. 키값이 중복되어 저장된다면 먼저 저장된 값은 저장되지 않는다.<br>\n<img src=\"https://i.imgur.com/TI9n5UB.png\" alt=\"\"></p>\n<p>Map 컬렉션에는 HashMap, Hashtable, LinkedHashMap, Properties, TreeMap 등이 있다. 다음은 Map컬렉션에서 공통적으로 사용가능한 Map 인터페이스의 메소드들이다. 키로 객체들을 관리하기때문에 키를 매개값으로 갖는 메소드가 많다.<br>\n<img src=\"https://i.imgur.com/zCuSUsB.png\" alt=\"\"></p>\n<p>Map에서는 키를 알고 싶다면 get() 메소 도로 객체를 얻어낼 수 있다. 하지만 맵 안에 데이터를 하나하나 얻어 내고 싶다면 두 가지 방법이 있다. 먼저 아래는 Key를 Set 타입으로 뽑아서 하나하나 Iterator 시켜 그 key 값으로 value를 얻는 방법이 있을 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;String, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> Set&lt;String&gt; strings = map.keySet();</span><br><span class=\"line\"><span class=\"keyword\">final</span> Iterator&lt;String&gt; iterator = strings.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(iterator.hasNext())&#123;</span><br><span class=\"line\">    String key = iterator.next();</span><br><span class=\"line\">    String value = map.get(key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>두 번째 방법은 entrySet을 통해 Entry객체를 Set타입으로 뽑아서 key와 value를 동시에 얻는 방법이 있을 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;String, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class=\"line\"><span class=\"keyword\">final</span> Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = entries.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(iterator.hasNext())&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Map.Entry&lt;String, String&gt; mapEntry = iterator.next();</span><br><span class=\"line\">    mapEntry.getKey();</span><br><span class=\"line\">    mapEntry.getValue()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4><span id=\"hashmap\">HashMap</span></h4>\n<p>HashMap의 키로 사용할 객체는 HashCode와 equals()메소드를 재정의해서 동등객체가 될조건을 정해야한다. 동등 객체, 즉 동일한 키가 될 조건은 hashCode()의 리턴값이 같아야하고, equals()메소드가 true를 리턴해야한다. 동등 객체, 즉 동일한 키가 될 조건은 hashCoDE()의 리턴값이 같아야하고 equals()메소드가 true를 리턴해야 한다.</p>\n<p>주로 키 타입으로 String을 많이사용하는데 String은 글자가 다르면 hashCode, equals 메소드가 다르도록 재정의가 되있기때문에 키로 적합하다. 해쉬맵은 아래와같이 키타입과 value 타입을 파라미터로 주고 기본 생성자로 선언할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;K, V&gt; map = <span class=\"keyword\">new</span> HashMap&lt;K, V&gt;();</span><br></pre></td></tr></table></figure>\n<p><strong>예제</strong></p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/map/hashmap/HashMapExample1.java\" target=\"_blank\" rel=\"noopener\">이름을 키로 점수를 값으로 저장하기</a></li>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/map/hashmap/HashMapExample2.java\" target=\"_blank\" rel=\"noopener\">학번과 이름이 동일한 경우 같은 키로 인식</a></li>\n</ul>\n<h4><span id=\"hashtable\">Hashtable</span></h4>\n<p>Hashtable은 HashMap과 동일한 내부구조를 가진다. HashMap과 차이점은 Hashtable은 동기화된(synchronized)메소드로 구성되어 있기때문에 멀티스레드가 동시에 이 메소드들을 실행할 수 는 없고, 하나의 스레드가 실행을 완료해야만 다른 스레드를 실행할 수 있다.</p>\n<p>다음은 Hash테이블을 이용해 키보드로 아이디와 비밀번호를 입력받아서 패스워드 인증 기능을 구현하는 예제이다.</p>\n<p><strong>예제</strong></p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/map/hashtable/HashtableExample.java\" target=\"_blank\" rel=\"noopener\">아이디와 비밀번호 검사하기</a></li>\n</ul>\n<h4><span id=\"properties\">Properties</span></h4>\n<p>Properties는 Hashtable의 하위 클래스이기 때문에 HashTable의 모든 특징을 그대로 가지고 있다. Hashtable은 키와 값을 다양한 타입으로 지정이 가능한데 비해 Properties는 키와 값을 String 타입으로 제한한 컬렉션이다. Properties는 애플리케이션의 옵션정보, 데이터베이스 연결 정보 그리고 국제화(다국어) 정보가 저장된 프로퍼티(~.properties) 파일을 읽을 때 주로 사용한다.</p>\n<p>프로퍼티 파일은 키와 값이 = 기호로 연결되어 있는 텍스트 파일로 ISO 8859-1문자셋으로 저장된다. 이 문자셋으로 직접 표현할 수 없는 한글은 유니코드로 변환되어 저장된다.</p>\n<h3><span id=\"검색-기능을-강화시킨-컬렉션\">검색 기능을 강화시킨 컬렉션</span></h3>\n<p>컬렉션 프레임워크는 검색 기능을 강화시킨 TreeSet과 TreeMap을 제공하고 있다. 이름에서 알 수 있듯이 TreeSet은 Set 컬렉션이고, TreeMap은 Map 컬렉션이다. 이 컬렉션들은 이진 트리를 이용해서 계층적(Tree 구조)를 가지면서 객체를 저장한다.</p>\n<h4><span id=\"이진-트린-구조\">이진 트린 구조</span></h4>\n<p>이진 트리는 여러 개의 노드가 트리 형태로 이루어진 연결된 구조로, 루트 노드라고 불리는 하나의 노드에서부터 시작해서 각 노드에 최대 2개의 노드를 연결할 수 있는 구조를 가지고 있다.</p>\n<p><img src=\"https://i.imgur.com/SnTiRL0.png\" alt=\"\"></p>\n<p>위 아래로 연결된 두 노드를 부모 - 자식 관계에 있다고 하며 위의 노드를 부모 노드, 아래 노드를 자식 노드라고 한다. 하나의 노드는 최대 2개의 자식 노드와 연결될 수 있다. 이진 트리는 부모 노드의 값보다 작은 노드는 왼쪽에 위치시키고, 부모 노드의 값보다 큰 노드는 오른쪽에 위치시킨다. 예를 들어 6,3,9,2,5의 순서로 값을 저장하면 다음과 같은 순서로 진행된다.</p>\n<p><img src=\"https://i.imgur.com/vmcODcJ.png\" alt=\"\"></p>\n<p>작은값은 왼쪽에, 큰값은 오른쪽에 저장한다. 숫자가 아닌 문자가 저장할경우네느 문자의 유니코드 값으로 비교한다. 이진 트리가 범위 검색을 쉽게할 수 있는 이유는 아래와 같이 값들이 정렬되어 있어 그룹핑이 쉽기 때문이다.</p>\n<p><img src=\"https://i.imgur.com/dt6exaV.png\" alt=\"\"></p>\n<h4><span id=\"treeset\">TreeSet</span></h4>\n<p>TreeSet은 이진 트리를 기반으로 한 Set 컬렉션이다. 하나의 노드는 노드 값인 value와 왼쪽과 자식 노드를 참조하기 위한 두 개의 변수로 구성된다. TreeSet에 객체를 저장하면 자동으로 정렬되는데 부모 값과 비교해서 낮은 것은 왼쪽 자식 노드에, 높은 것은 오른쪽 자식 노드에 저장한다.<br>\n<img src=\"https://i.imgur.com/1tD53qf.png\" alt=\"\"></p>\n<p>TreeSet을 생성하기 위해서는 저장할 객체 타입을 파라미터로 표기하고 기본 생성자를 호출하면 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">TreeSet&lt;E&gt; treeSet = <span class=\"keyword\">new</span> TreeSet&lt;E&gt;();</span><br></pre></td></tr></table></figure>\n<p>Set 인터페이스 타입 변수에 대입해도 되지만 TreeSet클래스 타입으로 대입한 이유는 객체를 찾거나 범위 검색과 관련된 메소드를 사용하기 위해서이다. 다음은 TreeSet이 가지고있는 검색 관련된 메소드들이다.</p>\n<table>\n<thead>\n<tr>\n<th>메소드</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>first()</td>\n<td>제일 낮은 객체를 리턴</td>\n</tr>\n<tr>\n<td>last()</td>\n<td>제일 높은 객체를 리턴</td>\n</tr>\n<tr>\n<td>lower(E e)</td>\n<td>주어진 객체보다 바로 아래 객체를 리턴</td>\n</tr>\n<tr>\n<td>higher(E e)</td>\n<td>주어진 객체보다 바로 위 객체를 리턴</td>\n</tr>\n<tr>\n<td>floor(E e)</td>\n<td>주어진 객체와 동등한 객체가 있으면 리턴 . 만약 없다면 주어진 객체의 바로 위의 객체를 리턴</td>\n</tr>\n<tr>\n<td>celling(E e)</td>\n<td>주어진 객체와 동등한 객체가 있으면 리턴, 만약 없다면 주어진 객체의 바로 위의 객체를 리턴</td>\n</tr>\n<tr>\n<td>pollFirst()</td>\n<td>제일 낮은 객체를 꺼내오고 컬렉션에서 제거함</td>\n</tr>\n<tr>\n<td>pollLast()</td>\n<td>제일 높은 객체를 꺼내오고 컬렉션에서 제거함</td>\n</tr>\n</tbody>\n</table>\n<p>다음은 TreeSet을 이용해 몇가지 기능을 구현해보는 예제이다.</p>\n<p><strong>예제</strong></p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/tree/treeset/TreeSetExample1.java\" target=\"_blank\" rel=\"noopener\">TreeSet 특정 객체 찾기</a></li>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/tree/treeset/TreeSetExample2.java\" target=\"_blank\" rel=\"noopener\">TreeSet 객체 정렬하기</a></li>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/tree/treeset/TreeSetExample3.java\" target=\"_blank\" rel=\"noopener\">TreeSet 영어 단어를 정렬하고, 범위 검색해보기 </a></li>\n</ul>\n<h4><span id=\"treemap\">TreeMap</span></h4>\n<p>TreeMap은 이진 트리를 기반으로 한 Map 컬렉션이다. TreeSet 과의 차이점은 키와 값이 저장된 MapEntry를 저장한다는 점이다. TreeMap에 객체를 저장하면 자동으로 정렬되는데 기본적으로 부모 키값과 비교해서 키값이 낮은 것은 왼쪽 자식 노드에, 키값이 높은 것은 오른쪽 자식 노드에 Map.Entry 객체를 저장한다.</p>\n<p><img src=\"https://i.imgur.com/si0KBY0.png\" alt=\"\"></p>\n<p>TreeMap을 생성하기 위해서는 키로 저장할 객체 타입과 값으로 저장할 객체 타입을 타입 파라미터로 주고 기본 생성자를 호출하면 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">TreeMap&lt;String, Integer&gt; treeMap = <span class=\"keyword\">new</span> TreeMap&lt;String, Integer&gt;();</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>메소드</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>firstEntry()</td>\n<td>제일 낮은 Map.Entry를 리턴</td>\n</tr>\n<tr>\n<td>lastEntry()</td>\n<td>제일 높은 Map.Entry를 리턴</td>\n</tr>\n<tr>\n<td>lowerEntry(K key)</td>\n<td>주어진 키보다 바로 아래 Map.Entry를 리턴</td>\n</tr>\n<tr>\n<td>higherEntry(K key)</td>\n<td>주어진 키보다 바로 위 Map.Entry를 리턴</td>\n</tr>\n<tr>\n<td>floorEntry(K key)</td>\n<td>주어진 키와 동등한 키가 있으면 해당 Map.Entry를 리턴,<br>없다면 주어진 키 바로 아래의 Map.Entry를 리턴</td>\n</tr>\n<tr>\n<td>ceilingEntry(K key)</td>\n<td>주어진 키와 동등한 키가 있으면 해당 Map.Entry를 리턴,<br>없다면 주어진 키 바로 위의 Map.Entry를 리턴</td>\n</tr>\n<tr>\n<td>pollFirstEntry()</td>\n<td>제일 낮은 Map.Entry를 꺼내오고 컬렉션에서 제거함</td>\n</tr>\n<tr>\n<td>pollLastEntry()</td>\n<td>제일 높은 Map.Entry를 꺼내오고 컬렉션에서 제거함</td>\n</tr>\n</tbody>\n</table>\n<p>다음은 TreeMap 가지고 있는 정렬과 관련된 메소드들이다.</p>\n<table>\n<thead>\n<tr>\n<th>리턴 타입</th>\n<th>메소드</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NavigableSet<k></k></td>\n<td>descendingKeySet()</td>\n<td>내림차순으로 정렬된 키의 NavigableSet을 리턴</td>\n</tr>\n<tr>\n<td>NavigableMap&lt;K,V&gt;</td>\n<td>descendingMap()</td>\n<td>내림차순으로 정렬된 Map.Entry의 NavigableMap을 리턴</td>\n</tr>\n</tbody>\n</table>\n<p>descendingMap 메소드를 호출하면 내림차순 NavigableMap타입의 객체를 리턴해주는데 만약 한번 더호출하게되면 오름차순 객체를 리턴한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">NavigableMap&lt;K, V&gt; descendingMap = treeMap.descendingMap();</span><br><span class=\"line\">NavigableMap&lt;K, V&gt; ascendingMap = descendingMap.descendingMap();</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>리턴 타입</th>\n<th>메소드</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NavigableMap&lt;K, V&gt;</td>\n<td>headMap(k toKey, boolean inclusive)</td>\n<td>주어진 키보다 낮은 Map.Entry들을 NavigableMap으로리턴. 주어진 키의 Map.Entry 포함여부는 두번째 매개 값에 따라 달라짐</td>\n</tr>\n<tr>\n<td>NavigableMap&lt;K, V&gt;</td>\n<td>tailMap(k fromKey, boolean inclusive)</td>\n<td>주어진 객체보다 높은 Map.Entry들을 NavigableMap으로 리턴. 주어진 객체 포함여부는 두번째 매개값에서 따라 달라짐</td>\n</tr>\n<tr>\n<td>NavigableMap&lt;K, V&gt;</td>\n<td>subMap(K fromKey, boolean fromInclusive, K tokey, boolean toInclusive)</td>\n<td>시작과 끝으로 주어진 키 사이의 Map.Entry들을 NavigableMap 컬렉션으로 변환. 시작과 끝 키의 Map.Entry 포함여부는 두번째, 네번째 매개값에 따라 달라짐</td>\n</tr>\n</tbody>\n</table>\n<p>여기에서 간단하게 SubMap()메소드의 사용방법을 간단히 봐보자. subMap()메소드는 네 개의 매개 변수가 있는데, 시작키와 끝키, 그리고 이 키들의 Map.Entry를 포함할지 여부의 boolean값을 받는다. 이것을 기반으로 그 해당 범위내의 Map을 리턴해준다.</p>\n<p>다음은 TreeMap 구조를 이용해 몇가지 기능을 구현한 예제이다.</p>\n<p><strong>예제</strong></p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/tree/treemap/TreeMapExample1.java\" target=\"_blank\" rel=\"noopener\">TreeMap 특정 Map.Entry 찾기</a></li>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/tree/treemap/TreeMapExample2.java\" target=\"_blank\" rel=\"noopener\">TreeMap 객체 정렬하기</a></li>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/tree/treemap/TreeMapExample3.java\" target=\"_blank\" rel=\"noopener\">TreeMap 키로 정렬하고 범위 검색하기</a></li>\n</ul>\n<h4><span id=\"comparable과-compartor\">Comparable과 Compartor</span></h4>\n<p>TreeSet의 객체와 TreeMap의 키는 저장과 동시에 자동 오름차순으로 정렬되는데, 숫자일 경우 값으로 정렬하고, 문자열일 경우에는 유니코드로 정렬한다. TreeSet과 TreeMap은 이진 트리로 크기를 비교해 트리구조를 구성해야 하기 때문에 java.lang.Comparable 인터페이스를 구현해야 쓸 수 있다. 기본적으로 Wrraper Class들은 Comparable 인터페이스가 구현되어 있어 TreeSet과 TreeMap을 사용할 수 있다.</p>\n<p>또한 ArrayList 등의 자료구조를 Collection.sort()함수를 사용할때도 Comparable을 이용해 compareTo()메소드만 구현하게되면 쉽게 Collection프레임워크의 자료구조들을 정렬하여 사용할 수 있다. 쉽게 Coparable을 implements를 하여 compareTo()메소드만 정의해주면 된다. 아래의 설명을 참조하여 compareTo()를 재정의해주면된다.</p>\n<table>\n<thead>\n<tr>\n<th>리턴타임</th>\n<th>메소드</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>int</td>\n<td>compareTo(T o)</td>\n<td>주어진 객체와 같으면 0을리턴 <br> 주어진 객체보다 작으면 음수를 리턴 <br>  주어진 객체보다 크면 양수를 리터</td>\n</tr>\n</tbody>\n</table>\n<p>다음은 나이를 기준으로 Person객체를 오름차순으로 정렬하기 위해 Comparable 인터페이스를 구현한것이다. 나이가 적을 경우는 -1을 동일한경우는 0을 클경우는 1을 리턴하도록하여 compareTo() 메소드를 재정의하여 treeSet을 이용하여 유저를 출력하였다.</p>\n<p>다음은 <strong>Comparable 예제</strong>이다.</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/ComparableExample.java\" target=\"_blank\" rel=\"noopener\">Comparable 예제</a></li>\n</ul>\n<p>위에서 말했듯이 TreeSet, TreeMap을 사용할 때의 키가 Comparable을 구현하고 있지 않을 경우에는 저장하는 순간 ClassCastException이 발생한다. 이진 트리를 구성하기 위해서는 값 비교는 필 수이다. 그렇다면 객체에 Comparable 구현체를 구현하는 방법 말고 정렬하는 방법은 없을까… 그 방법은 Comparator 인터페이스다. 그런데 결국에는 둘 다 비슷한 방법이라고 생각한다. 어쨌든 예제를 간단하게 한번 봐보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">TreeSet&lt;E&gt; treeSet = <span class=\"keyword\">new</span> TreeSet&lt;E&gt;(<span class=\"keyword\">new</span> AscendingComparator());</span><br><span class=\"line\"></span><br><span class=\"line\">TreeMap&lt;K,V&gt; treeMap = <span class=\"keyword\">new</span> TreeMap&lt;K, V&gt; (<span class=\"keyword\">new</span> DescendingComparator());</span><br></pre></td></tr></table></figure>\n<p>정렬자는 Comparator 인터페이스를 구현한 객체를 말하는데, Comparator 인터페이스는 다음과 같이 메소드가 정의되어 있다.</p>\n<table>\n<thead>\n<tr>\n<th>리턴 타입</th>\n<th>메소드</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>int</td>\n<td>compare(T o1, T o2)</td>\n<td>o1과 o2가 동등하다면 0을리턴<br> o2이 o2보다 앞에 오게하면 음수를 리턴 <br> o1이 o2보다 뒤에 오게 하려면 양수를 리턴</td>\n</tr>\n</tbody>\n</table>\n<p>다음은 Comparator를 이용하여 과일 객체를 내림차순으로 정렬시키는 <strong>예제</strong>이다.</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/ComparatorExample.java\" target=\"_blank\" rel=\"noopener\">Compartor 예제</a></li>\n</ul>\n<h3><span id=\"lifo와-fifo-컬렉션\">LIFO와 FIFO 컬렉션</span></h3>\n<p>후입 선출(LIFO : Last In First Out)은 나중에 넣은 객체가 먼저 빠져 나가는 자료구조를 말한다. 반대로 선입 선출(FIFO : First In First Out)은 먼저 넣은 객체가 먼저 빠져나가는 구조를 말한다. 컬렉션 프레임워크에는 LIFO 자료구조를 제공하는 스택(Stack) 클래스와 FIFO 자료구조를 제공하는 (Queue) 인터페이스를 제공하고 있다. 다음은 스택과 큐의 구조를 보여준다.<br>\n<img src=\"https://i.imgur.com/QJcADSn.png\" alt=\"\"></p>\n<p>스택을 응용한 대표적인 예가 프로그램들의 함수를 저장하는 공간인 스택공간일 수 가 있다. 스택 메모리에 저장된 변수는 나중에 저장된것부터 저장된다. 큐를 응용한 대표적인 예가 스레드풀의 작업이다. 작업 큐는 먼저 들어온 작업부터 처리한다.</p>\n<h4><span id=\"stack\">Stack</span></h4>\n<p>Stack 클래스는 LIFO 자료구조를 구현한 클래스이다. 다음은 Stack 클래스의 주요 메소드들이다.</p>\n<table>\n<thead>\n<tr>\n<th>리턴 타입</th>\n<th>메소드</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>E</td>\n<td>push(E item)</td>\n<td>주어진 객체를 스택에 넣는다.</td>\n</tr>\n<tr>\n<td>E</td>\n<td>peek()</td>\n<td>스택의 맨 위 객체를 가져온다. 객체를 스택에서 제거하지 않는다.</td>\n</tr>\n<tr>\n<td>E</td>\n<td>pop()</td>\n<td>스택의 맨 위 객체를 가져온다. 객체를 스택에서 제거한다.</td>\n</tr>\n</tbody>\n</table>\n<p>Stack을 사용하기위해서는 아래와같이 스택을 생성할때 타입파라미터를 넘기고 기본생성자를 호출하면 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stack&lt;E&gt; stack = <span class=\"keyword\">new</span> Stack&lt;E&gt;();</span><br></pre></td></tr></table></figure>\n<p>다음은 택시에서 많이 볼 수 있는 동전케이스를 스택 클래스로 구현한 예제이다. 먼저 넣은 동전은 제일밑에 깔리고 나중에 넣은 동전이 위에 쌓이기 때문에 Stack에서 동전을 빼면 마지막에 넣은 동전이 먼저나오는 예제이다.</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/stack/StackExample.java\" target=\"_blank\" rel=\"noopener\">Stack 예제</a></li>\n</ul>\n<h4><span id=\"queue\">Queue</span></h4>\n<p>Queue인터페이스는 FIFO자료구조에서 사용되는 메소드를 정의하고 있다. 다음은 Queue 인터페이스에 정의되어 있는 메소드를 보여준다</p>\n<table>\n<thead>\n<tr>\n<th>리턴 타입</th>\n<th>메소드</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>boolean</td>\n<td>offer(E e)</td>\n<td>주어진 객체를 넣는다.</td>\n</tr>\n<tr>\n<td>E</td>\n<td>peek()</td>\n<td>객체 하나를 가져온다. 객체를 큐에서 제거하지 않는다.</td>\n</tr>\n<tr>\n<td>E</td>\n<td>poll()</td>\n<td>객체 하나를 가져온다. 객체를 큐에서 제거한다.</td>\n</tr>\n</tbody>\n</table>\n<p>Queue 인터페이스를 구현한 대표적인 클래스는 LinkedList이다. LinkedList는 List인터페이스를 구현했기 때문에 List 컬렉션이기도 하다. 다음 코드는 LinkedList 객체를 Queue 인터페이스 타입으로 변환한것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Queue&lt;E&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;E&gt;();</span><br></pre></td></tr></table></figure>\n<p>다음은 Queue를 이용해서 간단한 메시지 큐를 구현한 예제이다. 먼저 넣은 메시지가 반대쪽으로 먼저 나오기 때문에 넣은 순서대로 메시지가 처리 되는 예제이다.</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/queue/QueueExample.java\" target=\"_blank\" rel=\"noopener\">Queue 예제</a></li>\n</ul>\n<p>참고</p>\n<ul>\n<li><a href=\"https://book.naver.com/bookdb/book_detail.nhn?bid=8589375\" target=\"_blank\" rel=\"noopener\">이것이 자바다</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>시작하며</h2>\n<p>컬렉션에 대한 내용을 정리하게 된 계기는 먼저 자바 Collection 만의 API 기능을 효율적으로 사용하기 위해서이다. 다음은 자료구조를 적극적으로 활용하기 위해서이다. 자료구조를 이용하면 훨씬 효율적으로 데이터들을 관리할 수 있고 심지어 코드의 가독성 또한 좋아지기 때문이다. 가독성이 안 좋아지고 복잡함을 증가시키는 IF 문을 피하는 코드를 만드는 것은 아주 효율적인 코딩이라고 생각한다.</p>\n<p>예를 들어, List에 있는 이메일들을 중복 검사한다고 했을 때 단순하게 생각하면 List를 Email 숫자만큼 loop를 돌려 Email을 중복 검사하는 방법이 있을 수 있다. 하지만 HashSet, TreeSet을 이용하면 중복된 값이 저장이 되지 않기 때문에 좀 더 효율적으로 데이터를 관리하고, 소스코드를 깔끔하게 관리할 수 있다.</p>\n<p>또한 다른 예를 들면 여러 개의 이메일에서 특정 이메일을 검색한다고 했을 때 TreeSet 자료구조를 이용하면 트리구조로 데이터가 저장되기 때문에 검색 기능 또한 뛰어나다. 반면 List 같은 경우에는 loop로 하나하나 노드를 검색해서 해당 이메일이 나올 때까지 검색을 해야 하기 때문에 효율적이지 않다. 그러므로 자바에서 효율적인 코딩을 하기 위해서는 Collection 프레임워크를 자세히 알아두는 것은 좋다고 생각한다.</p>\n<p>아래의 내용은 ‘<a href=\"https://book.naver.com/bookdb/book_detail.nhn?bid=8589375\" target=\"_blank\" rel=\"noopener\">이것이 자바다</a>’ 를 보고 컬렉션에 대한 내용을 정리한것이다.</p>\n<h2>컬렉션 프레임워크</h2>\n<p>애플리케이션을 개발하다 보면 다수의 객체를 저장해야 하는 경우가 많이 발생한다. 예를 들어 Product 객체를 10개를 저장해야 한다. 어떻게 하면 효율적으로 저장할 수 있을까. 먼저 가장 간단한 배열을 확인해보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//길이 10인 배열생성</span></span><br><span class=\"line\">Product[] array = <span class=\"keyword\">new</span> Product[<span class=\"number\">10</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//객체추가</span></span><br><span class=\"line\">array[<span class=\"number\">0</span>] = <span class=\"keyword\">new</span> Product(<span class=\"string\">\"Model1\"</span>);</span><br><span class=\"line\">array[<span class=\"number\">1</span>] = <span class=\"keyword\">new</span> Product(<span class=\"string\">\"Model2\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//객체 검색</span></span><br><span class=\"line\">Product model1 = array[<span class=\"number\">0</span>];</span><br><span class=\"line\">Product model2 = array[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//객체 삭제</span></span><br><span class=\"line\">array[<span class=\"number\">0</span>] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">array[<span class=\"number\">1</span>] = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n<p>배열은 쉽게 생성하고 사용할 수 있지만, 저장할 수 있는 객체수가 배열을 생성할 때 결정되기 때문에 불특정 다수의 객체를 저장하기에는 문제가 있다. 물론 배열의 길이를 크게 생성하면 되지만, 이것은 좋은 방법이 아니다. 또 다른 문제는 배열의 객체를 삭제했을 때 해당 인덱스가 비게 되면 아래와 같이 중간중간에 객체가 없는 배열이 된다. 이렇게 되면 객체를 어디에 저장해야 할지 배열 인덱스 하나하나 검색 후 비어있는 공간에 객체를 저장해야 한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>][<span class=\"number\">2</span>][<span class=\"number\">3</span>][<span class=\"number\">4</span>][<span class=\"number\">5</span>][<span class=\"number\">6</span>]</span><br><span class=\"line\"> O  O  X  O  X  O</span><br></pre></td></tr></table></figure>\n<p>자바는 배열의 이러한 문제점을 해결하고, 널리 알려져 있는 자료구조(Data Structre)를 바탕으로 객체들을 효율적으로 추가, 삭제, 검색할수 있도록 Java.util 패키지에 컬렉션과 관련된 인터페이스와 클래스들을 포함시켜 놓았다. 이들을 총칭해서 컬렉션 프레임워크라 한다.</p>\n<p><strong>컬렉션</strong> 이란 사전적 의미로 요소를 수집해서 저장하는 것을 의미하는데, 자바 컬렉션은 객체를 수집해서 저장하는 역할을 한다. 자바 컬렉션 프레임워크는 몇 가지 인터페이스를 통해서 다양한 컬렉션 클래스를 이용할 수 있도록 한다. 컬렉션 프레임워크의 주요 인터페이스로는 List, Set, Map이 있다. 이 인터페이스들은 컬렉션을 사용하는 방법을 정의하는 것인데, 다음은 인터페이스로 사용 가능한 컬렉션 클래스를 보여준다.</p>\n<p><img src=\"https://i.imgur.com/JmO4zX2.png\" alt=\"\"></p>\n<p>List와 Set은 객체 추가, 삭제 검색하는 방법에 많은 공통점이 있기 때문에 이 인터페이스들의 공통된 메소드들만 모아 Collection 인터페이스로 정의해 두고 있다. Map은 키와 값을 하나의 쌍으로 묶어서 관리하는 구조로 되어있어 List및 Set과는 사용방법이 완전히 다르다.</p>\n<table>\n<thead>\n<tr>\n<th>인터페이스 분류</th>\n<th>특징</th>\n<th>구현클래스</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Collection (List)</td>\n<td>- 순서룰유지하고저장<br>- 중복 저장 가능</td>\n<td>ArrayList, Vector, LinkedList</td>\n</tr>\n<tr>\n<td>Collection (Set)</td>\n<td>- 순서를 유지 않고 저장 <br> - 중복 저장 안됨</td>\n<td>HashSet, TreeSet</td>\n</tr>\n<tr>\n<td>Map</td>\n<td>- 키와 값의 쌍으로 저장 <br> - 키는 중복 안 됨</td>\n<td>HashMap,Hashtable,TreeMap, Properties</td>\n</tr>\n</tbody>\n</table>\n<h3>List 컬렉션</h3>\n<p>List 컬렉션은 객체를 일렬로 늘어놓은 구조를 가지고 있다. 객체를 인덱스로 관리하기 때문에 객체를 저장하면 자동 인덱스가 부여되고 인덱스로 객체를 검색, 삭제할 수 있는 기능을 제공한다.  List 컬렉션에는 ArrayList, Vector, LinkedList 등이 있는데 다음은 List 컬렉션에서 공통적으로 사용 가능한 List 인터페이스의 메소드들이다. 인덱스로 객체를 관리하기 때문에 인덱스를 매게 값으로 갖눈 메소드가 많다.</p>\n<p><strong>객체 추가</strong></p>\n<table>\n<thead>\n<tr>\n<th>메소드</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>boolean add(E e)</td>\n<td>주어진 객체를 맨 끝에 추가</td>\n</tr>\n<tr>\n<td>void add(E e)</td>\n<td>주어진 인덱스에 객체를 추가</td>\n</tr>\n<tr>\n<td>set add(E e)</td>\n<td>주어진 인덱스에 저장된 객체를 주어진 객체로바꿈</td>\n</tr>\n</tbody>\n</table>\n<p><strong>객체 검색</strong></p>\n<table>\n<thead>\n<tr>\n<th>메소드</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>boolean contains(Object o)</td>\n<td>주어진 객체가 저장되어 있는지 여부</td>\n</tr>\n<tr>\n<td>E get(int index)</td>\n<td>주어진 인덱스에 객체를 리턴</td>\n</tr>\n<tr>\n<td>isEmpty()</td>\n<td>컬렉션이 비어있는지 검사</td>\n</tr>\n<tr>\n<td>int size()</td>\n<td>저장되어 있는 전체 객체 수를 리턴</td>\n</tr>\n</tbody>\n</table>\n<p><strong>객체 삭제</strong></p>\n<table>\n<thead>\n<tr>\n<th>메소드</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>void clean()</td>\n<td>저장된 모든 객체를 삭제</td>\n</tr>\n<tr>\n<td>E remove(int index)</td>\n<td>주어진 인덱스에 저장된 객체를 삭제</td>\n</tr>\n<tr>\n<td>boolean remove(Object o)</td>\n<td>주어진 객체를 삭제</td>\n</tr>\n</tbody>\n</table>\n<h4>ArrayList</h4>\n<p>ArrayList는 List 인터페이스의 구현 클래스로, ArrayList에 객체를 추가하면 객체가 인덱스로 관리된다. 일반배열과 ArrayList는 인덱스로 객체를 관리한다는 점에서는 유사하지만, 큰차이점을 가지고 있다. 배열은 생성할 때 크기가 고정되고, 사용중에 크기를 변경할 수 없지만, ArrayList는 저장 용량을 초과한 객체들이 들어오면 자동적으로 저장용량이 늘어난다. 다음은 ArrayList 객체의 내부 구조를 보여준다.</p>\n<p><img src=\"https://i.imgur.com/M08M97l.png\" alt=\"\"></p>\n<p>검사버튼 삭제버튼 초기에 ArrayList를 선언하면 10개의 객체를 저장할 수 있는 List가 선언이 된다. 만약 초기부터 용량을 크게 선언하고 싶다면 아래와 같이 선언하면 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;String&gt;(<span class=\"number\">30</span>);</span><br></pre></td></tr></table></figure>\n<p>ArrayList에 객체를 저장하면 인덱스 0 부터 차례대로 저장된다. ArrayList에서 특정 인덱스의 객체를 제거하면 바로 뒤 인덱스부터 마지막 인덱스까지 모두 앞으로 1씩 당겨진다. 마찬가지로 특정 인덱스에 객체를 삽입하면 해당 인덱스부터 마지막 인덱스까지 모두 1씩 밀려난다. 다음은 4번 인덱스가 제거되었을 때 5번 인덱스부터 모두 앞으로 1씩 당겨지는 모습을 보여준다.</p>\n<p><img src=\"https://i.imgur.com/nhg1zDA.png\" alt=\"\"></p>\n<p>위와같이 List안에서 노드가삭제가되면 앞으로 하나하나 다 밀려나야한다. 따라서 빈번한 객체 삭제와 삽입이 일어나나는 곳에서는 ArrayList를 사용하지 않고 삽입삭제에 용이한 LinkedList를 사용하는것이 좋다. 그러나 인덱스 검색이나 마지막 노드추가에서는 ArrayList가 더 좋은 성능을 발휘한다.</p>\n<p>다음예제는 ArrayList에 String 객체를 추가, 검색, 삭제하는방법의 간단한 예제이다.</p>\n<p><strong>예제</strong></p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/tree/master/java-basis-example/src/collection/list/arraylist\" target=\"_blank\" rel=\"noopener\">String 객체를 저장하는 ArrayList</a></li>\n</ul>\n<h4>Vector</h4>\n<p>Vector는 ArrayList와 동일한 내부 구조를 가지고 있다. Vector를 생성하기 위해서는 지정할 객체 타입을 타입 파라미터로 표기하고 기본 생성자를 호출하면 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;E&gt; list = <span class=\"keyword\">new</span> Vector&lt;E&gt;();</span><br></pre></td></tr></table></figure>\n<p>ArrayList와 다른점은 Vector는 동기화된 메소드로 구성되어 있기 때문에 멀티 스레드가 동시에 이 메소드들을 실행할 수 없고, 하나의 스레드가 실행을 완료해야만 다른 스레드가 실행할 수 있다. 그래서 멀티 스레드 환경에서 안전하게 객체를 추가, 삭제할 수 있다.</p>\n<p>다음은 Vector를 이용해서 객체를 추가, 삭제, 검색하는 예제이다.</p>\n<p><strong>예제</strong></p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/tree/master/java-basis-example/src/collection/list/vector\" target=\"_blank\" rel=\"noopener\">객체 저장, 삭제</a></li>\n</ul>\n<h4>LinkedList</h4>\n<p>LinkedList는 List 구현 클래스이므로 ArrayList와 사용방법은 똑같지만 내부 구조는 완전 다르다. ArrayList는 내부 배열 객체를 저장해서 인덱스로 관리하지만, LinkedList는 인접 참조를 링크해서 체인처럼 관리한다.</p>\n<p><img src=\"https://i.imgur.com/09ZGkA7.png\" alt=\"\"></p>\n<p>LinkedList에서 특정 인덱스의 객체를 제거하면 앞뒤 링크만 변경되고 나머지 링크는 변경되지 않는다. 특정 인덱스에 객체를 삽입할 때에도 마찬가지다. 그렇기 때문에 빈번한 객체를 삭제할 때는 LinkedList가 성능이 좋다. 왜냐 중간에서 하나 삭제를 하더라도 앞뒤의 노드만 연결해주면 되기 때문이다.<br>\nLinkedList는 생성하기 위해서는 저장할 객체 타입 파라미터(E)에 표기하고 기본 생성자로 호출하면 된다. 기본적으로 LinkedList는 처음 생성될 때에는 어떤한 링크도 만들어지지 않기 때문에 내부적으로 비어있다. 아래와 같이 생성할 수 있겠다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;E&gt; list = <span class=\"keyword\">new</span> LinkedList&lt;E&gt;();</span><br></pre></td></tr></table></figure>\n<p>다음 예제는 ArrayList와 LinkedList에 10000개의 객체를 삽입하는데 걸릴시간을 측정하는 예제이다. 누가 더 많은 시간이 걸리는지에 대한 예제이다.</p>\n<p><strong>예제</strong></p>\n<p><a href=\"https://github.com/minwan1/blog-example/tree/master/java-basis-example/src/collection/list/linkedlist\" target=\"_blank\" rel=\"noopener\">ArrayList와 LinkedList의 실행 성능 비교</a></p>\n<h3>Set 컬렉션</h3>\n<p>List 컬렉션은 저장 순서를 유지하지만, Set 컬렉션은 저장 순서가 유지되지 않는다. 또한 객체를 중복해서 저장할 수 없다. 하나의 null만 저장할 수 있다. Set 컬렉션은 수학의 집합에 비유될 수 있다. 집합은 순서와 상관없고 중복이 허용되지 않기 때문이다.</p>\n<p>Set 컬렉션에는 HashSet, LinkedHashSet, TreeSet등이 있는데, 다음은 Set 컬렉션에 공통적으로 사용 가능한 Set 인터페이스의 메소드들이다.</p>\n<p><img src=\"https://i.imgur.com/ZByMxEo.png\" alt=\"\"><br>\nSet 컬렉션은 인덱스로 객체를 검색해서 가져오는 메소드가 없다. 대신 전체 객체를 대상으로 한번씩 반복해서 가져오는 반복자(Iterator)를 제공한다. 반복자는 Iterator 인터페이스를 구현한 객체를 말하는데, itorator() 메소드를 호출하면 얻을 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Set&lt;String&gt; set = ...;</span><br><span class=\"line\">Iterator&lt;String&gt; iterator = set.iterator();</span><br></pre></td></tr></table></figure>\n<p>다음은 Iterator 인터페이스에 선언된 메소드들이다.</p>\n<table>\n<thead>\n<tr>\n<th>리턴 타입</th>\n<th>메소드명</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>boolean</td>\n<td>hasNext()</td>\n<td>가져올 객체가 있으면 true를 리턴하고 없으면 false를 리턴한다.</td>\n</tr>\n<tr>\n<td>E</td>\n<td>next()</td>\n<td>컬렉션에서 하나의 객체를 가져온다</td>\n</tr>\n<tr>\n<td>void</td>\n<td>remove()</td>\n<td>Set 컬렉션에서 객체를 제거한다.</td>\n</tr>\n</tbody>\n</table>\n<p>Iterator에서 하나의 객체를 가져올 때는 next() 메소드를 사용한다. next() 메소드를 사용하기전에 먼저 가져올 객체가 있는지 확인하는것이 좋다. hasNext() 메소드는 가져올 객체가 있으면 true를 리턴하고 더이상 가져올 객체가 없으면 false를 리턴한다. 따라서 true가 리턴될때 next() 메소드를 사용해야한다. 다음은 Set을 이용한 루핑 방법이다.</p>\n<p>방법 1. Iterator를 사용한벙법</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Set&lt;String&gt; set = ...;</span><br><span class=\"line\">Iterator&lt;String&gt; iterator = set.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(iterator.hasNext())&#123; <span class=\"comment\">// has가 다음 객체가있는지 체크해주니까 있는 만큼 루핑된다.</span></span><br><span class=\"line\">  String str = iterator.next();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>방법 2. For문 사용</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(String str : set)&#123; <span class=\"comment\">// 저장된 객체수만큼 루핑한다.</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4>HashSet</h4>\n<p>HashSet은 Set 인터페이스의 구현클래스이다. HashSet을 생성하기 위해서는 다음과 같이 기본생성자를 호출하면 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Set&lt;E&gt; set = <span class=\"keyword\">new</span> HashSet&lt;E&gt;();</span><br></pre></td></tr></table></figure>\n<p>HashSet은 Set의 성격대로 순서상관없이 저장되고, 중복 저장되지 않는다. HashSet이 판단하는 동일한 객체란 꼭 같은 인스턴스를 뜻하지 않는다. HashSet은 객체를 저장하기전에 먼저 객체의 HashCode()메소드를 호출해서 해시코드를 얻는다. 그리고 이미 저장되어 있는 객체의 hashCode() 메소드를 호출해서 해시코드를 얻어낸다. 그리고 이미저장되어 있는 객체들의 해시코드와 비교 한다. 만약 equals()메소드로 두 객체를 비교해서 true가 나오면 동일한 객체로 판단하고 중복 저장을 하지 않는다.</p>\n<p><img src=\"https://i.imgur.com/re05jjk.png\" alt=\"\"></p>\n<p>문자열을 HashSet에 저장할 경우, 깊은 문자열을 갖는 String 객체는 동등한 객체로 간주되고 다른 문자열을 갖는 String 객체는 다른 객체로 간주되는데, 그 이유는 String 클래스가 hashCode()와 equals() 메소드를 재정의해서 같은 문자열일 경우 hashCode()의 리턴값을 같게, equals()의 리턴값은 true가 나오도록 오버라이딩이 되있기 때문이다. 물론 자신이 정의 한 클래스에도 똑같이 적용할 수 있다.</p>\n<p>예를 들어 Member 클래스를 정의했다고 가정하자. 이 MemberClass에는 인스턴스가 달라도 이름과 나이가 동일하다면 동등 객체라고 equals()와 hashCode를 정의했다고 치자. 그리고 아래와 같이 Set에 객체를 넣는다고 해보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Set&lt;Member&gt; set = <span class=\"keyword\">new</span> HashSet&lt;Member&gt;();</span><br><span class=\"line\">set.add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"홍길동\"</span>, <span class=\"number\">30</span>));</span><br><span class=\"line\">set.add(<span class=\"keyword\">new</span> Member(<span class=\"string\">\"홍길동\"</span>, <span class=\"number\">30</span>));</span><br><span class=\"line\">System.out.println(<span class=\"string\">\"총 객체수 : \"</span> + set.size()); 저장된 객체 수 얻기 <span class=\"comment\">// 사이즈 1</span></span><br></pre></td></tr></table></figure>\n<p>위와같이 Set에 이름과 나이가 같은 객체를 두개 넣더라도 실제적으로 set에는 1개의 객체만 들어가게 된다.</p>\n<p>다음은 HashSet을 이용해 앞에서 간단한 Hashse에대한 기능을 확인하는 예제이다.</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/tree/master/java-basis-example/src/collection/set\" target=\"_blank\" rel=\"noopener\">String 객체를 중복없이 저장하는 HashSet</a></li>\n<li><a href=\"https://github.com/minwan1/blog-example/tree/master/java-basis-example/src/collection/set\" target=\"_blank\" rel=\"noopener\">Member 객체를 정보없이 저장하는 HashSet</a></li>\n</ul>\n<h3>Map 컬렉션</h3>\n<p>Map 컬렉션은 키(Key)와 값(value으로 구성된 Entry 객체를 저장하는 구조를 가지고 있다. 여기서 키와 값은 모두 객체이다. 키는 중복 저장될 수 없지만 값은 중복 저장될 수 있다. 키값이 중복되어 저장된다면 먼저 저장된 값은 저장되지 않는다.<br>\n<img src=\"https://i.imgur.com/TI9n5UB.png\" alt=\"\"></p>\n<p>Map 컬렉션에는 HashMap, Hashtable, LinkedHashMap, Properties, TreeMap 등이 있다. 다음은 Map컬렉션에서 공통적으로 사용가능한 Map 인터페이스의 메소드들이다. 키로 객체들을 관리하기때문에 키를 매개값으로 갖는 메소드가 많다.<br>\n<img src=\"https://i.imgur.com/zCuSUsB.png\" alt=\"\"></p>\n<p>Map에서는 키를 알고 싶다면 get() 메소 도로 객체를 얻어낼 수 있다. 하지만 맵 안에 데이터를 하나하나 얻어 내고 싶다면 두 가지 방법이 있다. 먼저 아래는 Key를 Set 타입으로 뽑아서 하나하나 Iterator 시켜 그 key 값으로 value를 얻는 방법이 있을 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;String, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> Set&lt;String&gt; strings = map.keySet();</span><br><span class=\"line\"><span class=\"keyword\">final</span> Iterator&lt;String&gt; iterator = strings.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(iterator.hasNext())&#123;</span><br><span class=\"line\">    String key = iterator.next();</span><br><span class=\"line\">    String value = map.get(key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>두 번째 방법은 entrySet을 통해 Entry객체를 Set타입으로 뽑아서 key와 value를 동시에 얻는 방법이 있을 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;String, String&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">final</span> Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class=\"line\"><span class=\"keyword\">final</span> Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = entries.iterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(iterator.hasNext())&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Map.Entry&lt;String, String&gt; mapEntry = iterator.next();</span><br><span class=\"line\">    mapEntry.getKey();</span><br><span class=\"line\">    mapEntry.getValue()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4>HashMap</h4>\n<p>HashMap의 키로 사용할 객체는 HashCode와 equals()메소드를 재정의해서 동등객체가 될조건을 정해야한다. 동등 객체, 즉 동일한 키가 될 조건은 hashCode()의 리턴값이 같아야하고, equals()메소드가 true를 리턴해야한다. 동등 객체, 즉 동일한 키가 될 조건은 hashCoDE()의 리턴값이 같아야하고 equals()메소드가 true를 리턴해야 한다.</p>\n<p>주로 키 타입으로 String을 많이사용하는데 String은 글자가 다르면 hashCode, equals 메소드가 다르도록 재정의가 되있기때문에 키로 적합하다. 해쉬맵은 아래와같이 키타입과 value 타입을 파라미터로 주고 기본 생성자로 선언할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Map&lt;K, V&gt; map = <span class=\"keyword\">new</span> HashMap&lt;K, V&gt;();</span><br></pre></td></tr></table></figure>\n<p><strong>예제</strong></p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/map/hashmap/HashMapExample1.java\" target=\"_blank\" rel=\"noopener\">이름을 키로 점수를 값으로 저장하기</a></li>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/map/hashmap/HashMapExample2.java\" target=\"_blank\" rel=\"noopener\">학번과 이름이 동일한 경우 같은 키로 인식</a></li>\n</ul>\n<h4>Hashtable</h4>\n<p>Hashtable은 HashMap과 동일한 내부구조를 가진다. HashMap과 차이점은 Hashtable은 동기화된(synchronized)메소드로 구성되어 있기때문에 멀티스레드가 동시에 이 메소드들을 실행할 수 는 없고, 하나의 스레드가 실행을 완료해야만 다른 스레드를 실행할 수 있다.</p>\n<p>다음은 Hash테이블을 이용해 키보드로 아이디와 비밀번호를 입력받아서 패스워드 인증 기능을 구현하는 예제이다.</p>\n<p><strong>예제</strong></p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/map/hashtable/HashtableExample.java\" target=\"_blank\" rel=\"noopener\">아이디와 비밀번호 검사하기</a></li>\n</ul>\n<h4>Properties</h4>\n<p>Properties는 Hashtable의 하위 클래스이기 때문에 HashTable의 모든 특징을 그대로 가지고 있다. Hashtable은 키와 값을 다양한 타입으로 지정이 가능한데 비해 Properties는 키와 값을 String 타입으로 제한한 컬렉션이다. Properties는 애플리케이션의 옵션정보, 데이터베이스 연결 정보 그리고 국제화(다국어) 정보가 저장된 프로퍼티(~.properties) 파일을 읽을 때 주로 사용한다.</p>\n<p>프로퍼티 파일은 키와 값이 = 기호로 연결되어 있는 텍스트 파일로 ISO 8859-1문자셋으로 저장된다. 이 문자셋으로 직접 표현할 수 없는 한글은 유니코드로 변환되어 저장된다.</p>\n<h3>검색 기능을 강화시킨 컬렉션</h3>\n<p>컬렉션 프레임워크는 검색 기능을 강화시킨 TreeSet과 TreeMap을 제공하고 있다. 이름에서 알 수 있듯이 TreeSet은 Set 컬렉션이고, TreeMap은 Map 컬렉션이다. 이 컬렉션들은 이진 트리를 이용해서 계층적(Tree 구조)를 가지면서 객체를 저장한다.</p>\n<h4>이진 트린 구조</h4>\n<p>이진 트리는 여러 개의 노드가 트리 형태로 이루어진 연결된 구조로, 루트 노드라고 불리는 하나의 노드에서부터 시작해서 각 노드에 최대 2개의 노드를 연결할 수 있는 구조를 가지고 있다.</p>\n<p><img src=\"https://i.imgur.com/SnTiRL0.png\" alt=\"\"></p>\n<p>위 아래로 연결된 두 노드를 부모 - 자식 관계에 있다고 하며 위의 노드를 부모 노드, 아래 노드를 자식 노드라고 한다. 하나의 노드는 최대 2개의 자식 노드와 연결될 수 있다. 이진 트리는 부모 노드의 값보다 작은 노드는 왼쪽에 위치시키고, 부모 노드의 값보다 큰 노드는 오른쪽에 위치시킨다. 예를 들어 6,3,9,2,5의 순서로 값을 저장하면 다음과 같은 순서로 진행된다.</p>\n<p><img src=\"https://i.imgur.com/vmcODcJ.png\" alt=\"\"></p>\n<p>작은값은 왼쪽에, 큰값은 오른쪽에 저장한다. 숫자가 아닌 문자가 저장할경우네느 문자의 유니코드 값으로 비교한다. 이진 트리가 범위 검색을 쉽게할 수 있는 이유는 아래와 같이 값들이 정렬되어 있어 그룹핑이 쉽기 때문이다.</p>\n<p><img src=\"https://i.imgur.com/dt6exaV.png\" alt=\"\"></p>\n<h4>TreeSet</h4>\n<p>TreeSet은 이진 트리를 기반으로 한 Set 컬렉션이다. 하나의 노드는 노드 값인 value와 왼쪽과 자식 노드를 참조하기 위한 두 개의 변수로 구성된다. TreeSet에 객체를 저장하면 자동으로 정렬되는데 부모 값과 비교해서 낮은 것은 왼쪽 자식 노드에, 높은 것은 오른쪽 자식 노드에 저장한다.<br>\n<img src=\"https://i.imgur.com/1tD53qf.png\" alt=\"\"></p>\n<p>TreeSet을 생성하기 위해서는 저장할 객체 타입을 파라미터로 표기하고 기본 생성자를 호출하면 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">TreeSet&lt;E&gt; treeSet = <span class=\"keyword\">new</span> TreeSet&lt;E&gt;();</span><br></pre></td></tr></table></figure>\n<p>Set 인터페이스 타입 변수에 대입해도 되지만 TreeSet클래스 타입으로 대입한 이유는 객체를 찾거나 범위 검색과 관련된 메소드를 사용하기 위해서이다. 다음은 TreeSet이 가지고있는 검색 관련된 메소드들이다.</p>\n<table>\n<thead>\n<tr>\n<th>메소드</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>first()</td>\n<td>제일 낮은 객체를 리턴</td>\n</tr>\n<tr>\n<td>last()</td>\n<td>제일 높은 객체를 리턴</td>\n</tr>\n<tr>\n<td>lower(E e)</td>\n<td>주어진 객체보다 바로 아래 객체를 리턴</td>\n</tr>\n<tr>\n<td>higher(E e)</td>\n<td>주어진 객체보다 바로 위 객체를 리턴</td>\n</tr>\n<tr>\n<td>floor(E e)</td>\n<td>주어진 객체와 동등한 객체가 있으면 리턴 . 만약 없다면 주어진 객체의 바로 위의 객체를 리턴</td>\n</tr>\n<tr>\n<td>celling(E e)</td>\n<td>주어진 객체와 동등한 객체가 있으면 리턴, 만약 없다면 주어진 객체의 바로 위의 객체를 리턴</td>\n</tr>\n<tr>\n<td>pollFirst()</td>\n<td>제일 낮은 객체를 꺼내오고 컬렉션에서 제거함</td>\n</tr>\n<tr>\n<td>pollLast()</td>\n<td>제일 높은 객체를 꺼내오고 컬렉션에서 제거함</td>\n</tr>\n</tbody>\n</table>\n<p>다음은 TreeSet을 이용해 몇가지 기능을 구현해보는 예제이다.</p>\n<p><strong>예제</strong></p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/tree/treeset/TreeSetExample1.java\" target=\"_blank\" rel=\"noopener\">TreeSet 특정 객체 찾기</a></li>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/tree/treeset/TreeSetExample2.java\" target=\"_blank\" rel=\"noopener\">TreeSet 객체 정렬하기</a></li>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/tree/treeset/TreeSetExample3.java\" target=\"_blank\" rel=\"noopener\">TreeSet 영어 단어를 정렬하고, 범위 검색해보기 </a></li>\n</ul>\n<h4>TreeMap</h4>\n<p>TreeMap은 이진 트리를 기반으로 한 Map 컬렉션이다. TreeSet 과의 차이점은 키와 값이 저장된 MapEntry를 저장한다는 점이다. TreeMap에 객체를 저장하면 자동으로 정렬되는데 기본적으로 부모 키값과 비교해서 키값이 낮은 것은 왼쪽 자식 노드에, 키값이 높은 것은 오른쪽 자식 노드에 Map.Entry 객체를 저장한다.</p>\n<p><img src=\"https://i.imgur.com/si0KBY0.png\" alt=\"\"></p>\n<p>TreeMap을 생성하기 위해서는 키로 저장할 객체 타입과 값으로 저장할 객체 타입을 타입 파라미터로 주고 기본 생성자를 호출하면 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">TreeMap&lt;String, Integer&gt; treeMap = <span class=\"keyword\">new</span> TreeMap&lt;String, Integer&gt;();</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>메소드</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>firstEntry()</td>\n<td>제일 낮은 Map.Entry를 리턴</td>\n</tr>\n<tr>\n<td>lastEntry()</td>\n<td>제일 높은 Map.Entry를 리턴</td>\n</tr>\n<tr>\n<td>lowerEntry(K key)</td>\n<td>주어진 키보다 바로 아래 Map.Entry를 리턴</td>\n</tr>\n<tr>\n<td>higherEntry(K key)</td>\n<td>주어진 키보다 바로 위 Map.Entry를 리턴</td>\n</tr>\n<tr>\n<td>floorEntry(K key)</td>\n<td>주어진 키와 동등한 키가 있으면 해당 Map.Entry를 리턴,<br>없다면 주어진 키 바로 아래의 Map.Entry를 리턴</td>\n</tr>\n<tr>\n<td>ceilingEntry(K key)</td>\n<td>주어진 키와 동등한 키가 있으면 해당 Map.Entry를 리턴,<br>없다면 주어진 키 바로 위의 Map.Entry를 리턴</td>\n</tr>\n<tr>\n<td>pollFirstEntry()</td>\n<td>제일 낮은 Map.Entry를 꺼내오고 컬렉션에서 제거함</td>\n</tr>\n<tr>\n<td>pollLastEntry()</td>\n<td>제일 높은 Map.Entry를 꺼내오고 컬렉션에서 제거함</td>\n</tr>\n</tbody>\n</table>\n<p>다음은 TreeMap 가지고 있는 정렬과 관련된 메소드들이다.</p>\n<table>\n<thead>\n<tr>\n<th>리턴 타입</th>\n<th>메소드</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NavigableSet<k></k></td>\n<td>descendingKeySet()</td>\n<td>내림차순으로 정렬된 키의 NavigableSet을 리턴</td>\n</tr>\n<tr>\n<td>NavigableMap&lt;K,V&gt;</td>\n<td>descendingMap()</td>\n<td>내림차순으로 정렬된 Map.Entry의 NavigableMap을 리턴</td>\n</tr>\n</tbody>\n</table>\n<p>descendingMap 메소드를 호출하면 내림차순 NavigableMap타입의 객체를 리턴해주는데 만약 한번 더호출하게되면 오름차순 객체를 리턴한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">NavigableMap&lt;K, V&gt; descendingMap = treeMap.descendingMap();</span><br><span class=\"line\">NavigableMap&lt;K, V&gt; ascendingMap = descendingMap.descendingMap();</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>리턴 타입</th>\n<th>메소드</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NavigableMap&lt;K, V&gt;</td>\n<td>headMap(k toKey, boolean inclusive)</td>\n<td>주어진 키보다 낮은 Map.Entry들을 NavigableMap으로리턴. 주어진 키의 Map.Entry 포함여부는 두번째 매개 값에 따라 달라짐</td>\n</tr>\n<tr>\n<td>NavigableMap&lt;K, V&gt;</td>\n<td>tailMap(k fromKey, boolean inclusive)</td>\n<td>주어진 객체보다 높은 Map.Entry들을 NavigableMap으로 리턴. 주어진 객체 포함여부는 두번째 매개값에서 따라 달라짐</td>\n</tr>\n<tr>\n<td>NavigableMap&lt;K, V&gt;</td>\n<td>subMap(K fromKey, boolean fromInclusive, K tokey, boolean toInclusive)</td>\n<td>시작과 끝으로 주어진 키 사이의 Map.Entry들을 NavigableMap 컬렉션으로 변환. 시작과 끝 키의 Map.Entry 포함여부는 두번째, 네번째 매개값에 따라 달라짐</td>\n</tr>\n</tbody>\n</table>\n<p>여기에서 간단하게 SubMap()메소드의 사용방법을 간단히 봐보자. subMap()메소드는 네 개의 매개 변수가 있는데, 시작키와 끝키, 그리고 이 키들의 Map.Entry를 포함할지 여부의 boolean값을 받는다. 이것을 기반으로 그 해당 범위내의 Map을 리턴해준다.</p>\n<p>다음은 TreeMap 구조를 이용해 몇가지 기능을 구현한 예제이다.</p>\n<p><strong>예제</strong></p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/tree/treemap/TreeMapExample1.java\" target=\"_blank\" rel=\"noopener\">TreeMap 특정 Map.Entry 찾기</a></li>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/tree/treemap/TreeMapExample2.java\" target=\"_blank\" rel=\"noopener\">TreeMap 객체 정렬하기</a></li>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/tree/treemap/TreeMapExample3.java\" target=\"_blank\" rel=\"noopener\">TreeMap 키로 정렬하고 범위 검색하기</a></li>\n</ul>\n<h4>Comparable과 Compartor</h4>\n<p>TreeSet의 객체와 TreeMap의 키는 저장과 동시에 자동 오름차순으로 정렬되는데, 숫자일 경우 값으로 정렬하고, 문자열일 경우에는 유니코드로 정렬한다. TreeSet과 TreeMap은 이진 트리로 크기를 비교해 트리구조를 구성해야 하기 때문에 java.lang.Comparable 인터페이스를 구현해야 쓸 수 있다. 기본적으로 Wrraper Class들은 Comparable 인터페이스가 구현되어 있어 TreeSet과 TreeMap을 사용할 수 있다.</p>\n<p>또한 ArrayList 등의 자료구조를 Collection.sort()함수를 사용할때도 Comparable을 이용해 compareTo()메소드만 구현하게되면 쉽게 Collection프레임워크의 자료구조들을 정렬하여 사용할 수 있다. 쉽게 Coparable을 implements를 하여 compareTo()메소드만 정의해주면 된다. 아래의 설명을 참조하여 compareTo()를 재정의해주면된다.</p>\n<table>\n<thead>\n<tr>\n<th>리턴타임</th>\n<th>메소드</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>int</td>\n<td>compareTo(T o)</td>\n<td>주어진 객체와 같으면 0을리턴 <br> 주어진 객체보다 작으면 음수를 리턴 <br>  주어진 객체보다 크면 양수를 리터</td>\n</tr>\n</tbody>\n</table>\n<p>다음은 나이를 기준으로 Person객체를 오름차순으로 정렬하기 위해 Comparable 인터페이스를 구현한것이다. 나이가 적을 경우는 -1을 동일한경우는 0을 클경우는 1을 리턴하도록하여 compareTo() 메소드를 재정의하여 treeSet을 이용하여 유저를 출력하였다.</p>\n<p>다음은 <strong>Comparable 예제</strong>이다.</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/ComparableExample.java\" target=\"_blank\" rel=\"noopener\">Comparable 예제</a></li>\n</ul>\n<p>위에서 말했듯이 TreeSet, TreeMap을 사용할 때의 키가 Comparable을 구현하고 있지 않을 경우에는 저장하는 순간 ClassCastException이 발생한다. 이진 트리를 구성하기 위해서는 값 비교는 필 수이다. 그렇다면 객체에 Comparable 구현체를 구현하는 방법 말고 정렬하는 방법은 없을까… 그 방법은 Comparator 인터페이스다. 그런데 결국에는 둘 다 비슷한 방법이라고 생각한다. 어쨌든 예제를 간단하게 한번 봐보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">TreeSet&lt;E&gt; treeSet = <span class=\"keyword\">new</span> TreeSet&lt;E&gt;(<span class=\"keyword\">new</span> AscendingComparator());</span><br><span class=\"line\"></span><br><span class=\"line\">TreeMap&lt;K,V&gt; treeMap = <span class=\"keyword\">new</span> TreeMap&lt;K, V&gt; (<span class=\"keyword\">new</span> DescendingComparator());</span><br></pre></td></tr></table></figure>\n<p>정렬자는 Comparator 인터페이스를 구현한 객체를 말하는데, Comparator 인터페이스는 다음과 같이 메소드가 정의되어 있다.</p>\n<table>\n<thead>\n<tr>\n<th>리턴 타입</th>\n<th>메소드</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>int</td>\n<td>compare(T o1, T o2)</td>\n<td>o1과 o2가 동등하다면 0을리턴<br> o2이 o2보다 앞에 오게하면 음수를 리턴 <br> o1이 o2보다 뒤에 오게 하려면 양수를 리턴</td>\n</tr>\n</tbody>\n</table>\n<p>다음은 Comparator를 이용하여 과일 객체를 내림차순으로 정렬시키는 <strong>예제</strong>이다.</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/ComparatorExample.java\" target=\"_blank\" rel=\"noopener\">Compartor 예제</a></li>\n</ul>\n<h3>LIFO와 FIFO 컬렉션</h3>\n<p>후입 선출(LIFO : Last In First Out)은 나중에 넣은 객체가 먼저 빠져 나가는 자료구조를 말한다. 반대로 선입 선출(FIFO : First In First Out)은 먼저 넣은 객체가 먼저 빠져나가는 구조를 말한다. 컬렉션 프레임워크에는 LIFO 자료구조를 제공하는 스택(Stack) 클래스와 FIFO 자료구조를 제공하는 (Queue) 인터페이스를 제공하고 있다. 다음은 스택과 큐의 구조를 보여준다.<br>\n<img src=\"https://i.imgur.com/QJcADSn.png\" alt=\"\"></p>\n<p>스택을 응용한 대표적인 예가 프로그램들의 함수를 저장하는 공간인 스택공간일 수 가 있다. 스택 메모리에 저장된 변수는 나중에 저장된것부터 저장된다. 큐를 응용한 대표적인 예가 스레드풀의 작업이다. 작업 큐는 먼저 들어온 작업부터 처리한다.</p>\n<h4>Stack</h4>\n<p>Stack 클래스는 LIFO 자료구조를 구현한 클래스이다. 다음은 Stack 클래스의 주요 메소드들이다.</p>\n<table>\n<thead>\n<tr>\n<th>리턴 타입</th>\n<th>메소드</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>E</td>\n<td>push(E item)</td>\n<td>주어진 객체를 스택에 넣는다.</td>\n</tr>\n<tr>\n<td>E</td>\n<td>peek()</td>\n<td>스택의 맨 위 객체를 가져온다. 객체를 스택에서 제거하지 않는다.</td>\n</tr>\n<tr>\n<td>E</td>\n<td>pop()</td>\n<td>스택의 맨 위 객체를 가져온다. 객체를 스택에서 제거한다.</td>\n</tr>\n</tbody>\n</table>\n<p>Stack을 사용하기위해서는 아래와같이 스택을 생성할때 타입파라미터를 넘기고 기본생성자를 호출하면 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Stack&lt;E&gt; stack = <span class=\"keyword\">new</span> Stack&lt;E&gt;();</span><br></pre></td></tr></table></figure>\n<p>다음은 택시에서 많이 볼 수 있는 동전케이스를 스택 클래스로 구현한 예제이다. 먼저 넣은 동전은 제일밑에 깔리고 나중에 넣은 동전이 위에 쌓이기 때문에 Stack에서 동전을 빼면 마지막에 넣은 동전이 먼저나오는 예제이다.</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/stack/StackExample.java\" target=\"_blank\" rel=\"noopener\">Stack 예제</a></li>\n</ul>\n<h4>Queue</h4>\n<p>Queue인터페이스는 FIFO자료구조에서 사용되는 메소드를 정의하고 있다. 다음은 Queue 인터페이스에 정의되어 있는 메소드를 보여준다</p>\n<table>\n<thead>\n<tr>\n<th>리턴 타입</th>\n<th>메소드</th>\n<th>설명</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>boolean</td>\n<td>offer(E e)</td>\n<td>주어진 객체를 넣는다.</td>\n</tr>\n<tr>\n<td>E</td>\n<td>peek()</td>\n<td>객체 하나를 가져온다. 객체를 큐에서 제거하지 않는다.</td>\n</tr>\n<tr>\n<td>E</td>\n<td>poll()</td>\n<td>객체 하나를 가져온다. 객체를 큐에서 제거한다.</td>\n</tr>\n</tbody>\n</table>\n<p>Queue 인터페이스를 구현한 대표적인 클래스는 LinkedList이다. LinkedList는 List인터페이스를 구현했기 때문에 List 컬렉션이기도 하다. 다음 코드는 LinkedList 객체를 Queue 인터페이스 타입으로 변환한것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Queue&lt;E&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;E&gt;();</span><br></pre></td></tr></table></figure>\n<p>다음은 Queue를 이용해서 간단한 메시지 큐를 구현한 예제이다. 먼저 넣은 메시지가 반대쪽으로 먼저 나오기 때문에 넣은 순서대로 메시지가 처리 되는 예제이다.</p>\n<ul>\n<li><a href=\"https://github.com/minwan1/blog-example/blob/master/java-basis-example/src/collection/queue/QueueExample.java\" target=\"_blank\" rel=\"noopener\">Queue 예제</a></li>\n</ul>\n<p>참고</p>\n<ul>\n<li><a href=\"https://book.naver.com/bookdb/book_detail.nhn?bid=8589375\" target=\"_blank\" rel=\"noopener\">이것이 자바다</a></li>\n</ul>\n"},{"title":"Toby-1 오브젝트와 의존관계","catalog":true,"date":"2018-06-06T15:00:00.000Z","subtitle":null,"header-img":null,"_content":"\n# 토비의 스프링\n이글은 [토비님의 스프링책](http://book.naver.com/bookdb/book_detail.nhn?bid=7006516)을 보고 요약한 내용입니다\n\n## 1장 오브젝트와 의존관계\n**들어가며**\n스프링이 자바에서 가장 중요하게 가치를 두는것은 바로 객체지향프로그래밍이 가능한 언어라는 점이다.  자바 엔터프라이즈 기술의 혼란속에서 잃어버렸던 객체지향 기술의 진정한 가치를 회복시키고 폭넓은 혜택을 누릴 수 있도록하는것이 스프링 철학이다. 그래서 스프링에서 관심을 많이두는것은 오브젝트의 생명주기이다. 그렇기 때문에 우리는 스프링이 어떤것이고, 무엇을 제공하는지 보다는 스프링이 관심을 갖는 대상인 오브젝트의 설계와 구현, 동작원리에대해 관심을 가져야한다.\n\n### 1.1 초난감 DAO\n먼저 간단하게 아래와같이 JDBC를 이용한 User CURD를 다룰것이다. 예제에서는 롬복을 사용하여 객체를 다룰것이다. 그리고 데이터베이스는 Inmemory DB인 H2를 사용할것이다.\n\n```java\n@Getter\n@Setter\n@NoArgsConstructor\npublic class User {\n    private String id;\n    private String name;\n    private String password;\n\n\n    @Builder\n    public User(String id, String name, String password) {\n        this.id = id;\n        this.name = name;\n        this.password = password;\n    }\n\n\n}\n\n```\n\n유저의 정보에 접근할 수 있는 DAO를 아래와같이 만들자.\n\n```java\npublic class UserDao {\n    public void add(User user) throws ClassNotFoundException, SQLException {\n        Class.forName(\"org.h2.Driver\");\n        Connection c = DriverManager.getConnection(\"jdbc:h2:tcp://localhost:9092/mem:testdb;MVCC=TRUE\", \"sa\", \"\");\n\n        PreparedStatement ps = c.prepareStatement(\"insert into users(id, name, password) values (?, ?, ?)\");\n        ps.setString(1, user.getId());\n        ps.setString(2, user.getName());\n        ps.setString(3, user.getPassword());\n\n        ps.executeUpdate();\n\n        ps.close();\n        c.close();\n    }\n\n    public User get(String id) throws ClassNotFoundException, SQLException {\n        Class.forName(\"org.h2.Driver\");\n        Connection c = DriverManager.getConnection(\"jdbc:h2:tcp://localhost:9092/mem:testdb;MVCC=TRUE\", \"sa\", \"\");\n\n        PreparedStatement ps = c.prepareStatement(\"select * from users where id = ?\");\n        ps.setString(1, id);\n\n        ResultSet rs = ps.executeQuery();\n        rs.next();\n\n        User user = new User();\n        user.setId(rs.getString(\"id\"));\n        user.setName(rs.getString(\"name\"));\n        user.setPassword(rs.getString(\"password\"));\n\n        rs.close();\n        ps.close();\n        c.close();\n\n        return user;\n    }\n}\n\n```\n그다음은 실제 User 정보가 담길 디비를 아래와같이 만들어보자.\n```sql\nCREATE TABLE users (\n  id          varchar(10) primary key,\n  name varchar(20) not null,\n  password varchar(10) not null\n);\n```\n\n이제 만들어진 코드를 바탕으로 테스트 코드를 아래와같이 작성해보자.\n\n```java\npublic static void main(String[] args) throws ClassNotFoundException, SQLException {\n    UserDao dao = new UserDao();\n\n    User user = new User();\n    user.setId(\"whiteship\");\n    user.setName(\"백기선\");\n    user.setPassword(\"married\");\n\n    dao.add(user);\n\n    System.out.println(user.getId() + \" 등록 성공\");\n\n    User user2 = dao.get(user.getId());\n    System.out.println(user2.getName());\n    System.out.println(user2.getPassword());\n    System.out.println(user2.getId() + \" 조회 성공\");\n}\n\n```\n\n위와같이 이제 테스트코드를 돌리게되면 데이터베이스를 통해 유저를 등록하고 조회를 할 수 있게 된다. 사실 위코드에서 소스가 작동하는데는 큰문제가 없다. 하지만 잠재적으로 엄청난 버그를 가지고있는 소스임은 분명하다. 그래서 위의 소스를 좀더 안전하고, 유지보수하기 좋은 소스를 만들기위해서 스프링과 결합하여 좀 더 효과적으로, 객체지향적으로 만들어나가는 방법에 대해 알아볼것이다.\n\n### 1.2 DAO 분리\n\n#### 커넥션만들기의 추출\n\n먼저 중복된 코드가 무엇인지에대해 생각하여야한다. 먼저 앞에서 만든 UserDao의 중복코드를 제거하기 위해서 관심사항들을 뽑아보자.\n\n* DB와 연결을 위한 커넥션을 가져오는 부분이다.\n* 사용자 등록을 위해 DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행하는 것 또한 계속 중복되고 있다.\n* 셋째는 작업이 끝나고 리소스들을 종료해주는 부분이다.\n\n먼저 DB와 연결을 위한 커넥션 부분을 제거해보자. getConnetion 메소드로 빼서 연결이 필요할때는 그메소드를 호출하는것이다.\n```java\npublic User get(String id)  throws ClassNotFoundException,SQLException{\n  Connection c = getConnetion();\n}\n\nprivate Connection getConnection() throws ClassNotFoundException,SQLException{\n  class.forName(\"com.mysql.jdbc.Driver\");\n  Connection C = DriverManager.getConnection(\"jdbc:mysql://localhost/springbook\",\"spring\",book);\n  return c\n}\n```\n위에 getConnection메소드는 관심의 종류에 따라 메소드 구분 해놓았다. 그렇기 때문에 한가지 관심 예를들어 데이터베이스의 종류를 바꾸는 등의  문제에서 하나의 메소드에 소스만 변경하게 되면 손쉽게 데이터 베이스를 변경할 수 있게 해준다. 기존 소스같은경우에는 스키마등이 변경된다고 치면 모든 스키마 URL등을 변경해줘야 했을것이다.\n\n#### DB커넥션 만들기의 독립\n이번에는 좀더 변화를 반기는 DAO를 만들것이다.\n\n**상속을 통한 확장**\n![](https://i.imgur.com/zpT9cHZ.png)\n\n위그림과 같이 UserDao를 추상클래스로 선언 하면 좀더 확장성 있는 소스가 될 것이다. 이렇게 선언하게되면 추상클래스에 add와 get만 메소드를 구현하고 getConnection은 깡통메소드로 나두게되면 NUserDao, DUserDao에서 getConnection만 구현하게되면 2개의 각기 다른 디비를 붙일 수 있다.\n\n이렇든 UserDao와같은 슈퍼클래스는 기본적인 로직의 흐름(커넥션가져오기,sql생성,실행,반환)만들고 서브클래스는 메소드를 구현하는 패턴을 템플릿 메소드 패턴이라고 한다. 템플릿 메소드 패턴은 스프링에서 애용하는 패턴이다.\n\n![](https://i.imgur.com/RSH9tOC.png)\n\n### 1.3 DAO의 확장\n모든 오브젝트는 변한다. 그런데 오브젝트가 다 동일한 방식으로 변하는건 아니고 공통 관심사에 따라 변한다. 지금까지 크게 두가지를 다뤘다.\n1. 데이터를 어떻게 접근할것인가\n2. 어떻게 데이터베이스를 쉽게 변경할것인가.\n\n위의 소스로 장점은 데이터 접근 방식이 수정된다면 우리는 UserDao를 변경할것이다. 만약 DB에서 꺼내온 정보를바탕으로 뭔가 정보가 수정된다면 그 구현체들 MUserDao, DUserDao가 수정될것이다. 이것은 것으로 보면 서로에게 영향을 안주는것같지만 상속이라는 방법을 사용했기때문에 지독한 의존성을 가진다. 다음에서부터는 그 의존성을 좀더 느슨하게 할것이다.\n\n#### 클래스의분리\nDB 커넥션과 관련된 부분을 서브클래스가 아니라, 아예 별도의 클래스로 분리해보자. 하지만 여전히 UserDao 에서 클래스를 생성해야하기때문에 UserDao는 ConnectionMaker클래스에 의존적이다.\n![](https://i.imgur.com/818CZkt.png)\n\n#### 인터페이스의 도입\n\n위에서 결국엔 클래스를 분리해도 데이터베이스를 연결하기 위해서는 지독한 의존성을 가지게된다. 이문제를 해결하기위해서는 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느스한 연결고리가 필요하다. 추상화란 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리하는 작업이다. 자바가 추상화를 위해 제공하는 가장 유용한 도구는 바로 인터페이스이다. 인터페이스를 통해 추상화를 하게되면 최소환의 통로를 통해 접근하는 쪽에서는 오브젝트를 만들때 사용할 클래스가 무엇인지 몰라도 된다.\n\n![](https://i.imgur.com/iCN1k2t.png)\n\n인터페이스를 도입했지만 여전히 자바에서 인터페이스를 통해 객체를 생성할때 아래와같이 new DConnectionMaker(); 선언을 해줘야하기떄문에 근본적인 문제가 해결되지않는다.\n\n```java\npublic UserDao(){\n  connectionMaker = new DConnectionMaker();\n}\n```\n\n#### 관계설정 책임의 분리\n![](https://i.imgur.com/ZBKuVCa.png)\n그래서 이러한 근본적인 문제를 해결하기 위해서는 인터페이스를 통해서 처음부터 관계를 설정해주면된다. 아래와같이.\n\n```java\npublic interface ConnectionMaker {\n    public Connection makeConnection() throws ClassNotFoundException, SQLException;\n}\n\npublic class DConnectionMaker implements ConnectionMaker {\n    public Connection makeConnection() throws ClassNotFoundException, SQLException {\n        // D 사의 독자적인 방법으로 Connection 을 생성하는 코드\n    }\n}\n\npublic class UserDao {\n    private ConnectionMaker connectionMaker; ㅡ> 인터페이스를 통해 오브젝트에 접근, so 구체적 클래스 정보가 필요 없다.\n\n    public UserDao(ConnectionMaker connectionMaker){\n        this.connectionMaker = connectionMaker;  \n    }\n\n    public void add(User user) throws ClassNotFoundException, SQLException {\n        Connection c = connectionMaker.makeConnection();\n      ㅡ> 인터페이스에 정의된 메소드를 사용하므로 클래스가 바뀐다고 메소드 이름이 변경 되지 않는다.\n    }\n\n    public user get(String id) throws ClassNotFoundException, SQLException {\n        Connection c = connectionMaker.makeConnection();\n    }\n}\n\n```\n\n이제 이렇게 의존성 주입을 해주게되면 ConnectionMaker의 역할을 할 수 있는 어떤 클래스가 들어와도 UserDao기능을 수행할 수 있게 된다.\n\n\n```java\npublic class UserDaoTest{\n    public static void main(String[] args) throws ClassNotFoundException, SQLException {\n        ConnectionMaker connectionMaker = new DConnectionMaker();\n        // UserDao가 사용할 ConnectionMaker 구현 클래스를 결정하고 오브젝트를 만든다.\n\n        UserDao dao = new UserDao(connectionMaker);\n        // 1. UserDao 생성\n        // 2. 사용할 ConnectionMaker 타입의 오브젝트 제공, 결국 두 오브젝트 사이의 의존관계 설정\n    }\n}\n```\n\n최종적으로 UserDaoTest와같이 UserDao를 즉 3자 호출하는곳에서 의존성 주입을하게되면 아래와같이 불필요한 의존관계를 끊을 수 있게된다. 이렇게되면 어떤 Connection이 들어와도 UserDao를 클래스 수정없이 UserDao클래스 기능을 사용할 수 있게된다.\n\n![](https://i.imgur.com/XghdksD.png)\n\n#### 1.3.4 원칙과 패턴\n\n##### 개방 폐쇄원칙\n개방 폐쇄 원칙은 깔끔한 설계를 위해 적용 가능한 객체지향 설계 원칙 중의 하나다. 클래스나 모듈은 확장에는 열려 있어야하고 변경에는 닫혀 있어야한다고 할 수 있다. UserDao는 DB연결 방법이라는 기능을 확장하는데는 열려있다. UserDao에는 전혀 영향을 주지 않고도 얼마든지 확장 가능하다. 잘설계된 객체지향 클래스의 구조를 살펴보면 바로 이 개방 폐쇄 원칙을 아주 잘 지키고 있다. 인터페이스를 사용해 확장 기능을 정의한 대부분의 API는 바로 개방 폐쇄 원칙을 잘 따르고 있다고 볼 수 있다.\n\n\n##### 높은 응집도와 낮은 결합도\n\n**높은 응집도 (같은 기능끼리 모여있다는것)**\n응집도가 높다는것은 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻, 하나의 모듈에서만 변경이 많이 일어나면 다른 모듈은 변경이 필요가 없을때를 말한다. 하나의 클래스에 여러가지 관심사가 모여있다면 그 관심사 하나가 변경되면 다른 영향을 미치짖 않는지 확인해야하는 이중의 부담이 생긴다. 예를들어 기존의 NConnectionMaker를 개선해서 2.0을 만들었다해보자. 그렇게되면 NConnectionMaker를 테스트하기위해서 모든 DAO를 테스트할필요는없다. 높은 응집도때문에 그냥 NConnectionMaker만 테스트해도 충분하다. ConnectionMaker를 분리해서 높은 응집도를 가지고있기 때문이다.\n\n**낮은 결합도**\n낮은 결합도는 높은 응집도 보다 더 민감한 원칙이다. 책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합도, 즉 느슨하게 연결된 형태를 유지하는것이 바람직하다. 결합도가 낮아지면 변화에 대응하느 속도가 높아지고, 구성이 깔끔해진다. 또한 확장하기에도 매우 편리하다. 예를들면 위에서 보여준 예제처럼 인터페이스를 통한 ConnectionMaker구현이 있을 수 있다.\n\n**전략패턴**\n개선한 UserDaoTest - UserDao - ConnectionMaker 구조를 디자인 패턴의 시각으로 보면 전략 패턴에 해당한다고 볼 수 있다. 전략패턴은 디자인 패턴의 꽃이라고 불릴만큼 다양하게 자주 사용되는 패턴이다. 개방 폐쇄 원칙의 실현에도 가장 잘 들어 맞는 패턴이라고 볼 수 있다. 전략 패턴은 자신의 기능 Context에서,필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용 할 수 있게 하는 디자인 패턴이다.\nUserDao는 전략패턴의 컨텍스트에 해당한다. 컨텍스트는 자신의 기능을 수행하는데 필요한 기능 중에서 변경 가능한, DB 연결 방식이라는 알고리즘을 ConnectionMaker라는 인터페이스로 정의하고, 이를 구현한 클래스, 즉 전략을 바꿔가면서 사용할 수 있게 분리했다.\n\n전략패턴은 컨텍스트(UserDao)를 사용하는 클라이언트(UserDaoTest)는 컨텍스트가 사용할 전략 (ConnectionMaker를 구현한 클래스, 예 DConnectionMaker)을 컨텍스트의 생성자등을 통해 제공해주는게 일반적이다.\n\n### 1.4 제어의 역전(IoC)\n\n#### 오브젝트 팩토리\n\nUserDaoTest는 기존에 UserDao가 직접 담당하던 기능, 즉 어떤 ConnectionMaker구현 클래스를 사용할지를 결정하는 기능을 엉겁결에 떠 맡았다. UserDao가 ConnectionMaker인터페이스를 구현한 특정 클래스로부터 완벽하게 독립할 수 있도록 UserDao의 클라이언트인 UserDaoTest가 그 수고를 담당하게 된 것이다.\n그런데 처음목적은 UserDaoTest는 UserDao의 기능이 잘 동작하는지를 테스트하려고 만든 것이다. 그런데 지금 또다른 책임까지 떠 맡고 있으니 UserDaoTest는 2개의 관심사를 가지고 있는것이다. 그러므로 두개의 관심사를 분리해줘야한다.\n\n##### 팩토리\n팩토리 클래스의 역할은 객체의 생성방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 것이다. 팩토리 클래스의 역할을 맡을 클래스는 DaoFactory이다. DaoFactory는 UserDaoTest에서는 DaoFactory에 요청해서 미리 만들어진 UserDao오브젝트를 가져와 사용하게 만든다.\n\n\n```java\n\npublic class DaoFactory{\n  public UserDao userDao(){\n    //팩토리메소는 UserDao탕ㅂ의 오브젝트를 어떻게 만들고 어떻게 준비시킬지 결정한다.\n    ConnectionMaker connectionMaker = new DConnectionMaker();\n    UserDao userDao = new UserDao(connectionMaker);\n\n    return userDao;\n  }\n}\n```\n\n아래와같이 이제 UserDaoTest는 더이상 UserDao가 어떻게 생성되는지 신경쓰지 않고 테스트하는것에만 집중할 수 있게된다.\n\n```java\npublic class UserDaoTest{\n  public static void main(String[] args) throws ClassNotFoundException,SQLException{\n    UserDao dao = new DaoFactory.userDao();\n    ...\n  }\n}\n```\n\n##### 설계도로서의 팩토리\n![](https://i.imgur.com/IxtsfLd.png)\n그림과 같이 UserDaoTest는 DaoFactory를통해 DConnectionMaker를 주입받아 사용하게된다.\n\n#### 오브젝트 팩토리의 활용\n만약 추가적인 Dao들이 추가된다고 생각해보자. 그러면 아래와같이 반복되는 코드가 발생하게된다.\n\n```java\npublic class DaoFactory{\n\n\n  public UserDao userDao(){\n    return new UserDao(new DConnectionMaker();)\n  }\n\n  public AccountDao userDao(){\n    return new UserDao(new DConnectionMaker();)\n  }\n\n  ...\n\n}\n```\n\n위의 문제를 해결할려면 ConnectionMaker를생성하는 아래의소스와같이 공통으로 뽑아내는 방법이있다.\n\n```java\n\npublic class DaoFactory{\n\n\n  public UserDao userDao(){\n    return new UserDao(new DConnectionMaker();)\n  }\n\n  public AccountDao userDao(){\n    return new UserDao(new DConnectionMaker();)\n  }\n\n  ...\n\n  public ConnectionMaker connectionMaker(){\n    return new DConnectionMaker();\n  }\n\n}\n```\n\n위와같이 소스를 변경하게되면 ConnectionMaker부분만 수정하게되면 Dao팩토리 메소드가 많아져도 ConnectionMaker의 메소드만 변경하게되면 모든 커넥션마커의 기능들이 수정되기때문에 시간을 절약할수 있게 된다.\n\n#### 제어권의 이전을 통한 제어관계 역전\n일반적으로 프로그램의 흐름은 main() 메소드와 같이 프로그램이 시작되는 지점에서 다음에 사용할 오브젝트를 결정하고 결정한 오브젝트를 생성하고, 만들어진 오브젝트를 사용한다. 언제 어떻게 오브젝트를 만들지를 스스로 관장한다. 모든 종류의 작업을 사용하는 쪽에서 제어하는 구조이다. 제어의 역전은 이런 제어 흐름의 개념을 거꾸로 뒤집는 것이다. 제어의 역전에서는 모든 제어의 권한을 자신이 아닌 다른 대상에게 위임한다.\n제어의 역전 개념은 이미 서블릿에서도 사용되고있다. 서블릿에 대한 제어권한을 가진 컨테이너가 적절한 시점에 서블릿 클래스의 오브젝트를 만들고 그안의 메소드를 호출한다. 이렇게 서블릿이나, JSP, EJB에서는 간단한 방식으로 제어의 역전 개념이 적용되어 있다.\n\n### 1.5 Spring IoC\n스프링의 핵심을 담당하는 건 바로 빈팩토리, 또는 ApplicationContext라고 불리는 것이다. 이것은 우리가 만든 DaoFactory가 하는 일을 스프링에서 좀더 일반화한 것이라고 할 수 있다\n\n#### 제어권의 이전을 통한 제어관계 역전\n스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 빈이라고 부른다. 스프링에서 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 빈팩토리라고 한다. 보통 빈팩토리보다는 이를 좀더 확장한 ApplicationContext를 주로 사용한다.\nApplicationContext는 별도의 정보를 참고해서 빈의 생성, 관계설정등의 제어 작업을 총괄한다. DaoFactory에서는 어떤 클래스의 오브젝트를 생성할지 어떻게 연결할것인지에 대해 설정을 해줬었다. 하지만 ApplicationContext는 직접 이런정보를 담지 않고 별도로 설정정보를 담고 있는 자바 @Configuration 설정되어져 있는 자바클래스의 정보를 가져와 이를 활용하는 범용적인 Ioc 엔진이라고 할 수 있다.\n\n##### DaoFactory를 사용하는 ApplicationContext\nDaoFactory를 스프링의 빈팩토리(ApplicationContext)가 사용할수있도록 설정 정보를 만들 것이다. 먼저 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스라고 인식할수 있도록 @Configuration 이라는 어노테이션을 추가한다. 그리고 오브젝트를 만들어주는 메소드에는 @Bean 이라는 어노테이션을 추가한다.\n\n```java\n\n@Configuration // 애플리케이션 컨텍스트 또는 빈 팩토리가 사용할 설정정보라는 표시\npublic class DaoFactory{\n\n  @Bean // 오브젝트를 새엉을 담당하는 IoC용 메소드라는 표시\n  public UserDao userDao(){\n    return new UserDao(connectionMaker());\n  }\n\n  @Bean\n  public ConnectionMaker connectionMaker(){\n    return new DConnectionMaker();\n  }\n}\n\n```\n\n이제 아래와같이 준비된 ApplicationContext의 getBean()이라는 메소드를 이용해서 UserDao의 오브젝트를 가져올 수 있다.\n\n```java\n\npublic class UserDaoTest{\n  public static void main(String[] args) throws ClassNotFoundException,SQLException{\n    ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);\n    UserDao dao = context.getBean(\"userDao\",UserDao.class);\n    ...\n  }\n\n}\n\n```\n\ncontext.getBean(\"userDao\",UserDao.class);의 userDao는 DaoFactory 메소드의 이름이다. 어떻게 메소드의 이름을 설정하느냐에따라 빈을 가지고올때 String값을 변경해주면 된다.\n\n\n#### ApplicationContext의 동작 방식\n스프링에서 ApplicationContext를 IoC컨테이너라고 하기도하고 간단히 스프링 컨테이너라고도 한다. @Configuration이 붙은 DaoFactory는 ApplicationContext가 활용하는 IoC설정정보다. 내부적으로 애플리케이션 컨텍스가 DaoFactory의 userDao() 메소드를 호출해서 오브젝트를 가져온 것을 클라이언트가 getBean()으로 요청할 때 전달 해준다. 아래 그림은 ApplicationContext의 사용되는 방식이다.\n\n![](https://i.imgur.com/Uf9J8vi.png)\n\n##### ApplicationContext를 사용했을때 장점\n1. 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.\n2. 애플리케이션 컨텍스트는 종합 IoC서비스를 제공해준다.\n  오브젝트가 만들어지는 방식, 오브젝트에 대한 후처리, 정보의 조합 설정 방식의 다변화, 인터셉티등 오브젝트를 효과적으로 활용할 수 있는 다양한 기능을 제공한다.\n3. 애플리케이션 컨텍스트는 빈을 검색하는 다양한방법을 제공한다.\n  타입만으로도 빈을 검색하거나 특별한 애노테이션 설정이 되어있는 빈을 찾을 수 도 있다.\n\n\n\n### 1.6 싱글톤 레지스틀와 오브젝트 스코프\nDaoFactory와 @Configuratuon애노테이션을 추가해서 스프링의 애플리케이션 컨텍스트를 사용하는것의 차이점에 대해서 알아볼것이다. 둘의 큰 차이점은 리턴해주는 빈의 동일성을 보장 해주는것이다. 먼저 아례의 예제를 보자\n\n```java\nDaoFactory factory = new DaoFactory();\nUserDao dao1 = factory.userDao();\nUserDao dao2 = factory.userDao();\n\nSystem.out.println(dao1); //springbook.dao.UserDao@118f375\nSystem.out.println(dao2); //springbook.dao.UserDao@117a8bd\n```\n\n출력결과에서 알수 있듯이 동일성이 보장되지 않는 객체들이 출력된다. 그럼 스프링 컨테이너를 이용해서 빈을 호출해 볼 것이다.\n\n```java\nApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);\n\nUserDao dao3 = factory.userDao();\nUserDao dao4 = factory.userDao();\n\nSystem.out.println(dao3); //springbook.dao.UserDao@ee22f7\nSystem.out.println(dao4); //springbook.dao.UserDao@ee22f7\n```\n\n스프링 컨테이너 즉 ApplicationContext를 통해 생성한 오브젝트는 동일성을 보장해준다. 여러번에 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 리턴해준다.\n\n#### 싱글톤 레지스트리로서의 애플리케이션 컨텍스트\nApplicationContext는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이다. 스프링은 기본적으로 별다른 설정을 하지 않으면 내부에 생성하는 빈오브젝트를 모두 싱글톤으로 생성한다.\n\n##### 서버 애플리케이션 싱글톤\n스프링에서 싱글톤을 사용하는 이유는 스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버 환경이기 때문이다. 물론 스프링으로 PC등에서 동작하는 독립형 윈도우 프로그램으로도 개발할수 있긴 하지만 극히 드물다.\n스프링이 처음 설계됐던 대규모의 엔터프라이즈 서버환경은 서버 하나당 최대로 초당 수십에서 수백 번씩 브라우저나 여타 시스템으로부터의 요청을 받아 처리할 수 있는 높은 성능이 요구되는 환경이었다. 또 하나의 요청을 처리하기위해 데이터 액세스로직, 서비스로직, 비지니스로직,프레젠테이션로직등의 다양한 기능을 담당하는 오브젝트들이 참여하는 계층형 구조였다.\n그런데 매번 클라이언트에서 요청이 들어 올때마다 각로직을 담당하는 오브젝트를 새로 만들어본다고 생각해보자. 요청 한번에 5개의 오브젝트가 새로 만들어지고 초당 500개의 요청이 들어오면 초당 2500개의 새로운 오브젝트가 생성된다. 1분이면 십오만개, 한시간이면 9백만개의 새로운 오브젝트가 만들어진다. 아무리 자바의 가비지컬렉션의 성능이 좋아졌다고 한들 이렇게 부하가 걸리면 서버가 감당하기 힘들다.\n엔터프라이즈 환경에서의 서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작한다. 서블릿 클래스당 하나의 오브젝트만 만들어 두고, 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용된다.\n이렇게 애플리케이션 안에 제한된 수, 대개 한개의 오브젝트만 만들어서 사용하는 것이 싱글톤 패턴의 원리이다.따라서 서버 환경에서는 서비스 싱글톤의 사용이 권장된다.\n\n##### 싱글톤 패턴의 한계\n싱글통 패턴을 적용한 UserDao\n\n```java\npublic class UserDao{\n  private static UserDao INSTANCE;\n  ...\n\n  private UserDao(ConnectionMaker connectionMaker){\n    this.connectionMaker = connectionMaker;\n  }\n\n  public static synchronized UserDao getInstance(){\n    if(INSTANCE == null) INSTANCE = new UserDao(???);\n    return INSTANCE;\n  }\n}\n```\n\n싱글톤의 단점\n```\n-private  생성자를 갖고 있기 때문에 상속할 수 없다.\n-싱글톤은 테스트하기가 힘들다.\n-서버환경에서는 싱글톤이 하나만 만들어지는것을 보장하지 못한다\n-싱글톤의 사용은 전역상태를 만들 수 있기 때문에 바람직하지 못하다.\n```\n\n##### 싱글톤 레지스트리\n자바의 기본적인 싱글톤 패턴의 구현 방식은 여러가지 단점이 있기 때문에 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다. 그것이 바로 싱글톤 레지스트리이다. 스프링 컨테이너는 싱글톤을 생성하고, 관리하고 공급하는 싱글톤 관리 컨테이너이기도 하다. 싱글톤 레지스트리는 스태틱메소드와 private생성자등을 사용해야하는 비정상적인 클래스가 아닌 평범한 자바 클래스를 싱글톤으로 활용하게 해준다.\n\n\n#### 싱글톤과 오브젝트의 상태\n싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있다. 따라서 상태 관리(전역변수)에 주의 해야한다. 기본적으로 클래스내에서 전역변수를 사용하지 말아야한다. 다중 사용자의 요청을 한꺼번에 처리하는 스레드들이 동시에 싱글톤오브젝트의 전역변수를 수정하는것은 매우 위험하다. 저장할 공간이 하나 뿐이니 서로 값을 덮어쓰고 자신이 저장하지 않은값을 읽어 오거나 삭제할수있기때문이다. 물론 읽기전용의 전역변수는 사용해도좋다. 이런 변수들은 final로 선언해주는거시 안전하다. 메소드안에는 지연변수(스택 영역에 저장되어져있다)이기떄문에 메소드 호출후에 초기화된다.\n\n#### 스프링 빈의 스코프\n스프링 내에서 빈이 생성되고 존재하고 등의 적용되는 범위에대해 스프링에서는 이것을 스코프라고한다. 기본적으로 프로토타입,요청,세션등으로 분리하여 관리해주는 스코프 범위가 존재한다.\n\n\n### 1.7 의존과계 주입(DI)\n#### 제어의 역전과 의존관계 주입\n여기에서 한가지 짚고 넘어갈 것은 IoC라는 용어인데, IoC가 매우 느슨하게 정의돼서 폭넓게 사용되는 용어라는것이다. 때문에 스프링을 IoC 컨테이너라고만 해서는 스프링이 제공하는 기능의 특징을 명확하게 설명하지 못했다. 그래서 나온말이 IoC방식을 핵심을 짚어주는 의존관계 주입(DI)이다. 스프링의 IoC 기능의 대표적인 동작원리는 주로 의존관계 주입이라고 불린다. 스프링이 여타 프레임워크와 차별화돼서 제공해주는 기능은 의존관계 주입이라는 새로운 용어를 사용할 때 분명하게 드러난다. 초기에는 주로 IoC 컨테이너라고 불리던 스프링이 지금은 의존관계 주입 컨테이너 또는 그영문약자를 써서 DI컨테이너라고 더 많이 불리고 있다.\n\n#### 런타임 의존관계 설정\n##### 의존관계\n두 개의 클래스 또는 모듈이 의존관계에 있다고 말할 때는 항상 방향성을 부여해줘야 한다. 즉 누가 누구에게 의존하는 관계 있다는 식어야한다. A클래스가 B에 의존하고 있을때 B가 변동사항이 있으면 A에 영향을 미치게된다. 하지만 A가 변경된다고해서 B는 영향 받지 않는다.\n\n##### UserDao의 의존관계\n![](https://i.imgur.com/Am2R3Z3.png)\n위 그림은 UserDao가 ConnectionMaker에 의존하고 있는 형태이다. ConnectionMaker인터페이스가 변한다면 그영향은 UserDao가 받을 것이다. 하지만 ConnectionMaker의 구현체인 DConnectionMaker등이 바뀌거나 내부적으로 메소드가 변화가 생겨도 UserDao에 영향을 주지 않는다. 이렇게 인터ㅔ이스대해서만 의존관계를 만들어두면 인터페이스를 구현 클래스와의 관계는 느슨해지면서 변환에 영향을 덜 받는 상태가 된다. 인터페이스를 통해 의존관계를 제한해주면 그만큼 변경에서 자유로워지는 셈이다.\n그런데 모델이나 코드에서 클래스와 인터페이스를 통해 드러나는 의존관계말고, 런타임시에 오브젝트 사이에서 만들어지는 의존관계도 있다. 의존과계 또는 오브젝트 의존 관계인데, 설계 시점의 의존관계가 실체화된 것이라고 볼 수 있다. 런타임 의존관계는 모델링 시점의 의존관계와는 성격이 분명히 다르다.\n인터페이스를 통해 설계 시점에 느슨한 의존관계를 갖는 경우에는 UserDao의 오브젝트가 런타임 시에 사용할 오브젝트가 어떤 클래스로 만든것인지 미리 알 수 가없다. 프로그램이 시작되고 UserDao 오브젝트가 만들어지고 나서 런타임 시에 의존관계를 맺는 대상, 즉 실제 사용대상인 오브젝트를 의존 오브젝트라고 한다.\n\n의존관계 주입은 이렇게 구체적인 의존 오브젝트와 그것을 사용할 주체, 보통 클라이언트라고 부르는 오브젝트를 런타임시에 연결해주는 작업을 말한다. UserDao는 ConnectionMaker 인터페이스라는 매우 단순한 조건만 만족하면 어떤 클래스로부터 만들어졌든 상관없이 오브젝트를 받아 들이고 사용한다.\n\n\n>의존관계주입이란\n-클래스 모델(UML)이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야한다.\n-런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정한다.\n-의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부주에서 제공(주입)해줌으로써 만들어진다.\n\n\n의존관계 주입의 핵심은 설계 시점에는 알지 못했던 두 오브젝트의 관계를 맺도록 도와주는 제 3의 존재가 있다는것이다. DI에서 말하는 제 3의 존재는 바로 관계설정 책임을 가진 클래스 라고 볼 수 있다. DaoFactory,ApplicationContext,Ioc컨테이너등이 모두 외부에서 오브젝트 사이의 런타임 관계를 맺어주는 책임을 지닌 제 3의 존재라고 볼 수 있다.\n\n##### UserDao의 의존관계 주입\n다시 처음에 봤던 UserDao 에 적용된 의존관계 주입 기술을 다시 살펴보자. 인터페이스를 사이에 두고 UserDao와 ConnectionMaker구현클래스간에 의존관계를 느슨하게 만들긴 했지만, 마지막으로 남은 문제가 있었는데 아래소스와같이 UserDao가 사용할 구체적인 클래스를 알고 있어야 하는점이다.\n\n```java\npublic UserDao(){\n  connectionMaker = new DConnectionMaker();\n}\n\n```\n\n이코드는 이미 설계 시점에 구체적인 런타임 의존관계 오브젝트를 알고 있다. 즉 DConnectionMaker오브젝트를 사용하겠다는 것 까지 UserDao가 결정하고 관리하고 있는셈이다.\n\n이코드의 문제는 이미 런타임시의 의존관계가 코드 속에 미리 다 결정되어있다는 것이다. 그래서 Ioc방식을 써서 UserDao로부터 런타임 의존관계를 드러내는 코드를 제거하고, 제 3의 존재에 런타임 의존관계 결정을 권한을 위함하는것이다. 그래서 최종적으로 만들어졌던것이 DaoFactory이다. DaoFactory는 런타임시점에 UserDao가 사용할 ConnectionMaker타입의 오브젝트를 결정하고 이를 생성한후에 UserDao의 생성자 파라미터로 주입해줌으로써 런타임 의존관계를 맺게 해준다. 이렇게 런타임시 주입의 기능을 수행함으로써 DaoFactory를 DI/IoC컨테이너라고도 한다.\n\nDI컨테이너느 자신이 결정한 의존관계를 맺어줄 클래스의 오브젝트를 만들고 이생성자를 파라미터로 오브젝트의 레퍼런스를 전달해준다. 그럼 아래 소스같이 생성자 파라미터를 통해 전달받은 런타임 의존관계를 갖는 오브젝트는 인스턴스 변수에 저장 해둔다.\n\n```java\npublic class UserDao{\n\n  private ConnectionMaker connectionMaker;\n\n  public UserDao(ConnectionMaker connectionMaker){\n    this.connectionMaker = connectionMaker;\n  }\n\n}\n```\n\n이렇게 해서 두 개의 오브젝트 간에 런타임 의존관계 만들어졌다. UserDao 오브젝트는 이제 생성자를 통해 주입받은 DConnectionMaker 오브젝트를 언제든 사용하면 된다. DI는 자신이 사용할 오브젝트에 대한 선택권과 생성 제어권을 외부로 넘기고 자신은 런타임시에 수동적로 주입받은 오브젝트를 사용한다는 점에서 IoC의 개념에 잘 들어 맞는다. 스프링 컨테이너의 IoC는 주로 의존관계 주입 또는 DI라는 데 초점이 맞춰져 있다. 그래서 스프링을 IoC컨테이너 외에도 DI컨테이너 또는 DI프레임워크라 한다.\n\n\n\n#### 의존관계 검색과 주입\n스프링이 제공하는 IoC방법에서 오브젝트를 주입하는 방법 의존성 주입만 있는것은 아니다. 의존 관계를 맺는 방법이 외부로부터의 주입이 아니라 스스로 검색을 이용하는 의존관계 검색이 있다. 의존관계 검색은 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾는다. 물론 자신이 어떤 클래스의 오브젝트를 이용할지는 결정하지 않는다. 의존관계 검색은 런타임 시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트의 생성작업은 외부 컨테이너에게 맡기지만, 이를 가져올때는 메소드나 생성자를 통한 파라미터 전달이 아닌 아래 소스와같이 직접 컨테이너에게 요청하는 방식이다.\n\n```java\npublic UserDao(){\n  DaoFactory daoFactory = new DaoFactory();\n  this.connectionMaker = daoFactory.connectionMaker();\n}\n```\n\n위와같이 생성해도 여전히 자신이 어떤 ConnectionMaker 오브젝트를 사용할지 미리 알지 못한다. 여전히 코드의 의존대상은 ConnectionMaker인터페이스이기 때문이다. 런타임시에 DaoFactory가 만들어서 돌려주는 오브젝트와 다이내믹하게 런타임 의존관계를 맺는다. 따라서 IoC개념을 잘 따르고 있으며, 그혜택을 받는 코드다. 하지만 적용방법은 외부로부터의 주입이 아니라 스스로 IoC 컨테이너인 DaoFactory에게 요청하는것이다.\n위소스의 작업을 일반화한 스프링의 애플리케이션 컨텍스트라면 미리 정해놓은 이름을 전달해서 그 이름에 해당하는 오브젝트를 찾게 된다. 따라서 이를 일종의 검색이라고 볼 수 있다. 또한 그 대상이 런타임 의존관계를 가질 오브젝트이므로 의존관계 검색이라고 부르는 것이다.\n스프링의 IoC 컨테이너인 애플리케이션 컨텍스트는 getBean이라는 메소드를 제공한다. 바로 이메소드가 의존관계를 검색에 사용되는것이다. 이것은 아래의 예제와같이 사용 할 수 있다.\n```java\npublic UserDao(){\n  AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.clas);\n\n  this.connectionMaker = context.getBean(\"connectionMaker\",ConnectionMaker.class);\n}\n```\n\n의존관계 검색은 기존 의존관계 주입의 거의 모든 장점을 갖고 있다. 하지만 코드면에서 좀 더 의존관계주입이 단순하고 깔끔하다. 의존관계 검색은 코드안에 오브젝트 팩토리 클래스나 스프링 API가 나타난다. 검색 방식을 이용하면 그안에서 컨텍스트를 만들고, 호출하고등의 불필요한 소스를 넣어줘야하기 때문이다. 따라서 대개는 의존관계주입방식을 사용하는것이 낫다.\n\n```java\n\npublic class UserDaoTest{\n  public static void main(String[] args) throws ClassNotFoundException,SQLException{\n    ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);\n    UserDao dao = context.getBean(\"userDao\",UserDao.class);\n    ...\n  }\n\n}\n```\n\n하지만 위에 소스처럼 static 메소드인 Main같은경우에는 DI를 이용해 오브젝트를 주입받을 방법이 없기 때문이다. 이러한경우 말고는 의존성주입을 받아 사용하는게 소스면에서 훨씬 깔끔하다.\n\n#### 의존관계 주입의 응용\n##### 부가기능 추가\n다음 이런경우를 한번 생각해보자. DAO가 DB를 얼마나 많이 연결해서 사용하는지 파악하고 싶다. DB연결횟수를 카운팅하기 위해 무식한 방법으로 모든 DAO의 makeConnection() 메소드를 호출하는 부분에 새로 추가한 카운터를 증가시키는 코드를 넣는것은 엄청난 낭비이고 노가다다.  그리고 무엇보다 DAO코드를 손대는것은 지금까지 피하려고했던 행동을 하는 것이다.\nDI 컨테이너에서라면 아주 간단한 방법으로 해결가능하다. DAO와 DB 커넥션을 만드는 오브젝트 사이에 열결횟수를 카운팅하는 오브젝트를 하나 더 추가하는 것이다.\n\n```java\npublic class CountingConnectionMaker implements ConnectionMaker{\n  int counter = 0;\n  private ConnectionMaker realConnectionMaker;\n\n  public CountingConnectionMaker realConnectionMaker(ConnectionMaker realConnectionMaker){\n    this.realConnectionMaker = realConnectionMaker;\n  }\n\n  public Connection makeConnection() throws ClassNotFoundException,SQLException{\n    this.counter++;\n    return realConnectionMaker.makeConnection();\n  }\n\n  public int getCounter(){\n    return this.counter;\n  }\n}\n```\nCountingConnectionMaker 클래스는 ConnectionMaker 인터페이스를 구현했지만 내부에서 직접 DB커넥션을 만들지 않는다. 대신 DAO가 DB커넥션을 가져올 때마다 호출하는 makeConnection()에서 DB연결횟수 카운터를 증가시킨다.CountingConnectionMaker는 자신의 관심사인 DB 연결횟수 카운팅 작업을 마치면 실제 DB 커넥션을 만들어주는 realConnectionMaker에 저장된 ConnectionMaker타입 오브젝트의 makeConnection()호출해서 그 결과를 DAO에 돌려준다.\n\n생성자를 보면 ConnectionConnectionMaker도 DI를 받는것을 알 수 있다. UserDao는 ConnectionMaker의 인터페이스에만 의존하고 있기 때문에 ConnectionMaker 를 구현하고있는 어떤 구현체라도 DI가 가능하다. 그래서 DI받는 오브젝트를 DConnection오브젝트를 대신 CountingConnectionMaker를 받은것이다. 그리고 그 CountingConnectionMaker는 DConnectionMaker를 의존주입을 받은것이다.\n![](https://i.imgur.com/EfluSD4.png)\n![](https://i.imgur.com/Am2R3Z3.png)\n이렇게해서 CountingConnectionMaker 재구성된 새로운 런타임 의존관계는 위 그림과 같다. 우의 그림을 코드라바꾸면 아래와같이 만들 수 있다.\n```java\n@Configuration\npublic class CountingDaoFactory{\n  @Bean\n  public UserDao userDao{\n    return new UserDao(ConnectionMaker());\n  }\n\n  @Bean\n  public ConnectionMaker connectionMaker(){\n    return new CountingConnectionMaker(realConnectionMaker());\n  }\n\n  @Bean\n  public ConnectionMaker realConnectionMaker(){\n    return new DConnectionMaker();\n  }\n}\n```\n\n이제 커넥션 카운팅을 위한 실행 코드를 만들어보자. 기본적으로 UserDaoTest와 같지만 설정요 클래스를 CountingDaoFactory로 변경해줘야한다. 그리고 CountingConnectionMaker빈을 가져온다. 설정정보에 지정된 이름과 타입만 알면 특정 빈을 가져 얼 수 있으니 CoutingConnectionMaker 오브젝트를 가져오는 건 간단하다.\n\n```java\n\npublic class UserDaoConnectionCountingTest{\n  public static void main(String[] args) throws ClassNotFoundException,SQLException{\n    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(CountingDaoFactory.class);\n    UserDao dao = context.getBean(\"userDao\",UserDao.class);\n\n    //\n    //DAO 사용코드\n    //\n\n    CountingConnectionMaker ccm = context.getBean(\"connectionMaker\",CountingConnectionMaker.class);\n    System.out.println(\"Connection counter :\" + ccm.getCounter());\n  }\n}\n```\n이렇게 함으로써 DBConnection 분석이 끝나면 다시 CountingDaoFactory 설정 클래스를 DaoFactory로 변경하거나 connectionMaker()메소드를 수정하는 것만으로 DAO의 런터암 의존관계는 이정상태로 복구된다.\n\n#### 메소드를 이용한 의존관계 주입\n간단하게 설명하자면 스프링에서 의존섭을 주입하는 방법은 생성자를 이용하는 방법뿐만 아니라 아래와 같이 setter아니면 직접 메소드를 정의해서 의존성을 주입하는 방법이있다.\n```java\npublic class UserDao{\n  private ConnectionMaker connectionMaker;\n\n  public void setConnectionMker(ConnectionMaker connectionMaker){\n    this.connectionMaker = connectionMaker;\n  }\n}\n```\n```java\n@Bean\npublic UserDao userDao(){\n  UserDao userDao = new UserDao();\n  userDao.setConnectionMaker(connectionMaker());\n  return userDao;\n}\n```\n단지 의존관계를 주입하는 시점과 방법이 달라졌을 뿐 결과는 동일하다.\n\n[예제소스](https://github.com/minwan1/Spring-toby)\n\n### 정리\n- 단일 책임원칙 기반하여 책임별로 클래스들을 나누었다. 예제를 보면 UserDao 같은경우에는 데이터 액세스에 관한 관심의 역할을 부여받음으로써 데이터 엑세스에대한 책임을 수행하고있다. ConnectionMaker 같은경우에는 데이터베이스 Connection방법을 설정을 할수 있는 역할을 부여받음으로써 데이터베이스 Connection방법에 관한 책임만을 가진다. 이렇게 명확하게 둘의 책임을 나눔으로써 데이터엑스세에 대한 비지니스로직을 변경한다거나 데이터베이스 Connection 방법을 변경한다거나할 때 서로의 영향을 안받는 독립적인 구조를 만들어 냈다.\n- 개방 폐쇄 원칙에 기반하여 클래스들을 나누었다. ConnectionMaker같은경우 인터페이스로 가져감으로써 데이터베이스 Connection 방법을 변경할때 거기에 맞는 구현체만 구현하게 되면 쉽게 데이베이스 Connection방법을 바꿀 수 있게 되었다. 또한 그 구현체 ConnectionMaker들은 데이터베이스 Connection 방법이 변경되지 않는 이상 바뀌지 않을 소스이다. 이런점을 보아서 개방 폐쇄원칙을 잘 준수했다고 볼 수 있다.\n- 오브젝트를 생성되고 관계를맺는 제어권을 별도의 오브젝트 팩토리로 만들었다. 객체를 직접 관리하지않고 팩토리를 통해 관리함으로써 기능들을 부품처럼 쉽게 바꿀수 있게 되었다.(제어의 역전/IOC)\n","source":"_posts/2018-06-07-Toby-1.md","raw":"---\ntitle: Toby-1 오브젝트와 의존관계\ncatalog: true\ndate: 2018-06-07\nsubtitle:\nheader-img:\ntags:\n- Java\n- Spring\n- Toby\n\n\n---\n\n# 토비의 스프링\n이글은 [토비님의 스프링책](http://book.naver.com/bookdb/book_detail.nhn?bid=7006516)을 보고 요약한 내용입니다\n\n## 1장 오브젝트와 의존관계\n**들어가며**\n스프링이 자바에서 가장 중요하게 가치를 두는것은 바로 객체지향프로그래밍이 가능한 언어라는 점이다.  자바 엔터프라이즈 기술의 혼란속에서 잃어버렸던 객체지향 기술의 진정한 가치를 회복시키고 폭넓은 혜택을 누릴 수 있도록하는것이 스프링 철학이다. 그래서 스프링에서 관심을 많이두는것은 오브젝트의 생명주기이다. 그렇기 때문에 우리는 스프링이 어떤것이고, 무엇을 제공하는지 보다는 스프링이 관심을 갖는 대상인 오브젝트의 설계와 구현, 동작원리에대해 관심을 가져야한다.\n\n### 1.1 초난감 DAO\n먼저 간단하게 아래와같이 JDBC를 이용한 User CURD를 다룰것이다. 예제에서는 롬복을 사용하여 객체를 다룰것이다. 그리고 데이터베이스는 Inmemory DB인 H2를 사용할것이다.\n\n```java\n@Getter\n@Setter\n@NoArgsConstructor\npublic class User {\n    private String id;\n    private String name;\n    private String password;\n\n\n    @Builder\n    public User(String id, String name, String password) {\n        this.id = id;\n        this.name = name;\n        this.password = password;\n    }\n\n\n}\n\n```\n\n유저의 정보에 접근할 수 있는 DAO를 아래와같이 만들자.\n\n```java\npublic class UserDao {\n    public void add(User user) throws ClassNotFoundException, SQLException {\n        Class.forName(\"org.h2.Driver\");\n        Connection c = DriverManager.getConnection(\"jdbc:h2:tcp://localhost:9092/mem:testdb;MVCC=TRUE\", \"sa\", \"\");\n\n        PreparedStatement ps = c.prepareStatement(\"insert into users(id, name, password) values (?, ?, ?)\");\n        ps.setString(1, user.getId());\n        ps.setString(2, user.getName());\n        ps.setString(3, user.getPassword());\n\n        ps.executeUpdate();\n\n        ps.close();\n        c.close();\n    }\n\n    public User get(String id) throws ClassNotFoundException, SQLException {\n        Class.forName(\"org.h2.Driver\");\n        Connection c = DriverManager.getConnection(\"jdbc:h2:tcp://localhost:9092/mem:testdb;MVCC=TRUE\", \"sa\", \"\");\n\n        PreparedStatement ps = c.prepareStatement(\"select * from users where id = ?\");\n        ps.setString(1, id);\n\n        ResultSet rs = ps.executeQuery();\n        rs.next();\n\n        User user = new User();\n        user.setId(rs.getString(\"id\"));\n        user.setName(rs.getString(\"name\"));\n        user.setPassword(rs.getString(\"password\"));\n\n        rs.close();\n        ps.close();\n        c.close();\n\n        return user;\n    }\n}\n\n```\n그다음은 실제 User 정보가 담길 디비를 아래와같이 만들어보자.\n```sql\nCREATE TABLE users (\n  id          varchar(10) primary key,\n  name varchar(20) not null,\n  password varchar(10) not null\n);\n```\n\n이제 만들어진 코드를 바탕으로 테스트 코드를 아래와같이 작성해보자.\n\n```java\npublic static void main(String[] args) throws ClassNotFoundException, SQLException {\n    UserDao dao = new UserDao();\n\n    User user = new User();\n    user.setId(\"whiteship\");\n    user.setName(\"백기선\");\n    user.setPassword(\"married\");\n\n    dao.add(user);\n\n    System.out.println(user.getId() + \" 등록 성공\");\n\n    User user2 = dao.get(user.getId());\n    System.out.println(user2.getName());\n    System.out.println(user2.getPassword());\n    System.out.println(user2.getId() + \" 조회 성공\");\n}\n\n```\n\n위와같이 이제 테스트코드를 돌리게되면 데이터베이스를 통해 유저를 등록하고 조회를 할 수 있게 된다. 사실 위코드에서 소스가 작동하는데는 큰문제가 없다. 하지만 잠재적으로 엄청난 버그를 가지고있는 소스임은 분명하다. 그래서 위의 소스를 좀더 안전하고, 유지보수하기 좋은 소스를 만들기위해서 스프링과 결합하여 좀 더 효과적으로, 객체지향적으로 만들어나가는 방법에 대해 알아볼것이다.\n\n### 1.2 DAO 분리\n\n#### 커넥션만들기의 추출\n\n먼저 중복된 코드가 무엇인지에대해 생각하여야한다. 먼저 앞에서 만든 UserDao의 중복코드를 제거하기 위해서 관심사항들을 뽑아보자.\n\n* DB와 연결을 위한 커넥션을 가져오는 부분이다.\n* 사용자 등록을 위해 DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행하는 것 또한 계속 중복되고 있다.\n* 셋째는 작업이 끝나고 리소스들을 종료해주는 부분이다.\n\n먼저 DB와 연결을 위한 커넥션 부분을 제거해보자. getConnetion 메소드로 빼서 연결이 필요할때는 그메소드를 호출하는것이다.\n```java\npublic User get(String id)  throws ClassNotFoundException,SQLException{\n  Connection c = getConnetion();\n}\n\nprivate Connection getConnection() throws ClassNotFoundException,SQLException{\n  class.forName(\"com.mysql.jdbc.Driver\");\n  Connection C = DriverManager.getConnection(\"jdbc:mysql://localhost/springbook\",\"spring\",book);\n  return c\n}\n```\n위에 getConnection메소드는 관심의 종류에 따라 메소드 구분 해놓았다. 그렇기 때문에 한가지 관심 예를들어 데이터베이스의 종류를 바꾸는 등의  문제에서 하나의 메소드에 소스만 변경하게 되면 손쉽게 데이터 베이스를 변경할 수 있게 해준다. 기존 소스같은경우에는 스키마등이 변경된다고 치면 모든 스키마 URL등을 변경해줘야 했을것이다.\n\n#### DB커넥션 만들기의 독립\n이번에는 좀더 변화를 반기는 DAO를 만들것이다.\n\n**상속을 통한 확장**\n![](https://i.imgur.com/zpT9cHZ.png)\n\n위그림과 같이 UserDao를 추상클래스로 선언 하면 좀더 확장성 있는 소스가 될 것이다. 이렇게 선언하게되면 추상클래스에 add와 get만 메소드를 구현하고 getConnection은 깡통메소드로 나두게되면 NUserDao, DUserDao에서 getConnection만 구현하게되면 2개의 각기 다른 디비를 붙일 수 있다.\n\n이렇든 UserDao와같은 슈퍼클래스는 기본적인 로직의 흐름(커넥션가져오기,sql생성,실행,반환)만들고 서브클래스는 메소드를 구현하는 패턴을 템플릿 메소드 패턴이라고 한다. 템플릿 메소드 패턴은 스프링에서 애용하는 패턴이다.\n\n![](https://i.imgur.com/RSH9tOC.png)\n\n### 1.3 DAO의 확장\n모든 오브젝트는 변한다. 그런데 오브젝트가 다 동일한 방식으로 변하는건 아니고 공통 관심사에 따라 변한다. 지금까지 크게 두가지를 다뤘다.\n1. 데이터를 어떻게 접근할것인가\n2. 어떻게 데이터베이스를 쉽게 변경할것인가.\n\n위의 소스로 장점은 데이터 접근 방식이 수정된다면 우리는 UserDao를 변경할것이다. 만약 DB에서 꺼내온 정보를바탕으로 뭔가 정보가 수정된다면 그 구현체들 MUserDao, DUserDao가 수정될것이다. 이것은 것으로 보면 서로에게 영향을 안주는것같지만 상속이라는 방법을 사용했기때문에 지독한 의존성을 가진다. 다음에서부터는 그 의존성을 좀더 느슨하게 할것이다.\n\n#### 클래스의분리\nDB 커넥션과 관련된 부분을 서브클래스가 아니라, 아예 별도의 클래스로 분리해보자. 하지만 여전히 UserDao 에서 클래스를 생성해야하기때문에 UserDao는 ConnectionMaker클래스에 의존적이다.\n![](https://i.imgur.com/818CZkt.png)\n\n#### 인터페이스의 도입\n\n위에서 결국엔 클래스를 분리해도 데이터베이스를 연결하기 위해서는 지독한 의존성을 가지게된다. 이문제를 해결하기위해서는 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느스한 연결고리가 필요하다. 추상화란 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리하는 작업이다. 자바가 추상화를 위해 제공하는 가장 유용한 도구는 바로 인터페이스이다. 인터페이스를 통해 추상화를 하게되면 최소환의 통로를 통해 접근하는 쪽에서는 오브젝트를 만들때 사용할 클래스가 무엇인지 몰라도 된다.\n\n![](https://i.imgur.com/iCN1k2t.png)\n\n인터페이스를 도입했지만 여전히 자바에서 인터페이스를 통해 객체를 생성할때 아래와같이 new DConnectionMaker(); 선언을 해줘야하기떄문에 근본적인 문제가 해결되지않는다.\n\n```java\npublic UserDao(){\n  connectionMaker = new DConnectionMaker();\n}\n```\n\n#### 관계설정 책임의 분리\n![](https://i.imgur.com/ZBKuVCa.png)\n그래서 이러한 근본적인 문제를 해결하기 위해서는 인터페이스를 통해서 처음부터 관계를 설정해주면된다. 아래와같이.\n\n```java\npublic interface ConnectionMaker {\n    public Connection makeConnection() throws ClassNotFoundException, SQLException;\n}\n\npublic class DConnectionMaker implements ConnectionMaker {\n    public Connection makeConnection() throws ClassNotFoundException, SQLException {\n        // D 사의 독자적인 방법으로 Connection 을 생성하는 코드\n    }\n}\n\npublic class UserDao {\n    private ConnectionMaker connectionMaker; ㅡ> 인터페이스를 통해 오브젝트에 접근, so 구체적 클래스 정보가 필요 없다.\n\n    public UserDao(ConnectionMaker connectionMaker){\n        this.connectionMaker = connectionMaker;  \n    }\n\n    public void add(User user) throws ClassNotFoundException, SQLException {\n        Connection c = connectionMaker.makeConnection();\n      ㅡ> 인터페이스에 정의된 메소드를 사용하므로 클래스가 바뀐다고 메소드 이름이 변경 되지 않는다.\n    }\n\n    public user get(String id) throws ClassNotFoundException, SQLException {\n        Connection c = connectionMaker.makeConnection();\n    }\n}\n\n```\n\n이제 이렇게 의존성 주입을 해주게되면 ConnectionMaker의 역할을 할 수 있는 어떤 클래스가 들어와도 UserDao기능을 수행할 수 있게 된다.\n\n\n```java\npublic class UserDaoTest{\n    public static void main(String[] args) throws ClassNotFoundException, SQLException {\n        ConnectionMaker connectionMaker = new DConnectionMaker();\n        // UserDao가 사용할 ConnectionMaker 구현 클래스를 결정하고 오브젝트를 만든다.\n\n        UserDao dao = new UserDao(connectionMaker);\n        // 1. UserDao 생성\n        // 2. 사용할 ConnectionMaker 타입의 오브젝트 제공, 결국 두 오브젝트 사이의 의존관계 설정\n    }\n}\n```\n\n최종적으로 UserDaoTest와같이 UserDao를 즉 3자 호출하는곳에서 의존성 주입을하게되면 아래와같이 불필요한 의존관계를 끊을 수 있게된다. 이렇게되면 어떤 Connection이 들어와도 UserDao를 클래스 수정없이 UserDao클래스 기능을 사용할 수 있게된다.\n\n![](https://i.imgur.com/XghdksD.png)\n\n#### 1.3.4 원칙과 패턴\n\n##### 개방 폐쇄원칙\n개방 폐쇄 원칙은 깔끔한 설계를 위해 적용 가능한 객체지향 설계 원칙 중의 하나다. 클래스나 모듈은 확장에는 열려 있어야하고 변경에는 닫혀 있어야한다고 할 수 있다. UserDao는 DB연결 방법이라는 기능을 확장하는데는 열려있다. UserDao에는 전혀 영향을 주지 않고도 얼마든지 확장 가능하다. 잘설계된 객체지향 클래스의 구조를 살펴보면 바로 이 개방 폐쇄 원칙을 아주 잘 지키고 있다. 인터페이스를 사용해 확장 기능을 정의한 대부분의 API는 바로 개방 폐쇄 원칙을 잘 따르고 있다고 볼 수 있다.\n\n\n##### 높은 응집도와 낮은 결합도\n\n**높은 응집도 (같은 기능끼리 모여있다는것)**\n응집도가 높다는것은 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻, 하나의 모듈에서만 변경이 많이 일어나면 다른 모듈은 변경이 필요가 없을때를 말한다. 하나의 클래스에 여러가지 관심사가 모여있다면 그 관심사 하나가 변경되면 다른 영향을 미치짖 않는지 확인해야하는 이중의 부담이 생긴다. 예를들어 기존의 NConnectionMaker를 개선해서 2.0을 만들었다해보자. 그렇게되면 NConnectionMaker를 테스트하기위해서 모든 DAO를 테스트할필요는없다. 높은 응집도때문에 그냥 NConnectionMaker만 테스트해도 충분하다. ConnectionMaker를 분리해서 높은 응집도를 가지고있기 때문이다.\n\n**낮은 결합도**\n낮은 결합도는 높은 응집도 보다 더 민감한 원칙이다. 책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합도, 즉 느슨하게 연결된 형태를 유지하는것이 바람직하다. 결합도가 낮아지면 변화에 대응하느 속도가 높아지고, 구성이 깔끔해진다. 또한 확장하기에도 매우 편리하다. 예를들면 위에서 보여준 예제처럼 인터페이스를 통한 ConnectionMaker구현이 있을 수 있다.\n\n**전략패턴**\n개선한 UserDaoTest - UserDao - ConnectionMaker 구조를 디자인 패턴의 시각으로 보면 전략 패턴에 해당한다고 볼 수 있다. 전략패턴은 디자인 패턴의 꽃이라고 불릴만큼 다양하게 자주 사용되는 패턴이다. 개방 폐쇄 원칙의 실현에도 가장 잘 들어 맞는 패턴이라고 볼 수 있다. 전략 패턴은 자신의 기능 Context에서,필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용 할 수 있게 하는 디자인 패턴이다.\nUserDao는 전략패턴의 컨텍스트에 해당한다. 컨텍스트는 자신의 기능을 수행하는데 필요한 기능 중에서 변경 가능한, DB 연결 방식이라는 알고리즘을 ConnectionMaker라는 인터페이스로 정의하고, 이를 구현한 클래스, 즉 전략을 바꿔가면서 사용할 수 있게 분리했다.\n\n전략패턴은 컨텍스트(UserDao)를 사용하는 클라이언트(UserDaoTest)는 컨텍스트가 사용할 전략 (ConnectionMaker를 구현한 클래스, 예 DConnectionMaker)을 컨텍스트의 생성자등을 통해 제공해주는게 일반적이다.\n\n### 1.4 제어의 역전(IoC)\n\n#### 오브젝트 팩토리\n\nUserDaoTest는 기존에 UserDao가 직접 담당하던 기능, 즉 어떤 ConnectionMaker구현 클래스를 사용할지를 결정하는 기능을 엉겁결에 떠 맡았다. UserDao가 ConnectionMaker인터페이스를 구현한 특정 클래스로부터 완벽하게 독립할 수 있도록 UserDao의 클라이언트인 UserDaoTest가 그 수고를 담당하게 된 것이다.\n그런데 처음목적은 UserDaoTest는 UserDao의 기능이 잘 동작하는지를 테스트하려고 만든 것이다. 그런데 지금 또다른 책임까지 떠 맡고 있으니 UserDaoTest는 2개의 관심사를 가지고 있는것이다. 그러므로 두개의 관심사를 분리해줘야한다.\n\n##### 팩토리\n팩토리 클래스의 역할은 객체의 생성방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 것이다. 팩토리 클래스의 역할을 맡을 클래스는 DaoFactory이다. DaoFactory는 UserDaoTest에서는 DaoFactory에 요청해서 미리 만들어진 UserDao오브젝트를 가져와 사용하게 만든다.\n\n\n```java\n\npublic class DaoFactory{\n  public UserDao userDao(){\n    //팩토리메소는 UserDao탕ㅂ의 오브젝트를 어떻게 만들고 어떻게 준비시킬지 결정한다.\n    ConnectionMaker connectionMaker = new DConnectionMaker();\n    UserDao userDao = new UserDao(connectionMaker);\n\n    return userDao;\n  }\n}\n```\n\n아래와같이 이제 UserDaoTest는 더이상 UserDao가 어떻게 생성되는지 신경쓰지 않고 테스트하는것에만 집중할 수 있게된다.\n\n```java\npublic class UserDaoTest{\n  public static void main(String[] args) throws ClassNotFoundException,SQLException{\n    UserDao dao = new DaoFactory.userDao();\n    ...\n  }\n}\n```\n\n##### 설계도로서의 팩토리\n![](https://i.imgur.com/IxtsfLd.png)\n그림과 같이 UserDaoTest는 DaoFactory를통해 DConnectionMaker를 주입받아 사용하게된다.\n\n#### 오브젝트 팩토리의 활용\n만약 추가적인 Dao들이 추가된다고 생각해보자. 그러면 아래와같이 반복되는 코드가 발생하게된다.\n\n```java\npublic class DaoFactory{\n\n\n  public UserDao userDao(){\n    return new UserDao(new DConnectionMaker();)\n  }\n\n  public AccountDao userDao(){\n    return new UserDao(new DConnectionMaker();)\n  }\n\n  ...\n\n}\n```\n\n위의 문제를 해결할려면 ConnectionMaker를생성하는 아래의소스와같이 공통으로 뽑아내는 방법이있다.\n\n```java\n\npublic class DaoFactory{\n\n\n  public UserDao userDao(){\n    return new UserDao(new DConnectionMaker();)\n  }\n\n  public AccountDao userDao(){\n    return new UserDao(new DConnectionMaker();)\n  }\n\n  ...\n\n  public ConnectionMaker connectionMaker(){\n    return new DConnectionMaker();\n  }\n\n}\n```\n\n위와같이 소스를 변경하게되면 ConnectionMaker부분만 수정하게되면 Dao팩토리 메소드가 많아져도 ConnectionMaker의 메소드만 변경하게되면 모든 커넥션마커의 기능들이 수정되기때문에 시간을 절약할수 있게 된다.\n\n#### 제어권의 이전을 통한 제어관계 역전\n일반적으로 프로그램의 흐름은 main() 메소드와 같이 프로그램이 시작되는 지점에서 다음에 사용할 오브젝트를 결정하고 결정한 오브젝트를 생성하고, 만들어진 오브젝트를 사용한다. 언제 어떻게 오브젝트를 만들지를 스스로 관장한다. 모든 종류의 작업을 사용하는 쪽에서 제어하는 구조이다. 제어의 역전은 이런 제어 흐름의 개념을 거꾸로 뒤집는 것이다. 제어의 역전에서는 모든 제어의 권한을 자신이 아닌 다른 대상에게 위임한다.\n제어의 역전 개념은 이미 서블릿에서도 사용되고있다. 서블릿에 대한 제어권한을 가진 컨테이너가 적절한 시점에 서블릿 클래스의 오브젝트를 만들고 그안의 메소드를 호출한다. 이렇게 서블릿이나, JSP, EJB에서는 간단한 방식으로 제어의 역전 개념이 적용되어 있다.\n\n### 1.5 Spring IoC\n스프링의 핵심을 담당하는 건 바로 빈팩토리, 또는 ApplicationContext라고 불리는 것이다. 이것은 우리가 만든 DaoFactory가 하는 일을 스프링에서 좀더 일반화한 것이라고 할 수 있다\n\n#### 제어권의 이전을 통한 제어관계 역전\n스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 빈이라고 부른다. 스프링에서 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 빈팩토리라고 한다. 보통 빈팩토리보다는 이를 좀더 확장한 ApplicationContext를 주로 사용한다.\nApplicationContext는 별도의 정보를 참고해서 빈의 생성, 관계설정등의 제어 작업을 총괄한다. DaoFactory에서는 어떤 클래스의 오브젝트를 생성할지 어떻게 연결할것인지에 대해 설정을 해줬었다. 하지만 ApplicationContext는 직접 이런정보를 담지 않고 별도로 설정정보를 담고 있는 자바 @Configuration 설정되어져 있는 자바클래스의 정보를 가져와 이를 활용하는 범용적인 Ioc 엔진이라고 할 수 있다.\n\n##### DaoFactory를 사용하는 ApplicationContext\nDaoFactory를 스프링의 빈팩토리(ApplicationContext)가 사용할수있도록 설정 정보를 만들 것이다. 먼저 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스라고 인식할수 있도록 @Configuration 이라는 어노테이션을 추가한다. 그리고 오브젝트를 만들어주는 메소드에는 @Bean 이라는 어노테이션을 추가한다.\n\n```java\n\n@Configuration // 애플리케이션 컨텍스트 또는 빈 팩토리가 사용할 설정정보라는 표시\npublic class DaoFactory{\n\n  @Bean // 오브젝트를 새엉을 담당하는 IoC용 메소드라는 표시\n  public UserDao userDao(){\n    return new UserDao(connectionMaker());\n  }\n\n  @Bean\n  public ConnectionMaker connectionMaker(){\n    return new DConnectionMaker();\n  }\n}\n\n```\n\n이제 아래와같이 준비된 ApplicationContext의 getBean()이라는 메소드를 이용해서 UserDao의 오브젝트를 가져올 수 있다.\n\n```java\n\npublic class UserDaoTest{\n  public static void main(String[] args) throws ClassNotFoundException,SQLException{\n    ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);\n    UserDao dao = context.getBean(\"userDao\",UserDao.class);\n    ...\n  }\n\n}\n\n```\n\ncontext.getBean(\"userDao\",UserDao.class);의 userDao는 DaoFactory 메소드의 이름이다. 어떻게 메소드의 이름을 설정하느냐에따라 빈을 가지고올때 String값을 변경해주면 된다.\n\n\n#### ApplicationContext의 동작 방식\n스프링에서 ApplicationContext를 IoC컨테이너라고 하기도하고 간단히 스프링 컨테이너라고도 한다. @Configuration이 붙은 DaoFactory는 ApplicationContext가 활용하는 IoC설정정보다. 내부적으로 애플리케이션 컨텍스가 DaoFactory의 userDao() 메소드를 호출해서 오브젝트를 가져온 것을 클라이언트가 getBean()으로 요청할 때 전달 해준다. 아래 그림은 ApplicationContext의 사용되는 방식이다.\n\n![](https://i.imgur.com/Uf9J8vi.png)\n\n##### ApplicationContext를 사용했을때 장점\n1. 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.\n2. 애플리케이션 컨텍스트는 종합 IoC서비스를 제공해준다.\n  오브젝트가 만들어지는 방식, 오브젝트에 대한 후처리, 정보의 조합 설정 방식의 다변화, 인터셉티등 오브젝트를 효과적으로 활용할 수 있는 다양한 기능을 제공한다.\n3. 애플리케이션 컨텍스트는 빈을 검색하는 다양한방법을 제공한다.\n  타입만으로도 빈을 검색하거나 특별한 애노테이션 설정이 되어있는 빈을 찾을 수 도 있다.\n\n\n\n### 1.6 싱글톤 레지스틀와 오브젝트 스코프\nDaoFactory와 @Configuratuon애노테이션을 추가해서 스프링의 애플리케이션 컨텍스트를 사용하는것의 차이점에 대해서 알아볼것이다. 둘의 큰 차이점은 리턴해주는 빈의 동일성을 보장 해주는것이다. 먼저 아례의 예제를 보자\n\n```java\nDaoFactory factory = new DaoFactory();\nUserDao dao1 = factory.userDao();\nUserDao dao2 = factory.userDao();\n\nSystem.out.println(dao1); //springbook.dao.UserDao@118f375\nSystem.out.println(dao2); //springbook.dao.UserDao@117a8bd\n```\n\n출력결과에서 알수 있듯이 동일성이 보장되지 않는 객체들이 출력된다. 그럼 스프링 컨테이너를 이용해서 빈을 호출해 볼 것이다.\n\n```java\nApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);\n\nUserDao dao3 = factory.userDao();\nUserDao dao4 = factory.userDao();\n\nSystem.out.println(dao3); //springbook.dao.UserDao@ee22f7\nSystem.out.println(dao4); //springbook.dao.UserDao@ee22f7\n```\n\n스프링 컨테이너 즉 ApplicationContext를 통해 생성한 오브젝트는 동일성을 보장해준다. 여러번에 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 리턴해준다.\n\n#### 싱글톤 레지스트리로서의 애플리케이션 컨텍스트\nApplicationContext는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이다. 스프링은 기본적으로 별다른 설정을 하지 않으면 내부에 생성하는 빈오브젝트를 모두 싱글톤으로 생성한다.\n\n##### 서버 애플리케이션 싱글톤\n스프링에서 싱글톤을 사용하는 이유는 스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버 환경이기 때문이다. 물론 스프링으로 PC등에서 동작하는 독립형 윈도우 프로그램으로도 개발할수 있긴 하지만 극히 드물다.\n스프링이 처음 설계됐던 대규모의 엔터프라이즈 서버환경은 서버 하나당 최대로 초당 수십에서 수백 번씩 브라우저나 여타 시스템으로부터의 요청을 받아 처리할 수 있는 높은 성능이 요구되는 환경이었다. 또 하나의 요청을 처리하기위해 데이터 액세스로직, 서비스로직, 비지니스로직,프레젠테이션로직등의 다양한 기능을 담당하는 오브젝트들이 참여하는 계층형 구조였다.\n그런데 매번 클라이언트에서 요청이 들어 올때마다 각로직을 담당하는 오브젝트를 새로 만들어본다고 생각해보자. 요청 한번에 5개의 오브젝트가 새로 만들어지고 초당 500개의 요청이 들어오면 초당 2500개의 새로운 오브젝트가 생성된다. 1분이면 십오만개, 한시간이면 9백만개의 새로운 오브젝트가 만들어진다. 아무리 자바의 가비지컬렉션의 성능이 좋아졌다고 한들 이렇게 부하가 걸리면 서버가 감당하기 힘들다.\n엔터프라이즈 환경에서의 서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작한다. 서블릿 클래스당 하나의 오브젝트만 만들어 두고, 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용된다.\n이렇게 애플리케이션 안에 제한된 수, 대개 한개의 오브젝트만 만들어서 사용하는 것이 싱글톤 패턴의 원리이다.따라서 서버 환경에서는 서비스 싱글톤의 사용이 권장된다.\n\n##### 싱글톤 패턴의 한계\n싱글통 패턴을 적용한 UserDao\n\n```java\npublic class UserDao{\n  private static UserDao INSTANCE;\n  ...\n\n  private UserDao(ConnectionMaker connectionMaker){\n    this.connectionMaker = connectionMaker;\n  }\n\n  public static synchronized UserDao getInstance(){\n    if(INSTANCE == null) INSTANCE = new UserDao(???);\n    return INSTANCE;\n  }\n}\n```\n\n싱글톤의 단점\n```\n-private  생성자를 갖고 있기 때문에 상속할 수 없다.\n-싱글톤은 테스트하기가 힘들다.\n-서버환경에서는 싱글톤이 하나만 만들어지는것을 보장하지 못한다\n-싱글톤의 사용은 전역상태를 만들 수 있기 때문에 바람직하지 못하다.\n```\n\n##### 싱글톤 레지스트리\n자바의 기본적인 싱글톤 패턴의 구현 방식은 여러가지 단점이 있기 때문에 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다. 그것이 바로 싱글톤 레지스트리이다. 스프링 컨테이너는 싱글톤을 생성하고, 관리하고 공급하는 싱글톤 관리 컨테이너이기도 하다. 싱글톤 레지스트리는 스태틱메소드와 private생성자등을 사용해야하는 비정상적인 클래스가 아닌 평범한 자바 클래스를 싱글톤으로 활용하게 해준다.\n\n\n#### 싱글톤과 오브젝트의 상태\n싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있다. 따라서 상태 관리(전역변수)에 주의 해야한다. 기본적으로 클래스내에서 전역변수를 사용하지 말아야한다. 다중 사용자의 요청을 한꺼번에 처리하는 스레드들이 동시에 싱글톤오브젝트의 전역변수를 수정하는것은 매우 위험하다. 저장할 공간이 하나 뿐이니 서로 값을 덮어쓰고 자신이 저장하지 않은값을 읽어 오거나 삭제할수있기때문이다. 물론 읽기전용의 전역변수는 사용해도좋다. 이런 변수들은 final로 선언해주는거시 안전하다. 메소드안에는 지연변수(스택 영역에 저장되어져있다)이기떄문에 메소드 호출후에 초기화된다.\n\n#### 스프링 빈의 스코프\n스프링 내에서 빈이 생성되고 존재하고 등의 적용되는 범위에대해 스프링에서는 이것을 스코프라고한다. 기본적으로 프로토타입,요청,세션등으로 분리하여 관리해주는 스코프 범위가 존재한다.\n\n\n### 1.7 의존과계 주입(DI)\n#### 제어의 역전과 의존관계 주입\n여기에서 한가지 짚고 넘어갈 것은 IoC라는 용어인데, IoC가 매우 느슨하게 정의돼서 폭넓게 사용되는 용어라는것이다. 때문에 스프링을 IoC 컨테이너라고만 해서는 스프링이 제공하는 기능의 특징을 명확하게 설명하지 못했다. 그래서 나온말이 IoC방식을 핵심을 짚어주는 의존관계 주입(DI)이다. 스프링의 IoC 기능의 대표적인 동작원리는 주로 의존관계 주입이라고 불린다. 스프링이 여타 프레임워크와 차별화돼서 제공해주는 기능은 의존관계 주입이라는 새로운 용어를 사용할 때 분명하게 드러난다. 초기에는 주로 IoC 컨테이너라고 불리던 스프링이 지금은 의존관계 주입 컨테이너 또는 그영문약자를 써서 DI컨테이너라고 더 많이 불리고 있다.\n\n#### 런타임 의존관계 설정\n##### 의존관계\n두 개의 클래스 또는 모듈이 의존관계에 있다고 말할 때는 항상 방향성을 부여해줘야 한다. 즉 누가 누구에게 의존하는 관계 있다는 식어야한다. A클래스가 B에 의존하고 있을때 B가 변동사항이 있으면 A에 영향을 미치게된다. 하지만 A가 변경된다고해서 B는 영향 받지 않는다.\n\n##### UserDao의 의존관계\n![](https://i.imgur.com/Am2R3Z3.png)\n위 그림은 UserDao가 ConnectionMaker에 의존하고 있는 형태이다. ConnectionMaker인터페이스가 변한다면 그영향은 UserDao가 받을 것이다. 하지만 ConnectionMaker의 구현체인 DConnectionMaker등이 바뀌거나 내부적으로 메소드가 변화가 생겨도 UserDao에 영향을 주지 않는다. 이렇게 인터ㅔ이스대해서만 의존관계를 만들어두면 인터페이스를 구현 클래스와의 관계는 느슨해지면서 변환에 영향을 덜 받는 상태가 된다. 인터페이스를 통해 의존관계를 제한해주면 그만큼 변경에서 자유로워지는 셈이다.\n그런데 모델이나 코드에서 클래스와 인터페이스를 통해 드러나는 의존관계말고, 런타임시에 오브젝트 사이에서 만들어지는 의존관계도 있다. 의존과계 또는 오브젝트 의존 관계인데, 설계 시점의 의존관계가 실체화된 것이라고 볼 수 있다. 런타임 의존관계는 모델링 시점의 의존관계와는 성격이 분명히 다르다.\n인터페이스를 통해 설계 시점에 느슨한 의존관계를 갖는 경우에는 UserDao의 오브젝트가 런타임 시에 사용할 오브젝트가 어떤 클래스로 만든것인지 미리 알 수 가없다. 프로그램이 시작되고 UserDao 오브젝트가 만들어지고 나서 런타임 시에 의존관계를 맺는 대상, 즉 실제 사용대상인 오브젝트를 의존 오브젝트라고 한다.\n\n의존관계 주입은 이렇게 구체적인 의존 오브젝트와 그것을 사용할 주체, 보통 클라이언트라고 부르는 오브젝트를 런타임시에 연결해주는 작업을 말한다. UserDao는 ConnectionMaker 인터페이스라는 매우 단순한 조건만 만족하면 어떤 클래스로부터 만들어졌든 상관없이 오브젝트를 받아 들이고 사용한다.\n\n\n>의존관계주입이란\n-클래스 모델(UML)이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야한다.\n-런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정한다.\n-의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부주에서 제공(주입)해줌으로써 만들어진다.\n\n\n의존관계 주입의 핵심은 설계 시점에는 알지 못했던 두 오브젝트의 관계를 맺도록 도와주는 제 3의 존재가 있다는것이다. DI에서 말하는 제 3의 존재는 바로 관계설정 책임을 가진 클래스 라고 볼 수 있다. DaoFactory,ApplicationContext,Ioc컨테이너등이 모두 외부에서 오브젝트 사이의 런타임 관계를 맺어주는 책임을 지닌 제 3의 존재라고 볼 수 있다.\n\n##### UserDao의 의존관계 주입\n다시 처음에 봤던 UserDao 에 적용된 의존관계 주입 기술을 다시 살펴보자. 인터페이스를 사이에 두고 UserDao와 ConnectionMaker구현클래스간에 의존관계를 느슨하게 만들긴 했지만, 마지막으로 남은 문제가 있었는데 아래소스와같이 UserDao가 사용할 구체적인 클래스를 알고 있어야 하는점이다.\n\n```java\npublic UserDao(){\n  connectionMaker = new DConnectionMaker();\n}\n\n```\n\n이코드는 이미 설계 시점에 구체적인 런타임 의존관계 오브젝트를 알고 있다. 즉 DConnectionMaker오브젝트를 사용하겠다는 것 까지 UserDao가 결정하고 관리하고 있는셈이다.\n\n이코드의 문제는 이미 런타임시의 의존관계가 코드 속에 미리 다 결정되어있다는 것이다. 그래서 Ioc방식을 써서 UserDao로부터 런타임 의존관계를 드러내는 코드를 제거하고, 제 3의 존재에 런타임 의존관계 결정을 권한을 위함하는것이다. 그래서 최종적으로 만들어졌던것이 DaoFactory이다. DaoFactory는 런타임시점에 UserDao가 사용할 ConnectionMaker타입의 오브젝트를 결정하고 이를 생성한후에 UserDao의 생성자 파라미터로 주입해줌으로써 런타임 의존관계를 맺게 해준다. 이렇게 런타임시 주입의 기능을 수행함으로써 DaoFactory를 DI/IoC컨테이너라고도 한다.\n\nDI컨테이너느 자신이 결정한 의존관계를 맺어줄 클래스의 오브젝트를 만들고 이생성자를 파라미터로 오브젝트의 레퍼런스를 전달해준다. 그럼 아래 소스같이 생성자 파라미터를 통해 전달받은 런타임 의존관계를 갖는 오브젝트는 인스턴스 변수에 저장 해둔다.\n\n```java\npublic class UserDao{\n\n  private ConnectionMaker connectionMaker;\n\n  public UserDao(ConnectionMaker connectionMaker){\n    this.connectionMaker = connectionMaker;\n  }\n\n}\n```\n\n이렇게 해서 두 개의 오브젝트 간에 런타임 의존관계 만들어졌다. UserDao 오브젝트는 이제 생성자를 통해 주입받은 DConnectionMaker 오브젝트를 언제든 사용하면 된다. DI는 자신이 사용할 오브젝트에 대한 선택권과 생성 제어권을 외부로 넘기고 자신은 런타임시에 수동적로 주입받은 오브젝트를 사용한다는 점에서 IoC의 개념에 잘 들어 맞는다. 스프링 컨테이너의 IoC는 주로 의존관계 주입 또는 DI라는 데 초점이 맞춰져 있다. 그래서 스프링을 IoC컨테이너 외에도 DI컨테이너 또는 DI프레임워크라 한다.\n\n\n\n#### 의존관계 검색과 주입\n스프링이 제공하는 IoC방법에서 오브젝트를 주입하는 방법 의존성 주입만 있는것은 아니다. 의존 관계를 맺는 방법이 외부로부터의 주입이 아니라 스스로 검색을 이용하는 의존관계 검색이 있다. 의존관계 검색은 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾는다. 물론 자신이 어떤 클래스의 오브젝트를 이용할지는 결정하지 않는다. 의존관계 검색은 런타임 시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트의 생성작업은 외부 컨테이너에게 맡기지만, 이를 가져올때는 메소드나 생성자를 통한 파라미터 전달이 아닌 아래 소스와같이 직접 컨테이너에게 요청하는 방식이다.\n\n```java\npublic UserDao(){\n  DaoFactory daoFactory = new DaoFactory();\n  this.connectionMaker = daoFactory.connectionMaker();\n}\n```\n\n위와같이 생성해도 여전히 자신이 어떤 ConnectionMaker 오브젝트를 사용할지 미리 알지 못한다. 여전히 코드의 의존대상은 ConnectionMaker인터페이스이기 때문이다. 런타임시에 DaoFactory가 만들어서 돌려주는 오브젝트와 다이내믹하게 런타임 의존관계를 맺는다. 따라서 IoC개념을 잘 따르고 있으며, 그혜택을 받는 코드다. 하지만 적용방법은 외부로부터의 주입이 아니라 스스로 IoC 컨테이너인 DaoFactory에게 요청하는것이다.\n위소스의 작업을 일반화한 스프링의 애플리케이션 컨텍스트라면 미리 정해놓은 이름을 전달해서 그 이름에 해당하는 오브젝트를 찾게 된다. 따라서 이를 일종의 검색이라고 볼 수 있다. 또한 그 대상이 런타임 의존관계를 가질 오브젝트이므로 의존관계 검색이라고 부르는 것이다.\n스프링의 IoC 컨테이너인 애플리케이션 컨텍스트는 getBean이라는 메소드를 제공한다. 바로 이메소드가 의존관계를 검색에 사용되는것이다. 이것은 아래의 예제와같이 사용 할 수 있다.\n```java\npublic UserDao(){\n  AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.clas);\n\n  this.connectionMaker = context.getBean(\"connectionMaker\",ConnectionMaker.class);\n}\n```\n\n의존관계 검색은 기존 의존관계 주입의 거의 모든 장점을 갖고 있다. 하지만 코드면에서 좀 더 의존관계주입이 단순하고 깔끔하다. 의존관계 검색은 코드안에 오브젝트 팩토리 클래스나 스프링 API가 나타난다. 검색 방식을 이용하면 그안에서 컨텍스트를 만들고, 호출하고등의 불필요한 소스를 넣어줘야하기 때문이다. 따라서 대개는 의존관계주입방식을 사용하는것이 낫다.\n\n```java\n\npublic class UserDaoTest{\n  public static void main(String[] args) throws ClassNotFoundException,SQLException{\n    ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);\n    UserDao dao = context.getBean(\"userDao\",UserDao.class);\n    ...\n  }\n\n}\n```\n\n하지만 위에 소스처럼 static 메소드인 Main같은경우에는 DI를 이용해 오브젝트를 주입받을 방법이 없기 때문이다. 이러한경우 말고는 의존성주입을 받아 사용하는게 소스면에서 훨씬 깔끔하다.\n\n#### 의존관계 주입의 응용\n##### 부가기능 추가\n다음 이런경우를 한번 생각해보자. DAO가 DB를 얼마나 많이 연결해서 사용하는지 파악하고 싶다. DB연결횟수를 카운팅하기 위해 무식한 방법으로 모든 DAO의 makeConnection() 메소드를 호출하는 부분에 새로 추가한 카운터를 증가시키는 코드를 넣는것은 엄청난 낭비이고 노가다다.  그리고 무엇보다 DAO코드를 손대는것은 지금까지 피하려고했던 행동을 하는 것이다.\nDI 컨테이너에서라면 아주 간단한 방법으로 해결가능하다. DAO와 DB 커넥션을 만드는 오브젝트 사이에 열결횟수를 카운팅하는 오브젝트를 하나 더 추가하는 것이다.\n\n```java\npublic class CountingConnectionMaker implements ConnectionMaker{\n  int counter = 0;\n  private ConnectionMaker realConnectionMaker;\n\n  public CountingConnectionMaker realConnectionMaker(ConnectionMaker realConnectionMaker){\n    this.realConnectionMaker = realConnectionMaker;\n  }\n\n  public Connection makeConnection() throws ClassNotFoundException,SQLException{\n    this.counter++;\n    return realConnectionMaker.makeConnection();\n  }\n\n  public int getCounter(){\n    return this.counter;\n  }\n}\n```\nCountingConnectionMaker 클래스는 ConnectionMaker 인터페이스를 구현했지만 내부에서 직접 DB커넥션을 만들지 않는다. 대신 DAO가 DB커넥션을 가져올 때마다 호출하는 makeConnection()에서 DB연결횟수 카운터를 증가시킨다.CountingConnectionMaker는 자신의 관심사인 DB 연결횟수 카운팅 작업을 마치면 실제 DB 커넥션을 만들어주는 realConnectionMaker에 저장된 ConnectionMaker타입 오브젝트의 makeConnection()호출해서 그 결과를 DAO에 돌려준다.\n\n생성자를 보면 ConnectionConnectionMaker도 DI를 받는것을 알 수 있다. UserDao는 ConnectionMaker의 인터페이스에만 의존하고 있기 때문에 ConnectionMaker 를 구현하고있는 어떤 구현체라도 DI가 가능하다. 그래서 DI받는 오브젝트를 DConnection오브젝트를 대신 CountingConnectionMaker를 받은것이다. 그리고 그 CountingConnectionMaker는 DConnectionMaker를 의존주입을 받은것이다.\n![](https://i.imgur.com/EfluSD4.png)\n![](https://i.imgur.com/Am2R3Z3.png)\n이렇게해서 CountingConnectionMaker 재구성된 새로운 런타임 의존관계는 위 그림과 같다. 우의 그림을 코드라바꾸면 아래와같이 만들 수 있다.\n```java\n@Configuration\npublic class CountingDaoFactory{\n  @Bean\n  public UserDao userDao{\n    return new UserDao(ConnectionMaker());\n  }\n\n  @Bean\n  public ConnectionMaker connectionMaker(){\n    return new CountingConnectionMaker(realConnectionMaker());\n  }\n\n  @Bean\n  public ConnectionMaker realConnectionMaker(){\n    return new DConnectionMaker();\n  }\n}\n```\n\n이제 커넥션 카운팅을 위한 실행 코드를 만들어보자. 기본적으로 UserDaoTest와 같지만 설정요 클래스를 CountingDaoFactory로 변경해줘야한다. 그리고 CountingConnectionMaker빈을 가져온다. 설정정보에 지정된 이름과 타입만 알면 특정 빈을 가져 얼 수 있으니 CoutingConnectionMaker 오브젝트를 가져오는 건 간단하다.\n\n```java\n\npublic class UserDaoConnectionCountingTest{\n  public static void main(String[] args) throws ClassNotFoundException,SQLException{\n    AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(CountingDaoFactory.class);\n    UserDao dao = context.getBean(\"userDao\",UserDao.class);\n\n    //\n    //DAO 사용코드\n    //\n\n    CountingConnectionMaker ccm = context.getBean(\"connectionMaker\",CountingConnectionMaker.class);\n    System.out.println(\"Connection counter :\" + ccm.getCounter());\n  }\n}\n```\n이렇게 함으로써 DBConnection 분석이 끝나면 다시 CountingDaoFactory 설정 클래스를 DaoFactory로 변경하거나 connectionMaker()메소드를 수정하는 것만으로 DAO의 런터암 의존관계는 이정상태로 복구된다.\n\n#### 메소드를 이용한 의존관계 주입\n간단하게 설명하자면 스프링에서 의존섭을 주입하는 방법은 생성자를 이용하는 방법뿐만 아니라 아래와 같이 setter아니면 직접 메소드를 정의해서 의존성을 주입하는 방법이있다.\n```java\npublic class UserDao{\n  private ConnectionMaker connectionMaker;\n\n  public void setConnectionMker(ConnectionMaker connectionMaker){\n    this.connectionMaker = connectionMaker;\n  }\n}\n```\n```java\n@Bean\npublic UserDao userDao(){\n  UserDao userDao = new UserDao();\n  userDao.setConnectionMaker(connectionMaker());\n  return userDao;\n}\n```\n단지 의존관계를 주입하는 시점과 방법이 달라졌을 뿐 결과는 동일하다.\n\n[예제소스](https://github.com/minwan1/Spring-toby)\n\n### 정리\n- 단일 책임원칙 기반하여 책임별로 클래스들을 나누었다. 예제를 보면 UserDao 같은경우에는 데이터 액세스에 관한 관심의 역할을 부여받음으로써 데이터 엑세스에대한 책임을 수행하고있다. ConnectionMaker 같은경우에는 데이터베이스 Connection방법을 설정을 할수 있는 역할을 부여받음으로써 데이터베이스 Connection방법에 관한 책임만을 가진다. 이렇게 명확하게 둘의 책임을 나눔으로써 데이터엑스세에 대한 비지니스로직을 변경한다거나 데이터베이스 Connection 방법을 변경한다거나할 때 서로의 영향을 안받는 독립적인 구조를 만들어 냈다.\n- 개방 폐쇄 원칙에 기반하여 클래스들을 나누었다. ConnectionMaker같은경우 인터페이스로 가져감으로써 데이터베이스 Connection 방법을 변경할때 거기에 맞는 구현체만 구현하게 되면 쉽게 데이베이스 Connection방법을 바꿀 수 있게 되었다. 또한 그 구현체 ConnectionMaker들은 데이터베이스 Connection 방법이 변경되지 않는 이상 바뀌지 않을 소스이다. 이런점을 보아서 개방 폐쇄원칙을 잘 준수했다고 볼 수 있다.\n- 오브젝트를 생성되고 관계를맺는 제어권을 별도의 오브젝트 팩토리로 만들었다. 객체를 직접 관리하지않고 팩토리를 통해 관리함으로써 기능들을 부품처럼 쉽게 바꿀수 있게 되었다.(제어의 역전/IOC)\n","slug":"2018-06-07-Toby-1","published":1,"updated":"2018-06-23T14:22:01.451Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl27fa004ejjpefyt6sksg","content":"<h1><span id=\"토비의-스프링\">토비의 스프링</span></h1>\n<p>이글은 <a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=7006516\" target=\"_blank\" rel=\"noopener\">토비님의 스프링책</a>을 보고 요약한 내용입니다</p>\n<h2><span id=\"1장-오브젝트와-의존관계\">1장 오브젝트와 의존관계</span></h2>\n<p><strong>들어가며</strong><br>\n스프링이 자바에서 가장 중요하게 가치를 두는것은 바로 객체지향프로그래밍이 가능한 언어라는 점이다.  자바 엔터프라이즈 기술의 혼란속에서 잃어버렸던 객체지향 기술의 진정한 가치를 회복시키고 폭넓은 혜택을 누릴 수 있도록하는것이 스프링 철학이다. 그래서 스프링에서 관심을 많이두는것은 오브젝트의 생명주기이다. 그렇기 때문에 우리는 스프링이 어떤것이고, 무엇을 제공하는지 보다는 스프링이 관심을 갖는 대상인 오브젝트의 설계와 구현, 동작원리에대해 관심을 가져야한다.</p>\n<h3><span id=\"11-초난감-dao\">1.1 초난감 DAO</span></h3>\n<p>먼저 간단하게 아래와같이 JDBC를 이용한 User CURD를 다룰것이다. 예제에서는 롬복을 사용하여 객체를 다룰것이다. 그리고 데이터베이스는 Inmemory DB인 H2를 사용할것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Setter</span></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String password;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Builder</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">(String id, String name, String password)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.password = password;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>유저의 정보에 접근할 수 있는 DAO를 아래와같이 만들자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDao</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(User user)</span> <span class=\"keyword\">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class=\"line\">        Class.forName(<span class=\"string\">\"org.h2.Driver\"</span>);</span><br><span class=\"line\">        Connection c = DriverManager.getConnection(<span class=\"string\">\"jdbc:h2:tcp://localhost:9092/mem:testdb;MVCC=TRUE\"</span>, <span class=\"string\">\"sa\"</span>, <span class=\"string\">\"\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        PreparedStatement ps = c.prepareStatement(<span class=\"string\">\"insert into users(id, name, password) values (?, ?, ?)\"</span>);</span><br><span class=\"line\">        ps.setString(<span class=\"number\">1</span>, user.getId());</span><br><span class=\"line\">        ps.setString(<span class=\"number\">2</span>, user.getName());</span><br><span class=\"line\">        ps.setString(<span class=\"number\">3</span>, user.getPassword());</span><br><span class=\"line\"></span><br><span class=\"line\">        ps.executeUpdate();</span><br><span class=\"line\"></span><br><span class=\"line\">        ps.close();</span><br><span class=\"line\">        c.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">get</span><span class=\"params\">(String id)</span> <span class=\"keyword\">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class=\"line\">        Class.forName(<span class=\"string\">\"org.h2.Driver\"</span>);</span><br><span class=\"line\">        Connection c = DriverManager.getConnection(<span class=\"string\">\"jdbc:h2:tcp://localhost:9092/mem:testdb;MVCC=TRUE\"</span>, <span class=\"string\">\"sa\"</span>, <span class=\"string\">\"\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        PreparedStatement ps = c.prepareStatement(<span class=\"string\">\"select * from users where id = ?\"</span>);</span><br><span class=\"line\">        ps.setString(<span class=\"number\">1</span>, id);</span><br><span class=\"line\"></span><br><span class=\"line\">        ResultSet rs = ps.executeQuery();</span><br><span class=\"line\">        rs.next();</span><br><span class=\"line\"></span><br><span class=\"line\">        User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">        user.setId(rs.getString(<span class=\"string\">\"id\"</span>));</span><br><span class=\"line\">        user.setName(rs.getString(<span class=\"string\">\"name\"</span>));</span><br><span class=\"line\">        user.setPassword(rs.getString(<span class=\"string\">\"password\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        rs.close();</span><br><span class=\"line\">        ps.close();</span><br><span class=\"line\">        c.close();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그다음은 실제 User 정보가 담길 디비를 아래와같이 만들어보자.</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">users</span> (</span><br><span class=\"line\">  <span class=\"keyword\">id</span>          <span class=\"built_in\">varchar</span>(<span class=\"number\">10</span>) primary <span class=\"keyword\">key</span>,</span><br><span class=\"line\">  <span class=\"keyword\">name</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">  <span class=\"keyword\">password</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">10</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>이제 만들어진 코드를 바탕으로 테스트 코드를 아래와같이 작성해보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class=\"line\">    UserDao dao = <span class=\"keyword\">new</span> UserDao();</span><br><span class=\"line\"></span><br><span class=\"line\">    User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">    user.setId(<span class=\"string\">\"whiteship\"</span>);</span><br><span class=\"line\">    user.setName(<span class=\"string\">\"백기선\"</span>);</span><br><span class=\"line\">    user.setPassword(<span class=\"string\">\"married\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    dao.add(user);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(user.getId() + <span class=\"string\">\" 등록 성공\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    User user2 = dao.get(user.getId());</span><br><span class=\"line\">    System.out.println(user2.getName());</span><br><span class=\"line\">    System.out.println(user2.getPassword());</span><br><span class=\"line\">    System.out.println(user2.getId() + <span class=\"string\">\" 조회 성공\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위와같이 이제 테스트코드를 돌리게되면 데이터베이스를 통해 유저를 등록하고 조회를 할 수 있게 된다. 사실 위코드에서 소스가 작동하는데는 큰문제가 없다. 하지만 잠재적으로 엄청난 버그를 가지고있는 소스임은 분명하다. 그래서 위의 소스를 좀더 안전하고, 유지보수하기 좋은 소스를 만들기위해서 스프링과 결합하여 좀 더 효과적으로, 객체지향적으로 만들어나가는 방법에 대해 알아볼것이다.</p>\n<h3><span id=\"12-dao-분리\">1.2 DAO 분리</span></h3>\n<h4><span id=\"커넥션만들기의-추출\">커넥션만들기의 추출</span></h4>\n<p>먼저 중복된 코드가 무엇인지에대해 생각하여야한다. 먼저 앞에서 만든 UserDao의 중복코드를 제거하기 위해서 관심사항들을 뽑아보자.</p>\n<ul>\n<li>DB와 연결을 위한 커넥션을 가져오는 부분이다.</li>\n<li>사용자 등록을 위해 DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행하는 것 또한 계속 중복되고 있다.</li>\n<li>셋째는 작업이 끝나고 리소스들을 종료해주는 부분이다.</li>\n</ul>\n<p>먼저 DB와 연결을 위한 커넥션 부분을 제거해보자. getConnetion 메소드로 빼서 연결이 필요할때는 그메소드를 호출하는것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">get</span><span class=\"params\">(String id)</span>  <span class=\"keyword\">throws</span> ClassNotFoundException,SQLException</span>&#123;</span><br><span class=\"line\">  Connection c = getConnetion();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Connection <span class=\"title\">getConnection</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ClassNotFoundException,SQLException</span>&#123;</span><br><span class=\"line\">  class.forName(\"com.mysql.jdbc.Driver\");</span><br><span class=\"line\">  Connection C = DriverManager.getConnection(<span class=\"string\">\"jdbc:mysql://localhost/springbook\"</span>,<span class=\"string\">\"spring\"</span>,book);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> c</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위에 getConnection메소드는 관심의 종류에 따라 메소드 구분 해놓았다. 그렇기 때문에 한가지 관심 예를들어 데이터베이스의 종류를 바꾸는 등의  문제에서 하나의 메소드에 소스만 변경하게 되면 손쉽게 데이터 베이스를 변경할 수 있게 해준다. 기존 소스같은경우에는 스키마등이 변경된다고 치면 모든 스키마 URL등을 변경해줘야 했을것이다.</p>\n<h4><span id=\"db커넥션-만들기의-독립\">DB커넥션 만들기의 독립</span></h4>\n<p>이번에는 좀더 변화를 반기는 DAO를 만들것이다.</p>\n<p><strong>상속을 통한 확장</strong><br>\n<img src=\"https://i.imgur.com/zpT9cHZ.png\" alt=\"\"></p>\n<p>위그림과 같이 UserDao를 추상클래스로 선언 하면 좀더 확장성 있는 소스가 될 것이다. 이렇게 선언하게되면 추상클래스에 add와 get만 메소드를 구현하고 getConnection은 깡통메소드로 나두게되면 NUserDao, DUserDao에서 getConnection만 구현하게되면 2개의 각기 다른 디비를 붙일 수 있다.</p>\n<p>이렇든 UserDao와같은 슈퍼클래스는 기본적인 로직의 흐름(커넥션가져오기,sql생성,실행,반환)만들고 서브클래스는 메소드를 구현하는 패턴을 템플릿 메소드 패턴이라고 한다. 템플릿 메소드 패턴은 스프링에서 애용하는 패턴이다.</p>\n<p><img src=\"https://i.imgur.com/RSH9tOC.png\" alt=\"\"></p>\n<h3><span id=\"13-dao의-확장\">1.3 DAO의 확장</span></h3>\n<p>모든 오브젝트는 변한다. 그런데 오브젝트가 다 동일한 방식으로 변하는건 아니고 공통 관심사에 따라 변한다. 지금까지 크게 두가지를 다뤘다.</p>\n<ol>\n<li>데이터를 어떻게 접근할것인가</li>\n<li>어떻게 데이터베이스를 쉽게 변경할것인가.</li>\n</ol>\n<p>위의 소스로 장점은 데이터 접근 방식이 수정된다면 우리는 UserDao를 변경할것이다. 만약 DB에서 꺼내온 정보를바탕으로 뭔가 정보가 수정된다면 그 구현체들 MUserDao, DUserDao가 수정될것이다. 이것은 것으로 보면 서로에게 영향을 안주는것같지만 상속이라는 방법을 사용했기때문에 지독한 의존성을 가진다. 다음에서부터는 그 의존성을 좀더 느슨하게 할것이다.</p>\n<h4><span id=\"클래스의분리\">클래스의분리</span></h4>\n<p>DB 커넥션과 관련된 부분을 서브클래스가 아니라, 아예 별도의 클래스로 분리해보자. 하지만 여전히 UserDao 에서 클래스를 생성해야하기때문에 UserDao는 ConnectionMaker클래스에 의존적이다.<br>\n<img src=\"https://i.imgur.com/818CZkt.png\" alt=\"\"></p>\n<h4><span id=\"인터페이스의-도입\">인터페이스의 도입</span></h4>\n<p>위에서 결국엔 클래스를 분리해도 데이터베이스를 연결하기 위해서는 지독한 의존성을 가지게된다. 이문제를 해결하기위해서는 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느스한 연결고리가 필요하다. 추상화란 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리하는 작업이다. 자바가 추상화를 위해 제공하는 가장 유용한 도구는 바로 인터페이스이다. 인터페이스를 통해 추상화를 하게되면 최소환의 통로를 통해 접근하는 쪽에서는 오브젝트를 만들때 사용할 클래스가 무엇인지 몰라도 된다.</p>\n<p><img src=\"https://i.imgur.com/iCN1k2t.png\" alt=\"\"></p>\n<p>인터페이스를 도입했지만 여전히 자바에서 인터페이스를 통해 객체를 생성할때 아래와같이 new DConnectionMaker(); 선언을 해줘야하기떄문에 근본적인 문제가 해결되지않는다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserDao</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  connectionMaker = <span class=\"keyword\">new</span> DConnectionMaker();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4><span id=\"관계설정-책임의-분리\">관계설정 책임의 분리</span></h4>\n<p><img src=\"https://i.imgur.com/ZBKuVCa.png\" alt=\"\"><br>\n그래서 이러한 근본적인 문제를 해결하기 위해서는 인터페이스를 통해서 처음부터 관계를 설정해주면된다. 아래와같이.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ConnectionMaker</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Connection <span class=\"title\">makeConnection</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ClassNotFoundException, SQLException</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DConnectionMaker</span> <span class=\"keyword\">implements</span> <span class=\"title\">ConnectionMaker</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Connection <span class=\"title\">makeConnection</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// D 사의 독자적인 방법으로 Connection 을 생성하는 코드</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDao</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ConnectionMaker connectionMaker; ㅡ&gt; 인터페이스를 통해 오브젝트에 접근, so 구체적 클래스 정보가 필요 없다.</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserDao</span><span class=\"params\">(ConnectionMaker connectionMaker)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.connectionMaker = connectionMaker;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(User user)</span> <span class=\"keyword\">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class=\"line\">        Connection c = connectionMaker.makeConnection();</span><br><span class=\"line\">      ㅡ&gt; 인터페이스에 정의된 메소드를 사용하므로 클래스가 바뀐다고 메소드 이름이 변경 되지 않는다.</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> user <span class=\"title\">get</span><span class=\"params\">(String id)</span> <span class=\"keyword\">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class=\"line\">        Connection c = connectionMaker.makeConnection();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이제 이렇게 의존성 주입을 해주게되면 ConnectionMaker의 역할을 할 수 있는 어떤 클래스가 들어와도 UserDao기능을 수행할 수 있게 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDaoTest</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class=\"line\">        ConnectionMaker connectionMaker = <span class=\"keyword\">new</span> DConnectionMaker();</span><br><span class=\"line\">        <span class=\"comment\">// UserDao가 사용할 ConnectionMaker 구현 클래스를 결정하고 오브젝트를 만든다.</span></span><br><span class=\"line\"></span><br><span class=\"line\">        UserDao dao = <span class=\"keyword\">new</span> UserDao(connectionMaker);</span><br><span class=\"line\">        <span class=\"comment\">// 1. UserDao 생성</span></span><br><span class=\"line\">        <span class=\"comment\">// 2. 사용할 ConnectionMaker 타입의 오브젝트 제공, 결국 두 오브젝트 사이의 의존관계 설정</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>최종적으로 UserDaoTest와같이 UserDao를 즉 3자 호출하는곳에서 의존성 주입을하게되면 아래와같이 불필요한 의존관계를 끊을 수 있게된다. 이렇게되면 어떤 Connection이 들어와도 UserDao를 클래스 수정없이 UserDao클래스 기능을 사용할 수 있게된다.</p>\n<p><img src=\"https://i.imgur.com/XghdksD.png\" alt=\"\"></p>\n<h4><span id=\"134-원칙과-패턴\">1.3.4 원칙과 패턴</span></h4>\n<h5><span id=\"개방-폐쇄원칙\">개방 폐쇄원칙</span></h5>\n<p>개방 폐쇄 원칙은 깔끔한 설계를 위해 적용 가능한 객체지향 설계 원칙 중의 하나다. 클래스나 모듈은 확장에는 열려 있어야하고 변경에는 닫혀 있어야한다고 할 수 있다. UserDao는 DB연결 방법이라는 기능을 확장하는데는 열려있다. UserDao에는 전혀 영향을 주지 않고도 얼마든지 확장 가능하다. 잘설계된 객체지향 클래스의 구조를 살펴보면 바로 이 개방 폐쇄 원칙을 아주 잘 지키고 있다. 인터페이스를 사용해 확장 기능을 정의한 대부분의 API는 바로 개방 폐쇄 원칙을 잘 따르고 있다고 볼 수 있다.</p>\n<h5><span id=\"높은-응집도와-낮은-결합도\">높은 응집도와 낮은 결합도</span></h5>\n<p><strong>높은 응집도 (같은 기능끼리 모여있다는것)</strong><br>\n응집도가 높다는것은 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻, 하나의 모듈에서만 변경이 많이 일어나면 다른 모듈은 변경이 필요가 없을때를 말한다. 하나의 클래스에 여러가지 관심사가 모여있다면 그 관심사 하나가 변경되면 다른 영향을 미치짖 않는지 확인해야하는 이중의 부담이 생긴다. 예를들어 기존의 NConnectionMaker를 개선해서 2.0을 만들었다해보자. 그렇게되면 NConnectionMaker를 테스트하기위해서 모든 DAO를 테스트할필요는없다. 높은 응집도때문에 그냥 NConnectionMaker만 테스트해도 충분하다. ConnectionMaker를 분리해서 높은 응집도를 가지고있기 때문이다.</p>\n<p><strong>낮은 결합도</strong><br>\n낮은 결합도는 높은 응집도 보다 더 민감한 원칙이다. 책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합도, 즉 느슨하게 연결된 형태를 유지하는것이 바람직하다. 결합도가 낮아지면 변화에 대응하느 속도가 높아지고, 구성이 깔끔해진다. 또한 확장하기에도 매우 편리하다. 예를들면 위에서 보여준 예제처럼 인터페이스를 통한 ConnectionMaker구현이 있을 수 있다.</p>\n<p><strong>전략패턴</strong><br>\n개선한 UserDaoTest - UserDao - ConnectionMaker 구조를 디자인 패턴의 시각으로 보면 전략 패턴에 해당한다고 볼 수 있다. 전략패턴은 디자인 패턴의 꽃이라고 불릴만큼 다양하게 자주 사용되는 패턴이다. 개방 폐쇄 원칙의 실현에도 가장 잘 들어 맞는 패턴이라고 볼 수 있다. 전략 패턴은 자신의 기능 Context에서,필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용 할 수 있게 하는 디자인 패턴이다.<br>\nUserDao는 전략패턴의 컨텍스트에 해당한다. 컨텍스트는 자신의 기능을 수행하는데 필요한 기능 중에서 변경 가능한, DB 연결 방식이라는 알고리즘을 ConnectionMaker라는 인터페이스로 정의하고, 이를 구현한 클래스, 즉 전략을 바꿔가면서 사용할 수 있게 분리했다.</p>\n<p>전략패턴은 컨텍스트(UserDao)를 사용하는 클라이언트(UserDaoTest)는 컨텍스트가 사용할 전략 (ConnectionMaker를 구현한 클래스, 예 DConnectionMaker)을 컨텍스트의 생성자등을 통해 제공해주는게 일반적이다.</p>\n<h3><span id=\"14-제어의-역전ioc\">1.4 제어의 역전(IoC)</span></h3>\n<h4><span id=\"오브젝트-팩토리\">오브젝트 팩토리</span></h4>\n<p>UserDaoTest는 기존에 UserDao가 직접 담당하던 기능, 즉 어떤 ConnectionMaker구현 클래스를 사용할지를 결정하는 기능을 엉겁결에 떠 맡았다. UserDao가 ConnectionMaker인터페이스를 구현한 특정 클래스로부터 완벽하게 독립할 수 있도록 UserDao의 클라이언트인 UserDaoTest가 그 수고를 담당하게 된 것이다.<br>\n그런데 처음목적은 UserDaoTest는 UserDao의 기능이 잘 동작하는지를 테스트하려고 만든 것이다. 그런데 지금 또다른 책임까지 떠 맡고 있으니 UserDaoTest는 2개의 관심사를 가지고 있는것이다. 그러므로 두개의 관심사를 분리해줘야한다.</p>\n<h5><span id=\"팩토리\">팩토리</span></h5>\n<p>팩토리 클래스의 역할은 객체의 생성방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 것이다. 팩토리 클래스의 역할을 맡을 클래스는 DaoFactory이다. DaoFactory는 UserDaoTest에서는 DaoFactory에 요청해서 미리 만들어진 UserDao오브젝트를 가져와 사용하게 만든다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaoFactory</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> UserDao <span class=\"title\">userDao</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//팩토리메소는 UserDao탕ㅂ의 오브젝트를 어떻게 만들고 어떻게 준비시킬지 결정한다.</span></span><br><span class=\"line\">    ConnectionMaker connectionMaker = <span class=\"keyword\">new</span> DConnectionMaker();</span><br><span class=\"line\">    UserDao userDao = <span class=\"keyword\">new</span> UserDao(connectionMaker);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> userDao;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>아래와같이 이제 UserDaoTest는 더이상 UserDao가 어떻게 생성되는지 신경쓰지 않고 테스트하는것에만 집중할 수 있게된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDaoTest</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException,SQLException</span>&#123;</span><br><span class=\"line\">    UserDao dao = <span class=\"keyword\">new</span> DaoFactory.userDao();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5><span id=\"설계도로서의-팩토리\">설계도로서의 팩토리</span></h5>\n<p><img src=\"https://i.imgur.com/IxtsfLd.png\" alt=\"\"><br>\n그림과 같이 UserDaoTest는 DaoFactory를통해 DConnectionMaker를 주입받아 사용하게된다.</p>\n<h4><span id=\"오브젝트-팩토리의-활용\">오브젝트 팩토리의 활용</span></h4>\n<p>만약 추가적인 Dao들이 추가된다고 생각해보자. 그러면 아래와같이 반복되는 코드가 발생하게된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaoFactory</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> UserDao <span class=\"title\">userDao</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UserDao(<span class=\"keyword\">new</span> DConnectionMaker();)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> AccountDao <span class=\"title\">userDao</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UserDao(<span class=\"keyword\">new</span> DConnectionMaker();)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위의 문제를 해결할려면 ConnectionMaker를생성하는 아래의소스와같이 공통으로 뽑아내는 방법이있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaoFactory</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> UserDao <span class=\"title\">userDao</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UserDao(<span class=\"keyword\">new</span> DConnectionMaker();)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> AccountDao <span class=\"title\">userDao</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UserDao(<span class=\"keyword\">new</span> DConnectionMaker();)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ConnectionMaker <span class=\"title\">connectionMaker</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DConnectionMaker();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위와같이 소스를 변경하게되면 ConnectionMaker부분만 수정하게되면 Dao팩토리 메소드가 많아져도 ConnectionMaker의 메소드만 변경하게되면 모든 커넥션마커의 기능들이 수정되기때문에 시간을 절약할수 있게 된다.</p>\n<h4><span id=\"제어권의-이전을-통한-제어관계-역전\">제어권의 이전을 통한 제어관계 역전</span></h4>\n<p>일반적으로 프로그램의 흐름은 main() 메소드와 같이 프로그램이 시작되는 지점에서 다음에 사용할 오브젝트를 결정하고 결정한 오브젝트를 생성하고, 만들어진 오브젝트를 사용한다. 언제 어떻게 오브젝트를 만들지를 스스로 관장한다. 모든 종류의 작업을 사용하는 쪽에서 제어하는 구조이다. 제어의 역전은 이런 제어 흐름의 개념을 거꾸로 뒤집는 것이다. 제어의 역전에서는 모든 제어의 권한을 자신이 아닌 다른 대상에게 위임한다.<br>\n제어의 역전 개념은 이미 서블릿에서도 사용되고있다. 서블릿에 대한 제어권한을 가진 컨테이너가 적절한 시점에 서블릿 클래스의 오브젝트를 만들고 그안의 메소드를 호출한다. 이렇게 서블릿이나, JSP, EJB에서는 간단한 방식으로 제어의 역전 개념이 적용되어 있다.</p>\n<h3><span id=\"15-spring-ioc\">1.5 Spring IoC</span></h3>\n<p>스프링의 핵심을 담당하는 건 바로 빈팩토리, 또는 ApplicationContext라고 불리는 것이다. 이것은 우리가 만든 DaoFactory가 하는 일을 스프링에서 좀더 일반화한 것이라고 할 수 있다</p>\n<h4><span id=\"제어권의-이전을-통한-제어관계-역전\">제어권의 이전을 통한 제어관계 역전</span></h4>\n<p>스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 빈이라고 부른다. 스프링에서 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 빈팩토리라고 한다. 보통 빈팩토리보다는 이를 좀더 확장한 ApplicationContext를 주로 사용한다.<br>\nApplicationContext는 별도의 정보를 참고해서 빈의 생성, 관계설정등의 제어 작업을 총괄한다. DaoFactory에서는 어떤 클래스의 오브젝트를 생성할지 어떻게 연결할것인지에 대해 설정을 해줬었다. 하지만 ApplicationContext는 직접 이런정보를 담지 않고 별도로 설정정보를 담고 있는 자바 @Configuration 설정되어져 있는 자바클래스의 정보를 가져와 이를 활용하는 범용적인 Ioc 엔진이라고 할 수 있다.</p>\n<h5><span id=\"daofactory를-사용하는-applicationcontext\">DaoFactory를 사용하는 ApplicationContext</span></h5>\n<p>DaoFactory를 스프링의 빈팩토리(ApplicationContext)가 사용할수있도록 설정 정보를 만들 것이다. 먼저 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스라고 인식할수 있도록 @Configuration 이라는 어노테이션을 추가한다. 그리고 오브젝트를 만들어주는 메소드에는 @Bean 이라는 어노테이션을 추가한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span> <span class=\"comment\">// 애플리케이션 컨텍스트 또는 빈 팩토리가 사용할 설정정보라는 표시</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaoFactory</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span> <span class=\"comment\">// 오브젝트를 새엉을 담당하는 IoC용 메소드라는 표시</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> UserDao <span class=\"title\">userDao</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UserDao(connectionMaker());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ConnectionMaker <span class=\"title\">connectionMaker</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DConnectionMaker();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이제 아래와같이 준비된 ApplicationContext의 getBean()이라는 메소드를 이용해서 UserDao의 오브젝트를 가져올 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDaoTest</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException,SQLException</span>&#123;</span><br><span class=\"line\">    ApplicationContext context = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(DaoFactory.class);</span><br><span class=\"line\">    UserDao dao = context.getBean(<span class=\"string\">\"userDao\"</span>,UserDao.class);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>context.getBean(“userDao”,UserDao.class);의 userDao는 DaoFactory 메소드의 이름이다. 어떻게 메소드의 이름을 설정하느냐에따라 빈을 가지고올때 String값을 변경해주면 된다.</p>\n<h4><span id=\"applicationcontext의-동작-방식\">ApplicationContext의 동작 방식</span></h4>\n<p>스프링에서 ApplicationContext를 IoC컨테이너라고 하기도하고 간단히 스프링 컨테이너라고도 한다. @Configuration이 붙은 DaoFactory는 ApplicationContext가 활용하는 IoC설정정보다. 내부적으로 애플리케이션 컨텍스가 DaoFactory의 userDao() 메소드를 호출해서 오브젝트를 가져온 것을 클라이언트가 getBean()으로 요청할 때 전달 해준다. 아래 그림은 ApplicationContext의 사용되는 방식이다.</p>\n<p><img src=\"https://i.imgur.com/Uf9J8vi.png\" alt=\"\"></p>\n<h5><span id=\"applicationcontext를-사용했을때-장점\">ApplicationContext를 사용했을때 장점</span></h5>\n<ol>\n<li>클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.</li>\n<li>애플리케이션 컨텍스트는 종합 IoC서비스를 제공해준다.<br>\n오브젝트가 만들어지는 방식, 오브젝트에 대한 후처리, 정보의 조합 설정 방식의 다변화, 인터셉티등 오브젝트를 효과적으로 활용할 수 있는 다양한 기능을 제공한다.</li>\n<li>애플리케이션 컨텍스트는 빈을 검색하는 다양한방법을 제공한다.<br>\n타입만으로도 빈을 검색하거나 특별한 애노테이션 설정이 되어있는 빈을 찾을 수 도 있다.</li>\n</ol>\n<h3><span id=\"16-싱글톤-레지스틀와-오브젝트-스코프\">1.6 싱글톤 레지스틀와 오브젝트 스코프</span></h3>\n<p>DaoFactory와 @Configuratuon애노테이션을 추가해서 스프링의 애플리케이션 컨텍스트를 사용하는것의 차이점에 대해서 알아볼것이다. 둘의 큰 차이점은 리턴해주는 빈의 동일성을 보장 해주는것이다. 먼저 아례의 예제를 보자</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">DaoFactory factory = <span class=\"keyword\">new</span> DaoFactory();</span><br><span class=\"line\">UserDao dao1 = factory.userDao();</span><br><span class=\"line\">UserDao dao2 = factory.userDao();</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(dao1); <span class=\"comment\">//springbook.dao.UserDao@118f375</span></span><br><span class=\"line\">System.out.println(dao2); <span class=\"comment\">//springbook.dao.UserDao@117a8bd</span></span><br></pre></td></tr></table></figure>\n<p>출력결과에서 알수 있듯이 동일성이 보장되지 않는 객체들이 출력된다. 그럼 스프링 컨테이너를 이용해서 빈을 호출해 볼 것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ApplicationContext context = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(DaoFactory.class);</span><br><span class=\"line\"></span><br><span class=\"line\">UserDao dao3 = factory.userDao();</span><br><span class=\"line\">UserDao dao4 = factory.userDao();</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(dao3); <span class=\"comment\">//springbook.dao.UserDao@ee22f7</span></span><br><span class=\"line\">System.out.println(dao4); <span class=\"comment\">//springbook.dao.UserDao@ee22f7</span></span><br></pre></td></tr></table></figure>\n<p>스프링 컨테이너 즉 ApplicationContext를 통해 생성한 오브젝트는 동일성을 보장해준다. 여러번에 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 리턴해준다.</p>\n<h4><span id=\"싱글톤-레지스트리로서의-애플리케이션-컨텍스트\">싱글톤 레지스트리로서의 애플리케이션 컨텍스트</span></h4>\n<p>ApplicationContext는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이다. 스프링은 기본적으로 별다른 설정을 하지 않으면 내부에 생성하는 빈오브젝트를 모두 싱글톤으로 생성한다.</p>\n<h5><span id=\"서버-애플리케이션-싱글톤\">서버 애플리케이션 싱글톤</span></h5>\n<p>스프링에서 싱글톤을 사용하는 이유는 스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버 환경이기 때문이다. 물론 스프링으로 PC등에서 동작하는 독립형 윈도우 프로그램으로도 개발할수 있긴 하지만 극히 드물다.<br>\n스프링이 처음 설계됐던 대규모의 엔터프라이즈 서버환경은 서버 하나당 최대로 초당 수십에서 수백 번씩 브라우저나 여타 시스템으로부터의 요청을 받아 처리할 수 있는 높은 성능이 요구되는 환경이었다. 또 하나의 요청을 처리하기위해 데이터 액세스로직, 서비스로직, 비지니스로직,프레젠테이션로직등의 다양한 기능을 담당하는 오브젝트들이 참여하는 계층형 구조였다.<br>\n그런데 매번 클라이언트에서 요청이 들어 올때마다 각로직을 담당하는 오브젝트를 새로 만들어본다고 생각해보자. 요청 한번에 5개의 오브젝트가 새로 만들어지고 초당 500개의 요청이 들어오면 초당 2500개의 새로운 오브젝트가 생성된다. 1분이면 십오만개, 한시간이면 9백만개의 새로운 오브젝트가 만들어진다. 아무리 자바의 가비지컬렉션의 성능이 좋아졌다고 한들 이렇게 부하가 걸리면 서버가 감당하기 힘들다.<br>\n엔터프라이즈 환경에서의 서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작한다. 서블릿 클래스당 하나의 오브젝트만 만들어 두고, 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용된다.<br>\n이렇게 애플리케이션 안에 제한된 수, 대개 한개의 오브젝트만 만들어서 사용하는 것이 싱글톤 패턴의 원리이다.따라서 서버 환경에서는 서비스 싱글톤의 사용이 권장된다.</p>\n<h5><span id=\"싱글톤-패턴의-한계\">싱글톤 패턴의 한계</span></h5>\n<p>싱글통 패턴을 적용한 UserDao</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDao</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> UserDao INSTANCE;</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">UserDao</span><span class=\"params\">(ConnectionMaker connectionMaker)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.connectionMaker = connectionMaker;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> UserDao <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(INSTANCE == <span class=\"keyword\">null</span>) INSTANCE = <span class=\"keyword\">new</span> UserDao(???);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>싱글톤의 단점</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-private  생성자를 갖고 있기 때문에 상속할 수 없다.</span><br><span class=\"line\">-싱글톤은 테스트하기가 힘들다.</span><br><span class=\"line\">-서버환경에서는 싱글톤이 하나만 만들어지는것을 보장하지 못한다</span><br><span class=\"line\">-싱글톤의 사용은 전역상태를 만들 수 있기 때문에 바람직하지 못하다.</span><br></pre></td></tr></table></figure>\n<h5><span id=\"싱글톤-레지스트리\">싱글톤 레지스트리</span></h5>\n<p>자바의 기본적인 싱글톤 패턴의 구현 방식은 여러가지 단점이 있기 때문에 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다. 그것이 바로 싱글톤 레지스트리이다. 스프링 컨테이너는 싱글톤을 생성하고, 관리하고 공급하는 싱글톤 관리 컨테이너이기도 하다. 싱글톤 레지스트리는 스태틱메소드와 private생성자등을 사용해야하는 비정상적인 클래스가 아닌 평범한 자바 클래스를 싱글톤으로 활용하게 해준다.</p>\n<h4><span id=\"싱글톤과-오브젝트의-상태\">싱글톤과 오브젝트의 상태</span></h4>\n<p>싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있다. 따라서 상태 관리(전역변수)에 주의 해야한다. 기본적으로 클래스내에서 전역변수를 사용하지 말아야한다. 다중 사용자의 요청을 한꺼번에 처리하는 스레드들이 동시에 싱글톤오브젝트의 전역변수를 수정하는것은 매우 위험하다. 저장할 공간이 하나 뿐이니 서로 값을 덮어쓰고 자신이 저장하지 않은값을 읽어 오거나 삭제할수있기때문이다. 물론 읽기전용의 전역변수는 사용해도좋다. 이런 변수들은 final로 선언해주는거시 안전하다. 메소드안에는 지연변수(스택 영역에 저장되어져있다)이기떄문에 메소드 호출후에 초기화된다.</p>\n<h4><span id=\"스프링-빈의-스코프\">스프링 빈의 스코프</span></h4>\n<p>스프링 내에서 빈이 생성되고 존재하고 등의 적용되는 범위에대해 스프링에서는 이것을 스코프라고한다. 기본적으로 프로토타입,요청,세션등으로 분리하여 관리해주는 스코프 범위가 존재한다.</p>\n<h3><span id=\"17-의존과계-주입di\">1.7 의존과계 주입(DI)</span></h3>\n<h4><span id=\"제어의-역전과-의존관계-주입\">제어의 역전과 의존관계 주입</span></h4>\n<p>여기에서 한가지 짚고 넘어갈 것은 IoC라는 용어인데, IoC가 매우 느슨하게 정의돼서 폭넓게 사용되는 용어라는것이다. 때문에 스프링을 IoC 컨테이너라고만 해서는 스프링이 제공하는 기능의 특징을 명확하게 설명하지 못했다. 그래서 나온말이 IoC방식을 핵심을 짚어주는 의존관계 주입(DI)이다. 스프링의 IoC 기능의 대표적인 동작원리는 주로 의존관계 주입이라고 불린다. 스프링이 여타 프레임워크와 차별화돼서 제공해주는 기능은 의존관계 주입이라는 새로운 용어를 사용할 때 분명하게 드러난다. 초기에는 주로 IoC 컨테이너라고 불리던 스프링이 지금은 의존관계 주입 컨테이너 또는 그영문약자를 써서 DI컨테이너라고 더 많이 불리고 있다.</p>\n<h4><span id=\"런타임-의존관계-설정\">런타임 의존관계 설정</span></h4>\n<h5><span id=\"의존관계\">의존관계</span></h5>\n<p>두 개의 클래스 또는 모듈이 의존관계에 있다고 말할 때는 항상 방향성을 부여해줘야 한다. 즉 누가 누구에게 의존하는 관계 있다는 식어야한다. A클래스가 B에 의존하고 있을때 B가 변동사항이 있으면 A에 영향을 미치게된다. 하지만 A가 변경된다고해서 B는 영향 받지 않는다.</p>\n<h5><span id=\"userdao의-의존관계\">UserDao의 의존관계</span></h5>\n<p><img src=\"https://i.imgur.com/Am2R3Z3.png\" alt=\"\"><br>\n위 그림은 UserDao가 ConnectionMaker에 의존하고 있는 형태이다. ConnectionMaker인터페이스가 변한다면 그영향은 UserDao가 받을 것이다. 하지만 ConnectionMaker의 구현체인 DConnectionMaker등이 바뀌거나 내부적으로 메소드가 변화가 생겨도 UserDao에 영향을 주지 않는다. 이렇게 인터ㅔ이스대해서만 의존관계를 만들어두면 인터페이스를 구현 클래스와의 관계는 느슨해지면서 변환에 영향을 덜 받는 상태가 된다. 인터페이스를 통해 의존관계를 제한해주면 그만큼 변경에서 자유로워지는 셈이다.<br>\n그런데 모델이나 코드에서 클래스와 인터페이스를 통해 드러나는 의존관계말고, 런타임시에 오브젝트 사이에서 만들어지는 의존관계도 있다. 의존과계 또는 오브젝트 의존 관계인데, 설계 시점의 의존관계가 실체화된 것이라고 볼 수 있다. 런타임 의존관계는 모델링 시점의 의존관계와는 성격이 분명히 다르다.<br>\n인터페이스를 통해 설계 시점에 느슨한 의존관계를 갖는 경우에는 UserDao의 오브젝트가 런타임 시에 사용할 오브젝트가 어떤 클래스로 만든것인지 미리 알 수 가없다. 프로그램이 시작되고 UserDao 오브젝트가 만들어지고 나서 런타임 시에 의존관계를 맺는 대상, 즉 실제 사용대상인 오브젝트를 의존 오브젝트라고 한다.</p>\n<p>의존관계 주입은 이렇게 구체적인 의존 오브젝트와 그것을 사용할 주체, 보통 클라이언트라고 부르는 오브젝트를 런타임시에 연결해주는 작업을 말한다. UserDao는 ConnectionMaker 인터페이스라는 매우 단순한 조건만 만족하면 어떤 클래스로부터 만들어졌든 상관없이 오브젝트를 받아 들이고 사용한다.</p>\n<blockquote>\n<p>의존관계주입이란<br>\n-클래스 모델(UML)이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야한다.<br>\n-런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정한다.<br>\n-의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부주에서 제공(주입)해줌으로써 만들어진다.</p>\n</blockquote>\n<p>의존관계 주입의 핵심은 설계 시점에는 알지 못했던 두 오브젝트의 관계를 맺도록 도와주는 제 3의 존재가 있다는것이다. DI에서 말하는 제 3의 존재는 바로 관계설정 책임을 가진 클래스 라고 볼 수 있다. DaoFactory,ApplicationContext,Ioc컨테이너등이 모두 외부에서 오브젝트 사이의 런타임 관계를 맺어주는 책임을 지닌 제 3의 존재라고 볼 수 있다.</p>\n<h5><span id=\"userdao의-의존관계-주입\">UserDao의 의존관계 주입</span></h5>\n<p>다시 처음에 봤던 UserDao 에 적용된 의존관계 주입 기술을 다시 살펴보자. 인터페이스를 사이에 두고 UserDao와 ConnectionMaker구현클래스간에 의존관계를 느슨하게 만들긴 했지만, 마지막으로 남은 문제가 있었는데 아래소스와같이 UserDao가 사용할 구체적인 클래스를 알고 있어야 하는점이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserDao</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  connectionMaker = <span class=\"keyword\">new</span> DConnectionMaker();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이코드는 이미 설계 시점에 구체적인 런타임 의존관계 오브젝트를 알고 있다. 즉 DConnectionMaker오브젝트를 사용하겠다는 것 까지 UserDao가 결정하고 관리하고 있는셈이다.</p>\n<p>이코드의 문제는 이미 런타임시의 의존관계가 코드 속에 미리 다 결정되어있다는 것이다. 그래서 Ioc방식을 써서 UserDao로부터 런타임 의존관계를 드러내는 코드를 제거하고, 제 3의 존재에 런타임 의존관계 결정을 권한을 위함하는것이다. 그래서 최종적으로 만들어졌던것이 DaoFactory이다. DaoFactory는 런타임시점에 UserDao가 사용할 ConnectionMaker타입의 오브젝트를 결정하고 이를 생성한후에 UserDao의 생성자 파라미터로 주입해줌으로써 런타임 의존관계를 맺게 해준다. 이렇게 런타임시 주입의 기능을 수행함으로써 DaoFactory를 DI/IoC컨테이너라고도 한다.</p>\n<p>DI컨테이너느 자신이 결정한 의존관계를 맺어줄 클래스의 오브젝트를 만들고 이생성자를 파라미터로 오브젝트의 레퍼런스를 전달해준다. 그럼 아래 소스같이 생성자 파라미터를 통해 전달받은 런타임 의존관계를 갖는 오브젝트는 인스턴스 변수에 저장 해둔다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDao</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> ConnectionMaker connectionMaker;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserDao</span><span class=\"params\">(ConnectionMaker connectionMaker)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.connectionMaker = connectionMaker;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이렇게 해서 두 개의 오브젝트 간에 런타임 의존관계 만들어졌다. UserDao 오브젝트는 이제 생성자를 통해 주입받은 DConnectionMaker 오브젝트를 언제든 사용하면 된다. DI는 자신이 사용할 오브젝트에 대한 선택권과 생성 제어권을 외부로 넘기고 자신은 런타임시에 수동적로 주입받은 오브젝트를 사용한다는 점에서 IoC의 개념에 잘 들어 맞는다. 스프링 컨테이너의 IoC는 주로 의존관계 주입 또는 DI라는 데 초점이 맞춰져 있다. 그래서 스프링을 IoC컨테이너 외에도 DI컨테이너 또는 DI프레임워크라 한다.</p>\n<h4><span id=\"의존관계-검색과-주입\">의존관계 검색과 주입</span></h4>\n<p>스프링이 제공하는 IoC방법에서 오브젝트를 주입하는 방법 의존성 주입만 있는것은 아니다. 의존 관계를 맺는 방법이 외부로부터의 주입이 아니라 스스로 검색을 이용하는 의존관계 검색이 있다. 의존관계 검색은 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾는다. 물론 자신이 어떤 클래스의 오브젝트를 이용할지는 결정하지 않는다. 의존관계 검색은 런타임 시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트의 생성작업은 외부 컨테이너에게 맡기지만, 이를 가져올때는 메소드나 생성자를 통한 파라미터 전달이 아닌 아래 소스와같이 직접 컨테이너에게 요청하는 방식이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserDao</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  DaoFactory daoFactory = <span class=\"keyword\">new</span> DaoFactory();</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.connectionMaker = daoFactory.connectionMaker();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위와같이 생성해도 여전히 자신이 어떤 ConnectionMaker 오브젝트를 사용할지 미리 알지 못한다. 여전히 코드의 의존대상은 ConnectionMaker인터페이스이기 때문이다. 런타임시에 DaoFactory가 만들어서 돌려주는 오브젝트와 다이내믹하게 런타임 의존관계를 맺는다. 따라서 IoC개념을 잘 따르고 있으며, 그혜택을 받는 코드다. 하지만 적용방법은 외부로부터의 주입이 아니라 스스로 IoC 컨테이너인 DaoFactory에게 요청하는것이다.<br>\n위소스의 작업을 일반화한 스프링의 애플리케이션 컨텍스트라면 미리 정해놓은 이름을 전달해서 그 이름에 해당하는 오브젝트를 찾게 된다. 따라서 이를 일종의 검색이라고 볼 수 있다. 또한 그 대상이 런타임 의존관계를 가질 오브젝트이므로 의존관계 검색이라고 부르는 것이다.<br>\n스프링의 IoC 컨테이너인 애플리케이션 컨텍스트는 getBean이라는 메소드를 제공한다. 바로 이메소드가 의존관계를 검색에 사용되는것이다. 이것은 아래의 예제와같이 사용 할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserDao</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  AnnotationConfigApplicationContext context = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(DaoFactory.clas);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.connectionMaker = context.getBean(<span class=\"string\">\"connectionMaker\"</span>,ConnectionMaker.class);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>의존관계 검색은 기존 의존관계 주입의 거의 모든 장점을 갖고 있다. 하지만 코드면에서 좀 더 의존관계주입이 단순하고 깔끔하다. 의존관계 검색은 코드안에 오브젝트 팩토리 클래스나 스프링 API가 나타난다. 검색 방식을 이용하면 그안에서 컨텍스트를 만들고, 호출하고등의 불필요한 소스를 넣어줘야하기 때문이다. 따라서 대개는 의존관계주입방식을 사용하는것이 낫다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDaoTest</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException,SQLException</span>&#123;</span><br><span class=\"line\">    ApplicationContext context = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(DaoFactory.class);</span><br><span class=\"line\">    UserDao dao = context.getBean(<span class=\"string\">\"userDao\"</span>,UserDao.class);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>하지만 위에 소스처럼 static 메소드인 Main같은경우에는 DI를 이용해 오브젝트를 주입받을 방법이 없기 때문이다. 이러한경우 말고는 의존성주입을 받아 사용하는게 소스면에서 훨씬 깔끔하다.</p>\n<h4><span id=\"의존관계-주입의-응용\">의존관계 주입의 응용</span></h4>\n<h5><span id=\"부가기능-추가\">부가기능 추가</span></h5>\n<p>다음 이런경우를 한번 생각해보자. DAO가 DB를 얼마나 많이 연결해서 사용하는지 파악하고 싶다. DB연결횟수를 카운팅하기 위해 무식한 방법으로 모든 DAO의 makeConnection() 메소드를 호출하는 부분에 새로 추가한 카운터를 증가시키는 코드를 넣는것은 엄청난 낭비이고 노가다다.  그리고 무엇보다 DAO코드를 손대는것은 지금까지 피하려고했던 행동을 하는 것이다.<br>\nDI 컨테이너에서라면 아주 간단한 방법으로 해결가능하다. DAO와 DB 커넥션을 만드는 오브젝트 사이에 열결횟수를 카운팅하는 오브젝트를 하나 더 추가하는 것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CountingConnectionMaker</span> <span class=\"keyword\">implements</span> <span class=\"title\">ConnectionMaker</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> counter = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ConnectionMaker realConnectionMaker;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> CountingConnectionMaker <span class=\"title\">realConnectionMaker</span><span class=\"params\">(ConnectionMaker realConnectionMaker)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.realConnectionMaker = realConnectionMaker;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Connection <span class=\"title\">makeConnection</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ClassNotFoundException,SQLException</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.counter++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> realConnectionMaker.makeConnection();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getCounter</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.counter;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>CountingConnectionMaker 클래스는 ConnectionMaker 인터페이스를 구현했지만 내부에서 직접 DB커넥션을 만들지 않는다. 대신 DAO가 DB커넥션을 가져올 때마다 호출하는 makeConnection()에서 DB연결횟수 카운터를 증가시킨다.CountingConnectionMaker는 자신의 관심사인 DB 연결횟수 카운팅 작업을 마치면 실제 DB 커넥션을 만들어주는 realConnectionMaker에 저장된 ConnectionMaker타입 오브젝트의 makeConnection()호출해서 그 결과를 DAO에 돌려준다.</p>\n<p>생성자를 보면 ConnectionConnectionMaker도 DI를 받는것을 알 수 있다. UserDao는 ConnectionMaker의 인터페이스에만 의존하고 있기 때문에 ConnectionMaker 를 구현하고있는 어떤 구현체라도 DI가 가능하다. 그래서 DI받는 오브젝트를 DConnection오브젝트를 대신 CountingConnectionMaker를 받은것이다. 그리고 그 CountingConnectionMaker는 DConnectionMaker를 의존주입을 받은것이다.<br>\n<img src=\"https://i.imgur.com/EfluSD4.png\" alt=\"\"><br>\n<img src=\"https://i.imgur.com/Am2R3Z3.png\" alt=\"\"><br>\n이렇게해서 CountingConnectionMaker 재구성된 새로운 런타임 의존관계는 위 그림과 같다. 우의 그림을 코드라바꾸면 아래와같이 만들 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CountingDaoFactory</span></span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> UserDao userDao&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UserDao(ConnectionMaker());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ConnectionMaker <span class=\"title\">connectionMaker</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CountingConnectionMaker(realConnectionMaker());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ConnectionMaker <span class=\"title\">realConnectionMaker</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DConnectionMaker();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이제 커넥션 카운팅을 위한 실행 코드를 만들어보자. 기본적으로 UserDaoTest와 같지만 설정요 클래스를 CountingDaoFactory로 변경해줘야한다. 그리고 CountingConnectionMaker빈을 가져온다. 설정정보에 지정된 이름과 타입만 알면 특정 빈을 가져 얼 수 있으니 CoutingConnectionMaker 오브젝트를 가져오는 건 간단하다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDaoConnectionCountingTest</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException,SQLException</span>&#123;</span><br><span class=\"line\">    AnnotationConfigApplicationContext context = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(CountingDaoFactory.class);</span><br><span class=\"line\">    UserDao dao = context.getBean(<span class=\"string\">\"userDao\"</span>,UserDao.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">//DAO 사용코드</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\">    CountingConnectionMaker ccm = context.getBean(<span class=\"string\">\"connectionMaker\"</span>,CountingConnectionMaker.class);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Connection counter :\"</span> + ccm.getCounter());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이렇게 함으로써 DBConnection 분석이 끝나면 다시 CountingDaoFactory 설정 클래스를 DaoFactory로 변경하거나 connectionMaker()메소드를 수정하는 것만으로 DAO의 런터암 의존관계는 이정상태로 복구된다.</p>\n<h4><span id=\"메소드를-이용한-의존관계-주입\">메소드를 이용한 의존관계 주입</span></h4>\n<p>간단하게 설명하자면 스프링에서 의존섭을 주입하는 방법은 생성자를 이용하는 방법뿐만 아니라 아래와 같이 setter아니면 직접 메소드를 정의해서 의존성을 주입하는 방법이있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDao</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ConnectionMaker connectionMaker;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setConnectionMker</span><span class=\"params\">(ConnectionMaker connectionMaker)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.connectionMaker = connectionMaker;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> UserDao <span class=\"title\">userDao</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  UserDao userDao = <span class=\"keyword\">new</span> UserDao();</span><br><span class=\"line\">  userDao.setConnectionMaker(connectionMaker());</span><br><span class=\"line\">  <span class=\"keyword\">return</span> userDao;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>단지 의존관계를 주입하는 시점과 방법이 달라졌을 뿐 결과는 동일하다.</p>\n<p><a href=\"https://github.com/minwan1/Spring-toby\" target=\"_blank\" rel=\"noopener\">예제소스</a></p>\n<h3><span id=\"정리\">정리</span></h3>\n<ul>\n<li>단일 책임원칙 기반하여 책임별로 클래스들을 나누었다. 예제를 보면 UserDao 같은경우에는 데이터 액세스에 관한 관심의 역할을 부여받음으로써 데이터 엑세스에대한 책임을 수행하고있다. ConnectionMaker 같은경우에는 데이터베이스 Connection방법을 설정을 할수 있는 역할을 부여받음으로써 데이터베이스 Connection방법에 관한 책임만을 가진다. 이렇게 명확하게 둘의 책임을 나눔으로써 데이터엑스세에 대한 비지니스로직을 변경한다거나 데이터베이스 Connection 방법을 변경한다거나할 때 서로의 영향을 안받는 독립적인 구조를 만들어 냈다.</li>\n<li>개방 폐쇄 원칙에 기반하여 클래스들을 나누었다. ConnectionMaker같은경우 인터페이스로 가져감으로써 데이터베이스 Connection 방법을 변경할때 거기에 맞는 구현체만 구현하게 되면 쉽게 데이베이스 Connection방법을 바꿀 수 있게 되었다. 또한 그 구현체 ConnectionMaker들은 데이터베이스 Connection 방법이 변경되지 않는 이상 바뀌지 않을 소스이다. 이런점을 보아서 개방 폐쇄원칙을 잘 준수했다고 볼 수 있다.</li>\n<li>오브젝트를 생성되고 관계를맺는 제어권을 별도의 오브젝트 팩토리로 만들었다. 객체를 직접 관리하지않고 팩토리를 통해 관리함으로써 기능들을 부품처럼 쉽게 바꿀수 있게 되었다.(제어의 역전/IOC)</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>토비의 스프링</h1>\n<p>이글은 <a href=\"http://book.naver.com/bookdb/book_detail.nhn?bid=7006516\" target=\"_blank\" rel=\"noopener\">토비님의 스프링책</a>을 보고 요약한 내용입니다</p>\n<h2>1장 오브젝트와 의존관계</h2>\n<p><strong>들어가며</strong><br>\n스프링이 자바에서 가장 중요하게 가치를 두는것은 바로 객체지향프로그래밍이 가능한 언어라는 점이다.  자바 엔터프라이즈 기술의 혼란속에서 잃어버렸던 객체지향 기술의 진정한 가치를 회복시키고 폭넓은 혜택을 누릴 수 있도록하는것이 스프링 철학이다. 그래서 스프링에서 관심을 많이두는것은 오브젝트의 생명주기이다. 그렇기 때문에 우리는 스프링이 어떤것이고, 무엇을 제공하는지 보다는 스프링이 관심을 갖는 대상인 오브젝트의 설계와 구현, 동작원리에대해 관심을 가져야한다.</p>\n<h3>1.1 초난감 DAO</h3>\n<p>먼저 간단하게 아래와같이 JDBC를 이용한 User CURD를 다룰것이다. 예제에서는 롬복을 사용하여 객체를 다룰것이다. 그리고 데이터베이스는 Inmemory DB인 H2를 사용할것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Setter</span></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String id;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String password;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Builder</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">User</span><span class=\"params\">(String id, String name, String password)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.id = id;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.password = password;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>유저의 정보에 접근할 수 있는 DAO를 아래와같이 만들자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDao</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(User user)</span> <span class=\"keyword\">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class=\"line\">        Class.forName(<span class=\"string\">\"org.h2.Driver\"</span>);</span><br><span class=\"line\">        Connection c = DriverManager.getConnection(<span class=\"string\">\"jdbc:h2:tcp://localhost:9092/mem:testdb;MVCC=TRUE\"</span>, <span class=\"string\">\"sa\"</span>, <span class=\"string\">\"\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        PreparedStatement ps = c.prepareStatement(<span class=\"string\">\"insert into users(id, name, password) values (?, ?, ?)\"</span>);</span><br><span class=\"line\">        ps.setString(<span class=\"number\">1</span>, user.getId());</span><br><span class=\"line\">        ps.setString(<span class=\"number\">2</span>, user.getName());</span><br><span class=\"line\">        ps.setString(<span class=\"number\">3</span>, user.getPassword());</span><br><span class=\"line\"></span><br><span class=\"line\">        ps.executeUpdate();</span><br><span class=\"line\"></span><br><span class=\"line\">        ps.close();</span><br><span class=\"line\">        c.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">get</span><span class=\"params\">(String id)</span> <span class=\"keyword\">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class=\"line\">        Class.forName(<span class=\"string\">\"org.h2.Driver\"</span>);</span><br><span class=\"line\">        Connection c = DriverManager.getConnection(<span class=\"string\">\"jdbc:h2:tcp://localhost:9092/mem:testdb;MVCC=TRUE\"</span>, <span class=\"string\">\"sa\"</span>, <span class=\"string\">\"\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        PreparedStatement ps = c.prepareStatement(<span class=\"string\">\"select * from users where id = ?\"</span>);</span><br><span class=\"line\">        ps.setString(<span class=\"number\">1</span>, id);</span><br><span class=\"line\"></span><br><span class=\"line\">        ResultSet rs = ps.executeQuery();</span><br><span class=\"line\">        rs.next();</span><br><span class=\"line\"></span><br><span class=\"line\">        User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">        user.setId(rs.getString(<span class=\"string\">\"id\"</span>));</span><br><span class=\"line\">        user.setName(rs.getString(<span class=\"string\">\"name\"</span>));</span><br><span class=\"line\">        user.setPassword(rs.getString(<span class=\"string\">\"password\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        rs.close();</span><br><span class=\"line\">        ps.close();</span><br><span class=\"line\">        c.close();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> user;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그다음은 실제 User 정보가 담길 디비를 아래와같이 만들어보자.</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">users</span> (</span><br><span class=\"line\">  <span class=\"keyword\">id</span>          <span class=\"built_in\">varchar</span>(<span class=\"number\">10</span>) primary <span class=\"keyword\">key</span>,</span><br><span class=\"line\">  <span class=\"keyword\">name</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">20</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span>,</span><br><span class=\"line\">  <span class=\"keyword\">password</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">10</span>) <span class=\"keyword\">not</span> <span class=\"literal\">null</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>이제 만들어진 코드를 바탕으로 테스트 코드를 아래와같이 작성해보자.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class=\"line\">    UserDao dao = <span class=\"keyword\">new</span> UserDao();</span><br><span class=\"line\"></span><br><span class=\"line\">    User user = <span class=\"keyword\">new</span> User();</span><br><span class=\"line\">    user.setId(<span class=\"string\">\"whiteship\"</span>);</span><br><span class=\"line\">    user.setName(<span class=\"string\">\"백기선\"</span>);</span><br><span class=\"line\">    user.setPassword(<span class=\"string\">\"married\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    dao.add(user);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(user.getId() + <span class=\"string\">\" 등록 성공\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    User user2 = dao.get(user.getId());</span><br><span class=\"line\">    System.out.println(user2.getName());</span><br><span class=\"line\">    System.out.println(user2.getPassword());</span><br><span class=\"line\">    System.out.println(user2.getId() + <span class=\"string\">\" 조회 성공\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위와같이 이제 테스트코드를 돌리게되면 데이터베이스를 통해 유저를 등록하고 조회를 할 수 있게 된다. 사실 위코드에서 소스가 작동하는데는 큰문제가 없다. 하지만 잠재적으로 엄청난 버그를 가지고있는 소스임은 분명하다. 그래서 위의 소스를 좀더 안전하고, 유지보수하기 좋은 소스를 만들기위해서 스프링과 결합하여 좀 더 효과적으로, 객체지향적으로 만들어나가는 방법에 대해 알아볼것이다.</p>\n<h3>1.2 DAO 분리</h3>\n<h4>커넥션만들기의 추출</h4>\n<p>먼저 중복된 코드가 무엇인지에대해 생각하여야한다. 먼저 앞에서 만든 UserDao의 중복코드를 제거하기 위해서 관심사항들을 뽑아보자.</p>\n<ul>\n<li>DB와 연결을 위한 커넥션을 가져오는 부분이다.</li>\n<li>사용자 등록을 위해 DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행하는 것 또한 계속 중복되고 있다.</li>\n<li>셋째는 작업이 끝나고 리소스들을 종료해주는 부분이다.</li>\n</ul>\n<p>먼저 DB와 연결을 위한 커넥션 부분을 제거해보자. getConnetion 메소드로 빼서 연결이 필요할때는 그메소드를 호출하는것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">get</span><span class=\"params\">(String id)</span>  <span class=\"keyword\">throws</span> ClassNotFoundException,SQLException</span>&#123;</span><br><span class=\"line\">  Connection c = getConnetion();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Connection <span class=\"title\">getConnection</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ClassNotFoundException,SQLException</span>&#123;</span><br><span class=\"line\">  class.forName(\"com.mysql.jdbc.Driver\");</span><br><span class=\"line\">  Connection C = DriverManager.getConnection(<span class=\"string\">\"jdbc:mysql://localhost/springbook\"</span>,<span class=\"string\">\"spring\"</span>,book);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> c</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위에 getConnection메소드는 관심의 종류에 따라 메소드 구분 해놓았다. 그렇기 때문에 한가지 관심 예를들어 데이터베이스의 종류를 바꾸는 등의  문제에서 하나의 메소드에 소스만 변경하게 되면 손쉽게 데이터 베이스를 변경할 수 있게 해준다. 기존 소스같은경우에는 스키마등이 변경된다고 치면 모든 스키마 URL등을 변경해줘야 했을것이다.</p>\n<h4>DB커넥션 만들기의 독립</h4>\n<p>이번에는 좀더 변화를 반기는 DAO를 만들것이다.</p>\n<p><strong>상속을 통한 확장</strong><br>\n<img src=\"https://i.imgur.com/zpT9cHZ.png\" alt=\"\"></p>\n<p>위그림과 같이 UserDao를 추상클래스로 선언 하면 좀더 확장성 있는 소스가 될 것이다. 이렇게 선언하게되면 추상클래스에 add와 get만 메소드를 구현하고 getConnection은 깡통메소드로 나두게되면 NUserDao, DUserDao에서 getConnection만 구현하게되면 2개의 각기 다른 디비를 붙일 수 있다.</p>\n<p>이렇든 UserDao와같은 슈퍼클래스는 기본적인 로직의 흐름(커넥션가져오기,sql생성,실행,반환)만들고 서브클래스는 메소드를 구현하는 패턴을 템플릿 메소드 패턴이라고 한다. 템플릿 메소드 패턴은 스프링에서 애용하는 패턴이다.</p>\n<p><img src=\"https://i.imgur.com/RSH9tOC.png\" alt=\"\"></p>\n<h3>1.3 DAO의 확장</h3>\n<p>모든 오브젝트는 변한다. 그런데 오브젝트가 다 동일한 방식으로 변하는건 아니고 공통 관심사에 따라 변한다. 지금까지 크게 두가지를 다뤘다.</p>\n<ol>\n<li>데이터를 어떻게 접근할것인가</li>\n<li>어떻게 데이터베이스를 쉽게 변경할것인가.</li>\n</ol>\n<p>위의 소스로 장점은 데이터 접근 방식이 수정된다면 우리는 UserDao를 변경할것이다. 만약 DB에서 꺼내온 정보를바탕으로 뭔가 정보가 수정된다면 그 구현체들 MUserDao, DUserDao가 수정될것이다. 이것은 것으로 보면 서로에게 영향을 안주는것같지만 상속이라는 방법을 사용했기때문에 지독한 의존성을 가진다. 다음에서부터는 그 의존성을 좀더 느슨하게 할것이다.</p>\n<h4>클래스의분리</h4>\n<p>DB 커넥션과 관련된 부분을 서브클래스가 아니라, 아예 별도의 클래스로 분리해보자. 하지만 여전히 UserDao 에서 클래스를 생성해야하기때문에 UserDao는 ConnectionMaker클래스에 의존적이다.<br>\n<img src=\"https://i.imgur.com/818CZkt.png\" alt=\"\"></p>\n<h4>인터페이스의 도입</h4>\n<p>위에서 결국엔 클래스를 분리해도 데이터베이스를 연결하기 위해서는 지독한 의존성을 가지게된다. 이문제를 해결하기위해서는 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느스한 연결고리가 필요하다. 추상화란 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리하는 작업이다. 자바가 추상화를 위해 제공하는 가장 유용한 도구는 바로 인터페이스이다. 인터페이스를 통해 추상화를 하게되면 최소환의 통로를 통해 접근하는 쪽에서는 오브젝트를 만들때 사용할 클래스가 무엇인지 몰라도 된다.</p>\n<p><img src=\"https://i.imgur.com/iCN1k2t.png\" alt=\"\"></p>\n<p>인터페이스를 도입했지만 여전히 자바에서 인터페이스를 통해 객체를 생성할때 아래와같이 new DConnectionMaker(); 선언을 해줘야하기떄문에 근본적인 문제가 해결되지않는다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserDao</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  connectionMaker = <span class=\"keyword\">new</span> DConnectionMaker();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4>관계설정 책임의 분리</h4>\n<p><img src=\"https://i.imgur.com/ZBKuVCa.png\" alt=\"\"><br>\n그래서 이러한 근본적인 문제를 해결하기 위해서는 인터페이스를 통해서 처음부터 관계를 설정해주면된다. 아래와같이.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ConnectionMaker</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Connection <span class=\"title\">makeConnection</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ClassNotFoundException, SQLException</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DConnectionMaker</span> <span class=\"keyword\">implements</span> <span class=\"title\">ConnectionMaker</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Connection <span class=\"title\">makeConnection</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// D 사의 독자적인 방법으로 Connection 을 생성하는 코드</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDao</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> ConnectionMaker connectionMaker; ㅡ&gt; 인터페이스를 통해 오브젝트에 접근, so 구체적 클래스 정보가 필요 없다.</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserDao</span><span class=\"params\">(ConnectionMaker connectionMaker)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.connectionMaker = connectionMaker;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(User user)</span> <span class=\"keyword\">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class=\"line\">        Connection c = connectionMaker.makeConnection();</span><br><span class=\"line\">      ㅡ&gt; 인터페이스에 정의된 메소드를 사용하므로 클래스가 바뀐다고 메소드 이름이 변경 되지 않는다.</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> user <span class=\"title\">get</span><span class=\"params\">(String id)</span> <span class=\"keyword\">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class=\"line\">        Connection c = connectionMaker.makeConnection();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이제 이렇게 의존성 주입을 해주게되면 ConnectionMaker의 역할을 할 수 있는 어떤 클래스가 들어와도 UserDao기능을 수행할 수 있게 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDaoTest</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class=\"line\">        ConnectionMaker connectionMaker = <span class=\"keyword\">new</span> DConnectionMaker();</span><br><span class=\"line\">        <span class=\"comment\">// UserDao가 사용할 ConnectionMaker 구현 클래스를 결정하고 오브젝트를 만든다.</span></span><br><span class=\"line\"></span><br><span class=\"line\">        UserDao dao = <span class=\"keyword\">new</span> UserDao(connectionMaker);</span><br><span class=\"line\">        <span class=\"comment\">// 1. UserDao 생성</span></span><br><span class=\"line\">        <span class=\"comment\">// 2. 사용할 ConnectionMaker 타입의 오브젝트 제공, 결국 두 오브젝트 사이의 의존관계 설정</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>최종적으로 UserDaoTest와같이 UserDao를 즉 3자 호출하는곳에서 의존성 주입을하게되면 아래와같이 불필요한 의존관계를 끊을 수 있게된다. 이렇게되면 어떤 Connection이 들어와도 UserDao를 클래스 수정없이 UserDao클래스 기능을 사용할 수 있게된다.</p>\n<p><img src=\"https://i.imgur.com/XghdksD.png\" alt=\"\"></p>\n<h4>1.3.4 원칙과 패턴</h4>\n<h5>개방 폐쇄원칙</h5>\n<p>개방 폐쇄 원칙은 깔끔한 설계를 위해 적용 가능한 객체지향 설계 원칙 중의 하나다. 클래스나 모듈은 확장에는 열려 있어야하고 변경에는 닫혀 있어야한다고 할 수 있다. UserDao는 DB연결 방법이라는 기능을 확장하는데는 열려있다. UserDao에는 전혀 영향을 주지 않고도 얼마든지 확장 가능하다. 잘설계된 객체지향 클래스의 구조를 살펴보면 바로 이 개방 폐쇄 원칙을 아주 잘 지키고 있다. 인터페이스를 사용해 확장 기능을 정의한 대부분의 API는 바로 개방 폐쇄 원칙을 잘 따르고 있다고 볼 수 있다.</p>\n<h5>높은 응집도와 낮은 결합도</h5>\n<p><strong>높은 응집도 (같은 기능끼리 모여있다는것)</strong><br>\n응집도가 높다는것은 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻, 하나의 모듈에서만 변경이 많이 일어나면 다른 모듈은 변경이 필요가 없을때를 말한다. 하나의 클래스에 여러가지 관심사가 모여있다면 그 관심사 하나가 변경되면 다른 영향을 미치짖 않는지 확인해야하는 이중의 부담이 생긴다. 예를들어 기존의 NConnectionMaker를 개선해서 2.0을 만들었다해보자. 그렇게되면 NConnectionMaker를 테스트하기위해서 모든 DAO를 테스트할필요는없다. 높은 응집도때문에 그냥 NConnectionMaker만 테스트해도 충분하다. ConnectionMaker를 분리해서 높은 응집도를 가지고있기 때문이다.</p>\n<p><strong>낮은 결합도</strong><br>\n낮은 결합도는 높은 응집도 보다 더 민감한 원칙이다. 책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합도, 즉 느슨하게 연결된 형태를 유지하는것이 바람직하다. 결합도가 낮아지면 변화에 대응하느 속도가 높아지고, 구성이 깔끔해진다. 또한 확장하기에도 매우 편리하다. 예를들면 위에서 보여준 예제처럼 인터페이스를 통한 ConnectionMaker구현이 있을 수 있다.</p>\n<p><strong>전략패턴</strong><br>\n개선한 UserDaoTest - UserDao - ConnectionMaker 구조를 디자인 패턴의 시각으로 보면 전략 패턴에 해당한다고 볼 수 있다. 전략패턴은 디자인 패턴의 꽃이라고 불릴만큼 다양하게 자주 사용되는 패턴이다. 개방 폐쇄 원칙의 실현에도 가장 잘 들어 맞는 패턴이라고 볼 수 있다. 전략 패턴은 자신의 기능 Context에서,필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용 할 수 있게 하는 디자인 패턴이다.<br>\nUserDao는 전략패턴의 컨텍스트에 해당한다. 컨텍스트는 자신의 기능을 수행하는데 필요한 기능 중에서 변경 가능한, DB 연결 방식이라는 알고리즘을 ConnectionMaker라는 인터페이스로 정의하고, 이를 구현한 클래스, 즉 전략을 바꿔가면서 사용할 수 있게 분리했다.</p>\n<p>전략패턴은 컨텍스트(UserDao)를 사용하는 클라이언트(UserDaoTest)는 컨텍스트가 사용할 전략 (ConnectionMaker를 구현한 클래스, 예 DConnectionMaker)을 컨텍스트의 생성자등을 통해 제공해주는게 일반적이다.</p>\n<h3>1.4 제어의 역전(IoC)</h3>\n<h4>오브젝트 팩토리</h4>\n<p>UserDaoTest는 기존에 UserDao가 직접 담당하던 기능, 즉 어떤 ConnectionMaker구현 클래스를 사용할지를 결정하는 기능을 엉겁결에 떠 맡았다. UserDao가 ConnectionMaker인터페이스를 구현한 특정 클래스로부터 완벽하게 독립할 수 있도록 UserDao의 클라이언트인 UserDaoTest가 그 수고를 담당하게 된 것이다.<br>\n그런데 처음목적은 UserDaoTest는 UserDao의 기능이 잘 동작하는지를 테스트하려고 만든 것이다. 그런데 지금 또다른 책임까지 떠 맡고 있으니 UserDaoTest는 2개의 관심사를 가지고 있는것이다. 그러므로 두개의 관심사를 분리해줘야한다.</p>\n<h5>팩토리</h5>\n<p>팩토리 클래스의 역할은 객체의 생성방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 것이다. 팩토리 클래스의 역할을 맡을 클래스는 DaoFactory이다. DaoFactory는 UserDaoTest에서는 DaoFactory에 요청해서 미리 만들어진 UserDao오브젝트를 가져와 사용하게 만든다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaoFactory</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> UserDao <span class=\"title\">userDao</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//팩토리메소는 UserDao탕ㅂ의 오브젝트를 어떻게 만들고 어떻게 준비시킬지 결정한다.</span></span><br><span class=\"line\">    ConnectionMaker connectionMaker = <span class=\"keyword\">new</span> DConnectionMaker();</span><br><span class=\"line\">    UserDao userDao = <span class=\"keyword\">new</span> UserDao(connectionMaker);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> userDao;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>아래와같이 이제 UserDaoTest는 더이상 UserDao가 어떻게 생성되는지 신경쓰지 않고 테스트하는것에만 집중할 수 있게된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDaoTest</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException,SQLException</span>&#123;</span><br><span class=\"line\">    UserDao dao = <span class=\"keyword\">new</span> DaoFactory.userDao();</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5>설계도로서의 팩토리</h5>\n<p><img src=\"https://i.imgur.com/IxtsfLd.png\" alt=\"\"><br>\n그림과 같이 UserDaoTest는 DaoFactory를통해 DConnectionMaker를 주입받아 사용하게된다.</p>\n<h4>오브젝트 팩토리의 활용</h4>\n<p>만약 추가적인 Dao들이 추가된다고 생각해보자. 그러면 아래와같이 반복되는 코드가 발생하게된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaoFactory</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> UserDao <span class=\"title\">userDao</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UserDao(<span class=\"keyword\">new</span> DConnectionMaker();)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> AccountDao <span class=\"title\">userDao</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UserDao(<span class=\"keyword\">new</span> DConnectionMaker();)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위의 문제를 해결할려면 ConnectionMaker를생성하는 아래의소스와같이 공통으로 뽑아내는 방법이있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaoFactory</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> UserDao <span class=\"title\">userDao</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UserDao(<span class=\"keyword\">new</span> DConnectionMaker();)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> AccountDao <span class=\"title\">userDao</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UserDao(<span class=\"keyword\">new</span> DConnectionMaker();)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ConnectionMaker <span class=\"title\">connectionMaker</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DConnectionMaker();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위와같이 소스를 변경하게되면 ConnectionMaker부분만 수정하게되면 Dao팩토리 메소드가 많아져도 ConnectionMaker의 메소드만 변경하게되면 모든 커넥션마커의 기능들이 수정되기때문에 시간을 절약할수 있게 된다.</p>\n<h4>제어권의 이전을 통한 제어관계 역전</h4>\n<p>일반적으로 프로그램의 흐름은 main() 메소드와 같이 프로그램이 시작되는 지점에서 다음에 사용할 오브젝트를 결정하고 결정한 오브젝트를 생성하고, 만들어진 오브젝트를 사용한다. 언제 어떻게 오브젝트를 만들지를 스스로 관장한다. 모든 종류의 작업을 사용하는 쪽에서 제어하는 구조이다. 제어의 역전은 이런 제어 흐름의 개념을 거꾸로 뒤집는 것이다. 제어의 역전에서는 모든 제어의 권한을 자신이 아닌 다른 대상에게 위임한다.<br>\n제어의 역전 개념은 이미 서블릿에서도 사용되고있다. 서블릿에 대한 제어권한을 가진 컨테이너가 적절한 시점에 서블릿 클래스의 오브젝트를 만들고 그안의 메소드를 호출한다. 이렇게 서블릿이나, JSP, EJB에서는 간단한 방식으로 제어의 역전 개념이 적용되어 있다.</p>\n<h3>1.5 Spring IoC</h3>\n<p>스프링의 핵심을 담당하는 건 바로 빈팩토리, 또는 ApplicationContext라고 불리는 것이다. 이것은 우리가 만든 DaoFactory가 하는 일을 스프링에서 좀더 일반화한 것이라고 할 수 있다</p>\n<h4>제어권의 이전을 통한 제어관계 역전</h4>\n<p>스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 빈이라고 부른다. 스프링에서 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 빈팩토리라고 한다. 보통 빈팩토리보다는 이를 좀더 확장한 ApplicationContext를 주로 사용한다.<br>\nApplicationContext는 별도의 정보를 참고해서 빈의 생성, 관계설정등의 제어 작업을 총괄한다. DaoFactory에서는 어떤 클래스의 오브젝트를 생성할지 어떻게 연결할것인지에 대해 설정을 해줬었다. 하지만 ApplicationContext는 직접 이런정보를 담지 않고 별도로 설정정보를 담고 있는 자바 @Configuration 설정되어져 있는 자바클래스의 정보를 가져와 이를 활용하는 범용적인 Ioc 엔진이라고 할 수 있다.</p>\n<h5>DaoFactory를 사용하는 ApplicationContext</h5>\n<p>DaoFactory를 스프링의 빈팩토리(ApplicationContext)가 사용할수있도록 설정 정보를 만들 것이다. 먼저 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스라고 인식할수 있도록 @Configuration 이라는 어노테이션을 추가한다. 그리고 오브젝트를 만들어주는 메소드에는 @Bean 이라는 어노테이션을 추가한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span> <span class=\"comment\">// 애플리케이션 컨텍스트 또는 빈 팩토리가 사용할 설정정보라는 표시</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DaoFactory</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span> <span class=\"comment\">// 오브젝트를 새엉을 담당하는 IoC용 메소드라는 표시</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> UserDao <span class=\"title\">userDao</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UserDao(connectionMaker());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ConnectionMaker <span class=\"title\">connectionMaker</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DConnectionMaker();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이제 아래와같이 준비된 ApplicationContext의 getBean()이라는 메소드를 이용해서 UserDao의 오브젝트를 가져올 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDaoTest</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException,SQLException</span>&#123;</span><br><span class=\"line\">    ApplicationContext context = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(DaoFactory.class);</span><br><span class=\"line\">    UserDao dao = context.getBean(<span class=\"string\">\"userDao\"</span>,UserDao.class);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>context.getBean(“userDao”,UserDao.class);의 userDao는 DaoFactory 메소드의 이름이다. 어떻게 메소드의 이름을 설정하느냐에따라 빈을 가지고올때 String값을 변경해주면 된다.</p>\n<h4>ApplicationContext의 동작 방식</h4>\n<p>스프링에서 ApplicationContext를 IoC컨테이너라고 하기도하고 간단히 스프링 컨테이너라고도 한다. @Configuration이 붙은 DaoFactory는 ApplicationContext가 활용하는 IoC설정정보다. 내부적으로 애플리케이션 컨텍스가 DaoFactory의 userDao() 메소드를 호출해서 오브젝트를 가져온 것을 클라이언트가 getBean()으로 요청할 때 전달 해준다. 아래 그림은 ApplicationContext의 사용되는 방식이다.</p>\n<p><img src=\"https://i.imgur.com/Uf9J8vi.png\" alt=\"\"></p>\n<h5>ApplicationContext를 사용했을때 장점</h5>\n<ol>\n<li>클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.</li>\n<li>애플리케이션 컨텍스트는 종합 IoC서비스를 제공해준다.<br>\n오브젝트가 만들어지는 방식, 오브젝트에 대한 후처리, 정보의 조합 설정 방식의 다변화, 인터셉티등 오브젝트를 효과적으로 활용할 수 있는 다양한 기능을 제공한다.</li>\n<li>애플리케이션 컨텍스트는 빈을 검색하는 다양한방법을 제공한다.<br>\n타입만으로도 빈을 검색하거나 특별한 애노테이션 설정이 되어있는 빈을 찾을 수 도 있다.</li>\n</ol>\n<h3>1.6 싱글톤 레지스틀와 오브젝트 스코프</h3>\n<p>DaoFactory와 @Configuratuon애노테이션을 추가해서 스프링의 애플리케이션 컨텍스트를 사용하는것의 차이점에 대해서 알아볼것이다. 둘의 큰 차이점은 리턴해주는 빈의 동일성을 보장 해주는것이다. 먼저 아례의 예제를 보자</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">DaoFactory factory = <span class=\"keyword\">new</span> DaoFactory();</span><br><span class=\"line\">UserDao dao1 = factory.userDao();</span><br><span class=\"line\">UserDao dao2 = factory.userDao();</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(dao1); <span class=\"comment\">//springbook.dao.UserDao@118f375</span></span><br><span class=\"line\">System.out.println(dao2); <span class=\"comment\">//springbook.dao.UserDao@117a8bd</span></span><br></pre></td></tr></table></figure>\n<p>출력결과에서 알수 있듯이 동일성이 보장되지 않는 객체들이 출력된다. 그럼 스프링 컨테이너를 이용해서 빈을 호출해 볼 것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">ApplicationContext context = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(DaoFactory.class);</span><br><span class=\"line\"></span><br><span class=\"line\">UserDao dao3 = factory.userDao();</span><br><span class=\"line\">UserDao dao4 = factory.userDao();</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(dao3); <span class=\"comment\">//springbook.dao.UserDao@ee22f7</span></span><br><span class=\"line\">System.out.println(dao4); <span class=\"comment\">//springbook.dao.UserDao@ee22f7</span></span><br></pre></td></tr></table></figure>\n<p>스프링 컨테이너 즉 ApplicationContext를 통해 생성한 오브젝트는 동일성을 보장해준다. 여러번에 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 리턴해준다.</p>\n<h4>싱글톤 레지스트리로서의 애플리케이션 컨텍스트</h4>\n<p>ApplicationContext는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이다. 스프링은 기본적으로 별다른 설정을 하지 않으면 내부에 생성하는 빈오브젝트를 모두 싱글톤으로 생성한다.</p>\n<h5>서버 애플리케이션 싱글톤</h5>\n<p>스프링에서 싱글톤을 사용하는 이유는 스프링이 주로 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버 환경이기 때문이다. 물론 스프링으로 PC등에서 동작하는 독립형 윈도우 프로그램으로도 개발할수 있긴 하지만 극히 드물다.<br>\n스프링이 처음 설계됐던 대규모의 엔터프라이즈 서버환경은 서버 하나당 최대로 초당 수십에서 수백 번씩 브라우저나 여타 시스템으로부터의 요청을 받아 처리할 수 있는 높은 성능이 요구되는 환경이었다. 또 하나의 요청을 처리하기위해 데이터 액세스로직, 서비스로직, 비지니스로직,프레젠테이션로직등의 다양한 기능을 담당하는 오브젝트들이 참여하는 계층형 구조였다.<br>\n그런데 매번 클라이언트에서 요청이 들어 올때마다 각로직을 담당하는 오브젝트를 새로 만들어본다고 생각해보자. 요청 한번에 5개의 오브젝트가 새로 만들어지고 초당 500개의 요청이 들어오면 초당 2500개의 새로운 오브젝트가 생성된다. 1분이면 십오만개, 한시간이면 9백만개의 새로운 오브젝트가 만들어진다. 아무리 자바의 가비지컬렉션의 성능이 좋아졌다고 한들 이렇게 부하가 걸리면 서버가 감당하기 힘들다.<br>\n엔터프라이즈 환경에서의 서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작한다. 서블릿 클래스당 하나의 오브젝트만 만들어 두고, 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용된다.<br>\n이렇게 애플리케이션 안에 제한된 수, 대개 한개의 오브젝트만 만들어서 사용하는 것이 싱글톤 패턴의 원리이다.따라서 서버 환경에서는 서비스 싱글톤의 사용이 권장된다.</p>\n<h5>싱글톤 패턴의 한계</h5>\n<p>싱글통 패턴을 적용한 UserDao</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDao</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> UserDao INSTANCE;</span><br><span class=\"line\">  ...</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">UserDao</span><span class=\"params\">(ConnectionMaker connectionMaker)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.connectionMaker = connectionMaker;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> UserDao <span class=\"title\">getInstance</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(INSTANCE == <span class=\"keyword\">null</span>) INSTANCE = <span class=\"keyword\">new</span> UserDao(???);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> INSTANCE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>싱글톤의 단점</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">-private  생성자를 갖고 있기 때문에 상속할 수 없다.</span><br><span class=\"line\">-싱글톤은 테스트하기가 힘들다.</span><br><span class=\"line\">-서버환경에서는 싱글톤이 하나만 만들어지는것을 보장하지 못한다</span><br><span class=\"line\">-싱글톤의 사용은 전역상태를 만들 수 있기 때문에 바람직하지 못하다.</span><br></pre></td></tr></table></figure>\n<h5>싱글톤 레지스트리</h5>\n<p>자바의 기본적인 싱글톤 패턴의 구현 방식은 여러가지 단점이 있기 때문에 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다. 그것이 바로 싱글톤 레지스트리이다. 스프링 컨테이너는 싱글톤을 생성하고, 관리하고 공급하는 싱글톤 관리 컨테이너이기도 하다. 싱글톤 레지스트리는 스태틱메소드와 private생성자등을 사용해야하는 비정상적인 클래스가 아닌 평범한 자바 클래스를 싱글톤으로 활용하게 해준다.</p>\n<h4>싱글톤과 오브젝트의 상태</h4>\n<p>싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있다. 따라서 상태 관리(전역변수)에 주의 해야한다. 기본적으로 클래스내에서 전역변수를 사용하지 말아야한다. 다중 사용자의 요청을 한꺼번에 처리하는 스레드들이 동시에 싱글톤오브젝트의 전역변수를 수정하는것은 매우 위험하다. 저장할 공간이 하나 뿐이니 서로 값을 덮어쓰고 자신이 저장하지 않은값을 읽어 오거나 삭제할수있기때문이다. 물론 읽기전용의 전역변수는 사용해도좋다. 이런 변수들은 final로 선언해주는거시 안전하다. 메소드안에는 지연변수(스택 영역에 저장되어져있다)이기떄문에 메소드 호출후에 초기화된다.</p>\n<h4>스프링 빈의 스코프</h4>\n<p>스프링 내에서 빈이 생성되고 존재하고 등의 적용되는 범위에대해 스프링에서는 이것을 스코프라고한다. 기본적으로 프로토타입,요청,세션등으로 분리하여 관리해주는 스코프 범위가 존재한다.</p>\n<h3>1.7 의존과계 주입(DI)</h3>\n<h4>제어의 역전과 의존관계 주입</h4>\n<p>여기에서 한가지 짚고 넘어갈 것은 IoC라는 용어인데, IoC가 매우 느슨하게 정의돼서 폭넓게 사용되는 용어라는것이다. 때문에 스프링을 IoC 컨테이너라고만 해서는 스프링이 제공하는 기능의 특징을 명확하게 설명하지 못했다. 그래서 나온말이 IoC방식을 핵심을 짚어주는 의존관계 주입(DI)이다. 스프링의 IoC 기능의 대표적인 동작원리는 주로 의존관계 주입이라고 불린다. 스프링이 여타 프레임워크와 차별화돼서 제공해주는 기능은 의존관계 주입이라는 새로운 용어를 사용할 때 분명하게 드러난다. 초기에는 주로 IoC 컨테이너라고 불리던 스프링이 지금은 의존관계 주입 컨테이너 또는 그영문약자를 써서 DI컨테이너라고 더 많이 불리고 있다.</p>\n<h4>런타임 의존관계 설정</h4>\n<h5>의존관계</h5>\n<p>두 개의 클래스 또는 모듈이 의존관계에 있다고 말할 때는 항상 방향성을 부여해줘야 한다. 즉 누가 누구에게 의존하는 관계 있다는 식어야한다. A클래스가 B에 의존하고 있을때 B가 변동사항이 있으면 A에 영향을 미치게된다. 하지만 A가 변경된다고해서 B는 영향 받지 않는다.</p>\n<h5>UserDao의 의존관계</h5>\n<p><img src=\"https://i.imgur.com/Am2R3Z3.png\" alt=\"\"><br>\n위 그림은 UserDao가 ConnectionMaker에 의존하고 있는 형태이다. ConnectionMaker인터페이스가 변한다면 그영향은 UserDao가 받을 것이다. 하지만 ConnectionMaker의 구현체인 DConnectionMaker등이 바뀌거나 내부적으로 메소드가 변화가 생겨도 UserDao에 영향을 주지 않는다. 이렇게 인터ㅔ이스대해서만 의존관계를 만들어두면 인터페이스를 구현 클래스와의 관계는 느슨해지면서 변환에 영향을 덜 받는 상태가 된다. 인터페이스를 통해 의존관계를 제한해주면 그만큼 변경에서 자유로워지는 셈이다.<br>\n그런데 모델이나 코드에서 클래스와 인터페이스를 통해 드러나는 의존관계말고, 런타임시에 오브젝트 사이에서 만들어지는 의존관계도 있다. 의존과계 또는 오브젝트 의존 관계인데, 설계 시점의 의존관계가 실체화된 것이라고 볼 수 있다. 런타임 의존관계는 모델링 시점의 의존관계와는 성격이 분명히 다르다.<br>\n인터페이스를 통해 설계 시점에 느슨한 의존관계를 갖는 경우에는 UserDao의 오브젝트가 런타임 시에 사용할 오브젝트가 어떤 클래스로 만든것인지 미리 알 수 가없다. 프로그램이 시작되고 UserDao 오브젝트가 만들어지고 나서 런타임 시에 의존관계를 맺는 대상, 즉 실제 사용대상인 오브젝트를 의존 오브젝트라고 한다.</p>\n<p>의존관계 주입은 이렇게 구체적인 의존 오브젝트와 그것을 사용할 주체, 보통 클라이언트라고 부르는 오브젝트를 런타임시에 연결해주는 작업을 말한다. UserDao는 ConnectionMaker 인터페이스라는 매우 단순한 조건만 만족하면 어떤 클래스로부터 만들어졌든 상관없이 오브젝트를 받아 들이고 사용한다.</p>\n<blockquote>\n<p>의존관계주입이란<br>\n-클래스 모델(UML)이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야한다.<br>\n-런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정한다.<br>\n-의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부주에서 제공(주입)해줌으로써 만들어진다.</p>\n</blockquote>\n<p>의존관계 주입의 핵심은 설계 시점에는 알지 못했던 두 오브젝트의 관계를 맺도록 도와주는 제 3의 존재가 있다는것이다. DI에서 말하는 제 3의 존재는 바로 관계설정 책임을 가진 클래스 라고 볼 수 있다. DaoFactory,ApplicationContext,Ioc컨테이너등이 모두 외부에서 오브젝트 사이의 런타임 관계를 맺어주는 책임을 지닌 제 3의 존재라고 볼 수 있다.</p>\n<h5>UserDao의 의존관계 주입</h5>\n<p>다시 처음에 봤던 UserDao 에 적용된 의존관계 주입 기술을 다시 살펴보자. 인터페이스를 사이에 두고 UserDao와 ConnectionMaker구현클래스간에 의존관계를 느슨하게 만들긴 했지만, 마지막으로 남은 문제가 있었는데 아래소스와같이 UserDao가 사용할 구체적인 클래스를 알고 있어야 하는점이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserDao</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  connectionMaker = <span class=\"keyword\">new</span> DConnectionMaker();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이코드는 이미 설계 시점에 구체적인 런타임 의존관계 오브젝트를 알고 있다. 즉 DConnectionMaker오브젝트를 사용하겠다는 것 까지 UserDao가 결정하고 관리하고 있는셈이다.</p>\n<p>이코드의 문제는 이미 런타임시의 의존관계가 코드 속에 미리 다 결정되어있다는 것이다. 그래서 Ioc방식을 써서 UserDao로부터 런타임 의존관계를 드러내는 코드를 제거하고, 제 3의 존재에 런타임 의존관계 결정을 권한을 위함하는것이다. 그래서 최종적으로 만들어졌던것이 DaoFactory이다. DaoFactory는 런타임시점에 UserDao가 사용할 ConnectionMaker타입의 오브젝트를 결정하고 이를 생성한후에 UserDao의 생성자 파라미터로 주입해줌으로써 런타임 의존관계를 맺게 해준다. 이렇게 런타임시 주입의 기능을 수행함으로써 DaoFactory를 DI/IoC컨테이너라고도 한다.</p>\n<p>DI컨테이너느 자신이 결정한 의존관계를 맺어줄 클래스의 오브젝트를 만들고 이생성자를 파라미터로 오브젝트의 레퍼런스를 전달해준다. 그럼 아래 소스같이 생성자 파라미터를 통해 전달받은 런타임 의존관계를 갖는 오브젝트는 인스턴스 변수에 저장 해둔다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDao</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> ConnectionMaker connectionMaker;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserDao</span><span class=\"params\">(ConnectionMaker connectionMaker)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.connectionMaker = connectionMaker;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이렇게 해서 두 개의 오브젝트 간에 런타임 의존관계 만들어졌다. UserDao 오브젝트는 이제 생성자를 통해 주입받은 DConnectionMaker 오브젝트를 언제든 사용하면 된다. DI는 자신이 사용할 오브젝트에 대한 선택권과 생성 제어권을 외부로 넘기고 자신은 런타임시에 수동적로 주입받은 오브젝트를 사용한다는 점에서 IoC의 개념에 잘 들어 맞는다. 스프링 컨테이너의 IoC는 주로 의존관계 주입 또는 DI라는 데 초점이 맞춰져 있다. 그래서 스프링을 IoC컨테이너 외에도 DI컨테이너 또는 DI프레임워크라 한다.</p>\n<h4>의존관계 검색과 주입</h4>\n<p>스프링이 제공하는 IoC방법에서 오브젝트를 주입하는 방법 의존성 주입만 있는것은 아니다. 의존 관계를 맺는 방법이 외부로부터의 주입이 아니라 스스로 검색을 이용하는 의존관계 검색이 있다. 의존관계 검색은 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾는다. 물론 자신이 어떤 클래스의 오브젝트를 이용할지는 결정하지 않는다. 의존관계 검색은 런타임 시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트의 생성작업은 외부 컨테이너에게 맡기지만, 이를 가져올때는 메소드나 생성자를 통한 파라미터 전달이 아닌 아래 소스와같이 직접 컨테이너에게 요청하는 방식이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserDao</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  DaoFactory daoFactory = <span class=\"keyword\">new</span> DaoFactory();</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.connectionMaker = daoFactory.connectionMaker();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위와같이 생성해도 여전히 자신이 어떤 ConnectionMaker 오브젝트를 사용할지 미리 알지 못한다. 여전히 코드의 의존대상은 ConnectionMaker인터페이스이기 때문이다. 런타임시에 DaoFactory가 만들어서 돌려주는 오브젝트와 다이내믹하게 런타임 의존관계를 맺는다. 따라서 IoC개념을 잘 따르고 있으며, 그혜택을 받는 코드다. 하지만 적용방법은 외부로부터의 주입이 아니라 스스로 IoC 컨테이너인 DaoFactory에게 요청하는것이다.<br>\n위소스의 작업을 일반화한 스프링의 애플리케이션 컨텍스트라면 미리 정해놓은 이름을 전달해서 그 이름에 해당하는 오브젝트를 찾게 된다. 따라서 이를 일종의 검색이라고 볼 수 있다. 또한 그 대상이 런타임 의존관계를 가질 오브젝트이므로 의존관계 검색이라고 부르는 것이다.<br>\n스프링의 IoC 컨테이너인 애플리케이션 컨텍스트는 getBean이라는 메소드를 제공한다. 바로 이메소드가 의존관계를 검색에 사용되는것이다. 이것은 아래의 예제와같이 사용 할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">UserDao</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  AnnotationConfigApplicationContext context = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(DaoFactory.clas);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.connectionMaker = context.getBean(<span class=\"string\">\"connectionMaker\"</span>,ConnectionMaker.class);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>의존관계 검색은 기존 의존관계 주입의 거의 모든 장점을 갖고 있다. 하지만 코드면에서 좀 더 의존관계주입이 단순하고 깔끔하다. 의존관계 검색은 코드안에 오브젝트 팩토리 클래스나 스프링 API가 나타난다. 검색 방식을 이용하면 그안에서 컨텍스트를 만들고, 호출하고등의 불필요한 소스를 넣어줘야하기 때문이다. 따라서 대개는 의존관계주입방식을 사용하는것이 낫다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDaoTest</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException,SQLException</span>&#123;</span><br><span class=\"line\">    ApplicationContext context = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(DaoFactory.class);</span><br><span class=\"line\">    UserDao dao = context.getBean(<span class=\"string\">\"userDao\"</span>,UserDao.class);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>하지만 위에 소스처럼 static 메소드인 Main같은경우에는 DI를 이용해 오브젝트를 주입받을 방법이 없기 때문이다. 이러한경우 말고는 의존성주입을 받아 사용하는게 소스면에서 훨씬 깔끔하다.</p>\n<h4>의존관계 주입의 응용</h4>\n<h5>부가기능 추가</h5>\n<p>다음 이런경우를 한번 생각해보자. DAO가 DB를 얼마나 많이 연결해서 사용하는지 파악하고 싶다. DB연결횟수를 카운팅하기 위해 무식한 방법으로 모든 DAO의 makeConnection() 메소드를 호출하는 부분에 새로 추가한 카운터를 증가시키는 코드를 넣는것은 엄청난 낭비이고 노가다다.  그리고 무엇보다 DAO코드를 손대는것은 지금까지 피하려고했던 행동을 하는 것이다.<br>\nDI 컨테이너에서라면 아주 간단한 방법으로 해결가능하다. DAO와 DB 커넥션을 만드는 오브젝트 사이에 열결횟수를 카운팅하는 오브젝트를 하나 더 추가하는 것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CountingConnectionMaker</span> <span class=\"keyword\">implements</span> <span class=\"title\">ConnectionMaker</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> counter = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ConnectionMaker realConnectionMaker;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> CountingConnectionMaker <span class=\"title\">realConnectionMaker</span><span class=\"params\">(ConnectionMaker realConnectionMaker)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.realConnectionMaker = realConnectionMaker;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Connection <span class=\"title\">makeConnection</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ClassNotFoundException,SQLException</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.counter++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> realConnectionMaker.makeConnection();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getCounter</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.counter;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>CountingConnectionMaker 클래스는 ConnectionMaker 인터페이스를 구현했지만 내부에서 직접 DB커넥션을 만들지 않는다. 대신 DAO가 DB커넥션을 가져올 때마다 호출하는 makeConnection()에서 DB연결횟수 카운터를 증가시킨다.CountingConnectionMaker는 자신의 관심사인 DB 연결횟수 카운팅 작업을 마치면 실제 DB 커넥션을 만들어주는 realConnectionMaker에 저장된 ConnectionMaker타입 오브젝트의 makeConnection()호출해서 그 결과를 DAO에 돌려준다.</p>\n<p>생성자를 보면 ConnectionConnectionMaker도 DI를 받는것을 알 수 있다. UserDao는 ConnectionMaker의 인터페이스에만 의존하고 있기 때문에 ConnectionMaker 를 구현하고있는 어떤 구현체라도 DI가 가능하다. 그래서 DI받는 오브젝트를 DConnection오브젝트를 대신 CountingConnectionMaker를 받은것이다. 그리고 그 CountingConnectionMaker는 DConnectionMaker를 의존주입을 받은것이다.<br>\n<img src=\"https://i.imgur.com/EfluSD4.png\" alt=\"\"><br>\n<img src=\"https://i.imgur.com/Am2R3Z3.png\" alt=\"\"><br>\n이렇게해서 CountingConnectionMaker 재구성된 새로운 런타임 의존관계는 위 그림과 같다. 우의 그림을 코드라바꾸면 아래와같이 만들 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CountingDaoFactory</span></span>&#123;</span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> UserDao userDao&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> UserDao(ConnectionMaker());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ConnectionMaker <span class=\"title\">connectionMaker</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CountingConnectionMaker(realConnectionMaker());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> ConnectionMaker <span class=\"title\">realConnectionMaker</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> DConnectionMaker();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이제 커넥션 카운팅을 위한 실행 코드를 만들어보자. 기본적으로 UserDaoTest와 같지만 설정요 클래스를 CountingDaoFactory로 변경해줘야한다. 그리고 CountingConnectionMaker빈을 가져온다. 설정정보에 지정된 이름과 타입만 알면 특정 빈을 가져 얼 수 있으니 CoutingConnectionMaker 오브젝트를 가져오는 건 간단하다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDaoConnectionCountingTest</span></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ClassNotFoundException,SQLException</span>&#123;</span><br><span class=\"line\">    AnnotationConfigApplicationContext context = <span class=\"keyword\">new</span> AnnotationConfigApplicationContext(CountingDaoFactory.class);</span><br><span class=\"line\">    UserDao dao = context.getBean(<span class=\"string\">\"userDao\"</span>,UserDao.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\">    <span class=\"comment\">//DAO 사용코드</span></span><br><span class=\"line\">    <span class=\"comment\">//</span></span><br><span class=\"line\"></span><br><span class=\"line\">    CountingConnectionMaker ccm = context.getBean(<span class=\"string\">\"connectionMaker\"</span>,CountingConnectionMaker.class);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"Connection counter :\"</span> + ccm.getCounter());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이렇게 함으로써 DBConnection 분석이 끝나면 다시 CountingDaoFactory 설정 클래스를 DaoFactory로 변경하거나 connectionMaker()메소드를 수정하는 것만으로 DAO의 런터암 의존관계는 이정상태로 복구된다.</p>\n<h4>메소드를 이용한 의존관계 주입</h4>\n<p>간단하게 설명하자면 스프링에서 의존섭을 주입하는 방법은 생성자를 이용하는 방법뿐만 아니라 아래와 같이 setter아니면 직접 메소드를 정의해서 의존성을 주입하는 방법이있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserDao</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> ConnectionMaker connectionMaker;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setConnectionMker</span><span class=\"params\">(ConnectionMaker connectionMaker)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.connectionMaker = connectionMaker;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> UserDao <span class=\"title\">userDao</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  UserDao userDao = <span class=\"keyword\">new</span> UserDao();</span><br><span class=\"line\">  userDao.setConnectionMaker(connectionMaker());</span><br><span class=\"line\">  <span class=\"keyword\">return</span> userDao;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>단지 의존관계를 주입하는 시점과 방법이 달라졌을 뿐 결과는 동일하다.</p>\n<p><a href=\"https://github.com/minwan1/Spring-toby\" target=\"_blank\" rel=\"noopener\">예제소스</a></p>\n<h3>정리</h3>\n<ul>\n<li>단일 책임원칙 기반하여 책임별로 클래스들을 나누었다. 예제를 보면 UserDao 같은경우에는 데이터 액세스에 관한 관심의 역할을 부여받음으로써 데이터 엑세스에대한 책임을 수행하고있다. ConnectionMaker 같은경우에는 데이터베이스 Connection방법을 설정을 할수 있는 역할을 부여받음으로써 데이터베이스 Connection방법에 관한 책임만을 가진다. 이렇게 명확하게 둘의 책임을 나눔으로써 데이터엑스세에 대한 비지니스로직을 변경한다거나 데이터베이스 Connection 방법을 변경한다거나할 때 서로의 영향을 안받는 독립적인 구조를 만들어 냈다.</li>\n<li>개방 폐쇄 원칙에 기반하여 클래스들을 나누었다. ConnectionMaker같은경우 인터페이스로 가져감으로써 데이터베이스 Connection 방법을 변경할때 거기에 맞는 구현체만 구현하게 되면 쉽게 데이베이스 Connection방법을 바꿀 수 있게 되었다. 또한 그 구현체 ConnectionMaker들은 데이터베이스 Connection 방법이 변경되지 않는 이상 바뀌지 않을 소스이다. 이런점을 보아서 개방 폐쇄원칙을 잘 준수했다고 볼 수 있다.</li>\n<li>오브젝트를 생성되고 관계를맺는 제어권을 별도의 오브젝트 팩토리로 만들었다. 객체를 직접 관리하지않고 팩토리를 통해 관리함으로써 기능들을 부품처럼 쉽게 바꿀수 있게 되었다.(제어의 역전/IOC)</li>\n</ul>\n"},{"title":"Git Commit 전에 ESLint 자동 검사 하기","catalog":true,"date":"2019-02-22T15:00:00.000Z","subtitle":"Eslint","header-img":null,"_content":"\n# Git Commit 전에 ESLint 자동 검사 하기\n보통 프론트엔드에서는 2인 이상 개발할 때 코드 컨벤션을 잡아주는 ESLint 오픈 소스를 사용합니다. 그런데 실제로 커밋을 하기전에 lint 검사를 하지 않거나 build 명령어를 실행하고 커밋하지 않는 이상 ESLint 코드 컨벤션을 어긴 코드들이 커밋될 수 있습니다. 이러한 문제점을 해결해주는것이 [husky](https://github.com/typicode/husky), [lint-staged](https://github.com/okonet/lint-staged), [prettier](https://github.com/prettier/prettier)가 있습니다. 이것에 대해 간단히 알아보겠습니다.\n\n## husky \n깃 커밋 또는 푸쉬전에 eslint, test 등을 실행 해볼 수 있는 도구입니다. 만약 테스트 또는 eslint 문법을 어겼다면 방금 커밋하려고했던 파일들은 커밋이 되지 않습니다.\n\n### husky 설치\n```\nnpm install husky --save-dev\n```\n\n### husky 사용법\n아래와 같이 커밋이나 푸시전에 테스트나 eslint 등을 테스트할 수 있습니다.\n```json\n// package.json\n{\n  \"husky\": {\n    \"hooks\": {\n      \"pre-commit\": \"eslint --fix\",\n      \"pre-push\": \"npm test\",\n      \"...\": \"...\"화\n      \n    }\n  }\n}\n```\n\n## lint-staged\n\n검사하기118/500자 내용삭제\n맞춤법검사기 결과영역\nstaged된 파일들을 lint 해주는 도구입니다. 전체 프로젝트를 ESLint를 실행하는 것은 속도가 느릴 수 있는데 lint-staged를 사용하면 특정 패턴에 파일에 대해서만 lint 수행을 가능하게 해줍니다.\n\n### lint-staged 설치\n```\nnpm install --save-dev lint-staged husky\n```\n\n\n### lint-staged 사용법\n아래는 .js파일에대해 \"eslint --fix\" 명령어를 실행하고 해당 파일들을 스테이지에 올려줍니다.\n```json\n{\n  \"husky\": {\n    \"hooks\": {  \n      \"pre-commit\": \"lint-staged\"\n    }\n  },\n  \"lint-staged\": {\n    \"*.js\": [\"eslint --fix\", \"git add\"]\n  }\n}\n```\n\n## prettier\n코드 컨벤션에 맞지 않는 코드를 고쳐주는 도구입니다. ES2017을 포함해서 JSX, typescript, flow를 지원하고, 심지어 CSS, LESS, SCSS 까지 지원합니다.\n\n```\nfoo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());\n```\n위와 같은 코드가있으면 prettier에 옵션에 맞는 코드를 작성하면 커밋전에 아래와같이 코드를 수정해줍니다.\n```\nfoo(\n  reallyLongArg(),\n  omgSoManyParameters(),\n  IShouldRefactorThis(),\n  isThereSeriouslyAnotherOne()\n);\n```\n\n### prettier 설치\nnpm install husky lint-staged prettier --save-dev\n\n### prettier 사용\u001c법\n아래 설정은 커밋 전에 staged된 모든 js파일을 대상으로 콤마를 찍어주고, 홑따옴표를 사용하고, 탭의 길이가 4로 수정되도록 설정했다.\n```json\n{\n  \"scripts\": {\n    \"precommit\": \"lint-staged\"\n  },\n  \"lint-staged\": {\n    \"*.js\": [\n      //prettier [opts] [filename ...]\n      \"prettier --write --trailing-comma es5 --single-quote true --tab-width 4\",\n      \"git add\"\n    ]\n  }\n}\n```\n나머지 옵션은 [여기](https://prettier.io/docs/en/options.html)를 확인해주시면 됩니다.","source":"_posts/2019-02-23-Git Commit 전에 ESLint 자동 검사하기.md","raw":"---\ntitle: Git Commit 전에 ESLint 자동 검사 하기\ncatalog: true\ndate: 2019-02-23\nsubtitle: Eslint\nheader-img:\ntags:\n- JavaScript\n\n\n\n---\n\n# Git Commit 전에 ESLint 자동 검사 하기\n보통 프론트엔드에서는 2인 이상 개발할 때 코드 컨벤션을 잡아주는 ESLint 오픈 소스를 사용합니다. 그런데 실제로 커밋을 하기전에 lint 검사를 하지 않거나 build 명령어를 실행하고 커밋하지 않는 이상 ESLint 코드 컨벤션을 어긴 코드들이 커밋될 수 있습니다. 이러한 문제점을 해결해주는것이 [husky](https://github.com/typicode/husky), [lint-staged](https://github.com/okonet/lint-staged), [prettier](https://github.com/prettier/prettier)가 있습니다. 이것에 대해 간단히 알아보겠습니다.\n\n## husky \n깃 커밋 또는 푸쉬전에 eslint, test 등을 실행 해볼 수 있는 도구입니다. 만약 테스트 또는 eslint 문법을 어겼다면 방금 커밋하려고했던 파일들은 커밋이 되지 않습니다.\n\n### husky 설치\n```\nnpm install husky --save-dev\n```\n\n### husky 사용법\n아래와 같이 커밋이나 푸시전에 테스트나 eslint 등을 테스트할 수 있습니다.\n```json\n// package.json\n{\n  \"husky\": {\n    \"hooks\": {\n      \"pre-commit\": \"eslint --fix\",\n      \"pre-push\": \"npm test\",\n      \"...\": \"...\"화\n      \n    }\n  }\n}\n```\n\n## lint-staged\n\n검사하기118/500자 내용삭제\n맞춤법검사기 결과영역\nstaged된 파일들을 lint 해주는 도구입니다. 전체 프로젝트를 ESLint를 실행하는 것은 속도가 느릴 수 있는데 lint-staged를 사용하면 특정 패턴에 파일에 대해서만 lint 수행을 가능하게 해줍니다.\n\n### lint-staged 설치\n```\nnpm install --save-dev lint-staged husky\n```\n\n\n### lint-staged 사용법\n아래는 .js파일에대해 \"eslint --fix\" 명령어를 실행하고 해당 파일들을 스테이지에 올려줍니다.\n```json\n{\n  \"husky\": {\n    \"hooks\": {  \n      \"pre-commit\": \"lint-staged\"\n    }\n  },\n  \"lint-staged\": {\n    \"*.js\": [\"eslint --fix\", \"git add\"]\n  }\n}\n```\n\n## prettier\n코드 컨벤션에 맞지 않는 코드를 고쳐주는 도구입니다. ES2017을 포함해서 JSX, typescript, flow를 지원하고, 심지어 CSS, LESS, SCSS 까지 지원합니다.\n\n```\nfoo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());\n```\n위와 같은 코드가있으면 prettier에 옵션에 맞는 코드를 작성하면 커밋전에 아래와같이 코드를 수정해줍니다.\n```\nfoo(\n  reallyLongArg(),\n  omgSoManyParameters(),\n  IShouldRefactorThis(),\n  isThereSeriouslyAnotherOne()\n);\n```\n\n### prettier 설치\nnpm install husky lint-staged prettier --save-dev\n\n### prettier 사용\u001c법\n아래 설정은 커밋 전에 staged된 모든 js파일을 대상으로 콤마를 찍어주고, 홑따옴표를 사용하고, 탭의 길이가 4로 수정되도록 설정했다.\n```json\n{\n  \"scripts\": {\n    \"precommit\": \"lint-staged\"\n  },\n  \"lint-staged\": {\n    \"*.js\": [\n      //prettier [opts] [filename ...]\n      \"prettier --write --trailing-comma es5 --single-quote true --tab-width 4\",\n      \"git add\"\n    ]\n  }\n}\n```\n나머지 옵션은 [여기](https://prettier.io/docs/en/options.html)를 확인해주시면 됩니다.","slug":"2019-02-23-Git Commit 전에 ESLint 자동 검사하기","published":1,"updated":"2019-02-23T14:36:34.261Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl84kp0000uspenzaf3kfu","content":"<h1><span id=\"git-commit-전에-eslint-자동-검사-하기\">Git Commit 전에 ESLint 자동 검사 하기</span></h1>\n<p>보통 프론트엔드에서는 2인 이상 개발할 때 코드 컨벤션을 잡아주는 ESLint 오픈 소스를 사용합니다. 그런데 실제로 커밋을 하기전에 lint 검사를 하지 않거나 build 명령어를 실행하고 커밋하지 않는 이상 ESLint 코드 컨벤션을 어긴 코드들이 커밋될 수 있습니다. 이러한 문제점을 해결해주는것이 <a href=\"https://github.com/typicode/husky\" target=\"_blank\" rel=\"noopener\">husky</a>, <a href=\"https://github.com/okonet/lint-staged\" target=\"_blank\" rel=\"noopener\">lint-staged</a>, <a href=\"https://github.com/prettier/prettier\" target=\"_blank\" rel=\"noopener\">prettier</a>가 있습니다. 이것에 대해 간단히 알아보겠습니다.</p>\n<h2><span id=\"husky\">husky</span></h2>\n<p>깃 커밋 또는 푸쉬전에 eslint, test 등을 실행 해볼 수 있는 도구입니다. 만약 테스트 또는 eslint 문법을 어겼다면 방금 커밋하려고했던 파일들은 커밋이 되지 않습니다.</p>\n<h3><span id=\"husky-설치\">husky 설치</span></h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install husky --save-dev</span><br></pre></td></tr></table></figure>\n<h3><span id=\"husky-사용법\">husky 사용법</span></h3>\n<p>아래와 같이 커밋이나 푸시전에 테스트나 eslint 등을 테스트할 수 있습니다.</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">// package.json</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"husky\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"hooks\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"pre-commit\"</span>: <span class=\"string\">\"eslint --fix\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"pre-push\"</span>: <span class=\"string\">\"npm test\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"...\"</span>: <span class=\"string\">\"...\"</span>화</span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"lint-staged\">lint-staged</span></h2>\n<p>검사하기118/500자 내용삭제<br>\n맞춤법검사기 결과영역<br>\nstaged된 파일들을 lint 해주는 도구입니다. 전체 프로젝트를 ESLint를 실행하는 것은 속도가 느릴 수 있는데 lint-staged를 사용하면 특정 패턴에 파일에 대해서만 lint 수행을 가능하게 해줍니다.</p>\n<h3><span id=\"lint-staged-설치\">lint-staged 설치</span></h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save-dev lint-staged husky</span><br></pre></td></tr></table></figure>\n<h3><span id=\"lint-staged-사용법\">lint-staged 사용법</span></h3>\n<p>아래는 .js파일에대해 “eslint --fix” 명령어를 실행하고 해당 파일들을 스테이지에 올려줍니다.</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"husky\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"hooks\"</span>: &#123;  </span><br><span class=\"line\">      <span class=\"attr\">\"pre-commit\"</span>: <span class=\"string\">\"lint-staged\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"lint-staged\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"*.js\"</span>: [<span class=\"string\">\"eslint --fix\"</span>, <span class=\"string\">\"git add\"</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"prettier\">prettier</span></h2>\n<p>코드 컨벤션에 맞지 않는 코드를 고쳐주는 도구입니다. ES2017을 포함해서 JSX, typescript, flow를 지원하고, 심지어 CSS, LESS, SCSS 까지 지원합니다.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());</span><br></pre></td></tr></table></figure>\n<p>위와 같은 코드가있으면 prettier에 옵션에 맞는 코드를 작성하면 커밋전에 아래와같이 코드를 수정해줍니다.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">foo(</span><br><span class=\"line\">  reallyLongArg(),</span><br><span class=\"line\">  omgSoManyParameters(),</span><br><span class=\"line\">  IShouldRefactorThis(),</span><br><span class=\"line\">  isThereSeriouslyAnotherOne()</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3><span id=\"prettier-설치\">prettier 설치</span></h3>\n<p>npm install husky lint-staged prettier --save-dev</p>\n<h3><span id=\"prettier-사용법\">prettier 사용\u001c법</span></h3>\n<p>아래 설정은 커밋 전에 staged된 모든 js파일을 대상으로 콤마를 찍어주고, 홑따옴표를 사용하고, 탭의 길이가 4로 수정되도록 설정했다.</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"precommit\"</span>: <span class=\"string\">\"lint-staged\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"lint-staged\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"*.js\"</span>: [</span><br><span class=\"line\">      //prettier [opts] [filename ...]</span><br><span class=\"line\">      <span class=\"string\">\"prettier --write --trailing-comma es5 --single-quote true --tab-width 4\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"git add\"</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>나머지 옵션은 <a href=\"https://prettier.io/docs/en/options.html\" target=\"_blank\" rel=\"noopener\">여기</a>를 확인해주시면 됩니다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>Git Commit 전에 ESLint 자동 검사 하기</h1>\n<p>보통 프론트엔드에서는 2인 이상 개발할 때 코드 컨벤션을 잡아주는 ESLint 오픈 소스를 사용합니다. 그런데 실제로 커밋을 하기전에 lint 검사를 하지 않거나 build 명령어를 실행하고 커밋하지 않는 이상 ESLint 코드 컨벤션을 어긴 코드들이 커밋될 수 있습니다. 이러한 문제점을 해결해주는것이 <a href=\"https://github.com/typicode/husky\" target=\"_blank\" rel=\"noopener\">husky</a>, <a href=\"https://github.com/okonet/lint-staged\" target=\"_blank\" rel=\"noopener\">lint-staged</a>, <a href=\"https://github.com/prettier/prettier\" target=\"_blank\" rel=\"noopener\">prettier</a>가 있습니다. 이것에 대해 간단히 알아보겠습니다.</p>\n<h2>husky</h2>\n<p>깃 커밋 또는 푸쉬전에 eslint, test 등을 실행 해볼 수 있는 도구입니다. 만약 테스트 또는 eslint 문법을 어겼다면 방금 커밋하려고했던 파일들은 커밋이 되지 않습니다.</p>\n<h3>husky 설치</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install husky --save-dev</span><br></pre></td></tr></table></figure>\n<h3>husky 사용법</h3>\n<p>아래와 같이 커밋이나 푸시전에 테스트나 eslint 등을 테스트할 수 있습니다.</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">// package.json</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"husky\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"hooks\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">\"pre-commit\"</span>: <span class=\"string\">\"eslint --fix\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"pre-push\"</span>: <span class=\"string\">\"npm test\"</span>,</span><br><span class=\"line\">      <span class=\"attr\">\"...\"</span>: <span class=\"string\">\"...\"</span>화</span><br><span class=\"line\">      </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>lint-staged</h2>\n<p>검사하기118/500자 내용삭제<br>\n맞춤법검사기 결과영역<br>\nstaged된 파일들을 lint 해주는 도구입니다. 전체 프로젝트를 ESLint를 실행하는 것은 속도가 느릴 수 있는데 lint-staged를 사용하면 특정 패턴에 파일에 대해서만 lint 수행을 가능하게 해줍니다.</p>\n<h3>lint-staged 설치</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save-dev lint-staged husky</span><br></pre></td></tr></table></figure>\n<h3>lint-staged 사용법</h3>\n<p>아래는 .js파일에대해 “eslint --fix” 명령어를 실행하고 해당 파일들을 스테이지에 올려줍니다.</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"husky\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"hooks\"</span>: &#123;  </span><br><span class=\"line\">      <span class=\"attr\">\"pre-commit\"</span>: <span class=\"string\">\"lint-staged\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"lint-staged\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"*.js\"</span>: [<span class=\"string\">\"eslint --fix\"</span>, <span class=\"string\">\"git add\"</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>prettier</h2>\n<p>코드 컨벤션에 맞지 않는 코드를 고쳐주는 도구입니다. ES2017을 포함해서 JSX, typescript, flow를 지원하고, 심지어 CSS, LESS, SCSS 까지 지원합니다.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">foo(reallyLongArg(), omgSoManyParameters(), IShouldRefactorThis(), isThereSeriouslyAnotherOne());</span><br></pre></td></tr></table></figure>\n<p>위와 같은 코드가있으면 prettier에 옵션에 맞는 코드를 작성하면 커밋전에 아래와같이 코드를 수정해줍니다.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">foo(</span><br><span class=\"line\">  reallyLongArg(),</span><br><span class=\"line\">  omgSoManyParameters(),</span><br><span class=\"line\">  IShouldRefactorThis(),</span><br><span class=\"line\">  isThereSeriouslyAnotherOne()</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h3>prettier 설치</h3>\n<p>npm install husky lint-staged prettier --save-dev</p>\n<h3>prettier 사용\u001c법</h3>\n<p>아래 설정은 커밋 전에 staged된 모든 js파일을 대상으로 콤마를 찍어주고, 홑따옴표를 사용하고, 탭의 길이가 4로 수정되도록 설정했다.</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"scripts\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"precommit\"</span>: <span class=\"string\">\"lint-staged\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">\"lint-staged\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">\"*.js\"</span>: [</span><br><span class=\"line\">      //prettier [opts] [filename ...]</span><br><span class=\"line\">      <span class=\"string\">\"prettier --write --trailing-comma es5 --single-quote true --tab-width 4\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"git add\"</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>나머지 옵션은 <a href=\"https://prettier.io/docs/en/options.html\" target=\"_blank\" rel=\"noopener\">여기</a>를 확인해주시면 됩니다.</p>\n"},{"title":"HandlerMethodArgumentResolver 인터페이스를 이용한 Controller 커스텀 파라미터 객체 만들기","catalog":true,"date":"2019-01-27T15:00:00.000Z","subtitle":"HandlerMethodArgumentResolver","header-img":null,"_content":"\n# HandlerMethodArgumentResolver 인터페이스를 이용한 Controller 커스텀 파라미터 객체 만들기\n이 인스터페이스는 전략 패턴의 일종으로 컨트롤러 메서드에서 특정 조건에 해당하는 파라미터에 바인딩 해주는 전략 인터페이스이다. 따라서 AOP로 모든 메서드를 일일이 찾아서 데이터를 바인딩 할 필요없이 어노테이션을 만들어 쉽게 바인딩 할 수 있다.\n\n예를 들어 컨트롤러에서 세션을 조회해야 하거나 HttpServletRequest에서 토큰 또는 쿠키 정보를 기반으로 인증 객체를 만들어야 한다고 가정해보자. 그렇게 되면 이러한 객체를 만들기 위해서는 아래의 소스같이 session에서 유저정보를 가져오거나 request 정보에서 인증정보를 가져오는 중복 코드가 발생할 수 있다. 이러한 문제를 HandlerMethodArgumentResolver를 이용하면 쉽게 해결할 수 있다.\n","source":"_posts/2019-01-28-HandlerMethodArgumentResolver.md","raw":"---\ntitle: HandlerMethodArgumentResolver 인터페이스를 이용한 Controller 커스텀 파라미터 객체 만들기\ncatalog: true\ndate: 2019-01-28\nsubtitle: HandlerMethodArgumentResolver\nheader-img:\ntags:\n- Java\n- Spring\n\n\n\n---\n\n# HandlerMethodArgumentResolver 인터페이스를 이용한 Controller 커스텀 파라미터 객체 만들기\n이 인스터페이스는 전략 패턴의 일종으로 컨트롤러 메서드에서 특정 조건에 해당하는 파라미터에 바인딩 해주는 전략 인터페이스이다. 따라서 AOP로 모든 메서드를 일일이 찾아서 데이터를 바인딩 할 필요없이 어노테이션을 만들어 쉽게 바인딩 할 수 있다.\n\n예를 들어 컨트롤러에서 세션을 조회해야 하거나 HttpServletRequest에서 토큰 또는 쿠키 정보를 기반으로 인증 객체를 만들어야 한다고 가정해보자. 그렇게 되면 이러한 객체를 만들기 위해서는 아래의 소스같이 session에서 유저정보를 가져오거나 request 정보에서 인증정보를 가져오는 중복 코드가 발생할 수 있다. 이러한 문제를 HandlerMethodArgumentResolver를 이용하면 쉽게 해결할 수 있다.\n","slug":"2019-01-28-HandlerMethodArgumentResolver","published":1,"updated":"2019-02-23T14:29:37.848Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjshl84kw0001uspeo1nrqvga","content":"<h1><span id=\"handlermethodargumentresolver-인터페이스를-이용한-controller-커스텀-파라미터-객체-만들기\">HandlerMethodArgumentResolver 인터페이스를 이용한 Controller 커스텀 파라미터 객체 만들기</span></h1>\n<p>이 인스터페이스는 전략 패턴의 일종으로 컨트롤러 메서드에서 특정 조건에 해당하는 파라미터에 바인딩 해주는 전략 인터페이스이다. 따라서 AOP로 모든 메서드를 일일이 찾아서 데이터를 바인딩 할 필요없이 어노테이션을 만들어 쉽게 바인딩 할 수 있다.</p>\n<p>예를 들어 컨트롤러에서 세션을 조회해야 하거나 HttpServletRequest에서 토큰 또는 쿠키 정보를 기반으로 인증 객체를 만들어야 한다고 가정해보자. 그렇게 되면 이러한 객체를 만들기 위해서는 아래의 소스같이 session에서 유저정보를 가져오거나 request 정보에서 인증정보를 가져오는 중복 코드가 발생할 수 있다. 이러한 문제를 HandlerMethodArgumentResolver를 이용하면 쉽게 해결할 수 있다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>HandlerMethodArgumentResolver 인터페이스를 이용한 Controller 커스텀 파라미터 객체 만들기</h1>\n<p>이 인스터페이스는 전략 패턴의 일종으로 컨트롤러 메서드에서 특정 조건에 해당하는 파라미터에 바인딩 해주는 전략 인터페이스이다. 따라서 AOP로 모든 메서드를 일일이 찾아서 데이터를 바인딩 할 필요없이 어노테이션을 만들어 쉽게 바인딩 할 수 있다.</p>\n<p>예를 들어 컨트롤러에서 세션을 조회해야 하거나 HttpServletRequest에서 토큰 또는 쿠키 정보를 기반으로 인증 객체를 만들어야 한다고 가정해보자. 그렇게 되면 이러한 객체를 만들기 위해서는 아래의 소스같이 session에서 유저정보를 가져오거나 request 정보에서 인증정보를 가져오는 중복 코드가 발생할 수 있다. 이러한 문제를 HandlerMethodArgumentResolver를 이용하면 쉽게 해결할 수 있다.</p>\n"}],"PostAsset":[{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-true.png","slug":"home_posts_tag-true.png","post":"cjshl27c0001djjpebt3l6sah","modified":0,"renderable":0},{"_id":"source/_posts/hexo-theme-beantech/home_posts_tag-false.png","slug":"home_posts_tag-false.png","post":"cjshl27c0001djjpebt3l6sah","modified":0,"renderable":0},{"_id":"source/_posts/hexo-theme-beantech/Demo.png","slug":"Demo.png","post":"cjshl27c0001djjpebt3l6sah","modified":0,"renderable":0}],"PostCategory":[],"PostTag":[{"post_id":"cjshl27b0000bjjpek08imevu","tag_id":"cjshl27ap0005jjpetnmowe65","_id":"cjshl27b9000ejjpeqyu8ov71"},{"post_id":"cjshl27b0000bjjpek08imevu","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27bb000gjjpej2lcyesc"},{"post_id":"cjshl27ag0001jjpe4dultufg","tag_id":"cjshl27ap0005jjpetnmowe65","_id":"cjshl27bd000jjjpestspsqbh"},{"post_id":"cjshl27ag0001jjpe4dultufg","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27bf000ljjper8t8oz8j"},{"post_id":"cjshl27b6000cjjpen0xyrqqw","tag_id":"cjshl27ap0005jjpetnmowe65","_id":"cjshl27bh000ojjpeo6apt34z"},{"post_id":"cjshl27b6000cjjpen0xyrqqw","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27bj000qjjpebfixky74"},{"post_id":"cjshl27bb000hjjpeabhv5fb4","tag_id":"cjshl27ap0005jjpetnmowe65","_id":"cjshl27bn000tjjpewe7tqfd3"},{"post_id":"cjshl27bb000hjjpeabhv5fb4","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27bp000vjjpez466ckk4"},{"post_id":"cjshl27be000kjjpere3osvpl","tag_id":"cjshl27ap0005jjpetnmowe65","_id":"cjshl27bq000yjjpe4wxajkbw"},{"post_id":"cjshl27be000kjjpere3osvpl","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27bs0010jjpeotbzmd15"},{"post_id":"cjshl27am0003jjpezjg34o2h","tag_id":"cjshl27ap0005jjpetnmowe65","_id":"cjshl27bt0013jjpetbxxgd4u"},{"post_id":"cjshl27am0003jjpezjg34o2h","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27bu0015jjpeaotxaald"},{"post_id":"cjshl27bf000mjjpef6b835wu","tag_id":"cjshl27ap0005jjpetnmowe65","_id":"cjshl27bw0017jjpeyo7lci5v"},{"post_id":"cjshl27bf000mjjpef6b835wu","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27by001ajjpevwf9ksq4"},{"post_id":"cjshl27bi000pjjpe57qfacuw","tag_id":"cjshl27ap0005jjpetnmowe65","_id":"cjshl27c0001cjjpeemir9bbf"},{"post_id":"cjshl27bi000pjjpe57qfacuw","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27c1001fjjpe6xyio2yw"},{"post_id":"cjshl27ar0006jjpeki1qiiqz","tag_id":"cjshl27ap0005jjpetnmowe65","_id":"cjshl27c2001gjjpeb59ehqvg"},{"post_id":"cjshl27ar0006jjpeki1qiiqz","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27c3001ijjpen76egx7b"},{"post_id":"cjshl27bp000wjjpen02u3c1m","tag_id":"cjshl27ap0005jjpetnmowe65","_id":"cjshl27c3001jjjpem6h1cce7"},{"post_id":"cjshl27bp000wjjpen02u3c1m","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27c4001ljjpea3hv4l96"},{"post_id":"cjshl27bq000zjjpeg9koei6x","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27c4001mjjpeqriymmcq"},{"post_id":"cjshl27at0008jjpeq8t1oez3","tag_id":"cjshl27bq000xjjpequ1vyibj","_id":"cjshl27c4001ojjpe7wfzk6vh"},{"post_id":"cjshl27bs0011jjpesujlvxmk","tag_id":"cjshl27bq000xjjpequ1vyibj","_id":"cjshl27c4001pjjpe5wuif6xl"},{"post_id":"cjshl27av0009jjpe1qytqzrd","tag_id":"cjshl27bt0012jjpel3hxpn3d","_id":"cjshl27c5001rjjpekez2xkj8"},{"post_id":"cjshl27b9000fjjpeki7g0mf5","tag_id":"cjshl27bw0018jjpembabuqnu","_id":"cjshl27c5001sjjpepfuf3fft"},{"post_id":"cjshl27b9000fjjpeki7g0mf5","tag_id":"cjshl27bt0012jjpel3hxpn3d","_id":"cjshl27c6001ujjpehpx66eia"},{"post_id":"cjshl27bk000rjjpezx4gpvse","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27c6001vjjpe9h53is6m"},{"post_id":"cjshl27bk000rjjpezx4gpvse","tag_id":"cjshl27bq000xjjpequ1vyibj","_id":"cjshl27c6001wjjpec82dcj01"},{"post_id":"cjshl27bn000ujjpeewqean6b","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27c6001yjjpemahv8nyt"},{"post_id":"cjshl27bn000ujjpeewqean6b","tag_id":"cjshl27bq000xjjpequ1vyibj","_id":"cjshl27c6001zjjpe67mvluvj"},{"post_id":"cjshl27bt0014jjpeod23vu4b","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27c70021jjpe2v6emxxo"},{"post_id":"cjshl27bt0014jjpeod23vu4b","tag_id":"cjshl27ap0005jjpetnmowe65","_id":"cjshl27c70022jjpe6bhh6z5n"},{"post_id":"cjshl27bt0014jjpeod23vu4b","tag_id":"cjshl27c4001njjpe5muqnemg","_id":"cjshl27c70023jjpexntfm5lg"},{"post_id":"cjshl27bv0016jjpeztnxg66o","tag_id":"cjshl27c4001qjjpezrruc7bv","_id":"cjshl27c70024jjpelxpthc69"},{"post_id":"cjshl27bv0016jjpeztnxg66o","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27c70025jjpe7z4w8ji0"},{"post_id":"cjshl27bw0019jjpekoyaivj4","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27c80026jjpe3zt5p4ew"},{"post_id":"cjshl27bw0019jjpekoyaivj4","tag_id":"cjshl27ap0005jjpetnmowe65","_id":"cjshl27c80027jjpenw1ymbum"},{"post_id":"cjshl27bw0019jjpekoyaivj4","tag_id":"cjshl27c5001tjjped6wxsbgp","_id":"cjshl27c90028jjpem9hg1tpe"},{"post_id":"cjshl27by001bjjpe7phsrv5x","tag_id":"cjshl27c6001xjjpe5sejzrxf","_id":"cjshl27c90029jjpe81xysy9w"},{"post_id":"cjshl27c0001djjpebt3l6sah","tag_id":"cjshl27c60020jjpe5hn6cli3","_id":"cjshl27c9002ajjpeb3al1k3i"},{"post_id":"cjshl27d9002bjjpekl3tx2gw","tag_id":"cjshl27ap0005jjpetnmowe65","_id":"cjshl27dc002djjpeo777hmie"},{"post_id":"cjshl27d9002bjjpekl3tx2gw","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27dd002fjjpebloin6kl"},{"post_id":"cjshl27da002cjjpe6ukaux6e","tag_id":"cjshl27ap0005jjpetnmowe65","_id":"cjshl27de002hjjpe2ye2m841"},{"post_id":"cjshl27da002cjjpe6ukaux6e","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27dg002jjjpeaaxzn8ol"},{"post_id":"cjshl27dc002ejjpe7e9op29d","tag_id":"cjshl27ap0005jjpetnmowe65","_id":"cjshl27dn002mjjpeer00swb6"},{"post_id":"cjshl27dc002ejjpe7e9op29d","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27dw002ojjpe9fzkmb8s"},{"post_id":"cjshl27dd002gjjpe7je0a9gc","tag_id":"cjshl27ap0005jjpetnmowe65","_id":"cjshl27dy002qjjpeulcad0u3"},{"post_id":"cjshl27dd002gjjpe7je0a9gc","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27e0002tjjpe0rjrid7q"},{"post_id":"cjshl27dx002pjjpe86nfrnci","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27e1002vjjpeq0sjn2jd"},{"post_id":"cjshl27de002ijjpe7oa834w5","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27e3002yjjpemnq24bex"},{"post_id":"cjshl27de002ijjpe7oa834w5","tag_id":"cjshl27dn002ljjpegg33ntu6","_id":"cjshl27e40030jjpev9bwn4vb"},{"post_id":"cjshl27dy002rjjpefhfdeo29","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27e60032jjpei9m1yhez"},{"post_id":"cjshl27dy002rjjpefhfdeo29","tag_id":"cjshl27ap0005jjpetnmowe65","_id":"cjshl27e70034jjpetsg4x8ne"},{"post_id":"cjshl27dy002rjjpefhfdeo29","tag_id":"cjshl27c5001tjjped6wxsbgp","_id":"cjshl27e80036jjpe0ot2ikew"},{"post_id":"cjshl27e0002ujjpea3krqpho","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27e90038jjpe9lhy4sus"},{"post_id":"cjshl27e0002ujjpea3krqpho","tag_id":"cjshl27ap0005jjpetnmowe65","_id":"cjshl27ea0039jjpe0xg3ss0p"},{"post_id":"cjshl27e0002ujjpea3krqpho","tag_id":"cjshl27c5001tjjped6wxsbgp","_id":"cjshl27ea003ajjpe71xcuga3"},{"post_id":"cjshl27dg002kjjpeziap35p6","tag_id":"cjshl27bq000xjjpequ1vyibj","_id":"cjshl27ea003bjjpen840oujf"},{"post_id":"cjshl27dg002kjjpeziap35p6","tag_id":"cjshl27dz002sjjpew965391g","_id":"cjshl27eb003cjjpekdndoglu"},{"post_id":"cjshl27e1002wjjpefwiovgk3","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27eb003djjpeegjwmx4d"},{"post_id":"cjshl27e1002wjjpefwiovgk3","tag_id":"cjshl27ap0005jjpetnmowe65","_id":"cjshl27eb003ejjpehn2jzddl"},{"post_id":"cjshl27e1002wjjpefwiovgk3","tag_id":"cjshl27c5001tjjped6wxsbgp","_id":"cjshl27eb003fjjpepv9r2dyq"},{"post_id":"cjshl27e3002zjjpex4x94vpi","tag_id":"cjshl27c6001xjjpe5sejzrxf","_id":"cjshl27eb003gjjpeq2u4gjng"},{"post_id":"cjshl27do002njjpee5fi9kma","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27eb003hjjpe2vvputfn"},{"post_id":"cjshl27do002njjpee5fi9kma","tag_id":"cjshl27ap0005jjpetnmowe65","_id":"cjshl27eb003ijjpeju5pxdtk"},{"post_id":"cjshl27do002njjpee5fi9kma","tag_id":"cjshl27e2002xjjpearprnjwe","_id":"cjshl27eb003jjjpez5jn3py1"},{"post_id":"cjshl27e40031jjpecvfde8l0","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27eb003kjjpecshr826l"},{"post_id":"cjshl27e60033jjpe50xsebgl","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27eb003ljjpefqwnf1qd"},{"post_id":"cjshl27e60033jjpe50xsebgl","tag_id":"cjshl27ap0005jjpetnmowe65","_id":"cjshl27eb003mjjpeqrsax317"},{"post_id":"cjshl27e70035jjpefv4w3w33","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27eb003njjpe75d58ucv"},{"post_id":"cjshl27e70035jjpefv4w3w33","tag_id":"cjshl27ap0005jjpetnmowe65","_id":"cjshl27ec003ojjpebg287hpa"},{"post_id":"cjshl27e70035jjpefv4w3w33","tag_id":"cjshl27c4001njjpe5muqnemg","_id":"cjshl27ec003pjjperm293m9w"},{"post_id":"cjshl27e80037jjpepsohvla5","tag_id":"cjshl27c6001xjjpe5sejzrxf","_id":"cjshl27ec003qjjpe8so3awwc"},{"post_id":"cjshl27el003ujjpeyngeigjw","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27en003wjjpeoc8s5ziq"},{"post_id":"cjshl27el003ujjpeyngeigjw","tag_id":"cjshl27ap0005jjpetnmowe65","_id":"cjshl27eo003yjjpecotufmgl"},{"post_id":"cjshl27el003ujjpeyngeigjw","tag_id":"cjshl27c5001tjjped6wxsbgp","_id":"cjshl27eo003zjjpendzoqozx"},{"post_id":"cjshl27em003vjjpehhl5xbg2","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27eo0040jjpev7im3zxa"},{"post_id":"cjshl27em003vjjpehhl5xbg2","tag_id":"cjshl27ap0005jjpetnmowe65","_id":"cjshl27eo0041jjpelxduqmzo"},{"post_id":"cjshl27em003vjjpehhl5xbg2","tag_id":"cjshl27c5001tjjped6wxsbgp","_id":"cjshl27eo0042jjpeib3aypxa"},{"post_id":"cjshl27ei003rjjpem3ebl4n4","tag_id":"cjshl27bq000xjjpequ1vyibj","_id":"cjshl27eo0043jjpetqqp3w16"},{"post_id":"cjshl27ei003rjjpem3ebl4n4","tag_id":"cjshl27ek003tjjpeu3el9gzt","_id":"cjshl27eo0044jjpen6pllfu4"},{"post_id":"cjshl27ej003sjjpesle38g8k","tag_id":"cjshl27ap0005jjpetnmowe65","_id":"cjshl27eo0045jjpehb9i1xes"},{"post_id":"cjshl27ej003sjjpesle38g8k","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27eo0046jjpejedb312k"},{"post_id":"cjshl27ej003sjjpesle38g8k","tag_id":"cjshl27ek003tjjpeu3el9gzt","_id":"cjshl27eo0047jjpeancjf7uc"},{"post_id":"cjshl27ej003sjjpesle38g8k","tag_id":"cjshl27bq000xjjpequ1vyibj","_id":"cjshl27eo0048jjpecbymftys"},{"post_id":"cjshl27f00049jjpepcw6g7cc","tag_id":"cjshl27bq000xjjpequ1vyibj","_id":"cjshl27f2004ajjpeuxtvwp4v"},{"post_id":"cjshl27f00049jjpepcw6g7cc","tag_id":"cjshl27dz002sjjpew965391g","_id":"cjshl27f2004bjjpemqxuqxub"},{"post_id":"cjshl27f5004cjjpejew0mjkn","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27f6004djjpedhhoh9p9"},{"post_id":"cjshl27fa004ejjpefyt6sksg","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl27fb004fjjpee1dkbqsx"},{"post_id":"cjshl27fa004ejjpefyt6sksg","tag_id":"cjshl27ap0005jjpetnmowe65","_id":"cjshl27fb004gjjpe35dts5hq"},{"post_id":"cjshl27fa004ejjpefyt6sksg","tag_id":"cjshl27e2002xjjpearprnjwe","_id":"cjshl27fb004hjjpescsfdmr5"},{"post_id":"cjshl84kw0001uspeo1nrqvga","tag_id":"cjshl27az000ajjpekkhmeuy6","_id":"cjshl84lf0003usped2jyv8ex"},{"post_id":"cjshl84kw0001uspeo1nrqvga","tag_id":"cjshl27ap0005jjpetnmowe65","_id":"cjshl84lg0004uspe73veqwsp"},{"post_id":"cjshl84kp0000uspenzaf3kfu","tag_id":"cjshl84l10002uspeaf8srelb","_id":"cjshl84lg0005uspevhn8bz0n"}],"Tag":[{"name":"Spring","_id":"cjshl27ap0005jjpetnmowe65"},{"name":"Java","_id":"cjshl27az000ajjpekkhmeuy6"},{"name":"ETC","_id":"cjshl27bq000xjjpequ1vyibj"},{"name":"Javascript","_id":"cjshl27bt0012jjpel3hxpn3d"},{"name":"Angular","_id":"cjshl27bw0018jjpembabuqnu"},{"name":"JPA","_id":"cjshl27c4001njjpe5muqnemg"},{"name":"Intellij","_id":"cjshl27c4001qjjpezrruc7bv"},{"name":"온라인 서점 API 만들기로 살펴보는 Spring Boot OOP","_id":"cjshl27c5001tjjped6wxsbgp"},{"name":"Netowork","_id":"cjshl27c6001xjjpe5sejzrxf"},{"name":"Blog","_id":"cjshl27c60020jjpe5hn6cli3"},{"name":"JVM","_id":"cjshl27dn002ljjpegg33ntu6"},{"name":"O/S","_id":"cjshl27dz002sjjpew965391g"},{"name":"Toby","_id":"cjshl27e2002xjjpearprnjwe"},{"name":"OAuth","_id":"cjshl27ek003tjjpeu3el9gzt"},{"name":"JavaScript","_id":"cjshl84l10002uspeaf8srelb"}]}}